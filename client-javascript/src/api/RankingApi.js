/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */


import ApiClient from "../ApiClient";
import RankFullResponse from '../model/RankFullResponse';
import SirqulResponse from '../model/SirqulResponse';

/**
* Ranking service.
* @module api/RankingApi
* @version 3.16
*/
export default class RankingApi {

    /**
    * Constructs a new RankingApi. 
    * @alias module:api/RankingApi
    * @class
    * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
    * default to {@link module:ApiClient#instance} if unspecified.
    */
    constructor(apiClient) {
        this.apiClient = apiClient || ApiClient.instance;
    }


    /**
     * Callback function to receive the result of the getHistoricalRankings operation.
     * @callback module:api/RankingApi~getHistoricalRankingsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/RankFullResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search Historical Rankings
     * Get historical leaderboard rankings by time-frame.
     * @param {String} appKey the application key for filtering results by application
     * @param {String} rankType the rank type to return
     * @param {Number} startDate timestamp in milliseconds to filter results with
     * @param {Number} endDate timestamp in milliseconds to filter results with
     * @param {Object} opts Optional parameters
     * @param {String} [deviceId] a unique id given by the device (deviceId or accountId required)
     * @param {Number} [accountId] the account id of the user
     * @param {String} [sortField = 'TOTAL')] determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
     * @param {Boolean} [descending = true)] determines whether to return results in ascending or descending order
     * @param {Number} [start = 0)] the start index for pagination
     * @param {Number} [limit = 100)] the limit for pagination
     * @param {module:api/RankingApi~getHistoricalRankingsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/RankFullResponse}
     */
    getHistoricalRankings(appKey, rankType, startDate, endDate, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'appKey' is set
      if (appKey === undefined || appKey === null) {
        throw new Error("Missing the required parameter 'appKey' when calling getHistoricalRankings");
      }
      // verify the required parameter 'rankType' is set
      if (rankType === undefined || rankType === null) {
        throw new Error("Missing the required parameter 'rankType' when calling getHistoricalRankings");
      }
      // verify the required parameter 'startDate' is set
      if (startDate === undefined || startDate === null) {
        throw new Error("Missing the required parameter 'startDate' when calling getHistoricalRankings");
      }
      // verify the required parameter 'endDate' is set
      if (endDate === undefined || endDate === null) {
        throw new Error("Missing the required parameter 'endDate' when calling getHistoricalRankings");
      }

      let pathParams = {
      };
      let queryParams = {
        'deviceId': opts['deviceId'],
        'accountId': opts['accountId'],
        'appKey': appKey,
        'rankType': rankType,
        'startDate': startDate,
        'endDate': endDate,
        'sortField': opts['sortField'],
        'descending': opts['descending'],
        'start': opts['start'],
        'limit': opts['limit']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = RankFullResponse;
      return this.apiClient.callApi(
        '/ranking/historical/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getRankings operation.
     * @callback module:api/RankingApi~getRankingsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/RankFullResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Search Rankings
     * Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
     * @param {Object} opts Optional parameters
     * @param {String} [deviceId] a unique id given by the device (deviceId or accountId required)
     * @param {Number} [accountId] the account id of the user (deviceId or accountId required)
     * @param {String} [gameType] This parameter is deprecated.
     * @param {String} [appKey] the application key for filtering results by application (required for non-EXECUTIVE users)
     * @param {String} [q] This parameter is deprecated.
     * @param {String} [keyword] keyword to search for
     * @param {String} [rankType = 'POINTS,DOWNLOADS,INVITATIONS')] a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
     * @param {String} [leaderboardMode = 'GLOBAL')] the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
     * @param {String} [withinAccountIds] comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
     * @param {Boolean} [returnUserRank = true)] determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
     * @param {Number} [albumId] album id to use when performing CUSTOM filters
     * @param {Number} [audienceId] audience id to use when performing CUSTOM filters
     * @param {String} [sortField = 'TOTAL')] determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
     * @param {Boolean} [descending = true)] determines whether to return results in ascending or descending order
     * @param {Number} [i] This parameter is deprecated.
     * @param {Number} [start = 0)] the start index for pagination
     * @param {Number} [l] This parameter is deprecated.
     * @param {Number} [limit = 100)] the limit for pagination
     * @param {module:api/RankingApi~getRankingsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/RankFullResponse}
     */
    getRankings(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'deviceId': opts['deviceId'],
        'accountId': opts['accountId'],
        'gameType': opts['gameType'],
        'appKey': opts['appKey'],
        'q': opts['q'],
        'keyword': opts['keyword'],
        'rankType': opts['rankType'],
        'leaderboardMode': opts['leaderboardMode'],
        'withinAccountIds': opts['withinAccountIds'],
        'returnUserRank': opts['returnUserRank'],
        'albumId': opts['albumId'],
        'audienceId': opts['audienceId'],
        'sortField': opts['sortField'],
        'descending': opts['descending'],
        '_i': opts['i'],
        'start': opts['start'],
        '_l': opts['l'],
        'limit': opts['limit']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = RankFullResponse;
      return this.apiClient.callApi(
        '/ranking/search', 'GET',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the getUserRank operation.
     * @callback module:api/RankingApi~getUserRankCallback
     * @param {String} error Error message, if any.
     * @param {Object} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Get Personal Rankings
     * Returns the user's ranks for one or more rank types and modes.
     * @param {Object} opts Optional parameters
     * @param {String} [deviceId] a unique id given by the device (deviceId or accountId required)
     * @param {Number} [accountId] the account id of the user
     * @param {String} [appKey] the application key for filtering results by application (required)
     * @param {String} [rankType] pass in all rankTypes and children rankTypes
     * @param {Boolean} [returnUserRank = false)] determines whether to return the user's current rank in the response, for each rankType
     * @param {String} [leaderboardMode = 'GLOBAL')] the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
     * @param {String} [sortField = 'TOTAL')] determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
     * @param {String} [keyword] keyword to search for (on rankType)
     * @param {Boolean} [descending = true)] determines whether to return results in descending order
     * @param {Number} [start = 0)] the start index for pagination
     * @param {Number} [limit = 100)] the limit for pagination
     * @param {module:api/RankingApi~getUserRankCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link Object}
     */
    getUserRank(opts, callback) {
      opts = opts || {};
      let postBody = null;

      let pathParams = {
      };
      let queryParams = {
        'deviceId': opts['deviceId'],
        'accountId': opts['accountId'],
        'appKey': opts['appKey'],
        'rankType': opts['rankType'],
        'returnUserRank': opts['returnUserRank'],
        'leaderboardMode': opts['leaderboardMode'],
        'sortField': opts['sortField'],
        'keyword': opts['keyword'],
        'descending': opts['descending'],
        'start': opts['start'],
        'limit': opts['limit']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = Object;
      return this.apiClient.callApi(
        '/ranking/personal/ranks', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the overrideUserRank operation.
     * @callback module:api/RankingApi~overrideUserRankCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SirqulResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Override User Rank
     * Allows an admin of an application to override a user's scores for a leaderboard.
     * @param {Number} accountId the logged in user's account id (must have permissions to manage data for the application)
     * @param {Number} ownerAccountId the end user's account id to override
     * @param {String} appKey the application key the leaderboard is for
     * @param {String} rankType the rankType of the leaderboard
     * @param {Object} opts Optional parameters
     * @param {Number} [totalScore] the total score to update
     * @param {Number} [totalCount] the total count to update
     * @param {Number} [totalTime] the total time to update
     * @param {Number} [dailyScore] the daily score to update
     * @param {Number} [dailyCount] the daily count to update
     * @param {Number} [dailyTime] the daily time to update
     * @param {Number} [weeklyScore] the weekly score to update
     * @param {Number} [weeklyCount] the weekly count to update
     * @param {Number} [weeklyTime] the weekly time to update
     * @param {Number} [monthlyScore] the monthly score to update
     * @param {Number} [monthlyCount] the monthly count to update
     * @param {Number} [monthlyTime] the monthly time to update
     * @param {Number} [topScore] the top score to update
     * @param {Number} [lowestScore] the lowest score to update
     * @param {Number} [streakCount] the streak count to update
     * @param {Number} [streakBestCount] the best streak count to update
     * @param {Number} [startDate] the start date to update
     * @param {Number} [endDate] the end date to update
     * @param {module:api/RankingApi~overrideUserRankCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SirqulResponse}
     */
    overrideUserRank(accountId, ownerAccountId, appKey, rankType, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'accountId' is set
      if (accountId === undefined || accountId === null) {
        throw new Error("Missing the required parameter 'accountId' when calling overrideUserRank");
      }
      // verify the required parameter 'ownerAccountId' is set
      if (ownerAccountId === undefined || ownerAccountId === null) {
        throw new Error("Missing the required parameter 'ownerAccountId' when calling overrideUserRank");
      }
      // verify the required parameter 'appKey' is set
      if (appKey === undefined || appKey === null) {
        throw new Error("Missing the required parameter 'appKey' when calling overrideUserRank");
      }
      // verify the required parameter 'rankType' is set
      if (rankType === undefined || rankType === null) {
        throw new Error("Missing the required parameter 'rankType' when calling overrideUserRank");
      }

      let pathParams = {
      };
      let queryParams = {
        'accountId': accountId,
        'ownerAccountId': ownerAccountId,
        'appKey': appKey,
        'rankType': rankType,
        'totalScore': opts['totalScore'],
        'totalCount': opts['totalCount'],
        'totalTime': opts['totalTime'],
        'dailyScore': opts['dailyScore'],
        'dailyCount': opts['dailyCount'],
        'dailyTime': opts['dailyTime'],
        'weeklyScore': opts['weeklyScore'],
        'weeklyCount': opts['weeklyCount'],
        'weeklyTime': opts['weeklyTime'],
        'monthlyScore': opts['monthlyScore'],
        'monthlyCount': opts['monthlyCount'],
        'monthlyTime': opts['monthlyTime'],
        'topScore': opts['topScore'],
        'lowestScore': opts['lowestScore'],
        'streakCount': opts['streakCount'],
        'streakBestCount': opts['streakBestCount'],
        'startDate': opts['startDate'],
        'endDate': opts['endDate']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = SirqulResponse;
      return this.apiClient.callApi(
        '/ranking/override', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }

    /**
     * Callback function to receive the result of the updateRankings operation.
     * @callback module:api/RankingApi~updateRankingsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SirqulResponse} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * Update Ranking
     * Update the rank value 
     * @param {Number} accountId the account id of the user
     * @param {String} appKey the application key for filtering results by application
     * @param {String} rankType a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
     * @param {Object} opts Optional parameters
     * @param {Number} [increment = 1)] the value to increment
     * @param {Number} [timeIncrement] the time value to increment
     * @param {String} [tag] the analytic tag for this achievement (used to validate scores)
     * @param {Number} [startDate] custom date you can save along with the score for the user
     * @param {Number} [endDate] custom date you can save along with the score for the user
     * @param {Boolean} [updateGlobal] update the global rankings if true, default is false
     * @param {Boolean} [createLeaderboard = false)] create the leaderboard if it does not exist (default false)
     * @param {module:api/RankingApi~updateRankingsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SirqulResponse}
     */
    updateRankings(accountId, appKey, rankType, opts, callback) {
      opts = opts || {};
      let postBody = null;
      // verify the required parameter 'accountId' is set
      if (accountId === undefined || accountId === null) {
        throw new Error("Missing the required parameter 'accountId' when calling updateRankings");
      }
      // verify the required parameter 'appKey' is set
      if (appKey === undefined || appKey === null) {
        throw new Error("Missing the required parameter 'appKey' when calling updateRankings");
      }
      // verify the required parameter 'rankType' is set
      if (rankType === undefined || rankType === null) {
        throw new Error("Missing the required parameter 'rankType' when calling updateRankings");
      }

      let pathParams = {
      };
      let queryParams = {
        'accountId': accountId,
        'appKey': appKey,
        'rankType': rankType,
        'increment': opts['increment'],
        'timeIncrement': opts['timeIncrement'],
        'tag': opts['tag'],
        'startDate': opts['startDate'],
        'endDate': opts['endDate'],
        'updateGlobal': opts['updateGlobal'],
        'createLeaderboard': opts['createLeaderboard']
      };
      let headerParams = {
      };
      let formParams = {
      };

      let authNames = [];
      let contentTypes = [];
      let accepts = ['*/*'];
      let returnType = SirqulResponse;
      return this.apiClient.callApi(
        '/ranking/update', 'POST',
        pathParams, queryParams, headerParams, formParams, postBody,
        authNames, contentTypes, accepts, returnType, null, callback
      );
    }


}
