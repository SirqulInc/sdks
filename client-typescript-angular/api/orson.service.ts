/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { OrsonAiAddMovieResponse } from '../model/orsonAiAddMovieResponse';
// @ts-ignore
import { OrsonAiBatchResponse } from '../model/orsonAiBatchResponse';
// @ts-ignore
import { OrsonAiEmotionsResponse } from '../model/orsonAiEmotionsResponse';
// @ts-ignore
import { OrsonAiProtoResponse } from '../model/orsonAiProtoResponse';
// @ts-ignore
import { OrsonAiSTTResponse } from '../model/orsonAiSTTResponse';
// @ts-ignore
import { OrsonAiTTSResponse } from '../model/orsonAiTTSResponse';
// @ts-ignore
import { OrsonAiTechTuneResponse } from '../model/orsonAiTechTuneResponse';
// @ts-ignore
import { OrsonAiTopicsResponse } from '../model/orsonAiTopicsResponse';
// @ts-ignore
import { OrsonAiVoiceCanvasResponse } from '../model/orsonAiVoiceCanvasResponse';
// @ts-ignore
import { OrsonEpisodeResponse } from '../model/orsonEpisodeResponse';
// @ts-ignore
import { OrsonRenderResponse } from '../model/orsonRenderResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class OrsonService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Add Movie
     * Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
     * @endpoint post /api/{version}/orson/ai/addMovie
     * @param version 
     * @param accountId Sirqul Account Id
     * @param movieName Movie Name
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param tags A user defined list (comma-delimited) of tags associated with the movie
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public addMovie(version: number, accountId: number, movieName: string, thirdPartyAccountId?: string, tags?: string, file?: Blob, url?: string, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiAddMovieResponse>;
    public addMovie(version: number, accountId: number, movieName: string, thirdPartyAccountId?: string, tags?: string, file?: Blob, url?: string, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiAddMovieResponse>>;
    public addMovie(version: number, accountId: number, movieName: string, thirdPartyAccountId?: string, tags?: string, file?: Blob, url?: string, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiAddMovieResponse>>;
    public addMovie(version: number, accountId: number, movieName: string, thirdPartyAccountId?: string, tags?: string, file?: Blob, url?: string, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling addMovie.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling addMovie.');
        }
        if (movieName === null || movieName === undefined) {
            throw new Error('Required parameter movieName was null or undefined when calling addMovie.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tags',
            <any>tags,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'movieName',
            <any>movieName,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/addMovie`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiAddMovieResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Docs
     * Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
     * @endpoint get /api/{version}/orson/ai/docs
     * @param version 
     * @param accountId Sirqul Account Id
     * @param doc Doc
     * @param returnTopics Return Topics
     * @param limit Limit
     * @param offset Offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public aiDocs(version: number, accountId: number, doc: string, returnTopics?: boolean, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiProtoResponse>;
    public aiDocs(version: number, accountId: number, doc: string, returnTopics?: boolean, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiProtoResponse>>;
    public aiDocs(version: number, accountId: number, doc: string, returnTopics?: boolean, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiProtoResponse>>;
    public aiDocs(version: number, accountId: number, doc: string, returnTopics?: boolean, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling aiDocs.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling aiDocs.');
        }
        if (doc === null || doc === undefined) {
            throw new Error('Required parameter doc was null or undefined when calling aiDocs.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'doc',
            <any>doc,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'return_topics',
            <any>returnTopics,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offset',
            <any>offset,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/docs`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiProtoResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Find images
     * Returns a list of URIs of images that match the text.
     * @endpoint get /api/{version}/orson/ai/img
     * @param version 
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param parseFlag Parse Flag
     * @param fetchFlag Fetch Flag
     * @param size Size
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public aiFindImages(version: number, accountId: number, text: string, parseFlag?: string, fetchFlag?: string, size?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiProtoResponse>;
    public aiFindImages(version: number, accountId: number, text: string, parseFlag?: string, fetchFlag?: string, size?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiProtoResponse>>;
    public aiFindImages(version: number, accountId: number, text: string, parseFlag?: string, fetchFlag?: string, size?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiProtoResponse>>;
    public aiFindImages(version: number, accountId: number, text: string, parseFlag?: string, fetchFlag?: string, size?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling aiFindImages.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling aiFindImages.');
        }
        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling aiFindImages.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'text',
            <any>text,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'parse_flag',
            <any>parseFlag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'fetch_flag',
            <any>fetchFlag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'size',
            <any>size,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/img`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiProtoResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Tags
     * Search the tags column of user provided tags using this endpoint.
     * @endpoint get /api/{version}/orson/ai/tags
     * @param version 
     * @param accountId Sirqul Account Id
     * @param tags Tags
     * @param conditional Conditional
     * @param limit Limit
     * @param offset Offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public aiTags(version: number, accountId: number, tags: string, conditional?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiProtoResponse>;
    public aiTags(version: number, accountId: number, tags: string, conditional?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiProtoResponse>>;
    public aiTags(version: number, accountId: number, tags: string, conditional?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiProtoResponse>>;
    public aiTags(version: number, accountId: number, tags: string, conditional?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling aiTags.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling aiTags.');
        }
        if (tags === null || tags === undefined) {
            throw new Error('Required parameter tags was null or undefined when calling aiTags.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tags',
            <any>tags,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'conditional',
            <any>conditional,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offset',
            <any>offset,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/tags`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiProtoResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Text
     * Search the movie text column of movie text using this endpoint.
     * @endpoint get /api/{version}/orson/ai/text
     * @param version 
     * @param accountId Sirqul Account Id
     * @param terms Terms
     * @param conditional Conditional
     * @param limit Limit
     * @param offset Offset
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public aiText(version: number, accountId: number, terms: string, conditional?: string, limit?: number, offset?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiProtoResponse>;
    public aiText(version: number, accountId: number, terms: string, conditional?: string, limit?: number, offset?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiProtoResponse>>;
    public aiText(version: number, accountId: number, terms: string, conditional?: string, limit?: number, offset?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiProtoResponse>>;
    public aiText(version: number, accountId: number, terms: string, conditional?: string, limit?: number, offset?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling aiText.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling aiText.');
        }
        if (terms === null || terms === undefined) {
            throw new Error('Required parameter terms was null or undefined when calling aiText.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'terms',
            <any>terms,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'conditional',
            <any>conditional,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offset',
            <any>offset,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/text`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiProtoResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Batch Analysis
     * Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
     * @endpoint post /api/{version}/orson/ai/batch
     * @param version 
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param limit The number of topics to return
     * @param operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public batch(version: number, accountId: number, thirdPartyAccountId?: string, limit?: number, operations?: string, file?: Blob, url?: string, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiBatchResponse>;
    public batch(version: number, accountId: number, thirdPartyAccountId?: string, limit?: number, operations?: string, file?: Blob, url?: string, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiBatchResponse>>;
    public batch(version: number, accountId: number, thirdPartyAccountId?: string, limit?: number, operations?: string, file?: Blob, url?: string, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiBatchResponse>>;
    public batch(version: number, accountId: number, thirdPartyAccountId?: string, limit?: number, operations?: string, file?: Blob, url?: string, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling batch.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling batch.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'operations',
            <any>operations,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/batch`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiBatchResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Creates an instant episode
     * Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
     * @endpoint post /api/{version}/orson/stories/episodes/instant
     * @param version 
     * @param accountId Sirqul Account Id
     * @param data Request Data String
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createInstantEpisode(version: number, accountId: number, data: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonEpisodeResponse>;
    public createInstantEpisode(version: number, accountId: number, data: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonEpisodeResponse>>;
    public createInstantEpisode(version: number, accountId: number, data: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonEpisodeResponse>>;
    public createInstantEpisode(version: number, accountId: number, data: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createInstantEpisode.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createInstantEpisode.');
        }
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling createInstantEpisode.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'data',
            <any>data,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/stories/episodes/instant`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonEpisodeResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create VoiceCanvas images
     * Create VoiceCanvas images for provided text, file upload, or file URL
     * @endpoint post /api/{version}/orson/ai/voiceCanvas
     * @param version 
     * @param accountId Sirqul Account Id
     * @param dimensions Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot;
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param text Provide a transcript or previously extracted topics for image generation
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param parseFlag When false, uses the raw value from text instead of identifying topics to fetch/generate from
     * @param fetchFlag When true, fetches images instead of generating them
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createVoiceCanvas(version: number, accountId: number, dimensions: string, thirdPartyAccountId?: string, text?: string, file?: Blob, url?: string, parseFlag?: boolean, fetchFlag?: boolean, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiVoiceCanvasResponse>;
    public createVoiceCanvas(version: number, accountId: number, dimensions: string, thirdPartyAccountId?: string, text?: string, file?: Blob, url?: string, parseFlag?: boolean, fetchFlag?: boolean, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiVoiceCanvasResponse>>;
    public createVoiceCanvas(version: number, accountId: number, dimensions: string, thirdPartyAccountId?: string, text?: string, file?: Blob, url?: string, parseFlag?: boolean, fetchFlag?: boolean, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiVoiceCanvasResponse>>;
    public createVoiceCanvas(version: number, accountId: number, dimensions: string, thirdPartyAccountId?: string, text?: string, file?: Blob, url?: string, parseFlag?: boolean, fetchFlag?: boolean, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createVoiceCanvas.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createVoiceCanvas.');
        }
        if (dimensions === null || dimensions === undefined) {
            throw new Error('Required parameter dimensions was null or undefined when calling createVoiceCanvas.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'dimensions',
            <any>dimensions,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'text',
            <any>text,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'parseFlag',
            <any>parseFlag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'fetchFlag',
            <any>fetchFlag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/voiceCanvas`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiVoiceCanvasResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Detect emotions
     * Detects emotions in an audio or video recording.
     * @endpoint post /api/{version}/orson/ai/emotion
     * @param version 
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public emotion(version: number, accountId: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiEmotionsResponse>;
    public emotion(version: number, accountId: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiEmotionsResponse>>;
    public emotion(version: number, accountId: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiEmotionsResponse>>;
    public emotion(version: number, accountId: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling emotion.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling emotion.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/emotion`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiEmotionsResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Add Movie Result
     * Get the result of an in progress Add Movie request from an earlier POST.
     * @endpoint get /api/{version}/orson/ai/addMovie/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getAddMovieResult(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiAddMovieResponse>;
    public getAddMovieResult(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiAddMovieResponse>>;
    public getAddMovieResult(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiAddMovieResponse>>;
    public getAddMovieResult(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getAddMovieResult.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getAddMovieResult.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAddMovieResult.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/addMovie/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiAddMovieResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Batch Analysis Results
     * Gets the completed Video Batch results, if done, or an error or status update if not.
     * @endpoint get /api/{version}/orson/ai/batch/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getBatch(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiBatchResponse>;
    public getBatch(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiBatchResponse>>;
    public getBatch(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiBatchResponse>>;
    public getBatch(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getBatch.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getBatch.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getBatch.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/batch/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiBatchResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Emotion Results
     * Checks the Emotion analysis and returns in progress, results, or error.
     * @endpoint get /api/{version}/orson/ai/emotion/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getEmotion(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiEmotionsResponse>;
    public getEmotion(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiEmotionsResponse>>;
    public getEmotion(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiEmotionsResponse>>;
    public getEmotion(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getEmotion.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getEmotion.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getEmotion.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/emotion/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiEmotionsResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Check episode status
     * Gets a summary of the episode\&#39;s status, including any renders.
     * @endpoint get /api/{version}/orson/stories/episodes/{episodeId}/status
     * @param version 
     * @param episodeId Episode ID
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getEpisodeStatus(version: number, episodeId: number, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonEpisodeResponse>;
    public getEpisodeStatus(version: number, episodeId: number, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonEpisodeResponse>>;
    public getEpisodeStatus(version: number, episodeId: number, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonEpisodeResponse>>;
    public getEpisodeStatus(version: number, episodeId: number, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getEpisodeStatus.');
        }
        if (episodeId === null || episodeId === undefined) {
            throw new Error('Required parameter episodeId was null or undefined when calling getEpisodeStatus.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getEpisodeStatus.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/stories/episodes/${this.configuration.encodeParam({name: "episodeId", value: episodeId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: "int64"})}/status`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonEpisodeResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Check episode status
     * Gets a summary of the episode\&#39;s status, including any renders.
     * @endpoint get /api/{version}/orson/stories/renders/{renderId}/status
     * @param version 
     * @param renderId Render ID
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getRenderStatus(version: number, renderId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonRenderResponse>;
    public getRenderStatus(version: number, renderId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonRenderResponse>>;
    public getRenderStatus(version: number, renderId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonRenderResponse>>;
    public getRenderStatus(version: number, renderId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getRenderStatus.');
        }
        if (renderId === null || renderId === undefined) {
            throw new Error('Required parameter renderId was null or undefined when calling getRenderStatus.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getRenderStatus.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/stories/renders/${this.configuration.encodeParam({name: "renderId", value: renderId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/status`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonRenderResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Speach to Text Result
     * The results of the video transcription and optional translation.
     * @endpoint get /api/{version}/orson/ai/stt/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getSTT(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiSTTResponse>;
    public getSTT(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiSTTResponse>>;
    public getSTT(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiSTTResponse>>;
    public getSTT(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getSTT.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getSTT.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getSTT.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/stt/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiSTTResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Text to Speach Result
     * Check the status of an in progress Text-to-Speech call or download the result.
     * @endpoint get /api/{version}/orson/ai/tts/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getTTS(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiTTSResponse>;
    public getTTS(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiTTSResponse>>;
    public getTTS(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiTTSResponse>>;
    public getTTS(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTTS.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getTTS.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTTS.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/tts/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiTTSResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get TechTune Results
     * Get a result or continue waiting for a pending request for TechTune analysis.
     * @endpoint get /api/{version}/orson/ai/techTune/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getTechTune(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiTechTuneResponse>;
    public getTechTune(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiTechTuneResponse>>;
    public getTechTune(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiTechTuneResponse>>;
    public getTechTune(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTechTune.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getTechTune.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTechTune.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/techTune/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiTechTuneResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Topics
     * Get the result of an in progress Topics Analysis from an earlier POST.
     * @endpoint get /api/{version}/orson/ai/topics/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getTopics(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiTopicsResponse>;
    public getTopics(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiTopicsResponse>>;
    public getTopics(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiTopicsResponse>>;
    public getTopics(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getTopics.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getTopics.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTopics.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/topics/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiTopicsResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get VoiceCanvas images
     * Get a result or continue waiting for a pending request for VoiceCanvas Images.
     * @endpoint get /api/{version}/orson/ai/voiceCanvas/{requestId}
     * @param version 
     * @param requestId Orson Request Id
     * @param accountId Sirqul Account Id
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getVoiceCanvas(version: number, requestId: string, accountId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiVoiceCanvasResponse>;
    public getVoiceCanvas(version: number, requestId: string, accountId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiVoiceCanvasResponse>>;
    public getVoiceCanvas(version: number, requestId: string, accountId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiVoiceCanvasResponse>>;
    public getVoiceCanvas(version: number, requestId: string, accountId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getVoiceCanvas.');
        }
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling getVoiceCanvas.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getVoiceCanvas.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/voiceCanvas/${this.configuration.encodeParam({name: "requestId", value: requestId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiVoiceCanvasResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Starts a StoryStitch video render
     * Starts a StoryStitch video render to produce your final video, returning the status details.
     * @endpoint post /api/{version}/orson/stories/renders
     * @param version 
     * @param accountId Sirqul Account Id
     * @param data Request Data String
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public startVideoRender(version: number, accountId: number, data: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonRenderResponse>;
    public startVideoRender(version: number, accountId: number, data: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonRenderResponse>>;
    public startVideoRender(version: number, accountId: number, data: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonRenderResponse>>;
    public startVideoRender(version: number, accountId: number, data: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling startVideoRender.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling startVideoRender.');
        }
        if (data === null || data === undefined) {
            throw new Error('Required parameter data was null or undefined when calling startVideoRender.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'data',
            <any>data,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/stories/renders`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonRenderResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Speach to Text
     * Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
     * @endpoint post /api/{version}/orson/ai/stt
     * @param version 
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param sourceLanguage Source Language
     * @param targetLanguage Target Language
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public stt(version: number, accountId: number, thirdPartyAccountId?: string, sourceLanguage?: string, targetLanguage?: string, file?: Blob, url?: string, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiSTTResponse>;
    public stt(version: number, accountId: number, thirdPartyAccountId?: string, sourceLanguage?: string, targetLanguage?: string, file?: Blob, url?: string, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiSTTResponse>>;
    public stt(version: number, accountId: number, thirdPartyAccountId?: string, sourceLanguage?: string, targetLanguage?: string, file?: Blob, url?: string, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiSTTResponse>>;
    public stt(version: number, accountId: number, thirdPartyAccountId?: string, sourceLanguage?: string, targetLanguage?: string, file?: Blob, url?: string, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling stt.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling stt.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sourceLanguage',
            <any>sourceLanguage,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'targetLanguage',
            <any>targetLanguage,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/stt`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiSTTResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Summarize Topics
     * Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
     * @endpoint post /api/{version}/orson/ai/topics
     * @param version 
     * @param accountId Sirqul Account Id
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param doc The text to get topics for.
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param limit The number of results to return
     * @param offset The starting offset into the total result set to start from
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public summarizeTopics(version: number, accountId: number, thirdPartyAccountId?: string, doc?: string, file?: Blob, url?: string, limit?: number, offset?: number, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiTopicsResponse>;
    public summarizeTopics(version: number, accountId: number, thirdPartyAccountId?: string, doc?: string, file?: Blob, url?: string, limit?: number, offset?: number, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiTopicsResponse>>;
    public summarizeTopics(version: number, accountId: number, thirdPartyAccountId?: string, doc?: string, file?: Blob, url?: string, limit?: number, offset?: number, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiTopicsResponse>>;
    public summarizeTopics(version: number, accountId: number, thirdPartyAccountId?: string, doc?: string, file?: Blob, url?: string, limit?: number, offset?: number, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling summarizeTopics.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling summarizeTopics.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'doc',
            <any>doc,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offset',
            <any>offset,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/topics`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiTopicsResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Detect Technical Issues
     * Analyses a movie file to detect technical issues, such as too few people in frame.
     * @endpoint post /api/{version}/orson/ai/techTune
     * @param version 
     * @param accountId Sirqul Account Id
     * @param numFacesExpected Number of expected faces
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param file An uploaded recording to analyze (Currently limited to 10MB)
     * @param url A recording file to download and analyze (Size limit: 1GB)
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public techTune(version: number, accountId: number, numFacesExpected: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiTechTuneResponse>;
    public techTune(version: number, accountId: number, numFacesExpected: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiTechTuneResponse>>;
    public techTune(version: number, accountId: number, numFacesExpected: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiTechTuneResponse>>;
    public techTune(version: number, accountId: number, numFacesExpected: number, thirdPartyAccountId?: string, file?: Blob, url?: string, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling techTune.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling techTune.');
        }
        if (numFacesExpected === null || numFacesExpected === undefined) {
            throw new Error('Required parameter numFacesExpected was null or undefined when calling techTune.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'numFacesExpected',
            <any>numFacesExpected,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'file',
            <any>file,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'url',
            <any>url,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/techTune`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiTechTuneResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Text to Speach
     * Creates an audio file for the given text, with the option of language and voice selection.
     * @endpoint post /api/{version}/orson/ai/tts
     * @param version 
     * @param accountId Sirqul Account Id
     * @param text Text
     * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
     * @param language The language to use for the speaker and incoming text
     * @param voice A language-specific voice to use, or picks the language default if not provided
     * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public tts(version: number, accountId: number, text: string, thirdPartyAccountId?: string, language?: string, voice?: string, callback?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OrsonAiTTSResponse>;
    public tts(version: number, accountId: number, text: string, thirdPartyAccountId?: string, language?: string, voice?: string, callback?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OrsonAiTTSResponse>>;
    public tts(version: number, accountId: number, text: string, thirdPartyAccountId?: string, language?: string, voice?: string, callback?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OrsonAiTTSResponse>>;
    public tts(version: number, accountId: number, text: string, thirdPartyAccountId?: string, language?: string, voice?: string, callback?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling tts.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling tts.');
        }
        if (text === null || text === undefined) {
            throw new Error('Required parameter text was null or undefined when calling tts.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyAccountId',
            <any>thirdPartyAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'text',
            <any>text,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'language',
            <any>language,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'voice',
            <any>voice,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'callback',
            <any>callback,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/orson/ai/tts`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OrsonAiTTSResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
