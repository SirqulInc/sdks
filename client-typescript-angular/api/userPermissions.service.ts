/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { SirqulResponse } from '../model/sirqulResponse';
// @ts-ignore
import { UserPermissionsResponse } from '../model/userPermissionsResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class UserPermissionsService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Add User
     * Adds a user to a permissionable object.
     * @endpoint post /api/{version}/consumer/permissions/add
     * @param version 
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param read the read permission of the users/groups
     * @param write the write permission of the users/groups
     * @param _delete the delete permission of the users/groups
     * @param add the add permission of the users/groups
     * @param connectionIds a comma separated list of connection ids (NOT the account ids)
     * @param connectionAccountIds a comma separated list of account ids
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user)
     * @param pending sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
     * @param admin sets whether the added users will become admins or not
     * @param includeFriendGroup flag to determine whether to include the built-in \&quot;friends\&quot; group
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param audienceIds comma separated list of audience ids. This is a feature only available to the permissionable\&#39;s application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public addUsersToPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, read?: boolean, write?: boolean, _delete?: boolean, add?: boolean, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, pending?: boolean, admin?: boolean, includeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public addUsersToPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, read?: boolean, write?: boolean, _delete?: boolean, add?: boolean, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, pending?: boolean, admin?: boolean, includeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public addUsersToPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, read?: boolean, write?: boolean, _delete?: boolean, add?: boolean, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, pending?: boolean, admin?: boolean, includeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public addUsersToPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, read?: boolean, write?: boolean, _delete?: boolean, add?: boolean, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, pending?: boolean, admin?: boolean, includeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling addUsersToPermissionable.');
        }
        if (permissionableType === null || permissionableType === undefined) {
            throw new Error('Required parameter permissionableType was null or undefined when calling addUsersToPermissionable.');
        }
        if (permissionableId === null || permissionableId === undefined) {
            throw new Error('Required parameter permissionableId was null or undefined when calling addUsersToPermissionable.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableType',
            <any>permissionableType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableId',
            <any>permissionableId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'read',
            <any>read,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'write',
            <any>write,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'delete',
            <any>_delete,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'add',
            <any>add,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionIds',
            <any>connectionIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountIds',
            <any>connectionAccountIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionGroupIds',
            <any>connectionGroupIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'pending',
            <any>pending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'admin',
            <any>admin,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeFriendGroup',
            <any>includeFriendGroup,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIds',
            <any>audienceIds,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/consumer/permissions/add`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Approve Permissionable
     * Sets the approval status of a permissionable object.
     * @endpoint post /api/{version}/permissionable/approve
     * @param version 
     * @param permissionableType The permissionable type of the object
     * @param permissionableId The id of the permissionable object
     * @param deviceId A unique ID given by the device (deviceId or accountId required)
     * @param accountId The account ID of the user (deviceId or accountId required)
     * @param approvalStatus The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public approvePermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, approvalStatus?: 'PENDING' | 'REJECTED' | 'APPROVED' | 'FEATURED', observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public approvePermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, approvalStatus?: 'PENDING' | 'REJECTED' | 'APPROVED' | 'FEATURED', observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public approvePermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, approvalStatus?: 'PENDING' | 'REJECTED' | 'APPROVED' | 'FEATURED', observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public approvePermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, approvalStatus?: 'PENDING' | 'REJECTED' | 'APPROVED' | 'FEATURED', observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling approvePermissionable.');
        }
        if (permissionableType === null || permissionableType === undefined) {
            throw new Error('Required parameter permissionableType was null or undefined when calling approvePermissionable.');
        }
        if (permissionableId === null || permissionableId === undefined) {
            throw new Error('Required parameter permissionableId was null or undefined when calling approvePermissionable.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableType',
            <any>permissionableType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableId',
            <any>permissionableId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'approvalStatus',
            <any>approvalStatus,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/permissionable/approve`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Leave
     * Used when the user wants to leave from someone else\&#39;s permissionable object
     * @endpoint post /api/{version}/consumer/permissions/leave
     * @param version 
     * @param permissionableType the permissionable type PermissionableType
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public leaveFromPermissionable(version: number, permissionableType: string, permissionableId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public leaveFromPermissionable(version: number, permissionableType: string, permissionableId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public leaveFromPermissionable(version: number, permissionableType: string, permissionableId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public leaveFromPermissionable(version: number, permissionableType: string, permissionableId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling leaveFromPermissionable.');
        }
        if (permissionableType === null || permissionableType === undefined) {
            throw new Error('Required parameter permissionableType was null or undefined when calling leaveFromPermissionable.');
        }
        if (permissionableId === null || permissionableId === undefined) {
            throw new Error('Required parameter permissionableId was null or undefined when calling leaveFromPermissionable.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableType',
            <any>permissionableType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableId',
            <any>permissionableId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/consumer/permissions/leave`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove User
     * Used to remove someone (assuming they have permission) from a permissionable object
     * @endpoint post /api/{version}/consumer/permissions/remove
     * @param version 
     * @param permissionableType the permissionable type of the object
     * @param permissionableId the id of the permissionable object
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionIds a comma separated list of connection ids (NOT the account ids)
     * @param connectionAccountIds a comma separated list of account ids
     * @param connectionGroupIds a comma separated list of connection group ids (these are groups made by the user)
     * @param removeFriendGroup flag to determine whether to remove the built-in \&quot;friends\&quot; group
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param audienceIds comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public removeUsersFromPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, removeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public removeUsersFromPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, removeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public removeUsersFromPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, removeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public removeUsersFromPermissionable(version: number, permissionableType: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, connectionGroupIds?: string, removeFriendGroup?: boolean, latitude?: number, longitude?: number, audienceIds?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling removeUsersFromPermissionable.');
        }
        if (permissionableType === null || permissionableType === undefined) {
            throw new Error('Required parameter permissionableType was null or undefined when calling removeUsersFromPermissionable.');
        }
        if (permissionableId === null || permissionableId === undefined) {
            throw new Error('Required parameter permissionableId was null or undefined when calling removeUsersFromPermissionable.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableType',
            <any>permissionableType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableId',
            <any>permissionableId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionIds',
            <any>connectionIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountIds',
            <any>connectionAccountIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionGroupIds',
            <any>connectionGroupIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'removeFriendGroup',
            <any>removeFriendGroup,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIds',
            <any>audienceIds,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/consumer/permissions/remove`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Permissionables
     * Search on UserPermissions
     * @endpoint get /api/{version}/permissions/search
     * @param version 
     * @param deviceId A unique ID given by the device (deviceId or accountId required)
     * @param accountId The account ID of the user (deviceId or accountId required)
     * @param connectionAccountId Filter results for a specific user account
     * @param connectionAccountIds Comma separated list of account IDs to filter results with
     * @param permissionableType Filter user permissions by the permissionable object type
     * @param permissionableId The id of the permissionable object to filter by
     * @param keyword Keyword to search within permissionable records
     * @param sortField Field to sort results on
     * @param descending Sort descending when true
     * @param pending Return user permissions that are pending
     * @param admin Return user permissions that are admins
     * @param start the start index for pagination
     * @param limit the limit for pagination
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchPermissionables(version: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, keyword?: string, sortField?: string, descending?: boolean, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<UserPermissionsResponse>>;
    public searchPermissionables(version: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, keyword?: string, sortField?: string, descending?: boolean, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<UserPermissionsResponse>>>;
    public searchPermissionables(version: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, keyword?: string, sortField?: string, descending?: boolean, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<UserPermissionsResponse>>>;
    public searchPermissionables(version: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, keyword?: string, sortField?: string, descending?: boolean, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchPermissionables.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountIds',
            <any>connectionAccountIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableType',
            <any>permissionableType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableId',
            <any>permissionableId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'pending',
            <any>pending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'admin',
            <any>admin,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/permissions/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<UserPermissionsResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Permissionables by Distnace
     * Search on UserPermissions by distance
     * @endpoint get /api/{version}/permissions/distancesearch
     * @param version 
     * @param latitude The latitude of the current account
     * @param longitude The longitude of the current account
     * @param deviceId A unique ID given by the device (deviceId or accountId required)
     * @param accountId The account ID of the user (deviceId or accountId required)
     * @param connectionAccountId Filter results for a specific user account
     * @param connectionAccountIds Comma separated list of account IDs to filter results with
     * @param permissionableType Filter user permissions by the permissionable object type
     * @param permissionableId The id of the permissionable object to filter by
     * @param searchRange The search range in miles
     * @param keyword Keyword to search within permissionable records
     * @param pending Return user permissions that are pending
     * @param admin Return user permissions that are admins
     * @param start The start index for pagination
     * @param limit The limit for pagination
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchPermissionablesFollowingDistance(version: number, latitude: number, longitude: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, searchRange?: number, keyword?: string, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<UserPermissionsResponse>>;
    public searchPermissionablesFollowingDistance(version: number, latitude: number, longitude: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, searchRange?: number, keyword?: string, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<UserPermissionsResponse>>>;
    public searchPermissionablesFollowingDistance(version: number, latitude: number, longitude: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, searchRange?: number, keyword?: string, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<UserPermissionsResponse>>>;
    public searchPermissionablesFollowingDistance(version: number, latitude: number, longitude: number, deviceId?: string, accountId?: number, connectionAccountId?: number, connectionAccountIds?: string, permissionableType?: 'ACCOUNT' | 'GAMELEVEL' | 'ALBUM_CONTEST' | 'THEME_DESCRIPTOR' | 'SCHEDULED_NOTIFICATION' | 'TASK' | 'TRIGGER', permissionableId?: number, searchRange?: number, keyword?: string, pending?: boolean, admin?: boolean, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchPermissionablesFollowingDistance.');
        }
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling searchPermissionablesFollowingDistance.');
        }
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling searchPermissionablesFollowingDistance.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountIds',
            <any>connectionAccountIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableType',
            <any>permissionableType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'permissionableId',
            <any>permissionableId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'searchRange',
            <any>searchRange,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'pending',
            <any>pending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'admin',
            <any>admin,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/permissions/distancesearch`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<UserPermissionsResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
