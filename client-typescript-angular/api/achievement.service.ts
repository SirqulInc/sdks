/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { AchievementProgressResponse } from '../model/achievementProgressResponse';
// @ts-ignore
import { AchievementResponse } from '../model/achievementResponse';
// @ts-ignore
import { AchievementShortResponse } from '../model/achievementShortResponse';
// @ts-ignore
import { AchievementTierResponse } from '../model/achievementTierResponse';
// @ts-ignore
import { SirqulResponse } from '../model/sirqulResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class AchievementService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Searches an Achievement Tier
     * Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint post /api/{version}/achievement/tier/search
     * @param version 
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param appKey the application key
     * @param keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
     * @param achievementType filter results by achievementType (these are exact case sensitive matches)
     * @param rankType filter results by the rankType (these are the exact case sensitive matches)
     * @param sortField the field to sort by. See {@link AchievementApiMap}
     * @param descending determines whether the sort list is in descending or ascending order (of the achievement)
     * @param descendingGoal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
     * @param start The start of the index for pagination
     * @param limit the limit for pagination (has a hard limit of 1000)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public apiVersionAchievementTierSearchPost(version: number, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: number, rankType?: string, sortField?: string, descending?: boolean, descendingGoal?: boolean, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementTierResponse>;
    public apiVersionAchievementTierSearchPost(version: number, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: number, rankType?: string, sortField?: string, descending?: boolean, descendingGoal?: boolean, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementTierResponse>>;
    public apiVersionAchievementTierSearchPost(version: number, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: number, rankType?: string, sortField?: string, descending?: boolean, descendingGoal?: boolean, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementTierResponse>>;
    public apiVersionAchievementTierSearchPost(version: number, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: number, rankType?: string, sortField?: string, descending?: boolean, descendingGoal?: boolean, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling apiVersionAchievementTierSearchPost.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementType',
            <any>achievementType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankType',
            <any>rankType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descendingGoal',
            <any>descendingGoal,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/tier/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementTierResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint post /api/{version}/achievement/create
     * @param version 
     * @param appKey the application key the achievement is for
     * @param title the title of the achievement (255 character limit)
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param analyticsTag the analytics tag that will trigger when a user\&#39;s achievement count gets updated
     * @param description the description of the achievement
     * @param rankType the rank type for updating leader boards
     * @param rankIncrement determines how much the rank count is incremented
     * @param minIncrement restrict scores to be above or equal to this minimum value
     * @param maxIncrement restrict scores to be below or equal to this maximum value
     * @param validate determines whether the customId on analytics are used to validate a user\&#39;s achievement progress.
     * @param active achievement is active or inactive
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createAchievement(version: number, appKey: string, title: string, deviceId?: string, accountId?: number, analyticsTag?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, maxIncrement?: number, validate?: boolean, active?: boolean, triggerDefinition?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementResponse>;
    public createAchievement(version: number, appKey: string, title: string, deviceId?: string, accountId?: number, analyticsTag?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, maxIncrement?: number, validate?: boolean, active?: boolean, triggerDefinition?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementResponse>>;
    public createAchievement(version: number, appKey: string, title: string, deviceId?: string, accountId?: number, analyticsTag?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, maxIncrement?: number, validate?: boolean, active?: boolean, triggerDefinition?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementResponse>>;
    public createAchievement(version: number, appKey: string, title: string, deviceId?: string, accountId?: number, analyticsTag?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, maxIncrement?: number, validate?: boolean, active?: boolean, triggerDefinition?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createAchievement.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createAchievement.');
        }
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling createAchievement.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'analyticsTag',
            <any>analyticsTag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'title',
            <any>title,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankType',
            <any>rankType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankIncrement',
            <any>rankIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'minIncrement',
            <any>minIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'maxIncrement',
            <any>maxIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'validate',
            <any>validate,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'active',
            <any>active,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'triggerDefinition',
            <any>triggerDefinition,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Achievement Tier
     * Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint post /api/{version}/achievement/tier/create
     * @param version 
     * @param achievementId the achievement id for adding a new tier
     * @param scoreAllInstances score all instances
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param icon achievement tier icon image file
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule
     * @param title the title of the achievement tier
     * @param description the description of the achievement tier
     * @param goalCount the count requirement for completing the achievement tier
     * @param missionId The ID of the mission to associate with the achievement
     * @param gameId The ID of the game to associate with the achievement
     * @param packId The ID of the pack to associate with the achievement
     * @param gameLevelId The ID of the game level to associate with the achievement
     * @param gameObjectId The ID of the game object to associate with the achievement
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createAchievementTier(version: number, achievementId: number, scoreAllInstances: boolean, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementTierResponse>;
    public createAchievementTier(version: number, achievementId: number, scoreAllInstances: boolean, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementTierResponse>>;
    public createAchievementTier(version: number, achievementId: number, scoreAllInstances: boolean, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementTierResponse>>;
    public createAchievementTier(version: number, achievementId: number, scoreAllInstances: boolean, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling createAchievementTier.');
        }
        if (achievementId === null || achievementId === undefined) {
            throw new Error('Required parameter achievementId was null or undefined when calling createAchievementTier.');
        }
        if (scoreAllInstances === null || scoreAllInstances === undefined) {
            throw new Error('Required parameter scoreAllInstances was null or undefined when calling createAchievementTier.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementId',
            <any>achievementId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'icon',
            <any>icon,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'iconAssetId',
            <any>iconAssetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'title',
            <any>title,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'goalCount',
            <any>goalCount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameId',
            <any>gameId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameObjectId',
            <any>gameObjectId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'scoreAllInstances',
            <any>scoreAllInstances,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/tier/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementTierResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Achievement
     * Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
     * @endpoint post /api/{version}/achievement/delete
     * @param version 
     * @param achievementId The ID of the achievement
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public deleteAchievement(version: number, achievementId: number, accountId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public deleteAchievement(version: number, achievementId: number, accountId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public deleteAchievement(version: number, achievementId: number, accountId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public deleteAchievement(version: number, achievementId: number, accountId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteAchievement.');
        }
        if (achievementId === null || achievementId === undefined) {
            throw new Error('Required parameter achievementId was null or undefined when calling deleteAchievement.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementId',
            <any>achievementId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/delete`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Achievement Tier
     * Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
     * @endpoint post /api/{version}/achievement/tier/delete
     * @param version 
     * @param achievementTierId the achievement id for deletion
     * @param accountId the account id of the user (deviceId or accountId required).
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public deleteAchievementTier(version: number, achievementTierId: number, accountId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public deleteAchievementTier(version: number, achievementTierId: number, accountId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public deleteAchievementTier(version: number, achievementTierId: number, accountId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public deleteAchievementTier(version: number, achievementTierId: number, accountId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling deleteAchievementTier.');
        }
        if (achievementTierId === null || achievementTierId === undefined) {
            throw new Error('Required parameter achievementTierId was null or undefined when calling deleteAchievementTier.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementTierId',
            <any>achievementTierId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/tier/delete`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Achievement
     * Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint get /api/{version}/achievement/get
     * @param version 
     * @param achievementId The ID of the achievement
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param achievementType achievementType
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getAchievement(version: number, achievementId: number, deviceId?: string, accountId?: number, achievementType?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementTierResponse>;
    public getAchievement(version: number, achievementId: number, deviceId?: string, accountId?: number, achievementType?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementTierResponse>>;
    public getAchievement(version: number, achievementId: number, deviceId?: string, accountId?: number, achievementType?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementTierResponse>>;
    public getAchievement(version: number, achievementId: number, deviceId?: string, accountId?: number, achievementType?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getAchievement.');
        }
        if (achievementId === null || achievementId === undefined) {
            throw new Error('Required parameter achievementId was null or undefined when calling getAchievement.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementId',
            <any>achievementId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementType',
            <any>achievementType,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementTierResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Gets an achievement tier
     * Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint post /api/{version}/achievement/tier/get
     * @param version 
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param achievementTierId the achievement tier id that is being retrieved
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getAchievementTier(version: number, accountId: number, achievementTierId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementTierResponse>;
    public getAchievementTier(version: number, accountId: number, achievementTierId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementTierResponse>>;
    public getAchievementTier(version: number, accountId: number, achievementTierId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementTierResponse>>;
    public getAchievementTier(version: number, accountId: number, achievementTierId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getAchievementTier.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAchievementTier.');
        }
        if (achievementTierId === null || achievementTierId === undefined) {
            throw new Error('Required parameter achievementTierId was null or undefined when calling getAchievementTier.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementTierId',
            <any>achievementTierId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/tier/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementTierResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Achievement Progress
     * Gets a list of user achievements.
     * @endpoint get /api/{version}/achievement/progress/get
     * @param version 
     * @param returnNulls determines whether to return null fields in the response
     * @param appKey the application key for filtering results by application
     * @param includeUndiscovered determines whether to return achievements that the user has not discovered yet
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionAccountEmail the email of the account to view achievements
     * @param connectionAccountId the id of the account to view achievements
     * @param rankType filter results by achievement rankType
     * @param achievementType filter results by achievement type
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getUserAchievements(version: number, returnNulls: boolean, appKey: string, includeUndiscovered: boolean, deviceId?: string, accountId?: number, connectionAccountEmail?: string, connectionAccountId?: number, rankType?: string, achievementType?: string, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<AchievementProgressResponse>>;
    public getUserAchievements(version: number, returnNulls: boolean, appKey: string, includeUndiscovered: boolean, deviceId?: string, accountId?: number, connectionAccountEmail?: string, connectionAccountId?: number, rankType?: string, achievementType?: string, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<AchievementProgressResponse>>>;
    public getUserAchievements(version: number, returnNulls: boolean, appKey: string, includeUndiscovered: boolean, deviceId?: string, accountId?: number, connectionAccountEmail?: string, connectionAccountId?: number, rankType?: string, achievementType?: string, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<AchievementProgressResponse>>>;
    public getUserAchievements(version: number, returnNulls: boolean, appKey: string, includeUndiscovered: boolean, deviceId?: string, accountId?: number, connectionAccountEmail?: string, connectionAccountId?: number, rankType?: string, achievementType?: string, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling getUserAchievements.');
        }
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling getUserAchievements.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling getUserAchievements.');
        }
        if (includeUndiscovered === null || includeUndiscovered === undefined) {
            throw new Error('Required parameter includeUndiscovered was null or undefined when calling getUserAchievements.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountEmail',
            <any>connectionAccountEmail,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankType',
            <any>rankType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementType',
            <any>achievementType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeUndiscovered',
            <any>includeUndiscovered,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/progress/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<AchievementProgressResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Achievement Tags
     * List achievement tags by application
     * @endpoint get /api/{version}/achievement/tag/list
     * @param version 
     * @param appKey filter results by application key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public listAchievementTags(version: number, appKey?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public listAchievementTags(version: number, appKey?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public listAchievementTags(version: number, appKey?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public listAchievementTags(version: number, appKey?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listAchievementTags.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/tag/list`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Achievements
     * List achievements by billable.
     * @endpoint get /api/{version}/achievement/list
     * @param version 
     * @param sortField the field to sort by. See AchievementApiMap
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param start the start index for pagination
     * @param limit the limit for pagination (has a hard limit of 1000)
     * @param activeOnly Filter results to only return active achievements
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param appKey the application key
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches)
     * @param rankType filter results by the rankType (these are exact case sensitive matches)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public listAchievements(version: number, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, start: number, limit: number, activeOnly: boolean, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: string, rankType?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<AchievementShortResponse>>;
    public listAchievements(version: number, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, start: number, limit: number, activeOnly: boolean, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: string, rankType?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<AchievementShortResponse>>>;
    public listAchievements(version: number, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, start: number, limit: number, activeOnly: boolean, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: string, rankType?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<AchievementShortResponse>>>;
    public listAchievements(version: number, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, start: number, limit: number, activeOnly: boolean, deviceId?: string, accountId?: number, appKey?: string, keyword?: string, achievementType?: string, rankType?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling listAchievements.');
        }
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling listAchievements.');
        }
        if (descending === null || descending === undefined) {
            throw new Error('Required parameter descending was null or undefined when calling listAchievements.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling listAchievements.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling listAchievements.');
        }
        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling listAchievements.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementType',
            <any>achievementType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankType',
            <any>rankType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'activeOnly',
            <any>activeOnly,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/list`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<AchievementShortResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Achievements
     * Searches achievements by application for consumers.
     * @endpoint get /api/{version}/achievement/search
     * @param version 
     * @param appKey the application key
     * @param sortField the field to sort by. See AchievementApiMap
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param includeTiers return tiers, only applicable for version &gt;3.18
     * @param includeInactiveTiers return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18
     * @param start the start index for pagination
     * @param limit the limit for pagination (has a hard limit of 1000)
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
     * @param achievementType filter results by the achievementType (these are exact case sensitive matches)
     * @param rankType filter results by the rankType (these are exact case sensitive matches)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchAchievements(version: number, appKey: string, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, includeTiers: boolean, includeInactiveTiers: boolean, start: number, limit: number, deviceId?: string, accountId?: number, keyword?: string, achievementType?: string, rankType?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<AchievementShortResponse>>;
    public searchAchievements(version: number, appKey: string, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, includeTiers: boolean, includeInactiveTiers: boolean, start: number, limit: number, deviceId?: string, accountId?: number, keyword?: string, achievementType?: string, rankType?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<AchievementShortResponse>>>;
    public searchAchievements(version: number, appKey: string, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, includeTiers: boolean, includeInactiveTiers: boolean, start: number, limit: number, deviceId?: string, accountId?: number, keyword?: string, achievementType?: string, rankType?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<AchievementShortResponse>>>;
    public searchAchievements(version: number, appKey: string, sortField: 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'RANK_TYPE' | 'APPLICATION_ID' | 'APPLICATION_NAME' | 'BILLABLE_ID', descending: boolean, includeTiers: boolean, includeInactiveTiers: boolean, start: number, limit: number, deviceId?: string, accountId?: number, keyword?: string, achievementType?: string, rankType?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling searchAchievements.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchAchievements.');
        }
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling searchAchievements.');
        }
        if (descending === null || descending === undefined) {
            throw new Error('Required parameter descending was null or undefined when calling searchAchievements.');
        }
        if (includeTiers === null || includeTiers === undefined) {
            throw new Error('Required parameter includeTiers was null or undefined when calling searchAchievements.');
        }
        if (includeInactiveTiers === null || includeInactiveTiers === undefined) {
            throw new Error('Required parameter includeInactiveTiers was null or undefined when calling searchAchievements.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling searchAchievements.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling searchAchievements.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementType',
            <any>achievementType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankType',
            <any>rankType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeTiers',
            <any>includeTiers,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeInactiveTiers',
            <any>includeInactiveTiers,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<AchievementShortResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Achievement
     * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint post /api/{version}/achievement/update
     * @param version 
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param achievementId the achievement ID for updating an existing achievement
     * @param analyticsTag the analytics tag that will trigger when a user\&#39;s achievement count gets updated
     * @param title the title of the achievement (255 character limit)
     * @param description the description of the achievement
     * @param rankType the rank type for updating leader boards
     * @param rankIncrement determines how much the rank count is incremented
     * @param minIncrement restrict scores to be above or equal to this minimum value
     * @param nullMinIncrement enable to ignore usage of minIncrement
     * @param maxIncrement restrict scores to be below or equal to this maximum value
     * @param nullMaxIncrement enable to ignore usage of maxIncrement
     * @param validate determines whether the customId on analytics are used to validate a user\&#39;s achievement progress.
     * @param active if it\&#39;s active or inactive
     * @param triggerDefinition if provided will define what triggers to run after a tier is completed
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateAchievement(version: number, deviceId?: string, accountId?: number, achievementId?: number, analyticsTag?: string, title?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, nullMinIncrement?: boolean, maxIncrement?: number, nullMaxIncrement?: boolean, validate?: boolean, active?: boolean, triggerDefinition?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementResponse>;
    public updateAchievement(version: number, deviceId?: string, accountId?: number, achievementId?: number, analyticsTag?: string, title?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, nullMinIncrement?: boolean, maxIncrement?: number, nullMaxIncrement?: boolean, validate?: boolean, active?: boolean, triggerDefinition?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementResponse>>;
    public updateAchievement(version: number, deviceId?: string, accountId?: number, achievementId?: number, analyticsTag?: string, title?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, nullMinIncrement?: boolean, maxIncrement?: number, nullMaxIncrement?: boolean, validate?: boolean, active?: boolean, triggerDefinition?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementResponse>>;
    public updateAchievement(version: number, deviceId?: string, accountId?: number, achievementId?: number, analyticsTag?: string, title?: string, description?: string, rankType?: string, rankIncrement?: number, minIncrement?: number, nullMinIncrement?: boolean, maxIncrement?: number, nullMaxIncrement?: boolean, validate?: boolean, active?: boolean, triggerDefinition?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateAchievement.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementId',
            <any>achievementId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'analyticsTag',
            <any>analyticsTag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'title',
            <any>title,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankType',
            <any>rankType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'rankIncrement',
            <any>rankIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'minIncrement',
            <any>minIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'nullMinIncrement',
            <any>nullMinIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'maxIncrement',
            <any>maxIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'nullMaxIncrement',
            <any>nullMaxIncrement,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'validate',
            <any>validate,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'active',
            <any>active,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'triggerDefinition',
            <any>triggerDefinition,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Achievement Tier
     * Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
     * @endpoint post /api/{version}/achievement/tier/update
     * @param version 
     * @param achievementTierId the achievement tier id for updating
     * @param deviceId a unique id given by the device (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param icon achievement tier icon image file
     * @param iconAssetId the icon assetId, if icon is provided, icon will overrule
     * @param title the title of the achievement tier
     * @param description the description of the achievement tier
     * @param goalCount the count requirement for completing the achievement tier
     * @param missionId The ID of the mission to associate with the achievement
     * @param gameId The ID of the game to associate with the achievement
     * @param packId The ID of the pack to associate with the achievement
     * @param gameLevelId The ID of the game level to associate with the achievement
     * @param gameObjectId The ID of the game object to associate with the achievement
     * @param scoreAllInstances score all instances
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateAchievementTier(version: number, achievementTierId: number, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreAllInstances?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AchievementTierResponse>;
    public updateAchievementTier(version: number, achievementTierId: number, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreAllInstances?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AchievementTierResponse>>;
    public updateAchievementTier(version: number, achievementTierId: number, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreAllInstances?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AchievementTierResponse>>;
    public updateAchievementTier(version: number, achievementTierId: number, deviceId?: string, accountId?: number, icon?: Blob, iconAssetId?: number, title?: string, description?: string, goalCount?: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreAllInstances?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateAchievementTier.');
        }
        if (achievementTierId === null || achievementTierId === undefined) {
            throw new Error('Required parameter achievementTierId was null or undefined when calling updateAchievementTier.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementTierId',
            <any>achievementTierId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'icon',
            <any>icon,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'iconAssetId',
            <any>iconAssetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'title',
            <any>title,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'goalCount',
            <any>goalCount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameId',
            <any>gameId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameObjectId',
            <any>gameObjectId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'scoreAllInstances',
            <any>scoreAllInstances,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/tier/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AchievementTierResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Achievement Progress
     * Update user achievement progress.
     * @endpoint post /api/{version}/achievement/progress/update
     * @param version 
     * @param accountId the account id of the user
     * @param achievementId the achievement id (achievementId or tag required)
     * @param tag the analytic tag to identify an achievement (achievementId or tag required)
     * @param customId a custom identifier used for validation
     * @param increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement\&#39;s rankIncrement value)
     * @param startDate a custom start date that the client can set (not yet used in server logic)
     * @param endDate a custom end date that the client can set (not yet used in server logic)
     * @param returnProgress determines whether to return the achievement progress response
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateUserAchievement(version: number, accountId: number, achievementId?: number, tag?: string, customId?: number, increment?: number, startDate?: number, endDate?: number, returnProgress?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public updateUserAchievement(version: number, accountId: number, achievementId?: number, tag?: string, customId?: number, increment?: number, startDate?: number, endDate?: number, returnProgress?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public updateUserAchievement(version: number, accountId: number, achievementId?: number, tag?: string, customId?: number, increment?: number, startDate?: number, endDate?: number, returnProgress?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public updateUserAchievement(version: number, accountId: number, achievementId?: number, tag?: string, customId?: number, increment?: number, startDate?: number, endDate?: number, returnProgress?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (version === null || version === undefined) {
            throw new Error('Required parameter version was null or undefined when calling updateUserAchievement.');
        }
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateUserAchievement.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'achievementId',
            <any>achievementId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tag',
            <any>tag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'customId',
            <any>customId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'increment',
            <any>increment,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startDate',
            <any>startDate,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'endDate',
            <any>endDate,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnProgress',
            <any>returnProgress,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/${this.configuration.encodeParam({name: "version", value: version, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/achievement/progress/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
