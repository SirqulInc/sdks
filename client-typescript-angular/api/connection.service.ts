/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { ConnectionGroupResponse } from '../model/connectionGroupResponse';
// @ts-ignore
import { ConnectionInfoResponse } from '../model/connectionInfoResponse';
// @ts-ignore
import { ConnectionListResponse } from '../model/connectionListResponse';
// @ts-ignore
import { ConnectionResponse } from '../model/connectionResponse';
// @ts-ignore
import { SirqulResponse } from '../model/sirqulResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class ConnectionService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Add Connection
     * Adds a connection to a group.
     * @endpoint post /consumer/connection/group/addConnection
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionId the connection id
     * @param connectionAccountId the connection account id
     * @param pendingId the pending id
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public addConnectionToGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public addConnectionToGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public addConnectionToGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public addConnectionToGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling addConnectionToGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling addConnectionToGroup.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionId',
            <any>connectionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'pendingId',
            <any>pendingId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group/addConnection`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add Connections
     * Adds a list of connections to a group.
     * @endpoint post /connection/group/addConnections
     * @param connectionGroupId the connection group ID
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionIds comma separated list of connection ids
     * @param connectionAccountIds comma separated list of connection account ids
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public addConnectionsToGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public addConnectionsToGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public addConnectionsToGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public addConnectionsToGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (connectionGroupId === null || connectionGroupId === undefined) {
            throw new Error('Required parameter connectionGroupId was null or undefined when calling addConnectionsToGroup.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionIds',
            <any>connectionIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountIds',
            <any>connectionAccountIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionGroupId',
            <any>connectionGroupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/connection/group/addConnections`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Add Connection Groups
     * Add sub groups to a group.
     * @endpoint post /consumer/connection/group/addSubGroup
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to add to the parent group
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public addSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ConnectionGroupResponse>;
    public addSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConnectionGroupResponse>>;
    public addSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConnectionGroupResponse>>;
    public addSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling addSubGroups.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling addSubGroups.');
        }
        if (subGroupIds === null || subGroupIds === undefined) {
            throw new Error('Required parameter subGroupIds was null or undefined when calling addSubGroups.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'subGroupIds',
            <any>subGroupIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group/addSubGroup`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ConnectionGroupResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create or Update Connection
     * Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
     * @endpoint post /consumer/connection/add
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionId the connection id for editing
     * @param connectionAccountId the connection account id (i.e. the account id of another user)
     * @param pendingId the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
     * @param groupId optional group id if the user wants to add this person into a group
     * @param gameType This parameter is deprecated.
     * @param appKey the application key
     * @param isTrusted determines whether the user is trusting this account
     * @param ignoreFriendRequest determines whether the user has set to ignore the user\&#39;s friend request
     * @param isContact determines whether the user is a contact of this account
     * @param isBlocked determines whether the user is blocking this account
     * @param isFollowing determines whether the user is following this account
     * @param connectionResponse whether to return the connection response or not
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createOrUpdateConnection(deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, groupId?: number, gameType?: string, appKey?: string, isTrusted?: boolean, ignoreFriendRequest?: boolean, isContact?: boolean, isBlocked?: boolean, isFollowing?: boolean, connectionResponse?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ConnectionResponse>;
    public createOrUpdateConnection(deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, groupId?: number, gameType?: string, appKey?: string, isTrusted?: boolean, ignoreFriendRequest?: boolean, isContact?: boolean, isBlocked?: boolean, isFollowing?: boolean, connectionResponse?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConnectionResponse>>;
    public createOrUpdateConnection(deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, groupId?: number, gameType?: string, appKey?: string, isTrusted?: boolean, ignoreFriendRequest?: boolean, isContact?: boolean, isBlocked?: boolean, isFollowing?: boolean, connectionResponse?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConnectionResponse>>;
    public createOrUpdateConnection(deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, groupId?: number, gameType?: string, appKey?: string, isTrusted?: boolean, ignoreFriendRequest?: boolean, isContact?: boolean, isBlocked?: boolean, isFollowing?: boolean, connectionResponse?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionId',
            <any>connectionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'pendingId',
            <any>pendingId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameType',
            <any>gameType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'isTrusted',
            <any>isTrusted,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'ignoreFriendRequest',
            <any>ignoreFriendRequest,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'isContact',
            <any>isContact,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'isBlocked',
            <any>isBlocked,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'isFollowing',
            <any>isFollowing,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionResponse',
            <any>connectionResponse,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/add`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ConnectionResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create or Update Connection Group
     * Creates a new private group.
     * @endpoint post /consumer/connection/group
     * @param returnNulls whether to return nulls or not
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param name the name of the group
     * @param groupId the group id to update a group (don\&#39;t pass anything in if you want to create a new group)
     * @param assetId the asset to attach to the group
     * @param connections comma separated list of connection IDs
     * @param description the description of the group
     * @param canViewProfileInfo determines whether the connections in the group can see the user\&#39;s profile info
     * @param canViewGameInfo determines whether the connections in the group can see the user\&#39;s game info
     * @param canViewFriendInfo determines whether the connections in the group can see the user\&#39;s friends/connections
     * @param active Sets whether the connection group is active or inactive
     * @param latitude the latitude of the group
     * @param longitude the longitude of the group
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createOrUpdateGroup(returnNulls: boolean, deviceId?: string, accountId?: number, name?: string, groupId?: number, assetId?: number, connections?: string, description?: string, canViewProfileInfo?: boolean, canViewGameInfo?: boolean, canViewFriendInfo?: boolean, active?: boolean, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public createOrUpdateGroup(returnNulls: boolean, deviceId?: string, accountId?: number, name?: string, groupId?: number, assetId?: number, connections?: string, description?: string, canViewProfileInfo?: boolean, canViewGameInfo?: boolean, canViewFriendInfo?: boolean, active?: boolean, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public createOrUpdateGroup(returnNulls: boolean, deviceId?: string, accountId?: number, name?: string, groupId?: number, assetId?: number, connections?: string, description?: string, canViewProfileInfo?: boolean, canViewGameInfo?: boolean, canViewFriendInfo?: boolean, active?: boolean, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public createOrUpdateGroup(returnNulls: boolean, deviceId?: string, accountId?: number, name?: string, groupId?: number, assetId?: number, connections?: string, description?: string, canViewProfileInfo?: boolean, canViewGameInfo?: boolean, canViewFriendInfo?: boolean, active?: boolean, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling createOrUpdateGroup.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'name',
            <any>name,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'assetId',
            <any>assetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connections',
            <any>connections,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'canViewProfileInfo',
            <any>canViewProfileInfo,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'canViewGameInfo',
            <any>canViewGameInfo,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'canViewFriendInfo',
            <any>canViewFriendInfo,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'active',
            <any>active,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Accept Follow Request
     * Accept someone\&#39;s follow request.
     * @endpoint post /consumer/follow/accept
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public followAccept(accountId: number, connectionAccountId: number, appKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public followAccept(accountId: number, connectionAccountId: number, appKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public followAccept(accountId: number, connectionAccountId: number, appKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public followAccept(accountId: number, connectionAccountId: number, appKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling followAccept.');
        }
        if (connectionAccountId === null || connectionAccountId === undefined) {
            throw new Error('Required parameter connectionAccountId was null or undefined when calling followAccept.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling followAccept.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/follow/accept`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Reject Follow Request
     * Reject someone\&#39;s follow request or remove them as a follower.
     * @endpoint post /consumer/follow/reject
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who initiated the follow
     * @param appKey the application key for sending notifications
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public followReject(accountId: number, connectionAccountId: number, appKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public followReject(accountId: number, connectionAccountId: number, appKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public followReject(accountId: number, connectionAccountId: number, appKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public followReject(accountId: number, connectionAccountId: number, appKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling followReject.');
        }
        if (connectionAccountId === null || connectionAccountId === undefined) {
            throw new Error('Required parameter connectionAccountId was null or undefined when calling followReject.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling followReject.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/follow/reject`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove Follower / Unfollow
     * Unfollow someone you are following or remove them as a follower.
     * @endpoint post /consumer/follow/remove
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to unfollow
     * @param appKey the application key for sending notifications
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public followRemove(accountId: number, connectionAccountId: number, appKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public followRemove(accountId: number, connectionAccountId: number, appKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public followRemove(accountId: number, connectionAccountId: number, appKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public followRemove(accountId: number, connectionAccountId: number, appKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling followRemove.');
        }
        if (connectionAccountId === null || connectionAccountId === undefined) {
            throw new Error('Required parameter connectionAccountId was null or undefined when calling followRemove.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling followRemove.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/follow/remove`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send Follow Request
     * Send a request to follow someone.
     * @endpoint post /consumer/follow/request
     * @param accountId the account id of the user
     * @param connectionAccountId the account ID of the user who you want to follow
     * @param appKey the application key for sending notifications
     * @param approvalNeeded determines if the other user needs to confirm the follow request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public followRequest(accountId: number, connectionAccountId: number, appKey: string, approvalNeeded?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public followRequest(accountId: number, connectionAccountId: number, appKey: string, approvalNeeded?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public followRequest(accountId: number, connectionAccountId: number, appKey: string, approvalNeeded?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public followRequest(accountId: number, connectionAccountId: number, appKey: string, approvalNeeded?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling followRequest.');
        }
        if (connectionAccountId === null || connectionAccountId === undefined) {
            throw new Error('Required parameter connectionAccountId was null or undefined when calling followRequest.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling followRequest.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'approvalNeeded',
            <any>approvalNeeded,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/follow/request`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Accept Friend
     * Accept a friend request and optionally sends a notification.
     * @endpoint post /consumer/friend/accept
     * @param friendAccountId the friend\&#39;s account id
     * @param notifyFriend determines whether to send a notification to the afflicting party
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param gameType This parameter is deprecated.
     * @param appKey the application key
     * @param notificationMessage optional message to send in a notification
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public friendAccept(friendAccountId: number, notifyFriend: boolean, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public friendAccept(friendAccountId: number, notifyFriend: boolean, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public friendAccept(friendAccountId: number, notifyFriend: boolean, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public friendAccept(friendAccountId: number, notifyFriend: boolean, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (friendAccountId === null || friendAccountId === undefined) {
            throw new Error('Required parameter friendAccountId was null or undefined when calling friendAccept.');
        }
        if (notifyFriend === null || notifyFriend === undefined) {
            throw new Error('Required parameter notifyFriend was null or undefined when calling friendAccept.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'friendAccountId',
            <any>friendAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameType',
            <any>gameType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'notifyFriend',
            <any>notifyFriend,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'notificationMessage',
            <any>notificationMessage,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/friend/accept`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Decline Friend
     * Request a friend request and optionally sends a notification.
     * @endpoint post /consumer/friend/reject
     * @param friendAccountId the friend\&#39;s account id
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param gameType This parameter is deprecated.
     * @param appKey the application key
     * @param notifyFriend determines whether to send a notification to the afflicting party
     * @param notificationMessage optional message to send in a notification
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public friendReject(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notifyFriend?: boolean, notificationMessage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public friendReject(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notifyFriend?: boolean, notificationMessage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public friendReject(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notifyFriend?: boolean, notificationMessage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public friendReject(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notifyFriend?: boolean, notificationMessage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (friendAccountId === null || friendAccountId === undefined) {
            throw new Error('Required parameter friendAccountId was null or undefined when calling friendReject.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'friendAccountId',
            <any>friendAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameType',
            <any>gameType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'notifyFriend',
            <any>notifyFriend,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'notificationMessage',
            <any>notificationMessage,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/friend/reject`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Friend
     * Removes a friend from the user\&#39;s friends list.
     * @endpoint post /consumer/friend/remove
     * @param friendAccountId the account ID of the friend to remove
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param notifyFriend optionally notifies the connection that they have been removed as a friend
     * @param removeFromGroups optionally removes the connection from the user\&#39;s groups
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public friendRemove(friendAccountId: number, deviceId?: string, accountId?: number, notifyFriend?: boolean, removeFromGroups?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public friendRemove(friendAccountId: number, deviceId?: string, accountId?: number, notifyFriend?: boolean, removeFromGroups?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public friendRemove(friendAccountId: number, deviceId?: string, accountId?: number, notifyFriend?: boolean, removeFromGroups?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public friendRemove(friendAccountId: number, deviceId?: string, accountId?: number, notifyFriend?: boolean, removeFromGroups?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (friendAccountId === null || friendAccountId === undefined) {
            throw new Error('Required parameter friendAccountId was null or undefined when calling friendRemove.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'friendAccountId',
            <any>friendAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'notifyFriend',
            <any>notifyFriend,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'removeFromGroups',
            <any>removeFromGroups,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/friend/remove`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Request Friend
     * Sends a friend request notification to another user.
     * @endpoint post /consumer/friend/request
     * @param friendAccountId the friend\&#39;s account id
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param gameType This parameter is deprecated.
     * @param appKey the application key
     * @param notificationMessage optional message to send in a notification
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public friendRequest(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public friendRequest(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public friendRequest(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public friendRequest(friendAccountId: number, deviceId?: string, accountId?: number, gameType?: string, appKey?: string, notificationMessage?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (friendAccountId === null || friendAccountId === undefined) {
            throw new Error('Required parameter friendAccountId was null or undefined when calling friendRequest.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'friendAccountId',
            <any>friendAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameType',
            <any>gameType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'notificationMessage',
            <any>notificationMessage,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/friend/request`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Sent Friend Requests
     * Gets the connection sent friend requests.
     * @endpoint get /consumer/connection/getRequested
     * @param deviceId the ID of the device
     * @param accountId the id of the account
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getConnectionSentFriendRequests(deviceId?: string, accountId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ConnectionListResponse>;
    public getConnectionSentFriendRequests(deviceId?: string, accountId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConnectionListResponse>>;
    public getConnectionSentFriendRequests(deviceId?: string, accountId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConnectionListResponse>>;
    public getConnectionSentFriendRequests(deviceId?: string, accountId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/getRequested`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ConnectionListResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Connections
     * Gets the connections.
     * @endpoint get /consumer/connection/get
     * @param returnNulls whether to return nulls or not
     * @param filter a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)
     * @param sortField sorts the response list by ConnectionApiMap
     * @param descending sorts the response list by descending order if true
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id (deviceId or accountId required)
     * @param connectionAccountId optional parameter to search on other account\&#39;s connections
     * @param q This parameter is deprecated.
     * @param keyword an optional keyword to search on, this parameter is ignored if empty
     * @param i This parameter is deprecated.
     * @param l This parameter is deprecated.
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getConnections(returnNulls: boolean, filter: string, sortField: string, descending: boolean, start: number, limit: number, deviceId?: string, accountId?: number, connectionAccountId?: number, q?: string, keyword?: string, i?: number, l?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ConnectionListResponse>;
    public getConnections(returnNulls: boolean, filter: string, sortField: string, descending: boolean, start: number, limit: number, deviceId?: string, accountId?: number, connectionAccountId?: number, q?: string, keyword?: string, i?: number, l?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConnectionListResponse>>;
    public getConnections(returnNulls: boolean, filter: string, sortField: string, descending: boolean, start: number, limit: number, deviceId?: string, accountId?: number, connectionAccountId?: number, q?: string, keyword?: string, i?: number, l?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConnectionListResponse>>;
    public getConnections(returnNulls: boolean, filter: string, sortField: string, descending: boolean, start: number, limit: number, deviceId?: string, accountId?: number, connectionAccountId?: number, q?: string, keyword?: string, i?: number, l?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling getConnections.');
        }
        if (filter === null || filter === undefined) {
            throw new Error('Required parameter filter was null or undefined when calling getConnections.');
        }
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling getConnections.');
        }
        if (descending === null || descending === undefined) {
            throw new Error('Required parameter descending was null or undefined when calling getConnections.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling getConnections.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling getConnections.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'filter',
            <any>filter,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'q',
            <any>q,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            '_i',
            <any>i,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            '_l',
            <any>l,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ConnectionListResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Connection Group
     * @endpoint get /consumer/connection/group/details/get
     * @param combineConnections whether to combine connections or not
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param groupId the group id
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getGroupDetails(combineConnections: boolean, deviceId?: string, accountId?: number, groupId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ConnectionGroupResponse>;
    public getGroupDetails(combineConnections: boolean, deviceId?: string, accountId?: number, groupId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConnectionGroupResponse>>;
    public getGroupDetails(combineConnections: boolean, deviceId?: string, accountId?: number, groupId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConnectionGroupResponse>>;
    public getGroupDetails(combineConnections: boolean, deviceId?: string, accountId?: number, groupId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (combineConnections === null || combineConnections === undefined) {
            throw new Error('Required parameter combineConnections was null or undefined when calling getGroupDetails.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'combineConnections',
            <any>combineConnections,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group/details/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ConnectionGroupResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Connection Groups
     * Gets a user\&#39;s private groups and default groups.
     * @endpoint get /connection/group/search
     * @param sortField the field to sort by
     * @param descending whether to return results in descending or ascending order
     * @param activeOnly to search on active only or not
     * @param start The start of the pagination
     * @param limit the limit of the pagination
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param keyword keyword search string
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public groupSearch(sortField: 'CREATED' | 'UPDATED' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'CAN_VIEW_PROFILE_INFO' | 'CAN_VIEW_GAME_INFO' | 'CAN_VIEW_FRIEND_INFO' | 'INVITE_CODE' | 'OWNER_DISPLAY' | 'OWNER_USERNAME', descending: boolean, activeOnly: boolean, start: number, limit: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, keyword?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<ConnectionInfoResponse>>;
    public groupSearch(sortField: 'CREATED' | 'UPDATED' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'CAN_VIEW_PROFILE_INFO' | 'CAN_VIEW_GAME_INFO' | 'CAN_VIEW_FRIEND_INFO' | 'INVITE_CODE' | 'OWNER_DISPLAY' | 'OWNER_USERNAME', descending: boolean, activeOnly: boolean, start: number, limit: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, keyword?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<ConnectionInfoResponse>>>;
    public groupSearch(sortField: 'CREATED' | 'UPDATED' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'CAN_VIEW_PROFILE_INFO' | 'CAN_VIEW_GAME_INFO' | 'CAN_VIEW_FRIEND_INFO' | 'INVITE_CODE' | 'OWNER_DISPLAY' | 'OWNER_USERNAME', descending: boolean, activeOnly: boolean, start: number, limit: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, keyword?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<ConnectionInfoResponse>>>;
    public groupSearch(sortField: 'CREATED' | 'UPDATED' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'CAN_VIEW_PROFILE_INFO' | 'CAN_VIEW_GAME_INFO' | 'CAN_VIEW_FRIEND_INFO' | 'INVITE_CODE' | 'OWNER_DISPLAY' | 'OWNER_USERNAME', descending: boolean, activeOnly: boolean, start: number, limit: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, keyword?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling groupSearch.');
        }
        if (descending === null || descending === undefined) {
            throw new Error('Required parameter descending was null or undefined when calling groupSearch.');
        }
        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling groupSearch.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling groupSearch.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling groupSearch.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'activeOnly',
            <any>activeOnly,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/connection/group/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<ConnectionInfoResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Connection
     * Removes the connection from group.
     * @endpoint post /consumer/connection/group/removeConnection
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionId the connection id
     * @param connectionAccountId the connection account id
     * @param pendingId the pending id
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public removeConnectionFromGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public removeConnectionFromGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public removeConnectionFromGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public removeConnectionFromGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, connectionId?: number, connectionAccountId?: number, pendingId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling removeConnectionFromGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling removeConnectionFromGroup.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionId',
            <any>connectionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountId',
            <any>connectionAccountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'pendingId',
            <any>pendingId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group/removeConnection`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove Connections
     * Remove a list of connections from a group.
     * @endpoint post /connection/group/removeConnections
     * @param connectionGroupId connection group id
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param connectionIds comma separated list of connection ids
     * @param connectionAccountIds comma separated list of connection account ids
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public removeConnectionsFromGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public removeConnectionsFromGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public removeConnectionsFromGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public removeConnectionsFromGroup(connectionGroupId: number, deviceId?: string, accountId?: number, connectionIds?: string, connectionAccountIds?: string, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (connectionGroupId === null || connectionGroupId === undefined) {
            throw new Error('Required parameter connectionGroupId was null or undefined when calling removeConnectionsFromGroup.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionIds',
            <any>connectionIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionAccountIds',
            <any>connectionAccountIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'connectionGroupId',
            <any>connectionGroupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/connection/group/removeConnections`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Connection Group
     * Remove a user\&#39;s group.
     * @endpoint post /consumer/connection/group/remove
     * @param returnNulls whether to return nulls or not
     * @param groupId the group id
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public removeGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public removeGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public removeGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public removeGroup(returnNulls: boolean, groupId: number, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling removeGroup.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling removeGroup.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group/remove`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Remove Connection Groups
     * Remove sub groups from a group
     * @endpoint post /consumer/connection/group/removeSubGroup
     * @param returnNulls whether to return nulls or not
     * @param groupId the parent group id
     * @param subGroupIds comma separated list of group IDs to remove from the parent group
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id of the user (deviceId or accountId required)
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public removeSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public removeSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public removeSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public removeSubGroups(returnNulls: boolean, groupId: number, subGroupIds: string, deviceId?: string, accountId?: number, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling removeSubGroups.');
        }
        if (groupId === null || groupId === undefined) {
            throw new Error('Required parameter groupId was null or undefined when calling removeSubGroups.');
        }
        if (subGroupIds === null || subGroupIds === undefined) {
            throw new Error('Required parameter subGroupIds was null or undefined when calling removeSubGroups.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupId',
            <any>groupId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'subGroupIds',
            <any>subGroupIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/consumer/connection/group/removeSubGroup`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Possible Connections
     * Search for accounts that the user may not have a connection with.
     * @endpoint get /connection/search
     * @param returnNulls return all json attributes if true. defualt is true.
     * @param start start index of the pagination
     * @param limit limit of the pagination
     * @param deviceId the device id (deviceId or accountId required)
     * @param accountId the account id (deviceId or accountId required)
     * @param q This parameter is deprecated.
     * @param keyword keyword to search on, optional and this parameter is ignored if empt
     * @param latitude the current latitude of the user
     * @param longitude the current longitude of the user
     * @param gameType This parameter is deprecated.
     * @param appKey the public application key, if provided only looks for users of that application
     * @param i This parameter is deprecated.
     * @param l This parameter is deprecated.
     * @param sortField the field to sort on
     * @param hasLocation whether the search has location or not
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchConnections(returnNulls: boolean, start: number, limit: number, deviceId?: string, accountId?: number, q?: string, keyword?: string, latitude?: number, longitude?: number, gameType?: string, appKey?: string, i?: number, l?: number, sortField?: string, hasLocation?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ConnectionListResponse>;
    public searchConnections(returnNulls: boolean, start: number, limit: number, deviceId?: string, accountId?: number, q?: string, keyword?: string, latitude?: number, longitude?: number, gameType?: string, appKey?: string, i?: number, l?: number, sortField?: string, hasLocation?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ConnectionListResponse>>;
    public searchConnections(returnNulls: boolean, start: number, limit: number, deviceId?: string, accountId?: number, q?: string, keyword?: string, latitude?: number, longitude?: number, gameType?: string, appKey?: string, i?: number, l?: number, sortField?: string, hasLocation?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ConnectionListResponse>>;
    public searchConnections(returnNulls: boolean, start: number, limit: number, deviceId?: string, accountId?: number, q?: string, keyword?: string, latitude?: number, longitude?: number, gameType?: string, appKey?: string, i?: number, l?: number, sortField?: string, hasLocation?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (returnNulls === null || returnNulls === undefined) {
            throw new Error('Required parameter returnNulls was null or undefined when calling searchConnections.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling searchConnections.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling searchConnections.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnNulls',
            <any>returnNulls,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'q',
            <any>q,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameType',
            <any>gameType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            '_i',
            <any>i,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            '_l',
            <any>l,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'hasLocation',
            <any>hasLocation,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/connection/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ConnectionListResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
