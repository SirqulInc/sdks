/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { MissionShortResponse } from '../model/missionShortResponse';
// @ts-ignore
import { SirqulResponse } from '../model/sirqulResponse';
// @ts-ignore
import { TournamentResponse } from '../model/tournamentResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class TournamentService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Create Tournament
     * Create a tournament.
     * @endpoint post /tournament/create
     * @param accountId The logged in user.
     * @param appKey The appKey the tournament is created for.
     * @param title The title of the tournament
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param startDate The date/time to start the tournament
     * @param subType Custom string client apps can use for searching/filtering tournaments
     * @param imageAssetId The asset ID to attach to the tournament
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
     * @param costToPlayType The type of ticket required to pay
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played
     * @param startingLimit The starting number of players for a tournament (filled with AI\&#39;s)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced)
     * @param description The description of the tournament
     * @param metaData External custom client defined data
     * @param audienceIds The audiences associated with the tournament
     * @param active Activate/deactivate the tournament
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament
     * @param offerIds The list of offers to give as a reward beyond the tickets
     * @param offerAssetId The artwork ID to attach to the reward tickets offers
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content
     * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY
     * @param visibility Sets the visibility flag for the tournament
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not
     * @param winnerTag This sets what analytic tag is used when a winner is determined
     * @param tieTag This sets what analytic tag is used when a tie has occurred
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createTournament(accountId: number, appKey: string, title: string, costToPlay: number, startDate: number, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY' | 'MULTISTAGE', visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<TournamentResponse>;
    public createTournament(accountId: number, appKey: string, title: string, costToPlay: number, startDate: number, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY' | 'MULTISTAGE', visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TournamentResponse>>;
    public createTournament(accountId: number, appKey: string, title: string, costToPlay: number, startDate: number, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY' | 'MULTISTAGE', visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TournamentResponse>>;
    public createTournament(accountId: number, appKey: string, title: string, costToPlay: number, startDate: number, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY' | 'MULTISTAGE', visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createTournament.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createTournament.');
        }
        if (title === null || title === undefined) {
            throw new Error('Required parameter title was null or undefined when calling createTournament.');
        }
        if (costToPlay === null || costToPlay === undefined) {
            throw new Error('Required parameter costToPlay was null or undefined when calling createTournament.');
        }
        if (startDate === null || startDate === undefined) {
            throw new Error('Required parameter startDate was null or undefined when calling createTournament.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'title',
            <any>title,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'subType',
            <any>subType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'imageAssetId',
            <any>imageAssetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'secondsBetweenLevels',
            <any>secondsBetweenLevels,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'secondsForTieBreaker',
            <any>secondsForTieBreaker,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'secondsBetweenPacks',
            <any>secondsBetweenPacks,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'maximumLevelLength',
            <any>maximumLevelLength,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'costToPlay',
            <any>costToPlay,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'costToPlayType',
            <any>costToPlayType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'minimumToPlay',
            <any>minimumToPlay,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startingLimit',
            <any>startingLimit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'availableLimit',
            <any>availableLimit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'metaData',
            <any>metaData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startDate',
            <any>startDate,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIds',
            <any>audienceIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'active',
            <any>active,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableBuyBack',
            <any>enableBuyBack,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offerIds',
            <any>offerIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offerAssetId',
            <any>offerAssetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'fixedReward',
            <any>fixedReward,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'splitReward',
            <any>splitReward,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'allocateTickets',
            <any>allocateTickets,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tournamentData',
            <any>tournamentData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionType',
            <any>missionType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'visibility',
            <any>visibility,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'preliminaryGroups',
            <any>preliminaryGroups,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'preliminaryGroupAdvancements',
            <any>preliminaryGroupAdvancements,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableMultipleEntries',
            <any>enableMultipleEntries,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableMultipleVotes',
            <any>enableMultipleVotes,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'featured',
            <any>featured,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'winnerTag',
            <any>winnerTag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tieTag',
            <any>tieTag,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<TournamentResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Tournament
     * Delete a tournament.
     * @endpoint post /tournament/delete
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission to delete
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public deleteTournament(accountId: number, missionId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public deleteTournament(accountId: number, missionId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public deleteTournament(accountId: number, missionId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public deleteTournament(accountId: number, missionId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteTournament.');
        }
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling deleteTournament.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/delete`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Tournament
     * Get a tournament.
     * @endpoint get /tournament/get
     * @param accountId The id of the logged in user
     * @param missionId The id of the mission to return (either missionId or joinCode is required)
     * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required)
     * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE
     * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getTournament(accountId: number, missionId?: number, joinCode?: string, includeScores?: 'ALL' | 'MINE', objectPreviewSize?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<TournamentResponse>;
    public getTournament(accountId: number, missionId?: number, joinCode?: string, includeScores?: 'ALL' | 'MINE', objectPreviewSize?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TournamentResponse>>;
    public getTournament(accountId: number, missionId?: number, joinCode?: string, includeScores?: 'ALL' | 'MINE', objectPreviewSize?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TournamentResponse>>;
    public getTournament(accountId: number, missionId?: number, joinCode?: string, includeScores?: 'ALL' | 'MINE', objectPreviewSize?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getTournament.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'joinCode',
            <any>joinCode,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeScores',
            <any>includeScores,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'objectPreviewSize',
            <any>objectPreviewSize,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<TournamentResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Tournament Objects
     * Search on game objects of tournaments
     * @endpoint get /tournament/object/search
     * @param accountId the account ID
     * @param gameLevelId the game level id to filter results by
     * @param sortField the field to sort by
     * @param descending determines whether the sorted list is in descending or ascending order
     * @param start the start index for pagination
     * @param limit the limit for pagination
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchObjects(accountId: number, gameLevelId: number, sortField?: 'ID' | 'PLAYER_SCORE_COUNT', descending?: boolean, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public searchObjects(accountId: number, gameLevelId: number, sortField?: 'ID' | 'PLAYER_SCORE_COUNT', descending?: boolean, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public searchObjects(accountId: number, gameLevelId: number, sortField?: 'ID' | 'PLAYER_SCORE_COUNT', descending?: boolean, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public searchObjects(accountId: number, gameLevelId: number, sortField?: 'ID' | 'PLAYER_SCORE_COUNT', descending?: boolean, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchObjects.');
        }
        if (gameLevelId === null || gameLevelId === undefined) {
            throw new Error('Required parameter gameLevelId was null or undefined when calling searchObjects.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/object/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Tournament Rounds
     * Search for the user\&#39;s tournament games.
     * @endpoint get /tournament/round/search
     * @param accountId the account ID
     * @param appKey the application key
     * @param status comma separated list of statuses to filter results by
     * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
     * @param currentOnly search for games that are flagged current only
     * @param visibilities Filter tournament rounds by the mission visibility flag
     * @param start the start index for pagination
     * @param limit the limit for pagination
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchRounds(accountId: number, appKey: string, status?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY', currentOnly?: boolean, visibilities?: string, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public searchRounds(accountId: number, appKey: string, status?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY', currentOnly?: boolean, visibilities?: string, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public searchRounds(accountId: number, appKey: string, status?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY', currentOnly?: boolean, visibilities?: string, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public searchRounds(accountId: number, appKey: string, status?: string, missionType?: 'TOURNAMENT' | 'POOLPLAY', currentOnly?: boolean, visibilities?: string, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchRounds.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchRounds.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'status',
            <any>status,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionType',
            <any>missionType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'currentOnly',
            <any>currentOnly,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'visibilities',
            <any>visibilities,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/round/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Tournaments
     * Search for tournaments
     * @endpoint get /tournament/search
     * @param accountId The logged in user.
     * @param appKey The application key
     * @param keyword the keyword to search tournament on
     * @param subType filter results by subType
     * @param includeInactive whether to include inactives in the search or not
     * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
     * @param filter filter tournaments by the tournament\&#39;s current state
     * @param sortField which field to sort on
     * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false.
     * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
     * @param start Start the result set at some index.
     * @param limit Limit the result to some number
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchTournaments(accountId: number, appKey: string, keyword?: string, subType?: string, includeInactive?: boolean, missionTypes?: string, filter?: 'ALL' | 'UPCOMING' | 'PAST' | 'PRESENT' | 'ACTIVE', sortField?: 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'CREATED' | 'UPDATED' | 'MISSION_TYPE' | 'OWNER_DISPLAY' | 'START_DATE' | 'END_DATE' | 'STARTING_LIMIT' | 'AVAILABLE_LIMIT' | 'INVITE_COUNT' | 'ACCEPTED_COUNT', descending?: boolean, visibility?: string, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<MissionShortResponse>;
    public searchTournaments(accountId: number, appKey: string, keyword?: string, subType?: string, includeInactive?: boolean, missionTypes?: string, filter?: 'ALL' | 'UPCOMING' | 'PAST' | 'PRESENT' | 'ACTIVE', sortField?: 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'CREATED' | 'UPDATED' | 'MISSION_TYPE' | 'OWNER_DISPLAY' | 'START_DATE' | 'END_DATE' | 'STARTING_LIMIT' | 'AVAILABLE_LIMIT' | 'INVITE_COUNT' | 'ACCEPTED_COUNT', descending?: boolean, visibility?: string, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<MissionShortResponse>>;
    public searchTournaments(accountId: number, appKey: string, keyword?: string, subType?: string, includeInactive?: boolean, missionTypes?: string, filter?: 'ALL' | 'UPCOMING' | 'PAST' | 'PRESENT' | 'ACTIVE', sortField?: 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'CREATED' | 'UPDATED' | 'MISSION_TYPE' | 'OWNER_DISPLAY' | 'START_DATE' | 'END_DATE' | 'STARTING_LIMIT' | 'AVAILABLE_LIMIT' | 'INVITE_COUNT' | 'ACCEPTED_COUNT', descending?: boolean, visibility?: string, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<MissionShortResponse>>;
    public searchTournaments(accountId: number, appKey: string, keyword?: string, subType?: string, includeInactive?: boolean, missionTypes?: string, filter?: 'ALL' | 'UPCOMING' | 'PAST' | 'PRESENT' | 'ACTIVE', sortField?: 'ACTIVE' | 'TITLE' | 'DESCRIPTION' | 'CREATED' | 'UPDATED' | 'MISSION_TYPE' | 'OWNER_DISPLAY' | 'START_DATE' | 'END_DATE' | 'STARTING_LIMIT' | 'AVAILABLE_LIMIT' | 'INVITE_COUNT' | 'ACCEPTED_COUNT', descending?: boolean, visibility?: string, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchTournaments.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchTournaments.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'subType',
            <any>subType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeInactive',
            <any>includeInactive,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionTypes',
            <any>missionTypes,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'filter',
            <any>filter,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'visibility',
            <any>visibility,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<MissionShortResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Submit Tournament Score
     * Submit an array of scores for a tournament match. 
     * @endpoint post /tournament/score
     * @param accountId The logged in user account ID.
     * @param appKey The application key.
     * @param missionId The missionId to score for
     * @param gameId The gameId to score for
     * @param packId The packId to score for
     * @param scores a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60; 
     * @param gameLevelId The gameLevelId to score for
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public submitTournamentScore(accountId: number, appKey: string, missionId: number, gameId: number, packId: number, scores: string, gameLevelId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public submitTournamentScore(accountId: number, appKey: string, missionId: number, gameId: number, packId: number, scores: string, gameLevelId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public submitTournamentScore(accountId: number, appKey: string, missionId: number, gameId: number, packId: number, scores: string, gameLevelId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public submitTournamentScore(accountId: number, appKey: string, missionId: number, gameId: number, packId: number, scores: string, gameLevelId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling submitTournamentScore.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling submitTournamentScore.');
        }
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling submitTournamentScore.');
        }
        if (gameId === null || gameId === undefined) {
            throw new Error('Required parameter gameId was null or undefined when calling submitTournamentScore.');
        }
        if (packId === null || packId === undefined) {
            throw new Error('Required parameter packId was null or undefined when calling submitTournamentScore.');
        }
        if (scores === null || scores === undefined) {
            throw new Error('Required parameter scores was null or undefined when calling submitTournamentScore.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameId',
            <any>gameId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'scores',
            <any>scores,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/score`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Submit a vote for a multi-stage album tournament.
     * Submit a vote for a multi-stage album tournament.
     * @endpoint post /tournament/vote
     * @param accountId The logged in user.
     * @param appKey The application to target
     * @param missionId The tournament\&#39;s primary id
     * @param gameObjectId The tournament game object the user wants to vote on
     * @param deviceId The unique id of the device making the request (optional)
     * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public submitTournamentVote(accountId: number, appKey: string, missionId: number, gameObjectId: number, deviceId?: string, checkIfDeviceAlreadyVoted?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public submitTournamentVote(accountId: number, appKey: string, missionId: number, gameObjectId: number, deviceId?: string, checkIfDeviceAlreadyVoted?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public submitTournamentVote(accountId: number, appKey: string, missionId: number, gameObjectId: number, deviceId?: string, checkIfDeviceAlreadyVoted?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public submitTournamentVote(accountId: number, appKey: string, missionId: number, gameObjectId: number, deviceId?: string, checkIfDeviceAlreadyVoted?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling submitTournamentVote.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling submitTournamentVote.');
        }
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling submitTournamentVote.');
        }
        if (gameObjectId === null || gameObjectId === undefined) {
            throw new Error('Required parameter gameObjectId was null or undefined when calling submitTournamentVote.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameObjectId',
            <any>gameObjectId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'checkIfDeviceAlreadyVoted',
            <any>checkIfDeviceAlreadyVoted,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/vote`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Substitute Tournament Player
     * Service to replace the user\&#39;s opponent in the current level - pack - mission with an AI account.
     * @endpoint post /tournament/substitute
     * @param accountId the id of the logged in user
     * @param missionId the id of the mission
     * @param packId the id of the pack
     * @param gameLevelId the id of the game level
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public substituteTournamentPlayer(accountId: number, missionId: number, packId: number, gameLevelId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public substituteTournamentPlayer(accountId: number, missionId: number, packId: number, gameLevelId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public substituteTournamentPlayer(accountId: number, missionId: number, packId: number, gameLevelId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public substituteTournamentPlayer(accountId: number, missionId: number, packId: number, gameLevelId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling substituteTournamentPlayer.');
        }
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling substituteTournamentPlayer.');
        }
        if (packId === null || packId === undefined) {
            throw new Error('Required parameter packId was null or undefined when calling substituteTournamentPlayer.');
        }
        if (gameLevelId === null || gameLevelId === undefined) {
            throw new Error('Required parameter gameLevelId was null or undefined when calling substituteTournamentPlayer.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/substitute`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Tournament
     * Update a tournament.
     * @endpoint post /tournament/update
     * @param accountId The logged in user.
     * @param missionId The mission/tournament to update
     * @param title The title of the tournament
     * @param subType Custom string client apps can use for searching/filtering missions
     * @param imageAssetId The asset ID to attach to the tournament
     * @param secondsBetweenLevels The number of seconds in between the start of each tournament game
     * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker
     * @param secondsBetweenPacks The number of seconds in between the start of each tournament round
     * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
     * @param costToPlay The number of tickets required to pay to enter the tournament
     * @param costToPlayType The type of ticket required to pay
     * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played
     * @param startingLimit The starting number of players for a tournament (filled with AI\&#39;s)
     * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced)
     * @param description The description of the tournament
     * @param metaData External custom client defined data
     * @param startDate The date/time to start the tournament
     * @param audienceIds The audiences associated with the tournament
     * @param active Activate/deactivate the mission
     * @param enableBuyBack Determines whether to allow players to buy back into a tournament
     * @param offerIds The list of offers to give as a reward beyond the tickets
     * @param offerAssetId The artwork ID to attach to the reward offer
     * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided
     * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
     * @param allocateTickets Flag to indicate owner should receive tickets for completed missions
     * @param tournamentData A text based string that will be passed into each tournament setup to populate the content
     * @param visibility Sets the visibility flag for the tournament
     * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
     * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
     * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
     * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
     * @param featured This determines whether the tournament is \&quot;featured\&quot; or not
     * @param winnerTag This sets what analytic tag is used when a winner is determined
     * @param tieTag This sets what analytic tag is used when a winner is determined
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateTournament(accountId: number, missionId: number, title?: string, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlay?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, startDate?: number, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<TournamentResponse>;
    public updateTournament(accountId: number, missionId: number, title?: string, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlay?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, startDate?: number, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<TournamentResponse>>;
    public updateTournament(accountId: number, missionId: number, title?: string, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlay?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, startDate?: number, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<TournamentResponse>>;
    public updateTournament(accountId: number, missionId: number, title?: string, subType?: string, imageAssetId?: number, secondsBetweenLevels?: number, secondsForTieBreaker?: number, secondsBetweenPacks?: number, maximumLevelLength?: number, costToPlay?: number, costToPlayType?: string, minimumToPlay?: number, startingLimit?: number, availableLimit?: number, description?: string, metaData?: string, startDate?: number, audienceIds?: string, active?: boolean, enableBuyBack?: boolean, offerIds?: string, offerAssetId?: number, fixedReward?: boolean, splitReward?: 'EVEN' | 'ALL' | 'FIRST' | 'RANDOM', allocateTickets?: boolean, tournamentData?: string, visibility?: 'PUBLIC' | 'LISTABLE' | 'REWARDABLE' | 'TRIGGERABLE' | 'PRIVATE', preliminaryGroups?: number, preliminaryGroupAdvancements?: string, enableMultipleEntries?: boolean, enableMultipleVotes?: boolean, featured?: boolean, winnerTag?: string, tieTag?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateTournament.');
        }
        if (missionId === null || missionId === undefined) {
            throw new Error('Required parameter missionId was null or undefined when calling updateTournament.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'title',
            <any>title,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'subType',
            <any>subType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'imageAssetId',
            <any>imageAssetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'secondsBetweenLevels',
            <any>secondsBetweenLevels,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'secondsForTieBreaker',
            <any>secondsForTieBreaker,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'secondsBetweenPacks',
            <any>secondsBetweenPacks,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'maximumLevelLength',
            <any>maximumLevelLength,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'costToPlay',
            <any>costToPlay,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'costToPlayType',
            <any>costToPlayType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'minimumToPlay',
            <any>minimumToPlay,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startingLimit',
            <any>startingLimit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'availableLimit',
            <any>availableLimit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'metaData',
            <any>metaData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startDate',
            <any>startDate,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIds',
            <any>audienceIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'active',
            <any>active,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableBuyBack',
            <any>enableBuyBack,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offerIds',
            <any>offerIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'offerAssetId',
            <any>offerAssetId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'fixedReward',
            <any>fixedReward,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'splitReward',
            <any>splitReward,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'allocateTickets',
            <any>allocateTickets,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tournamentData',
            <any>tournamentData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'visibility',
            <any>visibility,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'preliminaryGroups',
            <any>preliminaryGroups,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'preliminaryGroupAdvancements',
            <any>preliminaryGroupAdvancements,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableMultipleEntries',
            <any>enableMultipleEntries,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableMultipleVotes',
            <any>enableMultipleVotes,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'featured',
            <any>featured,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'winnerTag',
            <any>winnerTag,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'tieTag',
            <any>tieTag,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/tournament/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<TournamentResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
