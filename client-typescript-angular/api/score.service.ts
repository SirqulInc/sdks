/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { ScoreResponse } from '../model/scoreResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class ScoreService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Create Score
     * Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
     * @endpoint post /score/create
     * @param accountId The logged in user.
     * @param appKey The game application key to save the score for.
     * @param points The score
     * @param missionId The missionId to score for, ignore if not playing mission.
     * @param gameId The gameId to score for, ignore if not playing mission.
     * @param packId The packId to score for, send -2 if playing community levels.
     * @param gameLevelId The gameLevelId to score for.
     * @param gameObjectId The gameObjectId to score for, ignore if level based scoring.
     * @param timeTaken The time taken to complete task
     * @param highest 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createScore(accountId: number, appKey: string, points: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, timeTaken?: number, highest?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ScoreResponse>;
    public createScore(accountId: number, appKey: string, points: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, timeTaken?: number, highest?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScoreResponse>>;
    public createScore(accountId: number, appKey: string, points: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, timeTaken?: number, highest?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScoreResponse>>;
    public createScore(accountId: number, appKey: string, points: number, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, timeTaken?: number, highest?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createScore.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createScore.');
        }
        if (points === null || points === undefined) {
            throw new Error('Required parameter points was null or undefined when calling createScore.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameId',
            <any>gameId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameObjectId',
            <any>gameObjectId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'points',
            <any>points,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'timeTaken',
            <any>timeTaken,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'highest',
            <any>highest,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/score/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ScoreResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Score
     * Get the high score for an item.  Pass in the full path IDs for the score.
     * @endpoint get /score/get
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission.
     * @param gameId The gameId to score for, null if not playing mission.
     * @param packId The packId to score for, null if playing community levels.
     * @param gameLevelId The gameLevelId to score for.
     * @param gameObjectId The gameObjectId to score for, null if level based scoring.
     * @param scoreObjectType The object type to filter scores by (TicketObjectType)
     * @param scoreStatus The status of the score to filter (ScoreStatus)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getScore(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreObjectType?: string, scoreStatus?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ScoreResponse>;
    public getScore(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreObjectType?: string, scoreStatus?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ScoreResponse>>;
    public getScore(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreObjectType?: string, scoreStatus?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ScoreResponse>>;
    public getScore(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, scoreObjectType?: string, scoreStatus?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getScore.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling getScore.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameId',
            <any>gameId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameObjectId',
            <any>gameObjectId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'scoreObjectType',
            <any>scoreObjectType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'scoreStatus',
            <any>scoreStatus,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/score/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ScoreResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Score
     * Search the scores for an item.  Pass in the full path IDs for the scores.
     * @endpoint get /score/search
     * @param accountId The logged in user.
     * @param appKey The game application key to get the level for.
     * @param missionId The missionId to score for, null if not playing mission.
     * @param gameId The gameId to score for, null if not playing mission.
     * @param packId The packId to score for, null if playing community levels.
     * @param gameLevelId The gameLevelId to score for.
     * @param gameObjectId The gameObjectId to score for, null if level based scoring.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchScores(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<ScoreResponse>>;
    public searchScores(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<ScoreResponse>>>;
    public searchScores(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<ScoreResponse>>>;
    public searchScores(accountId: number, appKey: string, missionId?: number, gameId?: number, packId?: number, gameLevelId?: number, gameObjectId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchScores.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling searchScores.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'missionId',
            <any>missionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameId',
            <any>gameId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'packId',
            <any>packId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameLevelId',
            <any>gameLevelId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameObjectId',
            <any>gameObjectId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/score/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<ScoreResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
