/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { ProfileResponse } from '../model/profileResponse';
// @ts-ignore
import { SirqulResponse } from '../model/sirqulResponse';
// @ts-ignore
import { ThirdPartyCredentialResponse } from '../model/thirdPartyCredentialResponse';
// @ts-ignore
import { ThirdPartyNetworkResponse } from '../model/thirdPartyNetworkResponse';
// @ts-ignore
import { ThirdPartyNetworkShortResponse } from '../model/thirdPartyNetworkShortResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class ThirdPartyCredentialsService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Create Credential
     * This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user\&#39;s third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
     * @endpoint post /thirdparty/credential/create
     * @param thirdPartyId the third party user account id
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token or phone number)
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique id of the account that needs authenticating (optional for PHONE_V2)
     * @param deviceId the unique id of the device making the request
     * @param sessionId the session id for the request
     * @param thirdPartyName the third party user\&#39;s display name
     * @param emailAddress optional email address associated with the third party account
     * @param signinOnlyMode when true will error out if can\&#39;t find any accounts matching (signin only)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters
     * @param latitude the latitude of the user
     * @param longitude the longitude of the user
     * @param metaData External custom client defined data
     * @param thirdPartyRefreshToken optional refresh token for the third party
     * @param audienceIdsToAdd audience ids to add to the account
     * @param audienceIdsToRemove audience ids to remove from the account
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createCredential(thirdPartyId: string, thirdPartyToken: string, networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyName?: string, emailAddress?: string, signinOnlyMode?: boolean, responseFilters?: string, latitude?: number, longitude?: number, metaData?: string, thirdPartyRefreshToken?: string, audienceIdsToAdd?: string, audienceIdsToRemove?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ProfileResponse>;
    public createCredential(thirdPartyId: string, thirdPartyToken: string, networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyName?: string, emailAddress?: string, signinOnlyMode?: boolean, responseFilters?: string, latitude?: number, longitude?: number, metaData?: string, thirdPartyRefreshToken?: string, audienceIdsToAdd?: string, audienceIdsToRemove?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ProfileResponse>>;
    public createCredential(thirdPartyId: string, thirdPartyToken: string, networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyName?: string, emailAddress?: string, signinOnlyMode?: boolean, responseFilters?: string, latitude?: number, longitude?: number, metaData?: string, thirdPartyRefreshToken?: string, audienceIdsToAdd?: string, audienceIdsToRemove?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ProfileResponse>>;
    public createCredential(thirdPartyId: string, thirdPartyToken: string, networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyName?: string, emailAddress?: string, signinOnlyMode?: boolean, responseFilters?: string, latitude?: number, longitude?: number, metaData?: string, thirdPartyRefreshToken?: string, audienceIdsToAdd?: string, audienceIdsToRemove?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (thirdPartyId === null || thirdPartyId === undefined) {
            throw new Error('Required parameter thirdPartyId was null or undefined when calling createCredential.');
        }
        if (thirdPartyToken === null || thirdPartyToken === undefined) {
            throw new Error('Required parameter thirdPartyToken was null or undefined when calling createCredential.');
        }
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling createCredential.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling createCredential.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sessionId',
            <any>sessionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyId',
            <any>thirdPartyId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyName',
            <any>thirdPartyName,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyToken',
            <any>thirdPartyToken,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'emailAddress',
            <any>emailAddress,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'signinOnlyMode',
            <any>signinOnlyMode,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'responseFilters',
            <any>responseFilters,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'metaData',
            <any>metaData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyRefreshToken',
            <any>thirdPartyRefreshToken,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIdsToAdd',
            <any>audienceIdsToAdd,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIdsToRemove',
            <any>audienceIdsToRemove,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/credential/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ProfileResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Create Network
     * Creates a custom third party network.
     * @endpoint post /thirdparty/network/create
     * @param accountId The account id making the request
     * @param name The name of the network
     * @param enableIntrospection Whether the network uses introspection calls
     * @param description The description of the network
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST)
     * @param introspectionURL The HTTP URL of the introspection call
     * @param introspectionParams The parameters of the introspection call
     * @param requiredRootField Required response params
     * @param enableMFA Whether this network uses MFA
     * @param sizeMFA Size of the MFA token
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token
     * @param oauthTokenURL OAuth token endpoint URL
     * @param oauthPrivateKey OAuth private key file (multipart)
     * @param oauthPublicKey OAuth public key file (multipart)
     * @param oauthClientId OAuth client id
     * @param oauthSecretKey OAuth secret key
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createNetwork(accountId: number, name: string, enableIntrospection: boolean, description?: string, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ThirdPartyNetworkResponse>;
    public createNetwork(accountId: number, name: string, enableIntrospection: boolean, description?: string, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThirdPartyNetworkResponse>>;
    public createNetwork(accountId: number, name: string, enableIntrospection: boolean, description?: string, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThirdPartyNetworkResponse>>;
    public createNetwork(accountId: number, name: string, enableIntrospection: boolean, description?: string, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createNetwork.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createNetwork.');
        }
        if (enableIntrospection === null || enableIntrospection === undefined) {
            throw new Error('Required parameter enableIntrospection was null or undefined when calling createNetwork.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'name',
            <any>name,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableIntrospection',
            <any>enableIntrospection,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'introspectionMethod',
            <any>introspectionMethod,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'introspectionURL',
            <any>introspectionURL,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'introspectionParams',
            <any>introspectionParams,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'requiredRootField',
            <any>requiredRootField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableMFA',
            <any>enableMFA,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sizeMFA',
            <any>sizeMFA,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'shelfLifeMFA',
            <any>shelfLifeMFA,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthTokenURL',
            <any>oauthTokenURL,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthPrivateKey',
            <any>oauthPrivateKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthPublicKey',
            <any>oauthPublicKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthClientId',
            <any>oauthClientId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthSecretKey',
            <any>oauthSecretKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/network/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ThirdPartyNetworkResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: body,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Credential
     * Delete a third party network on a Sirqul account.
     * @endpoint post /thirdparty/credential/delete
     * @param accountId The account id of the user
     * @param networkUID The third party network identifier
     * @param thirdPartyId The third party user id
     * @param appKey the application key
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public deleteCredential(accountId: number, networkUID: string, thirdPartyId: string, appKey: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public deleteCredential(accountId: number, networkUID: string, thirdPartyId: string, appKey: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public deleteCredential(accountId: number, networkUID: string, thirdPartyId: string, appKey: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public deleteCredential(accountId: number, networkUID: string, thirdPartyId: string, appKey: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteCredential.');
        }
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling deleteCredential.');
        }
        if (thirdPartyId === null || thirdPartyId === undefined) {
            throw new Error('Required parameter thirdPartyId was null or undefined when calling deleteCredential.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling deleteCredential.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyId',
            <any>thirdPartyId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/credential/delete`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Network
     * Marks a custom third party network as deleted. Only the network owners and managers have access to this.
     * @endpoint post /thirdparty/network/delete
     * @param accountId the id of the logged in user
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public deleteNetwork(accountId: number, networkUID: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public deleteNetwork(accountId: number, networkUID: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public deleteNetwork(accountId: number, networkUID: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public deleteNetwork(accountId: number, networkUID: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteNetwork.');
        }
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling deleteNetwork.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/network/delete`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Credential
     * Gets the account information given a third party token.
     * @endpoint post /thirdparty/credential/get
     * @param networkUID the access provider to authenticate against
     * @param appKey the application key
     * @param accountId the unique account id of a specific account that will be bound to the third-party credentials
     * @param deviceId the unique id of the device making the request
     * @param sessionId the session id for the request
     * @param thirdPartyCredentialId the third-party credentials id from the response of the credential/create step
     * @param thirdPartyToken the access token to authenticate with
     * @param thirdPartySecret the secret code to authenticate with (used for MFA)
     * @param createNewAccount flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters
     * @param latitude the latitude of the user
     * @param longitude the longitude of the user
     * @param audienceIdsToAdd audience ids to add to the account
     * @param audienceIdsToRemove audience ids to remove from the account
     * @param referralAccountId account id of the referrer (inviter-invitee relationship)
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getCredential(networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyCredentialId?: number, thirdPartyToken?: string, thirdPartySecret?: string, createNewAccount?: boolean, responseFilters?: string, latitude?: number, longitude?: number, audienceIdsToAdd?: string, audienceIdsToRemove?: string, referralAccountId?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ProfileResponse>;
    public getCredential(networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyCredentialId?: number, thirdPartyToken?: string, thirdPartySecret?: string, createNewAccount?: boolean, responseFilters?: string, latitude?: number, longitude?: number, audienceIdsToAdd?: string, audienceIdsToRemove?: string, referralAccountId?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ProfileResponse>>;
    public getCredential(networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyCredentialId?: number, thirdPartyToken?: string, thirdPartySecret?: string, createNewAccount?: boolean, responseFilters?: string, latitude?: number, longitude?: number, audienceIdsToAdd?: string, audienceIdsToRemove?: string, referralAccountId?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ProfileResponse>>;
    public getCredential(networkUID: string, appKey: string, accountId?: number, deviceId?: string, sessionId?: string, thirdPartyCredentialId?: number, thirdPartyToken?: string, thirdPartySecret?: string, createNewAccount?: boolean, responseFilters?: string, latitude?: number, longitude?: number, audienceIdsToAdd?: string, audienceIdsToRemove?: string, referralAccountId?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling getCredential.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling getCredential.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sessionId',
            <any>sessionId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyCredentialId',
            <any>thirdPartyCredentialId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyToken',
            <any>thirdPartyToken,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartySecret',
            <any>thirdPartySecret,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'createNewAccount',
            <any>createNewAccount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'responseFilters',
            <any>responseFilters,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIdsToAdd',
            <any>audienceIdsToAdd,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceIdsToRemove',
            <any>audienceIdsToRemove,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'referralAccountId',
            <any>referralAccountId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/credential/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ProfileResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Network
     * Get the details of a third party network. Only the network owners and managers have access to this.
     * @endpoint get /thirdparty/network/get
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getNetwork(accountId: number, networkUID: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ThirdPartyNetworkResponse>;
    public getNetwork(accountId: number, networkUID: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThirdPartyNetworkResponse>>;
    public getNetwork(accountId: number, networkUID: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThirdPartyNetworkResponse>>;
    public getNetwork(accountId: number, networkUID: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getNetwork.');
        }
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling getNetwork.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/network/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ThirdPartyNetworkResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Credentials
     * Search on a user\&#39;s linked third party networks.
     * @endpoint get /thirdparty/credential/search
     * @param accountId The account id of the user
     * @param keyword The keyword used to search on the third party name and network string
     * @param networkUID The network UID to filter results with
     * @param descending The order to return the search results
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchCredentials(accountId: number, keyword?: string, networkUID?: string, descending?: boolean, start?: number, limit?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<ThirdPartyCredentialResponse>>;
    public searchCredentials(accountId: number, keyword?: string, networkUID?: string, descending?: boolean, start?: number, limit?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<ThirdPartyCredentialResponse>>>;
    public searchCredentials(accountId: number, keyword?: string, networkUID?: string, descending?: boolean, start?: number, limit?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<ThirdPartyCredentialResponse>>>;
    public searchCredentials(accountId: number, keyword?: string, networkUID?: string, descending?: boolean, start?: number, limit?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchCredentials.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/credential/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<ThirdPartyCredentialResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Networks
     * Search on supported third party networks and custom networks from external users.
     * @endpoint get /thirdparty/network/search
     * @param accountId The account id making the request
     * @param sortField The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME
     * @param descending The order to return the search results
     * @param start The start of the pagination
     * @param limit The limit of the pagination
     * @param activeOnly Return only active results
     * @param keyword The keyword used to search on the network name and description fields
     * @param filterBillable Determines whether to only return applications that the user has access to
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public searchNetworks(accountId: number, sortField: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'BILLABLE_ENTITY_ID' | 'BILLABLE_ENTITY_NAME' | 'RESPONSIBLE_DISPLAY' | 'NAME' | 'DESCRIPTION', descending: boolean, start: number, limit: number, activeOnly: boolean, keyword?: string, filterBillable?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<ThirdPartyNetworkShortResponse>>;
    public searchNetworks(accountId: number, sortField: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'BILLABLE_ENTITY_ID' | 'BILLABLE_ENTITY_NAME' | 'RESPONSIBLE_DISPLAY' | 'NAME' | 'DESCRIPTION', descending: boolean, start: number, limit: number, activeOnly: boolean, keyword?: string, filterBillable?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<ThirdPartyNetworkShortResponse>>>;
    public searchNetworks(accountId: number, sortField: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'BILLABLE_ENTITY_ID' | 'BILLABLE_ENTITY_NAME' | 'RESPONSIBLE_DISPLAY' | 'NAME' | 'DESCRIPTION', descending: boolean, start: number, limit: number, activeOnly: boolean, keyword?: string, filterBillable?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<ThirdPartyNetworkShortResponse>>>;
    public searchNetworks(accountId: number, sortField: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'BILLABLE_ENTITY_ID' | 'BILLABLE_ENTITY_NAME' | 'RESPONSIBLE_DISPLAY' | 'NAME' | 'DESCRIPTION', descending: boolean, start: number, limit: number, activeOnly: boolean, keyword?: string, filterBillable?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling searchNetworks.');
        }
        if (sortField === null || sortField === undefined) {
            throw new Error('Required parameter sortField was null or undefined when calling searchNetworks.');
        }
        if (descending === null || descending === undefined) {
            throw new Error('Required parameter descending was null or undefined when calling searchNetworks.');
        }
        if (start === null || start === undefined) {
            throw new Error('Required parameter start was null or undefined when calling searchNetworks.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling searchNetworks.');
        }
        if (activeOnly === null || activeOnly === undefined) {
            throw new Error('Required parameter activeOnly was null or undefined when calling searchNetworks.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'activeOnly',
            <any>activeOnly,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'filterBillable',
            <any>filterBillable,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/network/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<ThirdPartyNetworkShortResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send MFA Challenge
     * Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
     * @endpoint post /thirdparty/credential/mfa/send
     * @param networkUID the third party network provider that has MFA enabled
     * @param appKey the application key
     * @param thirdPartyToken the access token to authenticate with
     * @param thirdPartyCredentialId optional id of the existing third party credential
     * @param deviceId the unique id of the device making the request
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public sendMFAChallenge(networkUID: string, appKey: string, thirdPartyToken?: string, thirdPartyCredentialId?: number, deviceId?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public sendMFAChallenge(networkUID: string, appKey: string, thirdPartyToken?: string, thirdPartyCredentialId?: number, deviceId?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public sendMFAChallenge(networkUID: string, appKey: string, thirdPartyToken?: string, thirdPartyCredentialId?: number, deviceId?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public sendMFAChallenge(networkUID: string, appKey: string, thirdPartyToken?: string, thirdPartyCredentialId?: number, deviceId?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling sendMFAChallenge.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling sendMFAChallenge.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyToken',
            <any>thirdPartyToken,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyCredentialId',
            <any>thirdPartyCredentialId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/credential/mfa/send`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Credential
     * Updates a third-party login for an account.
     * @endpoint post /thirdparty/credential/update
     * @param networkUID the access provider to authenticate against
     * @param thirdPartyId the third party user account id
     * @param appKey the application key
     * @param deviceId the unique id of the device making the request
     * @param thirdPartyName the third party user name
     * @param thirdPartyToken the access token to authenticate with (ex: username or fb token)
     * @param responseFilters this determines how much of the profile should be returned, see ProfileFilters
     * @param metaData External custom client defined data
     * @param thirdPartyRefreshToken optional refresh token for the third party
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateCredential(networkUID: string, thirdPartyId: string, appKey: string, deviceId?: string, thirdPartyName?: string, thirdPartyToken?: string, responseFilters?: string, metaData?: string, thirdPartyRefreshToken?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ProfileResponse>;
    public updateCredential(networkUID: string, thirdPartyId: string, appKey: string, deviceId?: string, thirdPartyName?: string, thirdPartyToken?: string, responseFilters?: string, metaData?: string, thirdPartyRefreshToken?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ProfileResponse>>;
    public updateCredential(networkUID: string, thirdPartyId: string, appKey: string, deviceId?: string, thirdPartyName?: string, thirdPartyToken?: string, responseFilters?: string, metaData?: string, thirdPartyRefreshToken?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ProfileResponse>>;
    public updateCredential(networkUID: string, thirdPartyId: string, appKey: string, deviceId?: string, thirdPartyName?: string, thirdPartyToken?: string, responseFilters?: string, metaData?: string, thirdPartyRefreshToken?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling updateCredential.');
        }
        if (thirdPartyId === null || thirdPartyId === undefined) {
            throw new Error('Required parameter thirdPartyId was null or undefined when calling updateCredential.');
        }
        if (appKey === null || appKey === undefined) {
            throw new Error('Required parameter appKey was null or undefined when calling updateCredential.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceId',
            <any>deviceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyId',
            <any>thirdPartyId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyName',
            <any>thirdPartyName,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyToken',
            <any>thirdPartyToken,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'responseFilters',
            <any>responseFilters,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'metaData',
            <any>metaData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'thirdPartyRefreshToken',
            <any>thirdPartyRefreshToken,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/credential/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ProfileResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Network
     * Updates a custom third party network. Only the network owners and managers have access to this.
     * @endpoint post /thirdparty/network/update
     * @param accountId The account id making the request
     * @param networkUID The unique identifier for the third party network defined by Sirqul
     * @param name The name of the network
     * @param description The description of the network
     * @param enableIntrospection Whether the network uses introspection calls
     * @param introspectionMethod HTTP method to use for introspection calls (e.g., GET, POST)
     * @param introspectionURL The HTTP URL of the introspection call
     * @param introspectionParams The parameters of the introspection call
     * @param requiredRootField Required response params
     * @param enableMFA Whether this network uses MFA
     * @param sizeMFA Size of the MFA token
     * @param shelfLifeMFA Shelf life (seconds) of the MFA token
     * @param oauthTokenURL OAuth token endpoint URL
     * @param oauthPrivateKey OAuth private key file (multipart)
     * @param oauthPublicKey OAuth public key file (multipart)
     * @param oauthClientId OAuth client id
     * @param oauthSecretKey OAuth secret key
     * @param body 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateNetwork(accountId: number, networkUID: string, name?: string, description?: string, enableIntrospection?: boolean, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<ThirdPartyNetworkResponse>;
    public updateNetwork(accountId: number, networkUID: string, name?: string, description?: string, enableIntrospection?: boolean, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<ThirdPartyNetworkResponse>>;
    public updateNetwork(accountId: number, networkUID: string, name?: string, description?: string, enableIntrospection?: boolean, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<ThirdPartyNetworkResponse>>;
    public updateNetwork(accountId: number, networkUID: string, name?: string, description?: string, enableIntrospection?: boolean, introspectionMethod?: string, introspectionURL?: string, introspectionParams?: string, requiredRootField?: string, enableMFA?: boolean, sizeMFA?: number, shelfLifeMFA?: number, oauthTokenURL?: string, oauthPrivateKey?: Blob, oauthPublicKey?: Blob, oauthClientId?: string, oauthSecretKey?: string, body?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateNetwork.');
        }
        if (networkUID === null || networkUID === undefined) {
            throw new Error('Required parameter networkUID was null or undefined when calling updateNetwork.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'networkUID',
            <any>networkUID,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'name',
            <any>name,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableIntrospection',
            <any>enableIntrospection,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'introspectionMethod',
            <any>introspectionMethod,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'introspectionURL',
            <any>introspectionURL,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'introspectionParams',
            <any>introspectionParams,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'requiredRootField',
            <any>requiredRootField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'enableMFA',
            <any>enableMFA,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sizeMFA',
            <any>sizeMFA,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'shelfLifeMFA',
            <any>shelfLifeMFA,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthTokenURL',
            <any>oauthTokenURL,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthPrivateKey',
            <any>oauthPrivateKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthPublicKey',
            <any>oauthPublicKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthClientId',
            <any>oauthClientId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'oauthSecretKey',
            <any>oauthSecretKey,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/thirdparty/network/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<ThirdPartyNetworkResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: body,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
