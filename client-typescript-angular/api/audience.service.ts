/**
 * Sirqul IoT Platform
 *
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpContext 
        }       from '@angular/common/http';
import { Observable }                                        from 'rxjs';
import { OpenApiHttpParams, QueryParamStyle } from '../query.params';

// @ts-ignore
import { AgeGroupResponse } from '../model/ageGroupResponse';
// @ts-ignore
import { AudienceDeviceResponse } from '../model/audienceDeviceResponse';
// @ts-ignore
import { AudienceResponse } from '../model/audienceResponse';
// @ts-ignore
import { OfferListResponse } from '../model/offerListResponse';
// @ts-ignore
import { SearchResponse } from '../model/searchResponse';
// @ts-ignore
import { SirqulResponse } from '../model/sirqulResponse';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { BaseService } from '../api.base.service';



@Injectable({
  providedIn: 'root'
})
export class AudienceService extends BaseService {

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string|string[], @Optional() configuration?: Configuration) {
        super(basePath, configuration);
    }

    /**
     * Create Audience
     * Create a user defined audience.
     * @endpoint post /audience/create
     * @param accountId The logged in user.
     * @param name The name of the audience
     * @param description The description of the audience
     * @param searchTags The search tags
     * @param gender The gender; possible values are: MALE, FEMALE, ANY
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
     * @param startTimeOffset Seconds from the start time of an event
     * @param endTimeOffset Seconds from the end time of an event
     * @param sendSuggestion If true, then notify matching users when they are inside the radius
     * @param associateDescription The description of the associated object
     * @param associateType The type of the object to center the audience geofence
     * @param associateId The ID of the object to center the audience geofence
     * @param groupingId Optional grouping id for the audience
     * @param metaData External custom client defined data
     * @param visibility Visibility of the audience
     * @param audienceType Type of audience
     * @param useOrder Use order for cohort
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type
     * @param appKey Filter results by application key
     * @param trilaterationTypes Trilateration types
     * @param uniqueName If true, makes sure the audience name is unique
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public createAudience(accountId: number, name: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, startTimeOffset?: number, endTimeOffset?: number, sendSuggestion?: boolean, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AudienceResponse>;
    public createAudience(accountId: number, name: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, startTimeOffset?: number, endTimeOffset?: number, sendSuggestion?: boolean, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AudienceResponse>>;
    public createAudience(accountId: number, name: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, startTimeOffset?: number, endTimeOffset?: number, sendSuggestion?: boolean, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AudienceResponse>>;
    public createAudience(accountId: number, name: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, startTimeOffset?: number, endTimeOffset?: number, sendSuggestion?: boolean, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling createAudience.');
        }
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createAudience.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'name',
            <any>name,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'searchTags',
            <any>searchTags,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gender',
            <any>gender,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'ageGroups',
            <any>ageGroups,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'categoryIds',
            <any>categoryIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'applicationIds',
            <any>applicationIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameExperienceLevel',
            <any>gameExperienceLevel,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'devices',
            <any>devices,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceIds',
            <any>deviceIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceVersions',
            <any>deviceVersions,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'locations',
            <any>locations,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'radius',
            <any>radius,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startTimeOffset',
            <any>startTimeOffset,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'endTimeOffset',
            <any>endTimeOffset,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sendSuggestion',
            <any>sendSuggestion,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'associateDescription',
            <any>associateDescription,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'associateType',
            <any>associateType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'associateId',
            <any>associateId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupingId',
            <any>groupingId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'metaData',
            <any>metaData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'visibility',
            <any>visibility,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceType',
            <any>audienceType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'useOrder',
            <any>useOrder,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'cohortRegionsData',
            <any>cohortRegionsData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'trilaterationTypes',
            <any>trilaterationTypes,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'uniqueName',
            <any>uniqueName,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/create`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AudienceResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Delete Audience
     * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
     * @endpoint post /audience/delete
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to delete.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public deleteAudience(accountId: number, audienceId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public deleteAudience(accountId: number, audienceId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public deleteAudience(accountId: number, audienceId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public deleteAudience(accountId: number, audienceId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling deleteAudience.');
        }
        if (audienceId === null || audienceId === undefined) {
            throw new Error('Required parameter audienceId was null or undefined when calling deleteAudience.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceId',
            <any>audienceId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/delete`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Age Groups
     * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
     * @endpoint get /audience/ageGroups
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getAgeGroups(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<AgeGroupResponse>>;
    public getAgeGroups(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<AgeGroupResponse>>>;
    public getAgeGroups(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<AgeGroupResponse>>>;
    public getAgeGroups(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/ageGroups`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<AgeGroupResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Audience
     * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
     * @endpoint get /audience/get
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to return.
     * @param appKey The application key (optional). If provided, results may be scoped to this application.
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getAudience(accountId: number, audienceId: number, appKey?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AudienceResponse>;
    public getAudience(accountId: number, audienceId: number, appKey?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AudienceResponse>>;
    public getAudience(accountId: number, audienceId: number, appKey?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AudienceResponse>>;
    public getAudience(accountId: number, audienceId: number, appKey?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getAudience.');
        }
        if (audienceId === null || audienceId === undefined) {
            throw new Error('Required parameter audienceId was null or undefined when calling getAudience.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceId',
            <any>audienceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnAccountCount',
            <any>returnAccountCount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnAlbumCount',
            <any>returnAlbumCount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'albumTypesForCount',
            <any>albumTypesForCount,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AudienceResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Search Audiences
     * Get the list audiences owned by the account
     * @endpoint get /audience/search
     * @param accountId The logged in user.
     * @param albumIds Comma separated list of album IDs to filter results with
     * @param keyword The keyword used to search
     * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
     * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
     * @param descending The order to return the results. Default is false, which will return the results in ascending order.
     * @param start The index into the record set to start with.
     * @param limit The total number of record to return (there is a hard limit of 100).
     * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions
     * @param activeOnly Determines whether to return only active results. Default is false.
     * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
     * @param appKey Filter results by application key
     * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
     * @param exactKeyword If true, match keyword exactly
     * @param audienceType (Deprecated) Filter results by audience type
     * @param audienceTypes comma separated string with the different audience types you want to filter for
     * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
     * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
     * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getAudienceList(accountId?: number, albumIds?: string, keyword?: string, keywordFields?: string, sortField?: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'SEND_SUGGESTION' | 'OWNER_ID' | 'OWNER_DISPLAY' | 'GENDER', descending?: boolean, start?: number, limit?: number, sendSuggestion?: boolean, activeOnly?: boolean, groupByGroupingId?: boolean, appKey?: string, returnGlobal?: boolean, exactKeyword?: boolean, audienceType?: string, audienceTypes?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<SearchResponse>>;
    public getAudienceList(accountId?: number, albumIds?: string, keyword?: string, keywordFields?: string, sortField?: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'SEND_SUGGESTION' | 'OWNER_ID' | 'OWNER_DISPLAY' | 'GENDER', descending?: boolean, start?: number, limit?: number, sendSuggestion?: boolean, activeOnly?: boolean, groupByGroupingId?: boolean, appKey?: string, returnGlobal?: boolean, exactKeyword?: boolean, audienceType?: string, audienceTypes?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<SearchResponse>>>;
    public getAudienceList(accountId?: number, albumIds?: string, keyword?: string, keywordFields?: string, sortField?: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'SEND_SUGGESTION' | 'OWNER_ID' | 'OWNER_DISPLAY' | 'GENDER', descending?: boolean, start?: number, limit?: number, sendSuggestion?: boolean, activeOnly?: boolean, groupByGroupingId?: boolean, appKey?: string, returnGlobal?: boolean, exactKeyword?: boolean, audienceType?: string, audienceTypes?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<SearchResponse>>>;
    public getAudienceList(accountId?: number, albumIds?: string, keyword?: string, keywordFields?: string, sortField?: 'ID' | 'CREATED' | 'UPDATED' | 'DELETED' | 'SEARCH_TAGS' | 'ACTIVE' | 'NAME' | 'DESCRIPTION' | 'SEND_SUGGESTION' | 'OWNER_ID' | 'OWNER_DISPLAY' | 'GENDER', descending?: boolean, start?: number, limit?: number, sendSuggestion?: boolean, activeOnly?: boolean, groupByGroupingId?: boolean, appKey?: string, returnGlobal?: boolean, exactKeyword?: boolean, audienceType?: string, audienceTypes?: string, returnAccountCount?: boolean, returnAlbumCount?: boolean, albumTypesForCount?: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'albumIds',
            <any>albumIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keyword',
            <any>keyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'keywordFields',
            <any>keywordFields,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sortField',
            <any>sortField,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'descending',
            <any>descending,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'start',
            <any>start,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sendSuggestion',
            <any>sendSuggestion,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'activeOnly',
            <any>activeOnly,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupByGroupingId',
            <any>groupByGroupingId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnGlobal',
            <any>returnGlobal,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'exactKeyword',
            <any>exactKeyword,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceType',
            <any>audienceType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceTypes',
            <any>audienceTypes,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnAccountCount',
            <any>returnAccountCount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'returnAlbumCount',
            <any>returnAlbumCount,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'albumTypesForCount',
            <any>albumTypesForCount,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/search`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<SearchResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Devices
     * Gets the list of available devices that can be selected by consumers and retailers.
     * @endpoint get /audience/devices
     * @param includeInactive If true return inactive record as well. default is false.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getDevices(includeInactive: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<Array<AudienceDeviceResponse>>;
    public getDevices(includeInactive: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<AudienceDeviceResponse>>>;
    public getDevices(includeInactive: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<AudienceDeviceResponse>>>;
    public getDevices(includeInactive: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (includeInactive === null || includeInactive === undefined) {
            throw new Error('Required parameter includeInactive was null or undefined when calling getDevices.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'includeInactive',
            <any>includeInactive,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/devices`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<Array<AudienceDeviceResponse>>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get Experiences
     * Gets the list of available experiences that can be selected by consumers and retailers.
     * @endpoint get /audience/experiences
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getExperiences(observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public getExperiences(observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public getExperiences(observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public getExperiences(observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {

        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/experiences`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get GroupedAudiences
     * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
     * @endpoint get /audience/grouped/get
     * @param accountId The logged in user.
     * @param audienceGroupingId The audience grouping id to return.
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public getGroupedAudiences(accountId: number, audienceGroupingId: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AudienceResponse>;
    public getGroupedAudiences(accountId: number, audienceGroupingId: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AudienceResponse>>;
    public getGroupedAudiences(accountId: number, audienceGroupingId: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AudienceResponse>>;
    public getGroupedAudiences(accountId: number, audienceGroupingId: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling getGroupedAudiences.');
        }
        if (audienceGroupingId === null || audienceGroupingId === undefined) {
            throw new Error('Required parameter audienceGroupingId was null or undefined when calling getGroupedAudiences.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceGroupingId',
            <any>audienceGroupingId,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/grouped/get`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AudienceResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Suggestions by Audience
     * List either Missions or Offers that the user matches the assigned audience.
     * @endpoint post /audience/suggestion/list
     * @param accountId The account to match offers for.
     * @param limit the limit of the index
     * @param suggestionType the type of suggestion
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public listByAccount(accountId: number, limit: number, suggestionType: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OfferListResponse>;
    public listByAccount(accountId: number, limit: number, suggestionType: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OfferListResponse>>;
    public listByAccount(accountId: number, limit: number, suggestionType: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OfferListResponse>>;
    public listByAccount(accountId: number, limit: number, suggestionType: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listByAccount.');
        }
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling listByAccount.');
        }
        if (suggestionType === null || suggestionType === undefined) {
            throw new Error('Required parameter suggestionType was null or undefined when calling listByAccount.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'suggestionType',
            <any>suggestionType,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/suggestion/list`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OfferListResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Offers by Audience
     * Get a list of offer locations based on audience information provided.
     * @endpoint get /audience/suggestion/offersByAudience
     * @param limit this is the limit of the index
     * @param gender this is the gender to list offers by
     * @param age this is the age to list offers by
     * @param categoryIds this is the category IDs to list offers by
     * @param latitude this is the latitude to list offers by
     * @param longitude this is the longitude to list offers by
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public listByAudience(limit: number, gender?: string, age?: number, categoryIds?: string, latitude?: number, longitude?: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OfferListResponse>;
    public listByAudience(limit: number, gender?: string, age?: number, categoryIds?: string, latitude?: number, longitude?: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OfferListResponse>>;
    public listByAudience(limit: number, gender?: string, age?: number, categoryIds?: string, latitude?: number, longitude?: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OfferListResponse>>;
    public listByAudience(limit: number, gender?: string, age?: number, categoryIds?: string, latitude?: number, longitude?: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (limit === null || limit === undefined) {
            throw new Error('Required parameter limit was null or undefined when calling listByAudience.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gender',
            <any>gender,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'age',
            <any>age,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'categoryIds',
            <any>categoryIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'limit',
            <any>limit,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/suggestion/offersByAudience`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OfferListResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * List Sent Suggestions 
     * Return list of recent trigger suggestions that have been sent to the user.
     * @endpoint get /audience/suggestion/latest
     * @param accountId The account to match offers for.
     * @param timeframe The timeframe in seconds of the latest suggestions
     * @param suggestionType The type of trigger suggestions to return
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public listLastestByAccount(accountId: number, timeframe: number, suggestionType: string, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<OfferListResponse>;
    public listLastestByAccount(accountId: number, timeframe: number, suggestionType: string, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<OfferListResponse>>;
    public listLastestByAccount(accountId: number, timeframe: number, suggestionType: string, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<OfferListResponse>>;
    public listLastestByAccount(accountId: number, timeframe: number, suggestionType: string, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling listLastestByAccount.');
        }
        if (timeframe === null || timeframe === undefined) {
            throw new Error('Required parameter timeframe was null or undefined when calling listLastestByAccount.');
        }
        if (suggestionType === null || suggestionType === undefined) {
            throw new Error('Required parameter suggestionType was null or undefined when calling listLastestByAccount.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'timeframe',
            <any>timeframe,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'suggestionType',
            <any>suggestionType,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/suggestion/latest`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<OfferListResponse>('get', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Send Suggestions
     * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
     * @endpoint post /audience/suggestion/send
     * @param accountId The account to match offers for.
     * @param latitude the latitude
     * @param longitude the longitude
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public sendByAccount(accountId: number, latitude: number, longitude: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<SirqulResponse>;
    public sendByAccount(accountId: number, latitude: number, longitude: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<SirqulResponse>>;
    public sendByAccount(accountId: number, latitude: number, longitude: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<SirqulResponse>>;
    public sendByAccount(accountId: number, latitude: number, longitude: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling sendByAccount.');
        }
        if (latitude === null || latitude === undefined) {
            throw new Error('Required parameter latitude was null or undefined when calling sendByAccount.');
        }
        if (longitude === null || longitude === undefined) {
            throw new Error('Required parameter longitude was null or undefined when calling sendByAccount.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'latitude',
            <any>latitude,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'longitude',
            <any>longitude,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/suggestion/send`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<SirqulResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Update Audience
     * Update a user defined audience.
     * @endpoint post /audience/update
     * @param accountId The logged in user.
     * @param audienceId The id of the audience to update.
     * @param name The name of the audience
     * @param description The description of the audience
     * @param searchTags The search tags
     * @param gender The gender; possible values are: MALE, FEMALE, ANY
     * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
     * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
     * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
     * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
     * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
     * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
     * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
     * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
     * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
     * @param active if audience is active
     * @param sendSuggestion If true, then notify matching users when they are inside the radius
     * @param startTimeOffset Seconds from the start time of an event
     * @param endTimeOffset Seconds from the end time of an event
     * @param associateDescription the associate description
     * @param associateType The type of the object to center the audience geofence
     * @param associateId The ID of the object to center the audience geofence
     * @param groupingId Optional grouping id for the audience
     * @param metaData External custom client defined data
     * @param visibility Visibility of the audience
     * @param audienceType Type of audience
     * @param useOrder Use order for cohort
     * @param cohortRegionsData Cohort data for \&quot;cohort\&quot; audience type
     * @param appKey Filter results by application key
     * @param trilaterationTypes Trilateration types
     * @param uniqueName If true, makes sure the audience name is unique
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     * @param options additional options
     */
    public updateAudience(accountId: number, audienceId: number, name?: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, active?: boolean, sendSuggestion?: boolean, startTimeOffset?: number, endTimeOffset?: number, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<AudienceResponse>;
    public updateAudience(accountId: number, audienceId: number, name?: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, active?: boolean, sendSuggestion?: boolean, startTimeOffset?: number, endTimeOffset?: number, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<AudienceResponse>>;
    public updateAudience(accountId: number, audienceId: number, name?: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, active?: boolean, sendSuggestion?: boolean, startTimeOffset?: number, endTimeOffset?: number, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<AudienceResponse>>;
    public updateAudience(accountId: number, audienceId: number, name?: string, description?: string, searchTags?: string, gender?: string, ageGroups?: string, categoryIds?: string, applicationIds?: string, gameExperienceLevel?: string, devices?: string, deviceIds?: string, deviceVersions?: string, locations?: string, radius?: string, active?: boolean, sendSuggestion?: boolean, startTimeOffset?: number, endTimeOffset?: number, associateDescription?: string, associateType?: string, associateId?: number, groupingId?: string, metaData?: string, visibility?: string, audienceType?: string, useOrder?: boolean, cohortRegionsData?: string, appKey?: string, trilaterationTypes?: string, uniqueName?: boolean, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: '*/*', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (accountId === null || accountId === undefined) {
            throw new Error('Required parameter accountId was null or undefined when calling updateAudience.');
        }
        if (audienceId === null || audienceId === undefined) {
            throw new Error('Required parameter audienceId was null or undefined when calling updateAudience.');
        }

        let localVarQueryParameters = new OpenApiHttpParams(this.encoder);

        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'accountId',
            <any>accountId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceId',
            <any>audienceId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'name',
            <any>name,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'description',
            <any>description,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'searchTags',
            <any>searchTags,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gender',
            <any>gender,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'ageGroups',
            <any>ageGroups,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'categoryIds',
            <any>categoryIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'applicationIds',
            <any>applicationIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'gameExperienceLevel',
            <any>gameExperienceLevel,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'devices',
            <any>devices,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceIds',
            <any>deviceIds,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'deviceVersions',
            <any>deviceVersions,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'locations',
            <any>locations,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'radius',
            <any>radius,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'active',
            <any>active,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'sendSuggestion',
            <any>sendSuggestion,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'startTimeOffset',
            <any>startTimeOffset,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'endTimeOffset',
            <any>endTimeOffset,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'associateDescription',
            <any>associateDescription,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'associateType',
            <any>associateType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'associateId',
            <any>associateId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'groupingId',
            <any>groupingId,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'metaData',
            <any>metaData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'visibility',
            <any>visibility,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'audienceType',
            <any>audienceType,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'useOrder',
            <any>useOrder,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'cohortRegionsData',
            <any>cohortRegionsData,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'appKey',
            <any>appKey,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'trilaterationTypes',
            <any>trilaterationTypes,
            QueryParamStyle.Form,
            true,
        );


        localVarQueryParameters = this.addToHttpParams(
            localVarQueryParameters,
            'uniqueName',
            <any>uniqueName,
            QueryParamStyle.Form,
            true,
        );


        let localVarHeaders = this.defaultHeaders;

        const localVarHttpHeaderAcceptSelected: string | undefined = options?.httpHeaderAccept ?? this.configuration.selectHeaderAccept([
            '*/*'
        ]);
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        const localVarHttpContext: HttpContext = options?.context ?? new HttpContext();

        const localVarTransferCache: boolean = options?.transferCache ?? true;


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/audience/update`;
        const { basePath, withCredentials } = this.configuration;
        return this.httpClient.request<AudienceResponse>('post', `${basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters.toHttpParams(),
                responseType: <any>responseType_,
                ...(withCredentials ? { withCredentials } : {}),
                headers: localVarHeaders,
                observe: observe,
                ...(localVarTransferCache !== undefined ? { transferCache: localVarTransferCache } : {}),
                reportProgress: reportProgress
            }
        );
    }

}
