//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.18

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class JsonObject {
  /// Returns a new [JsonObject] instance.
  JsonObject({
    this.asInt,
    this.asJsonObject,
    this.jsonNull,
    this.asString,
    this.asBoolean,
    this.jsonArray,
    this.jsonObject,
    this.jsonPrimitive,
    this.asJsonArray,
    this.asJsonPrimitive,
    this.asJsonNull,
    this.asNumber,
    this.asDouble,
    this.asFloat,
    this.asLong,
    this.asByte,
    this.asCharacter,
    this.asBigDecimal,
    this.asBigInteger,
    this.asShort,
  });

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? asInt;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  JsonObject? asJsonObject;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? jsonNull;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? asString;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? asBoolean;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? jsonArray;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? jsonObject;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? jsonPrimitive;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  JsonArray? asJsonArray;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  JsonPrimitive? asJsonPrimitive;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  JsonNull? asJsonNull;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  Object? asNumber;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  double? asDouble;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  double? asFloat;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? asLong;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? asByte;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? asCharacter;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  num? asBigDecimal;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? asBigInteger;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? asShort;

  @override
  bool operator ==(Object other) => identical(this, other) || other is JsonObject &&
    other.asInt == asInt &&
    other.asJsonObject == asJsonObject &&
    other.jsonNull == jsonNull &&
    other.asString == asString &&
    other.asBoolean == asBoolean &&
    other.jsonArray == jsonArray &&
    other.jsonObject == jsonObject &&
    other.jsonPrimitive == jsonPrimitive &&
    other.asJsonArray == asJsonArray &&
    other.asJsonPrimitive == asJsonPrimitive &&
    other.asJsonNull == asJsonNull &&
    other.asNumber == asNumber &&
    other.asDouble == asDouble &&
    other.asFloat == asFloat &&
    other.asLong == asLong &&
    other.asByte == asByte &&
    other.asCharacter == asCharacter &&
    other.asBigDecimal == asBigDecimal &&
    other.asBigInteger == asBigInteger &&
    other.asShort == asShort;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (asInt == null ? 0 : asInt!.hashCode) +
    (asJsonObject == null ? 0 : asJsonObject!.hashCode) +
    (jsonNull == null ? 0 : jsonNull!.hashCode) +
    (asString == null ? 0 : asString!.hashCode) +
    (asBoolean == null ? 0 : asBoolean!.hashCode) +
    (jsonArray == null ? 0 : jsonArray!.hashCode) +
    (jsonObject == null ? 0 : jsonObject!.hashCode) +
    (jsonPrimitive == null ? 0 : jsonPrimitive!.hashCode) +
    (asJsonArray == null ? 0 : asJsonArray!.hashCode) +
    (asJsonPrimitive == null ? 0 : asJsonPrimitive!.hashCode) +
    (asJsonNull == null ? 0 : asJsonNull!.hashCode) +
    (asNumber == null ? 0 : asNumber!.hashCode) +
    (asDouble == null ? 0 : asDouble!.hashCode) +
    (asFloat == null ? 0 : asFloat!.hashCode) +
    (asLong == null ? 0 : asLong!.hashCode) +
    (asByte == null ? 0 : asByte!.hashCode) +
    (asCharacter == null ? 0 : asCharacter!.hashCode) +
    (asBigDecimal == null ? 0 : asBigDecimal!.hashCode) +
    (asBigInteger == null ? 0 : asBigInteger!.hashCode) +
    (asShort == null ? 0 : asShort!.hashCode);

  @override
  String toString() => 'JsonObject[asInt=$asInt, asJsonObject=$asJsonObject, jsonNull=$jsonNull, asString=$asString, asBoolean=$asBoolean, jsonArray=$jsonArray, jsonObject=$jsonObject, jsonPrimitive=$jsonPrimitive, asJsonArray=$asJsonArray, asJsonPrimitive=$asJsonPrimitive, asJsonNull=$asJsonNull, asNumber=$asNumber, asDouble=$asDouble, asFloat=$asFloat, asLong=$asLong, asByte=$asByte, asCharacter=$asCharacter, asBigDecimal=$asBigDecimal, asBigInteger=$asBigInteger, asShort=$asShort]';

  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{};
    if (this.asInt != null) {
      json[r'asInt'] = this.asInt;
    } else {
      json[r'asInt'] = null;
    }
    if (this.asJsonObject != null) {
      json[r'asJsonObject'] = this.asJsonObject;
    } else {
      json[r'asJsonObject'] = null;
    }
    if (this.jsonNull != null) {
      json[r'jsonNull'] = this.jsonNull;
    } else {
      json[r'jsonNull'] = null;
    }
    if (this.asString != null) {
      json[r'asString'] = this.asString;
    } else {
      json[r'asString'] = null;
    }
    if (this.asBoolean != null) {
      json[r'asBoolean'] = this.asBoolean;
    } else {
      json[r'asBoolean'] = null;
    }
    if (this.jsonArray != null) {
      json[r'jsonArray'] = this.jsonArray;
    } else {
      json[r'jsonArray'] = null;
    }
    if (this.jsonObject != null) {
      json[r'jsonObject'] = this.jsonObject;
    } else {
      json[r'jsonObject'] = null;
    }
    if (this.jsonPrimitive != null) {
      json[r'jsonPrimitive'] = this.jsonPrimitive;
    } else {
      json[r'jsonPrimitive'] = null;
    }
    if (this.asJsonArray != null) {
      json[r'asJsonArray'] = this.asJsonArray;
    } else {
      json[r'asJsonArray'] = null;
    }
    if (this.asJsonPrimitive != null) {
      json[r'asJsonPrimitive'] = this.asJsonPrimitive;
    } else {
      json[r'asJsonPrimitive'] = null;
    }
    if (this.asJsonNull != null) {
      json[r'asJsonNull'] = this.asJsonNull;
    } else {
      json[r'asJsonNull'] = null;
    }
    if (this.asNumber != null) {
      json[r'asNumber'] = this.asNumber;
    } else {
      json[r'asNumber'] = null;
    }
    if (this.asDouble != null) {
      json[r'asDouble'] = this.asDouble;
    } else {
      json[r'asDouble'] = null;
    }
    if (this.asFloat != null) {
      json[r'asFloat'] = this.asFloat;
    } else {
      json[r'asFloat'] = null;
    }
    if (this.asLong != null) {
      json[r'asLong'] = this.asLong;
    } else {
      json[r'asLong'] = null;
    }
    if (this.asByte != null) {
      json[r'asByte'] = this.asByte;
    } else {
      json[r'asByte'] = null;
    }
    if (this.asCharacter != null) {
      json[r'asCharacter'] = this.asCharacter;
    } else {
      json[r'asCharacter'] = null;
    }
    if (this.asBigDecimal != null) {
      json[r'asBigDecimal'] = this.asBigDecimal;
    } else {
      json[r'asBigDecimal'] = null;
    }
    if (this.asBigInteger != null) {
      json[r'asBigInteger'] = this.asBigInteger;
    } else {
      json[r'asBigInteger'] = null;
    }
    if (this.asShort != null) {
      json[r'asShort'] = this.asShort;
    } else {
      json[r'asShort'] = null;
    }
    return json;
  }

  /// Returns a new [JsonObject] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static JsonObject? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "JsonObject[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "JsonObject[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return JsonObject(
        asInt: mapValueOfType<int>(json, r'asInt'),
        asJsonObject: JsonObject.fromJson(json[r'asJsonObject']),
        jsonNull: mapValueOfType<bool>(json, r'jsonNull'),
        asString: mapValueOfType<String>(json, r'asString'),
        asBoolean: mapValueOfType<bool>(json, r'asBoolean'),
        jsonArray: mapValueOfType<bool>(json, r'jsonArray'),
        jsonObject: mapValueOfType<bool>(json, r'jsonObject'),
        jsonPrimitive: mapValueOfType<bool>(json, r'jsonPrimitive'),
        asJsonArray: JsonArray.fromJson(json[r'asJsonArray']),
        asJsonPrimitive: JsonPrimitive.fromJson(json[r'asJsonPrimitive']),
        asJsonNull: JsonNull.fromJson(json[r'asJsonNull']),
        asNumber: mapValueOfType<Object>(json, r'asNumber'),
        asDouble: mapValueOfType<double>(json, r'asDouble'),
        asFloat: mapValueOfType<double>(json, r'asFloat'),
        asLong: mapValueOfType<int>(json, r'asLong'),
        asByte: mapValueOfType<String>(json, r'asByte'),
        asCharacter: mapValueOfType<String>(json, r'asCharacter'),
        asBigDecimal: num.parse('${json[r'asBigDecimal']}'),
        asBigInteger: mapValueOfType<int>(json, r'asBigInteger'),
        asShort: mapValueOfType<int>(json, r'asShort'),
      );
    }
    return null;
  }

  static List<JsonObject> listFromJson(dynamic json, {bool growable = false,}) {
    final result = <JsonObject>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = JsonObject.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, JsonObject> mapFromJson(dynamic json) {
    final map = <String, JsonObject>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = JsonObject.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of JsonObject-objects as value to a dart map
  static Map<String, List<JsonObject>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<JsonObject>>{};
    if (json is Map && json.isNotEmpty) {
      // ignore: parameter_assignments
      json = json.cast<String, dynamic>();
      for (final entry in json.entries) {
        map[entry.key] = JsonObject.listFromJson(entry.value, growable: growable,);
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}

