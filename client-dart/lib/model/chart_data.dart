//
// AUTO-GENERATED FILE, DO NOT MODIFY!
//
// @dart=2.18

// ignore_for_file: unused_element, unused_import
// ignore_for_file: always_put_required_named_parameters_first
// ignore_for_file: constant_identifier_names
// ignore_for_file: lines_longer_than_80_chars

part of openapi.api;

class ChartData {
  /// Returns a new [ChartData] instance.
  ChartData({
    this.valid,
    this.message,
    this.version,
    this.serializeNulls,
    this.startTimeLog,
    this.errorCode,
    this.request = const [],
    this.identifier,
    this.idAttribute,
    this.label,
    this.maxValue,
    this.totalCount,
    this.items = const [],
    this.aggregatedItems = const [],
    this.caption,
    this.showAnchor,
    this.anchorAlpha,
    this.getxAxisName,
    this.getyAxisMinValue,
    this.getyAxisName,
    this.decimalPrecision,
    this.formatNumberScale,
    this.numberPrefix,
    this.showNames,
    this.showValues,
    this.showAlternateHGridColor,
    this.alternateHGridColor,
    this.divLineColor,
    this.divLineAlpha,
    this.alternateHGridAlpha,
    this.rotateNames,
    this.returning,
  });

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? valid;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? message;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  double? version;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  bool? serializeNulls;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? startTimeLog;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? errorCode;

  List<NameStringValueResponse> request;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? identifier;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? idAttribute;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? label;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? maxValue;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  int? totalCount;

  List<Object> items;

  List<Object> aggregatedItems;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? caption;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? showAnchor;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? anchorAlpha;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? getxAxisName;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? getyAxisMinValue;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? getyAxisName;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? decimalPrecision;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? formatNumberScale;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? numberPrefix;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? showNames;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? showValues;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? showAlternateHGridColor;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? alternateHGridColor;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? divLineColor;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? divLineAlpha;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? alternateHGridAlpha;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? rotateNames;

  ///
  /// Please note: This property should have been non-nullable! Since the specification file
  /// does not include a default value (using the "default:" property), however, the generated
  /// source code must fall back to having a nullable type.
  /// Consider adding a "default:" property in the specification file to hide this note.
  ///
  String? returning;

  @override
  bool operator ==(Object other) => identical(this, other) || other is ChartData &&
    other.valid == valid &&
    other.message == message &&
    other.version == version &&
    other.serializeNulls == serializeNulls &&
    other.startTimeLog == startTimeLog &&
    other.errorCode == errorCode &&
    _deepEquality.equals(other.request, request) &&
    other.identifier == identifier &&
    other.idAttribute == idAttribute &&
    other.label == label &&
    other.maxValue == maxValue &&
    other.totalCount == totalCount &&
    _deepEquality.equals(other.items, items) &&
    _deepEquality.equals(other.aggregatedItems, aggregatedItems) &&
    other.caption == caption &&
    other.showAnchor == showAnchor &&
    other.anchorAlpha == anchorAlpha &&
    other.getxAxisName == getxAxisName &&
    other.getyAxisMinValue == getyAxisMinValue &&
    other.getyAxisName == getyAxisName &&
    other.decimalPrecision == decimalPrecision &&
    other.formatNumberScale == formatNumberScale &&
    other.numberPrefix == numberPrefix &&
    other.showNames == showNames &&
    other.showValues == showValues &&
    other.showAlternateHGridColor == showAlternateHGridColor &&
    other.alternateHGridColor == alternateHGridColor &&
    other.divLineColor == divLineColor &&
    other.divLineAlpha == divLineAlpha &&
    other.alternateHGridAlpha == alternateHGridAlpha &&
    other.rotateNames == rotateNames &&
    other.returning == returning;

  @override
  int get hashCode =>
    // ignore: unnecessary_parenthesis
    (valid == null ? 0 : valid!.hashCode) +
    (message == null ? 0 : message!.hashCode) +
    (version == null ? 0 : version!.hashCode) +
    (serializeNulls == null ? 0 : serializeNulls!.hashCode) +
    (startTimeLog == null ? 0 : startTimeLog!.hashCode) +
    (errorCode == null ? 0 : errorCode!.hashCode) +
    (request.hashCode) +
    (identifier == null ? 0 : identifier!.hashCode) +
    (idAttribute == null ? 0 : idAttribute!.hashCode) +
    (label == null ? 0 : label!.hashCode) +
    (maxValue == null ? 0 : maxValue!.hashCode) +
    (totalCount == null ? 0 : totalCount!.hashCode) +
    (items.hashCode) +
    (aggregatedItems.hashCode) +
    (caption == null ? 0 : caption!.hashCode) +
    (showAnchor == null ? 0 : showAnchor!.hashCode) +
    (anchorAlpha == null ? 0 : anchorAlpha!.hashCode) +
    (getxAxisName == null ? 0 : getxAxisName!.hashCode) +
    (getyAxisMinValue == null ? 0 : getyAxisMinValue!.hashCode) +
    (getyAxisName == null ? 0 : getyAxisName!.hashCode) +
    (decimalPrecision == null ? 0 : decimalPrecision!.hashCode) +
    (formatNumberScale == null ? 0 : formatNumberScale!.hashCode) +
    (numberPrefix == null ? 0 : numberPrefix!.hashCode) +
    (showNames == null ? 0 : showNames!.hashCode) +
    (showValues == null ? 0 : showValues!.hashCode) +
    (showAlternateHGridColor == null ? 0 : showAlternateHGridColor!.hashCode) +
    (alternateHGridColor == null ? 0 : alternateHGridColor!.hashCode) +
    (divLineColor == null ? 0 : divLineColor!.hashCode) +
    (divLineAlpha == null ? 0 : divLineAlpha!.hashCode) +
    (alternateHGridAlpha == null ? 0 : alternateHGridAlpha!.hashCode) +
    (rotateNames == null ? 0 : rotateNames!.hashCode) +
    (returning == null ? 0 : returning!.hashCode);

  @override
  String toString() => 'ChartData[valid=$valid, message=$message, version=$version, serializeNulls=$serializeNulls, startTimeLog=$startTimeLog, errorCode=$errorCode, request=$request, identifier=$identifier, idAttribute=$idAttribute, label=$label, maxValue=$maxValue, totalCount=$totalCount, items=$items, aggregatedItems=$aggregatedItems, caption=$caption, showAnchor=$showAnchor, anchorAlpha=$anchorAlpha, getxAxisName=$getxAxisName, getyAxisMinValue=$getyAxisMinValue, getyAxisName=$getyAxisName, decimalPrecision=$decimalPrecision, formatNumberScale=$formatNumberScale, numberPrefix=$numberPrefix, showNames=$showNames, showValues=$showValues, showAlternateHGridColor=$showAlternateHGridColor, alternateHGridColor=$alternateHGridColor, divLineColor=$divLineColor, divLineAlpha=$divLineAlpha, alternateHGridAlpha=$alternateHGridAlpha, rotateNames=$rotateNames, returning=$returning]';

  Map<String, dynamic> toJson() {
    final json = <String, dynamic>{};
    if (this.valid != null) {
      json[r'valid'] = this.valid;
    } else {
      json[r'valid'] = null;
    }
    if (this.message != null) {
      json[r'message'] = this.message;
    } else {
      json[r'message'] = null;
    }
    if (this.version != null) {
      json[r'version'] = this.version;
    } else {
      json[r'version'] = null;
    }
    if (this.serializeNulls != null) {
      json[r'serializeNulls'] = this.serializeNulls;
    } else {
      json[r'serializeNulls'] = null;
    }
    if (this.startTimeLog != null) {
      json[r'startTimeLog'] = this.startTimeLog;
    } else {
      json[r'startTimeLog'] = null;
    }
    if (this.errorCode != null) {
      json[r'errorCode'] = this.errorCode;
    } else {
      json[r'errorCode'] = null;
    }
      json[r'request'] = this.request;
    if (this.identifier != null) {
      json[r'identifier'] = this.identifier;
    } else {
      json[r'identifier'] = null;
    }
    if (this.idAttribute != null) {
      json[r'idAttribute'] = this.idAttribute;
    } else {
      json[r'idAttribute'] = null;
    }
    if (this.label != null) {
      json[r'label'] = this.label;
    } else {
      json[r'label'] = null;
    }
    if (this.maxValue != null) {
      json[r'maxValue'] = this.maxValue;
    } else {
      json[r'maxValue'] = null;
    }
    if (this.totalCount != null) {
      json[r'totalCount'] = this.totalCount;
    } else {
      json[r'totalCount'] = null;
    }
      json[r'items'] = this.items;
      json[r'aggregatedItems'] = this.aggregatedItems;
    if (this.caption != null) {
      json[r'caption'] = this.caption;
    } else {
      json[r'caption'] = null;
    }
    if (this.showAnchor != null) {
      json[r'showAnchor'] = this.showAnchor;
    } else {
      json[r'showAnchor'] = null;
    }
    if (this.anchorAlpha != null) {
      json[r'anchorAlpha'] = this.anchorAlpha;
    } else {
      json[r'anchorAlpha'] = null;
    }
    if (this.getxAxisName != null) {
      json[r'getxAxisName'] = this.getxAxisName;
    } else {
      json[r'getxAxisName'] = null;
    }
    if (this.getyAxisMinValue != null) {
      json[r'getyAxisMinValue'] = this.getyAxisMinValue;
    } else {
      json[r'getyAxisMinValue'] = null;
    }
    if (this.getyAxisName != null) {
      json[r'getyAxisName'] = this.getyAxisName;
    } else {
      json[r'getyAxisName'] = null;
    }
    if (this.decimalPrecision != null) {
      json[r'decimalPrecision'] = this.decimalPrecision;
    } else {
      json[r'decimalPrecision'] = null;
    }
    if (this.formatNumberScale != null) {
      json[r'formatNumberScale'] = this.formatNumberScale;
    } else {
      json[r'formatNumberScale'] = null;
    }
    if (this.numberPrefix != null) {
      json[r'numberPrefix'] = this.numberPrefix;
    } else {
      json[r'numberPrefix'] = null;
    }
    if (this.showNames != null) {
      json[r'showNames'] = this.showNames;
    } else {
      json[r'showNames'] = null;
    }
    if (this.showValues != null) {
      json[r'showValues'] = this.showValues;
    } else {
      json[r'showValues'] = null;
    }
    if (this.showAlternateHGridColor != null) {
      json[r'showAlternateHGridColor'] = this.showAlternateHGridColor;
    } else {
      json[r'showAlternateHGridColor'] = null;
    }
    if (this.alternateHGridColor != null) {
      json[r'alternateHGridColor'] = this.alternateHGridColor;
    } else {
      json[r'alternateHGridColor'] = null;
    }
    if (this.divLineColor != null) {
      json[r'divLineColor'] = this.divLineColor;
    } else {
      json[r'divLineColor'] = null;
    }
    if (this.divLineAlpha != null) {
      json[r'divLineAlpha'] = this.divLineAlpha;
    } else {
      json[r'divLineAlpha'] = null;
    }
    if (this.alternateHGridAlpha != null) {
      json[r'alternateHGridAlpha'] = this.alternateHGridAlpha;
    } else {
      json[r'alternateHGridAlpha'] = null;
    }
    if (this.rotateNames != null) {
      json[r'rotateNames'] = this.rotateNames;
    } else {
      json[r'rotateNames'] = null;
    }
    if (this.returning != null) {
      json[r'returning'] = this.returning;
    } else {
      json[r'returning'] = null;
    }
    return json;
  }

  /// Returns a new [ChartData] instance and imports its values from
  /// [value] if it's a [Map], null otherwise.
  // ignore: prefer_constructors_over_static_methods
  static ChartData? fromJson(dynamic value) {
    if (value is Map) {
      final json = value.cast<String, dynamic>();

      // Ensure that the map contains the required keys.
      // Note 1: the values aren't checked for validity beyond being non-null.
      // Note 2: this code is stripped in release mode!
      assert(() {
        requiredKeys.forEach((key) {
          assert(json.containsKey(key), 'Required key "ChartData[$key]" is missing from JSON.');
          assert(json[key] != null, 'Required key "ChartData[$key]" has a null value in JSON.');
        });
        return true;
      }());

      return ChartData(
        valid: mapValueOfType<bool>(json, r'valid'),
        message: mapValueOfType<String>(json, r'message'),
        version: mapValueOfType<double>(json, r'version'),
        serializeNulls: mapValueOfType<bool>(json, r'serializeNulls'),
        startTimeLog: mapValueOfType<int>(json, r'startTimeLog'),
        errorCode: mapValueOfType<String>(json, r'errorCode'),
        request: NameStringValueResponse.listFromJson(json[r'request']),
        identifier: mapValueOfType<String>(json, r'identifier'),
        idAttribute: mapValueOfType<String>(json, r'idAttribute'),
        label: mapValueOfType<String>(json, r'label'),
        maxValue: mapValueOfType<int>(json, r'maxValue'),
        totalCount: mapValueOfType<int>(json, r'totalCount'),
        items: Object.listFromJson(json[r'items']),
        aggregatedItems: Object.listFromJson(json[r'aggregatedItems']),
        caption: mapValueOfType<String>(json, r'caption'),
        showAnchor: mapValueOfType<String>(json, r'showAnchor'),
        anchorAlpha: mapValueOfType<String>(json, r'anchorAlpha'),
        getxAxisName: mapValueOfType<String>(json, r'getxAxisName'),
        getyAxisMinValue: mapValueOfType<String>(json, r'getyAxisMinValue'),
        getyAxisName: mapValueOfType<String>(json, r'getyAxisName'),
        decimalPrecision: mapValueOfType<String>(json, r'decimalPrecision'),
        formatNumberScale: mapValueOfType<String>(json, r'formatNumberScale'),
        numberPrefix: mapValueOfType<String>(json, r'numberPrefix'),
        showNames: mapValueOfType<String>(json, r'showNames'),
        showValues: mapValueOfType<String>(json, r'showValues'),
        showAlternateHGridColor: mapValueOfType<String>(json, r'showAlternateHGridColor'),
        alternateHGridColor: mapValueOfType<String>(json, r'alternateHGridColor'),
        divLineColor: mapValueOfType<String>(json, r'divLineColor'),
        divLineAlpha: mapValueOfType<String>(json, r'divLineAlpha'),
        alternateHGridAlpha: mapValueOfType<String>(json, r'alternateHGridAlpha'),
        rotateNames: mapValueOfType<String>(json, r'rotateNames'),
        returning: mapValueOfType<String>(json, r'returning'),
      );
    }
    return null;
  }

  static List<ChartData> listFromJson(dynamic json, {bool growable = false,}) {
    final result = <ChartData>[];
    if (json is List && json.isNotEmpty) {
      for (final row in json) {
        final value = ChartData.fromJson(row);
        if (value != null) {
          result.add(value);
        }
      }
    }
    return result.toList(growable: growable);
  }

  static Map<String, ChartData> mapFromJson(dynamic json) {
    final map = <String, ChartData>{};
    if (json is Map && json.isNotEmpty) {
      json = json.cast<String, dynamic>(); // ignore: parameter_assignments
      for (final entry in json.entries) {
        final value = ChartData.fromJson(entry.value);
        if (value != null) {
          map[entry.key] = value;
        }
      }
    }
    return map;
  }

  // maps a json object with a list of ChartData-objects as value to a dart map
  static Map<String, List<ChartData>> mapListFromJson(dynamic json, {bool growable = false,}) {
    final map = <String, List<ChartData>>{};
    if (json is Map && json.isNotEmpty) {
      // ignore: parameter_assignments
      json = json.cast<String, dynamic>();
      for (final entry in json.entries) {
        map[entry.key] = ChartData.listFromJson(entry.value, growable: growable,);
      }
    }
    return map;
  }

  /// The list of required keys that must be present in a JSON.
  static const requiredKeys = <String>{
  };
}

