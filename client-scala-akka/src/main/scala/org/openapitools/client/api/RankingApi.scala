/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import java.math.BigDecimal
import org.openapitools.client.model.RankFullResponse
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object RankingApi {

  def apply(baseUrl: String = "http://localhost") = new RankingApi(baseUrl)
}

class RankingApi(baseUrl: String) {

  /**
   * Get historical leaderboard rankings by time-frame.
   * 
   * Expected answers:
   *   code 200 : RankFullResponse (successful operation)
   * 
   * @param version 
   * @param appKey the application key for filtering results by application
   * @param rankType the rank type to return
   * @param startDate timestamp in milliseconds to filter results with
   * @param endDate timestamp in milliseconds to filter results with
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user
   * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
   * @param descending determines whether to return results in ascending or descending order
   * @param start the start index for pagination
   * @param limit the limit for pagination
   */
  def getHistoricalRankings(version: BigDecimal, appKey: String, rankType: String, startDate: Long, endDate: Long, deviceId: Option[String] = None, accountId: Option[Long] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[RankFullResponse] =
    ApiRequest[RankFullResponse](ApiMethods.GET, baseUrl, "/api/{version}/ranking/historical/search", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("rankType", rankType)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[RankFullResponse](200)
      

  /**
   * Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
   * 
   * Expected answers:
   *   code 200 : RankFullResponse (successful operation)
   * 
   * @param version 
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param gameType This parameter is deprecated.
   * @param appKey the application key for filtering results by application (required for non-EXECUTIVE users)
   * @param `q` This parameter is deprecated.
   * @param keyword keyword to search for
   * @param rankType a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
   * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
   * @param withinAccountIds comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
   * @param returnUserRank determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
   * @param albumId album id to use when performing CUSTOM filters
   * @param audienceId audience id to use when performing CUSTOM filters
   * @param sortField determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
   * @param descending determines whether to return results in ascending or descending order
   * @param `i` This parameter is deprecated.
   * @param start the start index for pagination
   * @param `l` This parameter is deprecated.
   * @param limit the limit for pagination
   */
  def getRankings(version: BigDecimal, deviceId: Option[String] = None, accountId: Option[Long] = None, gameType: Option[String] = None, appKey: Option[String] = None, `q`: Option[String] = None, keyword: Option[String] = None, rankType: Option[String] = None, leaderboardMode: Option[String] = None, withinAccountIds: Option[String] = None, returnUserRank: Option[Boolean] = None, albumId: Option[Long] = None, audienceId: Option[Long] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, `i`: Option[Int] = None, start: Option[Int] = None, `l`: Option[Int] = None, limit: Option[Int] = None): ApiRequest[RankFullResponse] =
    ApiRequest[RankFullResponse](ApiMethods.GET, baseUrl, "/api/{version}/ranking/search", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("gameType", gameType)
      .withQueryParam("appKey", appKey)
      .withQueryParam("q", `q`)
      .withQueryParam("keyword", keyword)
      .withQueryParam("rankType", rankType)
      .withQueryParam("leaderboardMode", leaderboardMode)
      .withQueryParam("withinAccountIds", withinAccountIds)
      .withQueryParam("returnUserRank", returnUserRank)
      .withQueryParam("albumId", albumId)
      .withQueryParam("audienceId", audienceId)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("_i", `i`)
      .withQueryParam("start", start)
      .withQueryParam("_l", `l`)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[RankFullResponse](200)
      

  /**
   * Returns the user's ranks for one or more rank types and modes.
   * 
   * Expected answers:
   *   code 200 : Any (successful operation)
   * 
   * @param version 
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user
   * @param appKey the application key for filtering results by application (required)
   * @param rankType pass in all rankTypes and children rankTypes
   * @param returnUserRank determines whether to return the user's current rank in the response, for each rankType
   * @param leaderboardMode the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
   * @param sortField determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
   * @param keyword keyword to search for (on rankType)
   * @param descending determines whether to return results in descending order
   * @param start the start index for pagination
   * @param limit the limit for pagination
   */
  def getUserRank(version: BigDecimal, deviceId: Option[String] = None, accountId: Option[Long] = None, appKey: Option[String] = None, rankType: Option[String] = None, returnUserRank: Option[Boolean] = None, leaderboardMode: Option[String] = None, sortField: Option[String] = None, keyword: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[Any] =
    ApiRequest[Any](ApiMethods.POST, baseUrl, "/api/{version}/ranking/personal/ranks", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("rankType", rankType)
      .withQueryParam("returnUserRank", returnUserRank)
      .withQueryParam("leaderboardMode", leaderboardMode)
      .withQueryParam("sortField", sortField)
      .withQueryParam("keyword", keyword)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[Any](200)
      

  /**
   * Allows an admin of an application to override a user's scores for a leaderboard.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId the logged in user's account id (must have permissions to manage data for the application)
   * @param ownerAccountId the end user's account id to override
   * @param appKey the application key the leaderboard is for
   * @param rankType the rankType of the leaderboard
   * @param totalScore the total score to update
   * @param totalCount the total count to update
   * @param totalTime the total time to update
   * @param dailyScore the daily score to update
   * @param dailyCount the daily count to update
   * @param dailyTime the daily time to update
   * @param weeklyScore the weekly score to update
   * @param weeklyCount the weekly count to update
   * @param weeklyTime the weekly time to update
   * @param monthlyScore the monthly score to update
   * @param monthlyCount the monthly count to update
   * @param monthlyTime the monthly time to update
   * @param topScore the top score to update
   * @param lowestScore the lowest score to update
   * @param streakCount the streak count to update
   * @param streakBestCount the best streak count to update
   * @param startDate the start date to update
   * @param endDate the end date to update
   */
  def overrideUserRank(version: BigDecimal, accountId: Long, ownerAccountId: Long, appKey: String, rankType: String, totalScore: Option[Long] = None, totalCount: Option[Long] = None, totalTime: Option[Long] = None, dailyScore: Option[Long] = None, dailyCount: Option[Long] = None, dailyTime: Option[Long] = None, weeklyScore: Option[Long] = None, weeklyCount: Option[Long] = None, weeklyTime: Option[Long] = None, monthlyScore: Option[Long] = None, monthlyCount: Option[Long] = None, monthlyTime: Option[Long] = None, topScore: Option[Long] = None, lowestScore: Option[Long] = None, streakCount: Option[Long] = None, streakBestCount: Option[Long] = None, startDate: Option[Long] = None, endDate: Option[Long] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/ranking/override", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("ownerAccountId", ownerAccountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("rankType", rankType)
      .withQueryParam("totalScore", totalScore)
      .withQueryParam("totalCount", totalCount)
      .withQueryParam("totalTime", totalTime)
      .withQueryParam("dailyScore", dailyScore)
      .withQueryParam("dailyCount", dailyCount)
      .withQueryParam("dailyTime", dailyTime)
      .withQueryParam("weeklyScore", weeklyScore)
      .withQueryParam("weeklyCount", weeklyCount)
      .withQueryParam("weeklyTime", weeklyTime)
      .withQueryParam("monthlyScore", monthlyScore)
      .withQueryParam("monthlyCount", monthlyCount)
      .withQueryParam("monthlyTime", monthlyTime)
      .withQueryParam("topScore", topScore)
      .withQueryParam("lowestScore", lowestScore)
      .withQueryParam("streakCount", streakCount)
      .withQueryParam("streakBestCount", streakBestCount)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Update the rank value 
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId the account id of the user
   * @param appKey the application key for filtering results by application
   * @param rankType a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
   * @param increment the value to increment
   * @param timeIncrement the time value to increment
   * @param tag the analytic tag for this achievement (used to validate scores)
   * @param startDate custom date you can save along with the score for the user
   * @param endDate custom date you can save along with the score for the user
   * @param updateGlobal update the global rankings if true, default is false
   * @param createLeaderboard create the leaderboard if it does not exist (default false)
   */
  def updateRankings(version: BigDecimal, accountId: Long, appKey: String, rankType: String, increment: Option[Long] = None, timeIncrement: Option[Long] = None, tag: Option[String] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, updateGlobal: Option[Boolean] = None, createLeaderboard: Option[Boolean] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/ranking/update", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("rankType", rankType)
      .withQueryParam("increment", increment)
      .withQueryParam("timeIncrement", timeIncrement)
      .withQueryParam("tag", tag)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("updateGlobal", updateGlobal)
      .withQueryParam("createLeaderboard", createLeaderboard)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      



}

