/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.model.TriggerResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object TriggerApi {

  def apply(baseUrl: String = "https://dev.sirqul.com/api/3.18") = new TriggerApi(baseUrl)
}

class TriggerApi(baseUrl: String) {

  /**
   * Create a trigger
   * 
   * Expected answers:
   *   code 200 : TriggerResponse (successful operation)
   * 
   * @param accountId The logged in user
   * @param name The name of the trigger
   * @param appKey The application to target
   * @param groupingId Client defined identifier for grouping triggers
   * @param endpointURL The URL for making an HTTP call
   * @param payload The parameters for making an HTTP call
   * @param scheduledDate The date and time of the next trigger
   * @param startDate The starting date of the trigger
   * @param endDate The ending date of the trigger
   * @param cronExpression The cron expression that represents the trigger's schedule
   * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger
   * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
   * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed)
   */
  def createTrigger(accountId: Long, name: String, appKey: Option[String] = None, groupingId: Option[String] = None, endpointURL: Option[String] = None, payload: Option[String] = None, scheduledDate: Option[Long] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, cronExpression: Option[String] = None, conditionalInput: Option[String] = None, visibility: Option[String] = None, active: Option[Boolean] = None): ApiRequest[TriggerResponse] =
    ApiRequest[TriggerResponse](ApiMethods.POST, baseUrl, "/trigger/create", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("name", name)
      .withQueryParam("appKey", appKey)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("endpointURL", endpointURL)
      .withQueryParam("payload", payload)
      .withQueryParam("scheduledDate", scheduledDate)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("cronExpression", cronExpression)
      .withQueryParam("conditionalInput", conditionalInput)
      .withQueryParam("visibility", visibility)
      .withQueryParam("active", active)
      .withSuccessResponse[TriggerResponse](200)
      

  /**
   * Mark a trigger as deleted.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param triggerId The id of the trigger to delete.
   */
  def deleteTrigger(accountId: Long, triggerId: Long): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/trigger/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("triggerId", triggerId)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get a trigger
   * 
   * Expected answers:
   *   code 200 : TriggerResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param triggerId The id of the Trigger to return.
   */
  def getTrigger(accountId: Long, triggerId: Long): ApiRequest[TriggerResponse] =
    ApiRequest[TriggerResponse](ApiMethods.GET, baseUrl, "/trigger/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("triggerId", triggerId)
      .withSuccessResponse[TriggerResponse](200)
      

  /**
   * Search for triggers
   * 
   * Expected answers:
   *   code 200 : Seq[TriggerResponse] (successful operation)
   * 
   * @param accountId The logged in user.
   * @param groupingId Filter results by a grouping identifier defined by the client
   * @param filter A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers 
   * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
   * @param templateTypes Template Types
   * @param appKey Filter the list by a specific application
   * @param keyword Keyword search on the trigger names.
   * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start Start the result set at some index.
   * @param limit Limit the result to some number.
   * @param activeOnly Determines whether to return only active results
   */
  def searchTriggers(accountId: Long, groupingId: Option[String] = None, filter: Option[String] = None, statuses: Option[String] = None, templateTypes: Option[String] = None, appKey: Option[String] = None, keyword: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None, activeOnly: Option[Boolean] = None): ApiRequest[Seq[TriggerResponse]] =
    ApiRequest[Seq[TriggerResponse]](ApiMethods.GET, baseUrl, "/trigger/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("filter", filter)
      .withQueryParam("statuses", statuses)
      .withQueryParam("templateTypes", templateTypes)
      .withQueryParam("appKey", appKey)
      .withQueryParam("keyword", keyword)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withQueryParam("activeOnly", activeOnly)
      .withSuccessResponse[Seq[TriggerResponse]](200)
      

  /**
   * Update a trigger
   * 
   * Expected answers:
   *   code 200 : TriggerResponse (successful operation)
   * 
   * @param triggerId The trigger to update
   * @param accountId The logged in user
   * @param name The name of the trigger
   * @param appKey The application to target
   * @param groupingId Client defined identifier for grouping triggers
   * @param endpointURL The URL for making an HTTP call
   * @param payload The parameters for making an HTTP call
   * @param scheduledDate The date and time of the next trigger
   * @param startDate The starting date of the trigger
   * @param endDate The ending date of the trigger
   * @param cronExpression The cron expression that represents the trigger's schedule
   * @param conditionalInput Json input representing conditional logic that has to be met before running the trigger
   * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
   * @param active Sets whether the Trigger is active or not (inactive Triggers are not processed)
   */
  def updateTrigger(triggerId: Long, accountId: Long, name: Option[String] = None, appKey: Option[String] = None, groupingId: Option[String] = None, endpointURL: Option[String] = None, payload: Option[String] = None, scheduledDate: Option[Long] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, cronExpression: Option[String] = None, conditionalInput: Option[String] = None, visibility: Option[String] = None, active: Option[Boolean] = None): ApiRequest[TriggerResponse] =
    ApiRequest[TriggerResponse](ApiMethods.POST, baseUrl, "/trigger/update", "application/json")
      .withQueryParam("triggerId", triggerId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("name", name)
      .withQueryParam("appKey", appKey)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("endpointURL", endpointURL)
      .withQueryParam("payload", payload)
      .withQueryParam("scheduledDate", scheduledDate)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("cronExpression", cronExpression)
      .withQueryParam("conditionalInput", conditionalInput)
      .withQueryParam("visibility", visibility)
      .withQueryParam("active", active)
      .withSuccessResponse[TriggerResponse](200)
      



}

