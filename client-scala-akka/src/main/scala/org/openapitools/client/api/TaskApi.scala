/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import java.math.BigDecimal
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.model.TaskResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object TaskApi {

  def apply(baseUrl: String = "http://localhost") = new TaskApi(baseUrl)
}

class TaskApi(baseUrl: String) {

  /**
   * Create a Task
   * 
   * Expected answers:
   *   code 200 : TaskResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param name The name of the task
   * @param appKey The application to target
   * @param groupingId Client defined identifier for grouping tasks
   * @param endpointURL The URL for making an HTTP call
   * @param payload The parameters for making an HTTP call
   * @param scheduledDate The date and time of the task
   * @param startDate The starting date of the task
   * @param endDate The ending date of the task
   * @param cronExpression The cron expression that represents the task's schedule
   * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
   * @param active Sets whether the Task is active or not (inactive Tasks are not processed)
   */
  def createTask(version: BigDecimal, accountId: Long, name: String, appKey: Option[String] = None, groupingId: Option[String] = None, endpointURL: Option[String] = None, payload: Option[String] = None, scheduledDate: Option[Long] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, cronExpression: Option[String] = None, visibility: Option[String] = None, active: Option[Boolean] = None): ApiRequest[TaskResponse] =
    ApiRequest[TaskResponse](ApiMethods.POST, baseUrl, "/api/{version}/task/create", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("name", name)
      .withQueryParam("appKey", appKey)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("endpointURL", endpointURL)
      .withQueryParam("payload", payload)
      .withQueryParam("scheduledDate", scheduledDate)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("cronExpression", cronExpression)
      .withQueryParam("visibility", visibility)
      .withQueryParam("active", active)
      .withPathParam("version", version)
      .withSuccessResponse[TaskResponse](200)
      

  /**
   * Delete a Task
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param taskId The id of the Task to delete.
   */
  def deleteTask(version: BigDecimal, accountId: Long, taskId: Long): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/task/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("taskId", taskId)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get a Task
   * 
   * Expected answers:
   *   code 200 : TaskResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param taskId The id of the Task to return.
   */
  def getTask(version: BigDecimal, accountId: Long, taskId: Long): ApiRequest[TaskResponse] =
    ApiRequest[TaskResponse](ApiMethods.GET, baseUrl, "/api/{version}/task/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("taskId", taskId)
      .withPathParam("version", version)
      .withSuccessResponse[TaskResponse](200)
      

  /**
   * Search on Tasks
   * 
   * Expected answers:
   *   code 200 : Seq[TaskResponse] (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param groupingId Filter results by a grouping identifier defined by the client
   * @param filter A comma separated list of filters:  * MINE - Return tasks that the user has created * SHARED - Return tasks that have been shared to the user * FOLLOWER - Return tasks that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return tasks that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC tasks that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC tasks regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all tasks that the user has liked * FEATURED - Return all tasks that have been featured * PENDING - Return all pending tasks 
   * @param statuses Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE
   * @param templateTypes Template Types
   * @param appKey Filter the list by a specific application
   * @param keyword Keyword search on the task names.
   * @param sortField The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start Start the result set at some index.
   * @param limit Limit the result to some number.
   * @param activeOnly Determines whether to return only active results
   */
  def searchTasks(version: BigDecimal, accountId: Long, groupingId: Option[String] = None, filter: Option[String] = None, statuses: Option[String] = None, templateTypes: Option[String] = None, appKey: Option[String] = None, keyword: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None, activeOnly: Option[Boolean] = None): ApiRequest[Seq[TaskResponse]] =
    ApiRequest[Seq[TaskResponse]](ApiMethods.GET, baseUrl, "/api/{version}/task/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("filter", filter)
      .withQueryParam("statuses", statuses)
      .withQueryParam("templateTypes", templateTypes)
      .withQueryParam("appKey", appKey)
      .withQueryParam("keyword", keyword)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withQueryParam("activeOnly", activeOnly)
      .withPathParam("version", version)
      .withSuccessResponse[Seq[TaskResponse]](200)
      

  /**
   * Update a Task
   * 
   * Expected answers:
   *   code 200 : TaskResponse (successful operation)
   * 
   * @param version 
   * @param taskId Task Id
   * @param accountId The logged in user.
   * @param name The name of the task
   * @param appKey The application to target
   * @param groupingId Client defined identifier for grouping tasks
   * @param endpointURL The URL for making an HTTP call
   * @param payload The parameters for making an HTTP call
   * @param scheduledDate The date and time of the task
   * @param startDate The starting date of the task
   * @param endDate The ending date of the task
   * @param cronExpression The cron expression that represents the task's schedule
   * @param visibility The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
   * @param active Sets whether the Task is active or not (inactive Tasks are not processed)
   */
  def updateTask(version: BigDecimal, taskId: Long, accountId: Long, name: Option[String] = None, appKey: Option[String] = None, groupingId: Option[String] = None, endpointURL: Option[String] = None, payload: Option[String] = None, scheduledDate: Option[Long] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, cronExpression: Option[String] = None, visibility: Option[String] = None, active: Option[Boolean] = None): ApiRequest[TaskResponse] =
    ApiRequest[TaskResponse](ApiMethods.POST, baseUrl, "/api/{version}/task/update", "application/json")
      .withQueryParam("taskId", taskId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("name", name)
      .withQueryParam("appKey", appKey)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("endpointURL", endpointURL)
      .withQueryParam("payload", payload)
      .withQueryParam("scheduledDate", scheduledDate)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("cronExpression", cronExpression)
      .withQueryParam("visibility", visibility)
      .withQueryParam("active", active)
      .withPathParam("version", version)
      .withSuccessResponse[TaskResponse](200)
      



}

