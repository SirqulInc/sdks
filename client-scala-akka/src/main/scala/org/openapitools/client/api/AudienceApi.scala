/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.AgeGroupResponse
import org.openapitools.client.model.AudienceDeviceResponse
import org.openapitools.client.model.AudienceResponse
import org.openapitools.client.model.OfferListResponse
import org.openapitools.client.model.SearchResponse
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object AudienceApi {

  def apply(baseUrl: String = "https://dev.sirqul.com/api/3.18") = new AudienceApi(baseUrl)
}

class AudienceApi(baseUrl: String) {

  /**
   * Create a user defined audience.
   * 
   * Expected answers:
   *   code 200 : AudienceResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param name The name of the audience
   * @param description The description of the audience
   * @param searchTags The search tags
   * @param gender The gender; possible values are: MALE, FEMALE, ANY
   * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
   * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
   * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
   * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
   * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
   * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
   * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
   * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
   * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
   * @param startTimeOffset Seconds from the start time of an event
   * @param endTimeOffset Seconds from the end time of an event
   * @param sendSuggestion If true, then notify matching users when they are inside the radius
   * @param associateDescription The description of the associated object
   * @param associateType The type of the object to center the audience geofence
   * @param associateId The ID of the object to center the audience geofence
   * @param groupingId Optional grouping id for the audience
   * @param metaData External custom client defined data
   * @param visibility Visibility of the audience
   * @param audienceType Type of audience
   * @param useOrder Use order for cohort
   * @param cohortRegionsData Cohort data for \"cohort\" audience type
   * @param appKey Filter results by application key
   * @param trilaterationTypes Trilateration types
   * @param uniqueName If true, makes sure the audience name is unique
   */
  def createAudience(accountId: Long, name: String, description: Option[String] = None, searchTags: Option[String] = None, gender: Option[String] = None, ageGroups: Option[String] = None, categoryIds: Option[String] = None, applicationIds: Option[String] = None, gameExperienceLevel: Option[String] = None, devices: Option[String] = None, deviceIds: Option[String] = None, deviceVersions: Option[String] = None, locations: Option[String] = None, radius: Option[String] = None, startTimeOffset: Option[Int] = None, endTimeOffset: Option[Int] = None, sendSuggestion: Option[Boolean] = None, associateDescription: Option[String] = None, associateType: Option[String] = None, associateId: Option[Long] = None, groupingId: Option[String] = None, metaData: Option[String] = None, visibility: Option[String] = None, audienceType: Option[String] = None, useOrder: Option[Boolean] = None, cohortRegionsData: Option[String] = None, appKey: Option[String] = None, trilaterationTypes: Option[String] = None, uniqueName: Option[Boolean] = None): ApiRequest[AudienceResponse] =
    ApiRequest[AudienceResponse](ApiMethods.POST, baseUrl, "/audience/create", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("name", name)
      .withQueryParam("description", description)
      .withQueryParam("searchTags", searchTags)
      .withQueryParam("gender", gender)
      .withQueryParam("ageGroups", ageGroups)
      .withQueryParam("categoryIds", categoryIds)
      .withQueryParam("applicationIds", applicationIds)
      .withQueryParam("gameExperienceLevel", gameExperienceLevel)
      .withQueryParam("devices", devices)
      .withQueryParam("deviceIds", deviceIds)
      .withQueryParam("deviceVersions", deviceVersions)
      .withQueryParam("locations", locations)
      .withQueryParam("radius", radius)
      .withQueryParam("startTimeOffset", startTimeOffset)
      .withQueryParam("endTimeOffset", endTimeOffset)
      .withQueryParam("sendSuggestion", sendSuggestion)
      .withQueryParam("associateDescription", associateDescription)
      .withQueryParam("associateType", associateType)
      .withQueryParam("associateId", associateId)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("metaData", metaData)
      .withQueryParam("visibility", visibility)
      .withQueryParam("audienceType", audienceType)
      .withQueryParam("useOrder", useOrder)
      .withQueryParam("cohortRegionsData", cohortRegionsData)
      .withQueryParam("appKey", appKey)
      .withQueryParam("trilaterationTypes", trilaterationTypes)
      .withQueryParam("uniqueName", uniqueName)
      .withSuccessResponse[AudienceResponse](200)
      

  /**
   * Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param audienceId The id of the audience to delete.
   */
  def deleteAudience(accountId: Long, audienceId: Long): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/audience/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("audienceId", audienceId)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
   * 
   * Expected answers:
   *   code 200 : Seq[AgeGroupResponse] (successful operation)
   */
  def getAgeGroups(): ApiRequest[Seq[AgeGroupResponse]] =
    ApiRequest[Seq[AgeGroupResponse]](ApiMethods.GET, baseUrl, "/audience/ageGroups", "application/json")
      .withSuccessResponse[Seq[AgeGroupResponse]](200)
      

  /**
   * Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
   * 
   * Expected answers:
   *   code 200 : AudienceResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param audienceId The id of the audience to return.
   * @param appKey The application key (optional). If provided, results may be scoped to this application.
   * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
   * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
   * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
   */
  def getAudience(accountId: Long, audienceId: Long, appKey: Option[String] = None, returnAccountCount: Option[Boolean] = None, returnAlbumCount: Option[Boolean] = None, albumTypesForCount: Option[String] = None): ApiRequest[AudienceResponse] =
    ApiRequest[AudienceResponse](ApiMethods.GET, baseUrl, "/audience/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("audienceId", audienceId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("returnAccountCount", returnAccountCount)
      .withQueryParam("returnAlbumCount", returnAlbumCount)
      .withQueryParam("albumTypesForCount", albumTypesForCount)
      .withSuccessResponse[AudienceResponse](200)
      

  /**
   * Get the list audiences owned by the account
   * 
   * Expected answers:
   *   code 200 : Seq[SearchResponse] (successful operation)
   * 
   * @param accountId The logged in user.
   * @param albumIds Comma separated list of album IDs to filter results with
   * @param keyword The keyword used to search
   * @param keywordFields Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
   * @param sortField The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
   * @param descending The order to return the results. Default is false, which will return the results in ascending order.
   * @param start The index into the record set to start with.
   * @param limit The total number of record to return (there is a hard limit of 100).
   * @param sendSuggestion Filter results based on whether or not the audience is set to send suggestions
   * @param activeOnly Determines whether to return only active results. Default is false.
   * @param groupByGroupingId Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
   * @param appKey Filter results by application key
   * @param returnGlobal If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
   * @param exactKeyword If true, match keyword exactly
   * @param audienceType (Deprecated) Filter results by audience type
   * @param audienceTypes comma separated string with the different audience types you want to filter for
   * @param returnAccountCount (boolean) set to true to include the accountCount associated with current audience of the current app
   * @param returnAlbumCount (boolean) set to true to include the albumCount associated with current audience of the current app
   * @param albumTypesForCount (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
   */
  def getAudienceList(accountId: Option[Long] = None, albumIds: Option[String] = None, keyword: Option[String] = None, keywordFields: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None, sendSuggestion: Option[Boolean] = None, activeOnly: Option[Boolean] = None, groupByGroupingId: Option[Boolean] = None, appKey: Option[String] = None, returnGlobal: Option[Boolean] = None, exactKeyword: Option[Boolean] = None, audienceType: Option[String] = None, audienceTypes: Option[String] = None, returnAccountCount: Option[Boolean] = None, returnAlbumCount: Option[Boolean] = None, albumTypesForCount: Option[String] = None): ApiRequest[Seq[SearchResponse]] =
    ApiRequest[Seq[SearchResponse]](ApiMethods.GET, baseUrl, "/audience/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("albumIds", albumIds)
      .withQueryParam("keyword", keyword)
      .withQueryParam("keywordFields", keywordFields)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withQueryParam("sendSuggestion", sendSuggestion)
      .withQueryParam("activeOnly", activeOnly)
      .withQueryParam("groupByGroupingId", groupByGroupingId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("returnGlobal", returnGlobal)
      .withQueryParam("exactKeyword", exactKeyword)
      .withQueryParam("audienceType", audienceType)
      .withQueryParam("audienceTypes", audienceTypes)
      .withQueryParam("returnAccountCount", returnAccountCount)
      .withQueryParam("returnAlbumCount", returnAlbumCount)
      .withQueryParam("albumTypesForCount", albumTypesForCount)
      .withSuccessResponse[Seq[SearchResponse]](200)
      

  /**
   * Gets the list of available devices that can be selected by consumers and retailers.
   * 
   * Expected answers:
   *   code 200 : Seq[AudienceDeviceResponse] (successful operation)
   * 
   * @param includeInactive If true return inactive record as well. default is false.
   */
  def getDevices(includeInactive: Boolean): ApiRequest[Seq[AudienceDeviceResponse]] =
    ApiRequest[Seq[AudienceDeviceResponse]](ApiMethods.GET, baseUrl, "/audience/devices", "application/json")
      .withQueryParam("includeInactive", includeInactive)
      .withSuccessResponse[Seq[AudienceDeviceResponse]](200)
      

  /**
   * Gets the list of available experiences that can be selected by consumers and retailers.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   */
  def getExperiences(): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.GET, baseUrl, "/audience/experiences", "application/json")
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
   * 
   * Expected answers:
   *   code 200 : AudienceResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param audienceGroupingId The audience grouping id to return.
   */
  def getGroupedAudiences(accountId: Long, audienceGroupingId: String): ApiRequest[AudienceResponse] =
    ApiRequest[AudienceResponse](ApiMethods.GET, baseUrl, "/audience/grouped/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("audienceGroupingId", audienceGroupingId)
      .withSuccessResponse[AudienceResponse](200)
      

  /**
   * List either Missions or Offers that the user matches the assigned audience.
   * 
   * Expected answers:
   *   code 200 : OfferListResponse (successful operation)
   * 
   * @param accountId The account to match offers for.
   * @param limit the limit of the index
   * @param suggestionType the type of suggestion
   */
  def listByAccount(accountId: Long, limit: Int, suggestionType: String): ApiRequest[OfferListResponse] =
    ApiRequest[OfferListResponse](ApiMethods.POST, baseUrl, "/audience/suggestion/list", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("limit", limit)
      .withQueryParam("suggestionType", suggestionType)
      .withSuccessResponse[OfferListResponse](200)
      

  /**
   * Get a list of offer locations based on audience information provided.
   * 
   * Expected answers:
   *   code 200 : OfferListResponse (successful operation)
   * 
   * @param limit this is the limit of the index
   * @param gender this is the gender to list offers by
   * @param age this is the age to list offers by
   * @param categoryIds this is the category IDs to list offers by
   * @param latitude this is the latitude to list offers by
   * @param longitude this is the longitude to list offers by
   */
  def listByAudience(limit: Int, gender: Option[String] = None, age: Option[Int] = None, categoryIds: Option[String] = None, latitude: Option[Double] = None, longitude: Option[Double] = None): ApiRequest[OfferListResponse] =
    ApiRequest[OfferListResponse](ApiMethods.GET, baseUrl, "/audience/suggestion/offersByAudience", "application/json")
      .withQueryParam("gender", gender)
      .withQueryParam("age", age)
      .withQueryParam("categoryIds", categoryIds)
      .withQueryParam("latitude", latitude)
      .withQueryParam("longitude", longitude)
      .withQueryParam("limit", limit)
      .withSuccessResponse[OfferListResponse](200)
      

  /**
   * Return list of recent trigger suggestions that have been sent to the user.
   * 
   * Expected answers:
   *   code 200 : OfferListResponse (successful operation)
   * 
   * @param accountId The account to match offers for.
   * @param timeframe The timeframe in seconds of the latest suggestions
   * @param suggestionType The type of trigger suggestions to return
   */
  def listLastestByAccount(accountId: Long, timeframe: Int, suggestionType: String): ApiRequest[OfferListResponse] =
    ApiRequest[OfferListResponse](ApiMethods.GET, baseUrl, "/audience/suggestion/latest", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("timeframe", timeframe)
      .withQueryParam("suggestionType", suggestionType)
      .withSuccessResponse[OfferListResponse](200)
      

  /**
   * Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param accountId The account to match offers for.
   * @param latitude the latitude
   * @param longitude the longitude
   */
  def sendByAccount(accountId: Long, latitude: Double, longitude: Double): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/audience/suggestion/send", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("latitude", latitude)
      .withQueryParam("longitude", longitude)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Update a user defined audience.
   * 
   * Expected answers:
   *   code 200 : AudienceResponse (successful operation)
   * 
   * @param accountId The logged in user.
   * @param audienceId The id of the audience to update.
   * @param name The name of the audience
   * @param description The description of the audience
   * @param searchTags The search tags
   * @param gender The gender; possible values are: MALE, FEMALE, ANY
   * @param ageGroups The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
   * @param categoryIds The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
   * @param applicationIds The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
   * @param gameExperienceLevel The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
   * @param devices (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
   * @param deviceIds The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
   * @param deviceVersions The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
   * @param locations The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
   * @param radius The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
   * @param active if audience is active
   * @param sendSuggestion If true, then notify matching users when they are inside the radius
   * @param startTimeOffset Seconds from the start time of an event
   * @param endTimeOffset Seconds from the end time of an event
   * @param associateDescription the associate description
   * @param associateType The type of the object to center the audience geofence
   * @param associateId The ID of the object to center the audience geofence
   * @param groupingId Optional grouping id for the audience
   * @param metaData External custom client defined data
   * @param visibility Visibility of the audience
   * @param audienceType Type of audience
   * @param useOrder Use order for cohort
   * @param cohortRegionsData Cohort data for \"cohort\" audience type
   * @param appKey Filter results by application key
   * @param trilaterationTypes Trilateration types
   * @param uniqueName If true, makes sure the audience name is unique
   */
  def updateAudience(accountId: Long, audienceId: Long, name: Option[String] = None, description: Option[String] = None, searchTags: Option[String] = None, gender: Option[String] = None, ageGroups: Option[String] = None, categoryIds: Option[String] = None, applicationIds: Option[String] = None, gameExperienceLevel: Option[String] = None, devices: Option[String] = None, deviceIds: Option[String] = None, deviceVersions: Option[String] = None, locations: Option[String] = None, radius: Option[String] = None, active: Option[Boolean] = None, sendSuggestion: Option[Boolean] = None, startTimeOffset: Option[Int] = None, endTimeOffset: Option[Int] = None, associateDescription: Option[String] = None, associateType: Option[String] = None, associateId: Option[Long] = None, groupingId: Option[String] = None, metaData: Option[String] = None, visibility: Option[String] = None, audienceType: Option[String] = None, useOrder: Option[Boolean] = None, cohortRegionsData: Option[String] = None, appKey: Option[String] = None, trilaterationTypes: Option[String] = None, uniqueName: Option[Boolean] = None): ApiRequest[AudienceResponse] =
    ApiRequest[AudienceResponse](ApiMethods.POST, baseUrl, "/audience/update", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("audienceId", audienceId)
      .withQueryParam("name", name)
      .withQueryParam("description", description)
      .withQueryParam("searchTags", searchTags)
      .withQueryParam("gender", gender)
      .withQueryParam("ageGroups", ageGroups)
      .withQueryParam("categoryIds", categoryIds)
      .withQueryParam("applicationIds", applicationIds)
      .withQueryParam("gameExperienceLevel", gameExperienceLevel)
      .withQueryParam("devices", devices)
      .withQueryParam("deviceIds", deviceIds)
      .withQueryParam("deviceVersions", deviceVersions)
      .withQueryParam("locations", locations)
      .withQueryParam("radius", radius)
      .withQueryParam("active", active)
      .withQueryParam("sendSuggestion", sendSuggestion)
      .withQueryParam("startTimeOffset", startTimeOffset)
      .withQueryParam("endTimeOffset", endTimeOffset)
      .withQueryParam("associateDescription", associateDescription)
      .withQueryParam("associateType", associateType)
      .withQueryParam("associateId", associateId)
      .withQueryParam("groupingId", groupingId)
      .withQueryParam("metaData", metaData)
      .withQueryParam("visibility", visibility)
      .withQueryParam("audienceType", audienceType)
      .withQueryParam("useOrder", useOrder)
      .withQueryParam("cohortRegionsData", cohortRegionsData)
      .withQueryParam("appKey", appKey)
      .withQueryParam("trilaterationTypes", trilaterationTypes)
      .withQueryParam("uniqueName", uniqueName)
      .withSuccessResponse[AudienceResponse](200)
      



}

