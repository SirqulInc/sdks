/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import java.math.BigDecimal
import org.openapitools.client.model.BlockedNotificationResponse
import org.openapitools.client.model.NotificationMessageListResponse
import org.openapitools.client.model.NotificationRecipientResponse
import org.openapitools.client.model.NotificationRecipientResponseListResponse
import org.openapitools.client.model.NotificationTemplateResponse
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object NotificationApi {

  def apply(baseUrl: String = "http://localhost") = new NotificationApi(baseUrl)
}

class NotificationApi(baseUrl: String) {

  /**
   * Create a notification template. Developers will only be able to create notification templates for their own applications.
   * 
   * Expected answers:
   *   code 200 : NotificationTemplateResponse (successful operation)
   * 
   * @param version 
   * @param accountId The account ID of the user.
   * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param title title of the notification template
   * @param body body of the notification template
   * @param appKey Filter results by application.
   * @param event Filter results by event.
   * @param tags tags associated with the note template
   */
  def createNotificationTemplate(version: BigDecimal, accountId: Long, conduit: String, title: String, body: String, appKey: Option[String] = None, event: Option[String] = None, tags: Option[String] = None): ApiRequest[NotificationTemplateResponse] =
    ApiRequest[NotificationTemplateResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/template/create", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("event", event)
      .withQueryParam("conduit", conduit)
      .withQueryParam("title", title)
      .withQueryParam("body", body)
      .withQueryParam("tags", tags)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationTemplateResponse](200)
      

  /**
   * Create or update blocked notification settings
   * 
   * Expected answers:
   *   code 200 : BlockedNotificationResponse (successful operation)
   * 
   * @param version 
   * @param appKey The application key
   * @param data batch data payload (application specific)
   * @param accountId the account id of the user
   */
  def createOrUpdateBlockedNotifications(version: BigDecimal, appKey: String, data: String, accountId: Option[Long] = None): ApiRequest[BlockedNotificationResponse] =
    ApiRequest[BlockedNotificationResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/blocked/batch", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("data", data)
      .withPathParam("version", version)
      .withSuccessResponse[BlockedNotificationResponse](200)
      

  /**
   * Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
   * 
   * Expected answers:
   *   code 200 : NotificationTemplateResponse (successful operation)
   * 
   * @param version 
   * @param accountId the account id of the user
   * @param notificationTemplateId the id of the notification template to delete
   */
  def deleteNotificationTemplate(version: BigDecimal, accountId: Long, notificationTemplateId: Long): ApiRequest[NotificationTemplateResponse] =
    ApiRequest[NotificationTemplateResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/template/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("notificationTemplateId", notificationTemplateId)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationTemplateResponse](200)
      

  /**
   * Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
   * 
   * Expected answers:
   *   code 200 : NotificationTemplateResponse (successful operation)
   * 
   * @param version 
   * @param accountId the id of the account
   * @param notificationTemplateId the id of the notification template to get
   */
  def getNotificationTemplate(version: BigDecimal, accountId: Long, notificationTemplateId: Long): ApiRequest[NotificationTemplateResponse] =
    ApiRequest[NotificationTemplateResponse](ApiMethods.GET, baseUrl, "/api/{version}/notification/template/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("notificationTemplateId", notificationTemplateId)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationTemplateResponse](200)
      

  /**
   * Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.
   * 
   * Expected answers:
   *   code 200 : NotificationMessageListResponse (successful operation)
   * 
   * @param version 
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param connectionAccountId the account id used to view another person's notifications
   * @param appKey the application key to filter messages by application
   * @param eventType comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
   * @param contentIds comma separated list of content ids to search notifications on
   * @param contentTypes comma separated list of content types to search notifications on
   * @param parentIds comma separated list of parent ids to search notifications on
   * @param parentTypes comma separated list of parent types to search notifications on
   * @param actionCategory Action category used to filter notifications
   * @param conduits comma separated list of conduits to search notifications on
   * @param keyword search notifications via keyword
   * @param returnReadMessages if set to true, will return notifications that have been marked as read
   * @param markAsRead if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
   * @param fromDate filter notifications from this date
   * @param latitude latitude used to update the user's current location
   * @param longitude longitude used to update the user's current location
   * @param returnSent whether to include notifications sent by the requester in the response
   * @param ignoreFlagged whether to ignore flagged notifications
   * @param start start of the pagination
   * @param limit limit of the pagination
   */
  def getNotifications(version: BigDecimal, deviceId: Option[String] = None, accountId: Option[Long] = None, connectionAccountId: Option[Long] = None, appKey: Option[String] = None, eventType: Option[String] = None, contentIds: Option[String] = None, contentTypes: Option[String] = None, parentIds: Option[String] = None, parentTypes: Option[String] = None, actionCategory: Option[String] = None, conduits: Option[String] = None, keyword: Option[String] = None, returnReadMessages: Option[Boolean] = None, markAsRead: Option[Boolean] = None, fromDate: Option[Long] = None, latitude: Option[Double] = None, longitude: Option[Double] = None, returnSent: Option[Boolean] = None, ignoreFlagged: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[NotificationMessageListResponse] =
    ApiRequest[NotificationMessageListResponse](ApiMethods.GET, baseUrl, "/api/{version}/notification/search", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("connectionAccountId", connectionAccountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("eventType", eventType)
      .withQueryParam("contentIds", contentIds)
      .withQueryParam("contentTypes", contentTypes)
      .withQueryParam("parentIds", parentIds)
      .withQueryParam("parentTypes", parentTypes)
      .withQueryParam("actionCategory", actionCategory)
      .withQueryParam("conduits", conduits)
      .withQueryParam("keyword", keyword)
      .withQueryParam("returnReadMessages", returnReadMessages)
      .withQueryParam("markAsRead", markAsRead)
      .withQueryParam("fromDate", fromDate)
      .withQueryParam("latitude", latitude)
      .withQueryParam("longitude", longitude)
      .withQueryParam("returnSent", returnSent)
      .withQueryParam("ignoreFlagged", ignoreFlagged)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationMessageListResponse](200)
      

  /**
   * Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param token A token that is generated by the device to sign requests for the notification service providers
   * @param pushType The type of push notification. Possible values include: APNS, GCM
   * @param deviceId The unique id of the device making the request (deviceId or accountId required)
   * @param accountId The account id of the user (deviceId or accountId required)
   * @param environment Determines if the token is a DEVELOPMENT or PRODUCTION token
   * @param appKey The application key
   * @param gameType This parameter is deprecated (use appKey instead)
   * @param active Sets whether the token is active or not (non-active tokens are not used)
   * @param latitude Latitude used to update the user's current location
   * @param longitude Longitude used to update the user's current location
   */
  def registerNotificationToken(version: BigDecimal, token: String, pushType: String, deviceId: Option[String] = None, accountId: Option[Long] = None, environment: Option[String] = None, appKey: Option[String] = None, gameType: Option[String] = None, active: Option[Boolean] = None, latitude: Option[Double] = None, longitude: Option[Double] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/token", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("token", token)
      .withQueryParam("pushType", pushType)
      .withQueryParam("environment", environment)
      .withQueryParam("appKey", appKey)
      .withQueryParam("gameType", gameType)
      .withQueryParam("active", active)
      .withQueryParam("latitude", latitude)
      .withQueryParam("longitude", longitude)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Search on the user's blocked notification settings
   * 
   * Expected answers:
   *   code 200 : BlockedNotificationResponse (successful operation)
   * 
   * @param version 
   * @param appKey The application key
   * @param accountId the account id of the user
   * @param searchTags search tags to filter results
   * @param events events to filter by (comma separated)
   * @param conduits conduits to filter by (comma separated)
   * @param customTypes custom types to filter by (comma separated)
   * @param contentTypes content types to filter by (comma separated)
   * @param contentIds content ids to filter by (comma separated)
   * @param sortField sort field for results
   * @param descending whether to sort descending
   * @param start start of the pagination
   * @param limit limit of the pagination
   */
  def searchBlockedNotifications(version: BigDecimal, appKey: String, accountId: Option[Long] = None, searchTags: Option[String] = None, events: Option[String] = None, conduits: Option[String] = None, customTypes: Option[String] = None, contentTypes: Option[String] = None, contentIds: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[BlockedNotificationResponse] =
    ApiRequest[BlockedNotificationResponse](ApiMethods.GET, baseUrl, "/api/{version}/notification/blocked/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("searchTags", searchTags)
      .withQueryParam("events", events)
      .withQueryParam("conduits", conduits)
      .withQueryParam("customTypes", customTypes)
      .withQueryParam("contentTypes", contentTypes)
      .withQueryParam("contentIds", contentIds)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[BlockedNotificationResponse](200)
      

  /**
   * Search for notification templates on owned applications.
   * 
   * Expected answers:
   *   code 200 : NotificationTemplateResponse (successful operation)
   * 
   * @param version 
   * @param accountId The account ID of the user.
   * @param sortField Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.
   * @param descending Specified whether the results are returned in descending or ascending order.
   * @param start The start of the pagination.
   * @param limit The limit of the pagination.
   * @param appKey Filter results by application.
   * @param event Filter results by event.
   * @param conduit Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param globalOnly Returns only templates that have been reserved for system use on all applications (only for admin accounts).
   * @param reservedOnly Returns only templates that use reserved events.
   * @param keyword Filter results by keyword on the title, tags.
   */
  def searchNotificationTemplate(version: BigDecimal, accountId: Long, sortField: String, descending: Boolean, start: Int, limit: Int, appKey: Option[String] = None, event: Option[String] = None, conduit: Option[String] = None, globalOnly: Option[Boolean] = None, reservedOnly: Option[Boolean] = None, keyword: Option[String] = None): ApiRequest[NotificationTemplateResponse] =
    ApiRequest[NotificationTemplateResponse](ApiMethods.GET, baseUrl, "/api/{version}/notification/template/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("event", event)
      .withQueryParam("conduit", conduit)
      .withQueryParam("globalOnly", globalOnly)
      .withQueryParam("reservedOnly", reservedOnly)
      .withQueryParam("keyword", keyword)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationTemplateResponse](200)
      

  /**
   * Search for application users to send notifications.
   * 
   * Expected answers:
   *   code 200 : Seq[NotificationRecipientResponse] (successful operation)
   * 
   * @param version 
   * @param sortField The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param keyword search by keyword on user's display name and email
   * @param audienceId This parameter is deprecated. filter results by audience
   * @param audienceIds filter results by audiences (comma separated list of audience ids)
   * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)
   * @param recipientAccountIds filter results by accounts (comma separated list of account ids)
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start start of the pagination
   * @param limit limit of the pagination (hard limit of 1000)
   */
  def searchRecipients(version: BigDecimal, sortField: String, deviceId: Option[String] = None, accountId: Option[Long] = None, appKey: Option[String] = None, conduit: Option[String] = None, keyword: Option[String] = None, audienceId: Option[Long] = None, audienceIds: Option[String] = None, connectionGroupIds: Option[String] = None, recipientAccountIds: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[Seq[NotificationRecipientResponse]] =
    ApiRequest[Seq[NotificationRecipientResponse]](ApiMethods.GET, baseUrl, "/api/{version}/notification/recipient/search", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("conduit", conduit)
      .withQueryParam("keyword", keyword)
      .withQueryParam("audienceId", audienceId)
      .withQueryParam("audienceIds", audienceIds)
      .withQueryParam("connectionGroupIds", connectionGroupIds)
      .withQueryParam("recipientAccountIds", recipientAccountIds)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[Seq[NotificationRecipientResponse]](200)
      

  /**
   * Search for application users to send notifications (count/grouped variant).
   * 
   * Expected answers:
   *   code 200 : NotificationRecipientResponseListResponse (successful operation)
   * 
   * @param version 
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param appKey filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param keyword search by keyword on user's display name and email
   * @param audienceId This parameter is deprecated. filter results by audience
   * @param audienceIds filter results by audiences (comma separated list of audience ids)
   * @param connectionGroupIds filter results by connection groups (comma separated list of connection group ids)
   * @param sortField The field to sort by (see API docs for allowed values).
   * @param descending Determines whether the sorted list is in descending or ascending order
   * @param start start of the pagination
   * @param limit limit of the pagination
   */
  def searchRecipientsCount(version: BigDecimal, deviceId: Option[String] = None, accountId: Option[Long] = None, appKey: Option[String] = None, conduit: Option[String] = None, keyword: Option[String] = None, audienceId: Option[Long] = None, audienceIds: Option[String] = None, connectionGroupIds: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[NotificationRecipientResponseListResponse] =
    ApiRequest[NotificationRecipientResponseListResponse](ApiMethods.GET, baseUrl, "/api/{version}/notification/recipient/search/count", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("conduit", conduit)
      .withQueryParam("keyword", keyword)
      .withQueryParam("audienceId", audienceId)
      .withQueryParam("audienceIds", audienceIds)
      .withQueryParam("connectionGroupIds", connectionGroupIds)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationRecipientResponseListResponse](200)
      

  /**
   * Send notifications to all users of an application. Only someone with permissions to the application can do this.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId The account id of the application owner/manager
   * @param appKey The application key for updating an existing application
   * @param customMessage Message string that will be displayed in on the notification
   * @param conduit The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param contentId Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentName Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentType Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentId Default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentType Default notification pay-load field (usage is dependent on the app and the type of event)
   */
  def sendBatchNotifications(version: BigDecimal, accountId: Long, appKey: String, customMessage: String, conduit: Option[String] = None, contentId: Option[Long] = None, contentName: Option[String] = None, contentType: Option[String] = None, parentId: Option[Long] = None, parentType: Option[String] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/batch", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("conduit", conduit)
      .withQueryParam("customMessage", customMessage)
      .withQueryParam("contentId", contentId)
      .withQueryParam("contentName", contentName)
      .withQueryParam("contentType", contentType)
      .withQueryParam("parentId", parentId)
      .withQueryParam("parentType", parentType)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param deviceId the unique id of the device making the request (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param receiverAccountIds comma separated list of account IDs that will receive the notification
   * @param includeFriendGroup determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
   * @param appKey the application key
   * @param gameType This parameter is deprecated.
   * @param conduit the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
   * @param contentId default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentName default notification pay-load field (usage is dependent on the app and the type of event)
   * @param contentType default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentId default notification pay-load field (usage is dependent on the app and the type of event)
   * @param parentType default notification pay-load field (usage is dependent on the app and the type of event)
   * @param actionCategory 
   * @param subject the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
   * @param customMessage message string that will be displayed in on the notification
   * @param friendOnlyAPNS only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
   * @param latitude latitude used to update the user's current location
   * @param longitude longitude used to update the user's current location
   */
  def sendCustomNotifications(version: BigDecimal, deviceId: Option[String] = None, accountId: Option[Long] = None, receiverAccountIds: Option[String] = None, includeFriendGroup: Option[Boolean] = None, appKey: Option[String] = None, gameType: Option[String] = None, conduit: Option[String] = None, contentId: Option[Long] = None, contentName: Option[String] = None, contentType: Option[String] = None, parentId: Option[Long] = None, parentType: Option[String] = None, actionCategory: Option[String] = None, subject: Option[String] = None, customMessage: Option[String] = None, friendOnlyAPNS: Option[Boolean] = None, latitude: Option[Double] = None, longitude: Option[Double] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/custom", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("receiverAccountIds", receiverAccountIds)
      .withQueryParam("includeFriendGroup", includeFriendGroup)
      .withQueryParam("appKey", appKey)
      .withQueryParam("gameType", gameType)
      .withQueryParam("conduit", conduit)
      .withQueryParam("contentId", contentId)
      .withQueryParam("contentName", contentName)
      .withQueryParam("contentType", contentType)
      .withQueryParam("parentId", parentId)
      .withQueryParam("parentType", parentType)
      .withQueryParam("actionCategory", actionCategory)
      .withQueryParam("subject", subject)
      .withQueryParam("customMessage", customMessage)
      .withQueryParam("friendOnlyAPNS", friendOnlyAPNS)
      .withQueryParam("latitude", latitude)
      .withQueryParam("longitude", longitude)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Update a notification template. Developers will only be able to update notification templates for their own applications.
   * 
   * Expected answers:
   *   code 200 : NotificationTemplateResponse (successful operation)
   * 
   * @param version 
   * @param accountId The account ID of the user.
   * @param notificationTemplateId The notification template ID to update.
   * @param title The title of the message (this would become the subject title for emails). There is a 191 character limit.
   * @param body The body of the message.
   * @param tags The search tags on the template used during search queries.
   */
  def updateNotificationTemplate(version: BigDecimal, accountId: Long, notificationTemplateId: Long, title: Option[String] = None, body: Option[String] = None, tags: Option[String] = None): ApiRequest[NotificationTemplateResponse] =
    ApiRequest[NotificationTemplateResponse](ApiMethods.POST, baseUrl, "/api/{version}/notification/template/update", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("notificationTemplateId", notificationTemplateId)
      .withQueryParam("title", title)
      .withQueryParam("body", body)
      .withQueryParam("tags", tags)
      .withPathParam("version", version)
      .withSuccessResponse[NotificationTemplateResponse](200)
      



}

