/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import java.math.BigDecimal
import java.io.File
import org.openapitools.client.model.OrsonAiAddMovieResponse
import org.openapitools.client.model.OrsonAiBatchResponse
import org.openapitools.client.model.OrsonAiEmotionsResponse
import org.openapitools.client.model.OrsonAiProtoResponse
import org.openapitools.client.model.OrsonAiSTTResponse
import org.openapitools.client.model.OrsonAiTTSResponse
import org.openapitools.client.model.OrsonAiTechTuneResponse
import org.openapitools.client.model.OrsonAiTopicsResponse
import org.openapitools.client.model.OrsonAiVoiceCanvasResponse
import org.openapitools.client.model.OrsonEpisodeResponse
import org.openapitools.client.model.OrsonRenderResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object OrsonApi {

  def apply(baseUrl: String = "http://localhost") = new OrsonApi(baseUrl)
}

class OrsonApi(baseUrl: String) {

  /**
   * Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
   * 
   * Expected answers:
   *   code 200 : OrsonAiAddMovieResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param movieName Movie Name
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param tags A user defined list (comma-delimited) of tags associated with the movie
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def addMovie(version: BigDecimal, accountId: Long, movieName: String, thirdPartyAccountId: Option[String] = None, tags: Option[String] = None, file: Option[File] = None, url: Option[String] = None, callback: Option[String] = None): ApiRequest[OrsonAiAddMovieResponse] =
    ApiRequest[OrsonAiAddMovieResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/addMovie", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("tags", tags)
      .withQueryParam("movieName", movieName)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiAddMovieResponse](200)
      

  /**
   * Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
   * 
   * Expected answers:
   *   code 200 : OrsonAiProtoResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param doc Doc
   * @param returnTopics Return Topics
   * @param limit Limit
   * @param offset Offset
   */
  def aiDocs(version: BigDecimal, accountId: Long, doc: String, returnTopics: Option[Boolean] = None, limit: Option[Int] = None, offset: Option[Int] = None): ApiRequest[OrsonAiProtoResponse] =
    ApiRequest[OrsonAiProtoResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/docs", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("doc", doc)
      .withQueryParam("return_topics", returnTopics)
      .withQueryParam("limit", limit)
      .withQueryParam("offset", offset)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiProtoResponse](200)
      

  /**
   * Returns a list of URIs of images that match the text.
   * 
   * Expected answers:
   *   code 200 : OrsonAiProtoResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param text Text
   * @param parseFlag Parse Flag
   * @param fetchFlag Fetch Flag
   * @param size Size
   */
  def aiFindImages(version: BigDecimal, accountId: Long, text: String, parseFlag: Option[String] = None, fetchFlag: Option[String] = None, size: Option[String] = None): ApiRequest[OrsonAiProtoResponse] =
    ApiRequest[OrsonAiProtoResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/img", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("text", text)
      .withQueryParam("parse_flag", parseFlag)
      .withQueryParam("fetch_flag", fetchFlag)
      .withQueryParam("size", size)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiProtoResponse](200)
      

  /**
   * Search the tags column of user provided tags using this endpoint.
   * 
   * Expected answers:
   *   code 200 : OrsonAiProtoResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param tags Tags
   * @param conditional Conditional
   * @param limit Limit
   * @param offset Offset
   */
  def aiTags(version: BigDecimal, accountId: Long, tags: String, conditional: Option[String] = None, limit: Option[Int] = None, offset: Option[Int] = None): ApiRequest[OrsonAiProtoResponse] =
    ApiRequest[OrsonAiProtoResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/tags", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("tags", tags)
      .withQueryParam("conditional", conditional)
      .withQueryParam("limit", limit)
      .withQueryParam("offset", offset)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiProtoResponse](200)
      

  /**
   * Search the movie text column of movie text using this endpoint.
   * 
   * Expected answers:
   *   code 200 : OrsonAiProtoResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param terms Terms
   * @param conditional Conditional
   * @param limit Limit
   * @param offset Offset
   */
  def aiText(version: BigDecimal, accountId: Long, terms: String, conditional: Option[String] = None, limit: Option[Int] = None, offset: Option[Int] = None): ApiRequest[OrsonAiProtoResponse] =
    ApiRequest[OrsonAiProtoResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/text", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("terms", terms)
      .withQueryParam("conditional", conditional)
      .withQueryParam("limit", limit)
      .withQueryParam("offset", offset)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiProtoResponse](200)
      

  /**
   * Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
   * 
   * Expected answers:
   *   code 200 : OrsonAiBatchResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param limit The number of topics to return
   * @param operations The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def batch(version: BigDecimal, accountId: Long, thirdPartyAccountId: Option[String] = None, limit: Option[Int] = None, operations: Option[String] = None, file: Option[File] = None, url: Option[String] = None, callback: Option[String] = None): ApiRequest[OrsonAiBatchResponse] =
    ApiRequest[OrsonAiBatchResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/batch", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("limit", limit)
      .withQueryParam("operations", operations)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiBatchResponse](200)
      

  /**
   * Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
   * 
   * Expected answers:
   *   code 200 : OrsonEpisodeResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param data Request Data String
   */
  def createInstantEpisode(version: BigDecimal, accountId: Long, data: String): ApiRequest[OrsonEpisodeResponse] =
    ApiRequest[OrsonEpisodeResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/stories/episodes/instant", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("data", data)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonEpisodeResponse](200)
      

  /**
   * Create VoiceCanvas images for provided text, file upload, or file URL
   * 
   * Expected answers:
   *   code 200 : OrsonAiVoiceCanvasResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param dimensions Enum: \"256x256\" \"512x512\" \"1024x1024\"
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param text Provide a transcript or previously extracted topics for image generation
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param parseFlag When false, uses the raw value from text instead of identifying topics to fetch/generate from
   * @param fetchFlag When true, fetches images instead of generating them
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def createVoiceCanvas(version: BigDecimal, accountId: Long, dimensions: String, thirdPartyAccountId: Option[String] = None, text: Option[String] = None, file: Option[File] = None, url: Option[String] = None, parseFlag: Option[Boolean] = None, fetchFlag: Option[Boolean] = None, callback: Option[String] = None): ApiRequest[OrsonAiVoiceCanvasResponse] =
    ApiRequest[OrsonAiVoiceCanvasResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/voiceCanvas", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("dimensions", dimensions)
      .withQueryParam("text", text)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("parseFlag", parseFlag)
      .withQueryParam("fetchFlag", fetchFlag)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiVoiceCanvasResponse](200)
      

  /**
   * Detects emotions in an audio or video recording.
   * 
   * Expected answers:
   *   code 200 : OrsonAiEmotionsResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def emotion(version: BigDecimal, accountId: Long, thirdPartyAccountId: Option[String] = None, file: Option[File] = None, url: Option[String] = None, callback: Option[String] = None): ApiRequest[OrsonAiEmotionsResponse] =
    ApiRequest[OrsonAiEmotionsResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/emotion", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiEmotionsResponse](200)
      

  /**
   * Get the result of an in progress Add Movie request from an earlier POST.
   * 
   * Expected answers:
   *   code 200 : OrsonAiAddMovieResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getAddMovieResult(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiAddMovieResponse] =
    ApiRequest[OrsonAiAddMovieResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/addMovie/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiAddMovieResponse](200)
      

  /**
   * Gets the completed Video Batch results, if done, or an error or status update if not.
   * 
   * Expected answers:
   *   code 200 : OrsonAiBatchResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getBatch(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiBatchResponse] =
    ApiRequest[OrsonAiBatchResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/batch/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiBatchResponse](200)
      

  /**
   * Checks the Emotion analysis and returns in progress, results, or error.
   * 
   * Expected answers:
   *   code 200 : OrsonAiEmotionsResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getEmotion(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiEmotionsResponse] =
    ApiRequest[OrsonAiEmotionsResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/emotion/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiEmotionsResponse](200)
      

  /**
   * Gets a summary of the episode's status, including any renders.
   * 
   * Expected answers:
   *   code 200 : OrsonEpisodeResponse (successful operation)
   * 
   * @param version 
   * @param episodeId Episode ID
   * @param accountId Sirqul Account Id
   */
  def getEpisodeStatus(version: BigDecimal, episodeId: Long, accountId: Long): ApiRequest[OrsonEpisodeResponse] =
    ApiRequest[OrsonEpisodeResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/stories/episodes/{episodeId}/status", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("episodeId", episodeId)
      .withSuccessResponse[OrsonEpisodeResponse](200)
      

  /**
   * Gets a summary of the episode's status, including any renders.
   * 
   * Expected answers:
   *   code 200 : OrsonRenderResponse (successful operation)
   * 
   * @param version 
   * @param renderId Render ID
   * @param accountId Sirqul Account Id
   */
  def getRenderStatus(version: BigDecimal, renderId: String, accountId: Long): ApiRequest[OrsonRenderResponse] =
    ApiRequest[OrsonRenderResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/stories/renders/{renderId}/status", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("renderId", renderId)
      .withSuccessResponse[OrsonRenderResponse](200)
      

  /**
   * The results of the video transcription and optional translation.
   * 
   * Expected answers:
   *   code 200 : OrsonAiSTTResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getSTT(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiSTTResponse] =
    ApiRequest[OrsonAiSTTResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/stt/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiSTTResponse](200)
      

  /**
   * Check the status of an in progress Text-to-Speech call or download the result.
   * 
   * Expected answers:
   *   code 200 : OrsonAiTTSResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getTTS(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiTTSResponse] =
    ApiRequest[OrsonAiTTSResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/tts/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiTTSResponse](200)
      

  /**
   * Get a result or continue waiting for a pending request for TechTune analysis.
   * 
   * Expected answers:
   *   code 200 : OrsonAiTechTuneResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getTechTune(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiTechTuneResponse] =
    ApiRequest[OrsonAiTechTuneResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/techTune/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiTechTuneResponse](200)
      

  /**
   * Get the result of an in progress Topics Analysis from an earlier POST.
   * 
   * Expected answers:
   *   code 200 : OrsonAiTopicsResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getTopics(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiTopicsResponse] =
    ApiRequest[OrsonAiTopicsResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/topics/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiTopicsResponse](200)
      

  /**
   * Get a result or continue waiting for a pending request for VoiceCanvas Images.
   * 
   * Expected answers:
   *   code 200 : OrsonAiVoiceCanvasResponse (successful operation)
   * 
   * @param version 
   * @param requestId Orson Request Id
   * @param accountId Sirqul Account Id
   */
  def getVoiceCanvas(version: BigDecimal, requestId: String, accountId: Long): ApiRequest[OrsonAiVoiceCanvasResponse] =
    ApiRequest[OrsonAiVoiceCanvasResponse](ApiMethods.GET, baseUrl, "/api/{version}/orson/ai/voiceCanvas/{requestId}", "application/json")
      .withQueryParam("accountId", accountId)
      .withPathParam("version", version)
      .withPathParam("requestId", requestId)
      .withSuccessResponse[OrsonAiVoiceCanvasResponse](200)
      

  /**
   * Starts a StoryStitch video render to produce your final video, returning the status details.
   * 
   * Expected answers:
   *   code 200 : OrsonRenderResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param data Request Data String
   */
  def startVideoRender(version: BigDecimal, accountId: Long, data: String): ApiRequest[OrsonRenderResponse] =
    ApiRequest[OrsonRenderResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/stories/renders", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("data", data)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonRenderResponse](200)
      

  /**
   * Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
   * 
   * Expected answers:
   *   code 200 : OrsonAiSTTResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param sourceLanguage Source Language
   * @param targetLanguage Target Language
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def stt(version: BigDecimal, accountId: Long, thirdPartyAccountId: Option[String] = None, sourceLanguage: Option[String] = None, targetLanguage: Option[String] = None, file: Option[File] = None, url: Option[String] = None, callback: Option[String] = None): ApiRequest[OrsonAiSTTResponse] =
    ApiRequest[OrsonAiSTTResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/stt", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("sourceLanguage", sourceLanguage)
      .withQueryParam("targetLanguage", targetLanguage)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiSTTResponse](200)
      

  /**
   * Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
   * 
   * Expected answers:
   *   code 200 : OrsonAiTopicsResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param doc The text to get topics for.
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param limit The number of results to return
   * @param offset The starting offset into the total result set to start from
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def summarizeTopics(version: BigDecimal, accountId: Long, thirdPartyAccountId: Option[String] = None, doc: Option[String] = None, file: Option[File] = None, url: Option[String] = None, limit: Option[Int] = None, offset: Option[Int] = None, callback: Option[String] = None): ApiRequest[OrsonAiTopicsResponse] =
    ApiRequest[OrsonAiTopicsResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/topics", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("doc", doc)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("limit", limit)
      .withQueryParam("offset", offset)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiTopicsResponse](200)
      

  /**
   * Analyses a movie file to detect technical issues, such as too few people in frame.
   * 
   * Expected answers:
   *   code 200 : OrsonAiTechTuneResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param numFacesExpected Number of expected faces
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param file An uploaded recording to analyze (Currently limited to 10MB)
   * @param url A recording file to download and analyze (Size limit: 1GB)
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def techTune(version: BigDecimal, accountId: Long, numFacesExpected: Int, thirdPartyAccountId: Option[String] = None, file: Option[File] = None, url: Option[String] = None, callback: Option[String] = None): ApiRequest[OrsonAiTechTuneResponse] =
    ApiRequest[OrsonAiTechTuneResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/techTune", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("numFacesExpected", numFacesExpected)
      .withQueryParam("file", file)
      .withQueryParam("url", url)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiTechTuneResponse](200)
      

  /**
   * Creates an audio file for the given text, with the option of language and voice selection.
   * 
   * Expected answers:
   *   code 200 : OrsonAiTTSResponse (successful operation)
   * 
   * @param version 
   * @param accountId Sirqul Account Id
   * @param text Text
   * @param thirdPartyAccountId A third-party account id that is meaningful to your systems
   * @param language The language to use for the speaker and incoming text
   * @param voice A language-specific voice to use, or picks the language default if not provided
   * @param callback When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open
   */
  def tts(version: BigDecimal, accountId: Long, text: String, thirdPartyAccountId: Option[String] = None, language: Option[String] = None, voice: Option[String] = None, callback: Option[String] = None): ApiRequest[OrsonAiTTSResponse] =
    ApiRequest[OrsonAiTTSResponse](ApiMethods.POST, baseUrl, "/api/{version}/orson/ai/tts", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("thirdPartyAccountId", thirdPartyAccountId)
      .withQueryParam("text", text)
      .withQueryParam("language", language)
      .withQueryParam("voice", voice)
      .withQueryParam("callback", callback)
      .withPathParam("version", version)
      .withSuccessResponse[OrsonAiTTSResponse](200)
      



}

