/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import java.math.BigDecimal
import org.openapitools.client.model.MissionShortResponse
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.model.TournamentResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object TournamentApi {

  def apply(baseUrl: String = "http://localhost") = new TournamentApi(baseUrl)
}

class TournamentApi(baseUrl: String) {

  /**
   * Create a tournament.
   * 
   * Expected answers:
   *   code 200 : TournamentResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param appKey The appKey the tournament is created for.
   * @param title The title of the tournament
   * @param costToPlay The number of tickets required to pay to enter the tournament
   * @param startDate The date/time to start the tournament
   * @param subType Custom string client apps can use for searching/filtering tournaments
   * @param imageAssetId The asset ID to attach to the tournament
   * @param secondsBetweenLevels The number of seconds in between the start of each tournament game/group
   * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker
   * @param secondsBetweenPacks The number of seconds in between the start of each tournament round
   * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
   * @param costToPlayType The type of ticket required to pay
   * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played
   * @param startingLimit The starting number of players for a tournament (filled with AI's)
   * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced)
   * @param description The description of the tournament
   * @param metaData External custom client defined data
   * @param audienceIds The audiences associated with the tournament
   * @param active Activate/deactivate the tournament
   * @param enableBuyBack Determines whether to allow players to buy back into a tournament
   * @param offerIds The list of offers to give as a reward beyond the tickets
   * @param offerAssetId The artwork ID to attach to the reward tickets offers
   * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided
   * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
   * @param allocateTickets Flag to indicate owner should receive tickets for completed missions
   * @param tournamentData A text based string that will be passed into each tournament setup to populate the content
   * @param missionType The style of tournament to build, options are: TOURNAMENT, POOLPLAY
   * @param visibility Sets the visibility flag for the tournament
   * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
   * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
   * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
   * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
   * @param featured This determines whether the tournament is \"featured\" or not
   * @param winnerTag This sets what analytic tag is used when a winner is determined
   * @param tieTag This sets what analytic tag is used when a tie has occurred
   */
  def createTournament(version: BigDecimal, accountId: Long, appKey: String, title: String, costToPlay: Int, startDate: Long, subType: Option[String] = None, imageAssetId: Option[Long] = None, secondsBetweenLevels: Option[Int] = None, secondsForTieBreaker: Option[Int] = None, secondsBetweenPacks: Option[Int] = None, maximumLevelLength: Option[Int] = None, costToPlayType: Option[String] = None, minimumToPlay: Option[Int] = None, startingLimit: Option[Int] = None, availableLimit: Option[Int] = None, description: Option[String] = None, metaData: Option[String] = None, audienceIds: Option[String] = None, active: Option[Boolean] = None, enableBuyBack: Option[Boolean] = None, offerIds: Option[String] = None, offerAssetId: Option[Long] = None, fixedReward: Option[Boolean] = None, splitReward: Option[String] = None, allocateTickets: Option[Boolean] = None, tournamentData: Option[String] = None, missionType: Option[String] = None, visibility: Option[String] = None, preliminaryGroups: Option[Int] = None, preliminaryGroupAdvancements: Option[String] = None, enableMultipleEntries: Option[Boolean] = None, enableMultipleVotes: Option[Boolean] = None, featured: Option[Boolean] = None, winnerTag: Option[String] = None, tieTag: Option[String] = None): ApiRequest[TournamentResponse] =
    ApiRequest[TournamentResponse](ApiMethods.POST, baseUrl, "/api/{version}/tournament/create", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("title", title)
      .withQueryParam("subType", subType)
      .withQueryParam("imageAssetId", imageAssetId)
      .withQueryParam("secondsBetweenLevels", secondsBetweenLevels)
      .withQueryParam("secondsForTieBreaker", secondsForTieBreaker)
      .withQueryParam("secondsBetweenPacks", secondsBetweenPacks)
      .withQueryParam("maximumLevelLength", maximumLevelLength)
      .withQueryParam("costToPlay", costToPlay)
      .withQueryParam("costToPlayType", costToPlayType)
      .withQueryParam("minimumToPlay", minimumToPlay)
      .withQueryParam("startingLimit", startingLimit)
      .withQueryParam("availableLimit", availableLimit)
      .withQueryParam("description", description)
      .withQueryParam("metaData", metaData)
      .withQueryParam("startDate", startDate)
      .withQueryParam("audienceIds", audienceIds)
      .withQueryParam("active", active)
      .withQueryParam("enableBuyBack", enableBuyBack)
      .withQueryParam("offerIds", offerIds)
      .withQueryParam("offerAssetId", offerAssetId)
      .withQueryParam("fixedReward", fixedReward)
      .withQueryParam("splitReward", splitReward)
      .withQueryParam("allocateTickets", allocateTickets)
      .withQueryParam("tournamentData", tournamentData)
      .withQueryParam("missionType", missionType)
      .withQueryParam("visibility", visibility)
      .withQueryParam("preliminaryGroups", preliminaryGroups)
      .withQueryParam("preliminaryGroupAdvancements", preliminaryGroupAdvancements)
      .withQueryParam("enableMultipleEntries", enableMultipleEntries)
      .withQueryParam("enableMultipleVotes", enableMultipleVotes)
      .withQueryParam("featured", featured)
      .withQueryParam("winnerTag", winnerTag)
      .withQueryParam("tieTag", tieTag)
      .withPathParam("version", version)
      .withSuccessResponse[TournamentResponse](200)
      

  /**
   * Delete a tournament.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId the id of the logged in user
   * @param missionId the id of the mission to delete
   */
  def deleteTournament(version: BigDecimal, accountId: Long, missionId: Long): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/tournament/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("missionId", missionId)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get a tournament.
   * 
   * Expected answers:
   *   code 200 : TournamentResponse (successful operation)
   * 
   * @param version 
   * @param accountId The id of the logged in user
   * @param missionId The id of the mission to return (either missionId or joinCode is required)
   * @param joinCode Optional identifier for getting the tournament (either missionId or joinCode is required)
   * @param includeScores Determines which type of scores are returned. Possible values include: ALL, MINE
   * @param objectPreviewSize Determines the max number of game objects that will get returned for each game level response
   */
  def getTournament(version: BigDecimal, accountId: Long, missionId: Option[Long] = None, joinCode: Option[String] = None, includeScores: Option[String] = None, objectPreviewSize: Option[Int] = None): ApiRequest[TournamentResponse] =
    ApiRequest[TournamentResponse](ApiMethods.GET, baseUrl, "/api/{version}/tournament/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("missionId", missionId)
      .withQueryParam("joinCode", joinCode)
      .withQueryParam("includeScores", includeScores)
      .withQueryParam("objectPreviewSize", objectPreviewSize)
      .withPathParam("version", version)
      .withSuccessResponse[TournamentResponse](200)
      

  /**
   * Search on game objects of tournaments
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId the account ID
   * @param gameLevelId the game level id to filter results by
   * @param sortField the field to sort by
   * @param descending determines whether the sorted list is in descending or ascending order
   * @param start the start index for pagination
   * @param limit the limit for pagination
   */
  def searchObjects(version: BigDecimal, accountId: Long, gameLevelId: Long, sortField: Option[String] = None, descending: Option[Boolean] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.GET, baseUrl, "/api/{version}/tournament/object/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("gameLevelId", gameLevelId)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Search for the user's tournament games.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId the account ID
   * @param appKey the application key
   * @param status comma separated list of statuses to filter results by
   * @param missionType The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
   * @param currentOnly search for games that are flagged current only
   * @param visibilities Filter tournament rounds by the mission visibility flag
   * @param start the start index for pagination
   * @param limit the limit for pagination
   */
  def searchRounds(version: BigDecimal, accountId: Long, appKey: String, status: Option[String] = None, missionType: Option[String] = None, currentOnly: Option[Boolean] = None, visibilities: Option[String] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.GET, baseUrl, "/api/{version}/tournament/round/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("status", status)
      .withQueryParam("missionType", missionType)
      .withQueryParam("currentOnly", currentOnly)
      .withQueryParam("visibilities", visibilities)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Search for tournaments
   * 
   * Expected answers:
   *   code 200 : MissionShortResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param appKey The application key
   * @param keyword the keyword to search tournament on
   * @param subType filter results by subType
   * @param includeInactive whether to include inactives in the search or not
   * @param missionTypes comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
   * @param filter filter tournaments by the tournament's current state
   * @param sortField which field to sort on
   * @param descending Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
   * @param visibility Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
   * @param start Start the result set at some index.
   * @param limit Limit the result to some number
   */
  def searchTournaments(version: BigDecimal, accountId: Long, appKey: String, keyword: Option[String] = None, subType: Option[String] = None, includeInactive: Option[Boolean] = None, missionTypes: Option[String] = None, filter: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, visibility: Option[String] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[MissionShortResponse] =
    ApiRequest[MissionShortResponse](ApiMethods.GET, baseUrl, "/api/{version}/tournament/search", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("keyword", keyword)
      .withQueryParam("subType", subType)
      .withQueryParam("includeInactive", includeInactive)
      .withQueryParam("missionTypes", missionTypes)
      .withQueryParam("filter", filter)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("visibility", visibility)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[MissionShortResponse](200)
      

  /**
   * Submit an array of scores for a tournament match. 
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user account ID.
   * @param appKey The application key.
   * @param missionId The missionId to score for
   * @param gameId The gameId to score for
   * @param packId The packId to score for
   * @param scores a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` 
   * @param gameLevelId The gameLevelId to score for
   */
  def submitTournamentScore(version: BigDecimal, accountId: Long, appKey: String, missionId: Long, gameId: Long, packId: Long, scores: String, gameLevelId: Option[Long] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/tournament/score", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("missionId", missionId)
      .withQueryParam("gameId", gameId)
      .withQueryParam("packId", packId)
      .withQueryParam("gameLevelId", gameLevelId)
      .withQueryParam("scores", scores)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Submit a vote for a multi-stage album tournament.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param appKey The application to target
   * @param missionId The tournament's primary id
   * @param gameObjectId The tournament game object the user wants to vote on
   * @param deviceId The unique id of the device making the request (optional)
   * @param checkIfDeviceAlreadyVoted When true, check if the device already voted to prevent duplicate votes from the same device
   */
  def submitTournamentVote(version: BigDecimal, accountId: Long, appKey: String, missionId: Long, gameObjectId: Long, deviceId: Option[String] = None, checkIfDeviceAlreadyVoted: Option[Boolean] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/tournament/vote", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("missionId", missionId)
      .withQueryParam("gameObjectId", gameObjectId)
      .withQueryParam("checkIfDeviceAlreadyVoted", checkIfDeviceAlreadyVoted)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Service to replace the user's opponent in the current level - pack - mission with an AI account.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param accountId the id of the logged in user
   * @param missionId the id of the mission
   * @param packId the id of the pack
   * @param gameLevelId the id of the game level
   */
  def substituteTournamentPlayer(version: BigDecimal, accountId: Long, missionId: Long, packId: Long, gameLevelId: Long): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/tournament/substitute", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("missionId", missionId)
      .withQueryParam("packId", packId)
      .withQueryParam("gameLevelId", gameLevelId)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Update a tournament.
   * 
   * Expected answers:
   *   code 200 : TournamentResponse (successful operation)
   * 
   * @param version 
   * @param accountId The logged in user.
   * @param missionId The mission/tournament to update
   * @param title The title of the tournament
   * @param subType Custom string client apps can use for searching/filtering missions
   * @param imageAssetId The asset ID to attach to the tournament
   * @param secondsBetweenLevels The number of seconds in between the start of each tournament game
   * @param secondsForTieBreaker The number of seconds to extend the round end time in the case of a tie breaker
   * @param secondsBetweenPacks The number of seconds in between the start of each tournament round
   * @param maximumLevelLength The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
   * @param costToPlay The number of tickets required to pay to enter the tournament
   * @param costToPlayType The type of ticket required to pay
   * @param minimumToPlay The minimum number of players required to sign up for the tournament to be played
   * @param startingLimit The starting number of players for a tournament (filled with AI's)
   * @param availableLimit The maximum number of players for a tournament (currently 128 but not enforced)
   * @param description The description of the tournament
   * @param metaData External custom client defined data
   * @param startDate The date/time to start the tournament
   * @param audienceIds The audiences associated with the tournament
   * @param active Activate/deactivate the mission
   * @param enableBuyBack Determines whether to allow players to buy back into a tournament
   * @param offerIds The list of offers to give as a reward beyond the tickets
   * @param offerAssetId The artwork ID to attach to the reward offer
   * @param fixedReward If set then do not update the ticket reward, auto set to true if offerIds provided
   * @param splitReward Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
   * @param allocateTickets Flag to indicate owner should receive tickets for completed missions
   * @param tournamentData A text based string that will be passed into each tournament setup to populate the content
   * @param visibility Sets the visibility flag for the tournament
   * @param preliminaryGroups The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
   * @param preliminaryGroupAdvancements This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
   * @param enableMultipleEntries This determines if multiple submissions/entries are allowed in a multi-stage album tournament
   * @param enableMultipleVotes This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
   * @param featured This determines whether the tournament is \"featured\" or not
   * @param winnerTag This sets what analytic tag is used when a winner is determined
   * @param tieTag This sets what analytic tag is used when a winner is determined
   */
  def updateTournament(version: BigDecimal, accountId: Long, missionId: Long, title: Option[String] = None, subType: Option[String] = None, imageAssetId: Option[Long] = None, secondsBetweenLevels: Option[Int] = None, secondsForTieBreaker: Option[Int] = None, secondsBetweenPacks: Option[Int] = None, maximumLevelLength: Option[Int] = None, costToPlay: Option[Int] = None, costToPlayType: Option[String] = None, minimumToPlay: Option[Int] = None, startingLimit: Option[Int] = None, availableLimit: Option[Int] = None, description: Option[String] = None, metaData: Option[String] = None, startDate: Option[Long] = None, audienceIds: Option[String] = None, active: Option[Boolean] = None, enableBuyBack: Option[Boolean] = None, offerIds: Option[String] = None, offerAssetId: Option[Long] = None, fixedReward: Option[Boolean] = None, splitReward: Option[String] = None, allocateTickets: Option[Boolean] = None, tournamentData: Option[String] = None, visibility: Option[String] = None, preliminaryGroups: Option[Int] = None, preliminaryGroupAdvancements: Option[String] = None, enableMultipleEntries: Option[Boolean] = None, enableMultipleVotes: Option[Boolean] = None, featured: Option[Boolean] = None, winnerTag: Option[String] = None, tieTag: Option[String] = None): ApiRequest[TournamentResponse] =
    ApiRequest[TournamentResponse](ApiMethods.POST, baseUrl, "/api/{version}/tournament/update", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("missionId", missionId)
      .withQueryParam("title", title)
      .withQueryParam("subType", subType)
      .withQueryParam("imageAssetId", imageAssetId)
      .withQueryParam("secondsBetweenLevels", secondsBetweenLevels)
      .withQueryParam("secondsForTieBreaker", secondsForTieBreaker)
      .withQueryParam("secondsBetweenPacks", secondsBetweenPacks)
      .withQueryParam("maximumLevelLength", maximumLevelLength)
      .withQueryParam("costToPlay", costToPlay)
      .withQueryParam("costToPlayType", costToPlayType)
      .withQueryParam("minimumToPlay", minimumToPlay)
      .withQueryParam("startingLimit", startingLimit)
      .withQueryParam("availableLimit", availableLimit)
      .withQueryParam("description", description)
      .withQueryParam("metaData", metaData)
      .withQueryParam("startDate", startDate)
      .withQueryParam("audienceIds", audienceIds)
      .withQueryParam("active", active)
      .withQueryParam("enableBuyBack", enableBuyBack)
      .withQueryParam("offerIds", offerIds)
      .withQueryParam("offerAssetId", offerAssetId)
      .withQueryParam("fixedReward", fixedReward)
      .withQueryParam("splitReward", splitReward)
      .withQueryParam("allocateTickets", allocateTickets)
      .withQueryParam("tournamentData", tournamentData)
      .withQueryParam("visibility", visibility)
      .withQueryParam("preliminaryGroups", preliminaryGroups)
      .withQueryParam("preliminaryGroupAdvancements", preliminaryGroupAdvancements)
      .withQueryParam("enableMultipleEntries", enableMultipleEntries)
      .withQueryParam("enableMultipleVotes", enableMultipleVotes)
      .withQueryParam("featured", featured)
      .withQueryParam("winnerTag", winnerTag)
      .withQueryParam("tieTag", tieTag)
      .withPathParam("version", version)
      .withSuccessResponse[TournamentResponse](200)
      



}

