/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import org.openapitools.client.model.AchievementProgressResponse
import org.openapitools.client.model.AchievementResponse
import org.openapitools.client.model.AchievementShortResponse
import org.openapitools.client.model.AchievementTierResponse
import java.io.File
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object AchievementApi {

  def apply(baseUrl: String = "https://dev.sirqul.com/api/3.18") = new AchievementApi(baseUrl)
}

class AchievementApi(baseUrl: String) {

  /**
   * Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementTierResponse (successful operation)
   * 
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param appKey the application key
   * @param keyword the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
   * @param achievementType filter results by achievementType (these are exact case sensitive matches)
   * @param rankType filter results by the rankType (these are the exact case sensitive matches)
   * @param sortField the field to sort by. See {@link AchievementApiMap}
   * @param descending determines whether the sort list is in descending or ascending order (of the achievement)
   * @param descendingGoal determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
   * @param start The start of the index for pagination
   * @param limit the limit for pagination (has a hard limit of 1000)
   */
  def achievementTierSearchPost(deviceId: Option[String] = None, accountId: Option[Long] = None, appKey: Option[String] = None, keyword: Option[String] = None, achievementType: Option[Long] = None, rankType: Option[String] = None, sortField: Option[String] = None, descending: Option[Boolean] = None, descendingGoal: Option[Boolean] = None, start: Option[Long] = None, limit: Option[Long] = None): ApiRequest[AchievementTierResponse] =
    ApiRequest[AchievementTierResponse](ApiMethods.POST, baseUrl, "/achievement/tier/search", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("keyword", keyword)
      .withQueryParam("achievementType", achievementType)
      .withQueryParam("rankType", rankType)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("descendingGoal", descendingGoal)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withSuccessResponse[AchievementTierResponse](200)
      

  /**
   * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementResponse (successful operation)
   * 
   * @param appKey the application key the achievement is for
   * @param title the title of the achievement (255 character limit)
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param analyticsTag the analytics tag that will trigger when a user's achievement count gets updated
   * @param description the description of the achievement
   * @param rankType the rank type for updating leader boards
   * @param rankIncrement determines how much the rank count is incremented
   * @param minIncrement restrict scores to be above or equal to this minimum value
   * @param maxIncrement restrict scores to be below or equal to this maximum value
   * @param validate determines whether the customId on analytics are used to validate a user's achievement progress.
   * @param active achievement is active or inactive
   * @param triggerDefinition if provided will define what triggers to run after a tier is completed
   */
  def createAchievement(appKey: String, title: String, deviceId: Option[String] = None, accountId: Option[Long] = None, analyticsTag: Option[String] = None, description: Option[String] = None, rankType: Option[String] = None, rankIncrement: Option[Int] = None, minIncrement: Option[Int] = None, maxIncrement: Option[Int] = None, validate: Option[Boolean] = None, active: Option[Boolean] = None, triggerDefinition: Option[String] = None): ApiRequest[AchievementResponse] =
    ApiRequest[AchievementResponse](ApiMethods.POST, baseUrl, "/achievement/create", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("analyticsTag", analyticsTag)
      .withQueryParam("title", title)
      .withQueryParam("description", description)
      .withQueryParam("rankType", rankType)
      .withQueryParam("rankIncrement", rankIncrement)
      .withQueryParam("minIncrement", minIncrement)
      .withQueryParam("maxIncrement", maxIncrement)
      .withQueryParam("validate", validate)
      .withQueryParam("active", active)
      .withQueryParam("triggerDefinition", triggerDefinition)
      .withSuccessResponse[AchievementResponse](200)
      

  /**
   * Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementTierResponse (successful operation)
   * 
   * @param achievementId the achievement id for adding a new tier
   * @param scoreAllInstances score all instances
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param icon achievement tier icon image file
   * @param iconAssetId the icon assetId, if icon is provided, icon will overrule
   * @param title the title of the achievement tier
   * @param description the description of the achievement tier
   * @param goalCount the count requirement for completing the achievement tier
   * @param missionId The ID of the mission to associate with the achievement
   * @param gameId The ID of the game to associate with the achievement
   * @param packId The ID of the pack to associate with the achievement
   * @param gameLevelId The ID of the game level to associate with the achievement
   * @param gameObjectId The ID of the game object to associate with the achievement
   */
  def createAchievementTier(achievementId: Long, scoreAllInstances: Boolean, deviceId: Option[String] = None, accountId: Option[Long] = None, icon: Option[File] = None, iconAssetId: Option[Long] = None, title: Option[String] = None, description: Option[String] = None, goalCount: Option[Long] = None, missionId: Option[Long] = None, gameId: Option[Long] = None, packId: Option[Long] = None, gameLevelId: Option[Long] = None, gameObjectId: Option[Int] = None): ApiRequest[AchievementTierResponse] =
    ApiRequest[AchievementTierResponse](ApiMethods.POST, baseUrl, "/achievement/tier/create", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementId", achievementId)
      .withQueryParam("icon", icon)
      .withQueryParam("iconAssetId", iconAssetId)
      .withQueryParam("title", title)
      .withQueryParam("description", description)
      .withQueryParam("goalCount", goalCount)
      .withQueryParam("missionId", missionId)
      .withQueryParam("gameId", gameId)
      .withQueryParam("packId", packId)
      .withQueryParam("gameLevelId", gameLevelId)
      .withQueryParam("gameObjectId", gameObjectId)
      .withQueryParam("scoreAllInstances", scoreAllInstances)
      .withSuccessResponse[AchievementTierResponse](200)
      

  /**
   * Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param achievementId The ID of the achievement
   * @param accountId the account id of the user (deviceId or accountId required)
   */
  def deleteAchievement(achievementId: Long, accountId: Option[Long] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/achievement/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementId", achievementId)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param achievementTierId the achievement id for deletion
   * @param accountId the account id of the user (deviceId or accountId required).
   */
  def deleteAchievementTier(achievementTierId: Long, accountId: Option[Long] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/achievement/tier/delete", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementTierId", achievementTierId)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementTierResponse (successful operation)
   * 
   * @param achievementId The ID of the achievement
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param achievementType achievementType
   */
  def getAchievement(achievementId: Long, deviceId: Option[String] = None, accountId: Option[Long] = None, achievementType: Option[String] = None): ApiRequest[AchievementTierResponse] =
    ApiRequest[AchievementTierResponse](ApiMethods.GET, baseUrl, "/achievement/get", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementId", achievementId)
      .withQueryParam("achievementType", achievementType)
      .withSuccessResponse[AchievementTierResponse](200)
      

  /**
   * Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementTierResponse (successful operation)
   * 
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param achievementTierId the achievement tier id that is being retrieved
   */
  def getAchievementTier(accountId: Long, achievementTierId: Long): ApiRequest[AchievementTierResponse] =
    ApiRequest[AchievementTierResponse](ApiMethods.POST, baseUrl, "/achievement/tier/get", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementTierId", achievementTierId)
      .withSuccessResponse[AchievementTierResponse](200)
      

  /**
   * Gets a list of user achievements.
   * 
   * Expected answers:
   *   code 200 : Seq[AchievementProgressResponse] (successful operation)
   * 
   * @param returnNulls determines whether to return null fields in the response
   * @param appKey the application key for filtering results by application
   * @param includeUndiscovered determines whether to return achievements that the user has not discovered yet
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param connectionAccountEmail the email of the account to view achievements
   * @param connectionAccountId the id of the account to view achievements
   * @param rankType filter results by achievement rankType
   * @param achievementType filter results by achievement type
   * @param latitude the current latitude of the user
   * @param longitude the current longitude of the user
   */
  def getUserAchievements(returnNulls: Boolean, appKey: String, includeUndiscovered: Boolean, deviceId: Option[String] = None, accountId: Option[Long] = None, connectionAccountEmail: Option[String] = None, connectionAccountId: Option[Long] = None, rankType: Option[String] = None, achievementType: Option[String] = None, latitude: Option[Double] = None, longitude: Option[Double] = None): ApiRequest[Seq[AchievementProgressResponse]] =
    ApiRequest[Seq[AchievementProgressResponse]](ApiMethods.GET, baseUrl, "/achievement/progress/get", "application/json")
      .withQueryParam("returnNulls", returnNulls)
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("connectionAccountEmail", connectionAccountEmail)
      .withQueryParam("connectionAccountId", connectionAccountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("rankType", rankType)
      .withQueryParam("achievementType", achievementType)
      .withQueryParam("includeUndiscovered", includeUndiscovered)
      .withQueryParam("latitude", latitude)
      .withQueryParam("longitude", longitude)
      .withSuccessResponse[Seq[AchievementProgressResponse]](200)
      

  /**
   * List achievement tags by application
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param appKey filter results by application key
   */
  def listAchievementTags(appKey: Option[String] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.GET, baseUrl, "/achievement/tag/list", "application/json")
      .withQueryParam("appKey", appKey)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * List achievements by billable.
   * 
   * Expected answers:
   *   code 200 : Seq[AchievementShortResponse] (successful operation)
   * 
   * @param sortField the field to sort by. See AchievementApiMap
   * @param descending determines whether the sorted list is in descending or ascending order
   * @param start the start index for pagination
   * @param limit the limit for pagination (has a hard limit of 1000)
   * @param activeOnly Filter results to only return active achievements
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param appKey the application key
   * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
   * @param achievementType filter results by the achievementType (these are exact case sensitive matches)
   * @param rankType filter results by the rankType (these are exact case sensitive matches)
   */
  def listAchievements(sortField: String, descending: Boolean, start: Int, limit: Int, activeOnly: Boolean, deviceId: Option[String] = None, accountId: Option[Long] = None, appKey: Option[String] = None, keyword: Option[String] = None, achievementType: Option[String] = None, rankType: Option[String] = None): ApiRequest[Seq[AchievementShortResponse]] =
    ApiRequest[Seq[AchievementShortResponse]](ApiMethods.GET, baseUrl, "/achievement/list", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("keyword", keyword)
      .withQueryParam("achievementType", achievementType)
      .withQueryParam("rankType", rankType)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withQueryParam("activeOnly", activeOnly)
      .withSuccessResponse[Seq[AchievementShortResponse]](200)
      

  /**
   * Searches achievements by application for consumers.
   * 
   * Expected answers:
   *   code 200 : Seq[AchievementShortResponse] (successful operation)
   * 
   * @param appKey the application key
   * @param sortField the field to sort by. See AchievementApiMap
   * @param descending determines whether the sorted list is in descending or ascending order
   * @param includeTiers return tiers, only applicable for version >3.18
   * @param includeInactiveTiers return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18
   * @param start the start index for pagination
   * @param limit the limit for pagination (has a hard limit of 1000)
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param keyword the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
   * @param achievementType filter results by the achievementType (these are exact case sensitive matches)
   * @param rankType filter results by the rankType (these are exact case sensitive matches)
   */
  def searchAchievements(appKey: String, sortField: String, descending: Boolean, includeTiers: Boolean, includeInactiveTiers: Boolean, start: Int, limit: Int, deviceId: Option[String] = None, accountId: Option[Long] = None, keyword: Option[String] = None, achievementType: Option[String] = None, rankType: Option[String] = None): ApiRequest[Seq[AchievementShortResponse]] =
    ApiRequest[Seq[AchievementShortResponse]](ApiMethods.GET, baseUrl, "/achievement/search", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("keyword", keyword)
      .withQueryParam("achievementType", achievementType)
      .withQueryParam("rankType", rankType)
      .withQueryParam("sortField", sortField)
      .withQueryParam("descending", descending)
      .withQueryParam("includeTiers", includeTiers)
      .withQueryParam("includeInactiveTiers", includeInactiveTiers)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withSuccessResponse[Seq[AchievementShortResponse]](200)
      

  /**
   * Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementResponse (successful operation)
   * 
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param achievementId the achievement ID for updating an existing achievement
   * @param analyticsTag the analytics tag that will trigger when a user's achievement count gets updated
   * @param title the title of the achievement (255 character limit)
   * @param description the description of the achievement
   * @param rankType the rank type for updating leader boards
   * @param rankIncrement determines how much the rank count is incremented
   * @param minIncrement restrict scores to be above or equal to this minimum value
   * @param nullMinIncrement enable to ignore usage of minIncrement
   * @param maxIncrement restrict scores to be below or equal to this maximum value
   * @param nullMaxIncrement enable to ignore usage of maxIncrement
   * @param validate determines whether the customId on analytics are used to validate a user's achievement progress.
   * @param active if it's active or inactive
   * @param triggerDefinition if provided will define what triggers to run after a tier is completed
   */
  def updateAchievement(deviceId: Option[String] = None, accountId: Option[Long] = None, achievementId: Option[Long] = None, analyticsTag: Option[String] = None, title: Option[String] = None, description: Option[String] = None, rankType: Option[String] = None, rankIncrement: Option[Int] = None, minIncrement: Option[Int] = None, nullMinIncrement: Option[Boolean] = None, maxIncrement: Option[Int] = None, nullMaxIncrement: Option[Boolean] = None, validate: Option[Boolean] = None, active: Option[Boolean] = None, triggerDefinition: Option[String] = None): ApiRequest[AchievementResponse] =
    ApiRequest[AchievementResponse](ApiMethods.POST, baseUrl, "/achievement/update", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementId", achievementId)
      .withQueryParam("analyticsTag", analyticsTag)
      .withQueryParam("title", title)
      .withQueryParam("description", description)
      .withQueryParam("rankType", rankType)
      .withQueryParam("rankIncrement", rankIncrement)
      .withQueryParam("minIncrement", minIncrement)
      .withQueryParam("nullMinIncrement", nullMinIncrement)
      .withQueryParam("maxIncrement", maxIncrement)
      .withQueryParam("nullMaxIncrement", nullMaxIncrement)
      .withQueryParam("validate", validate)
      .withQueryParam("active", active)
      .withQueryParam("triggerDefinition", triggerDefinition)
      .withSuccessResponse[AchievementResponse](200)
      

  /**
   * Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
   * 
   * Expected answers:
   *   code 200 : AchievementTierResponse (successful operation)
   * 
   * @param achievementTierId the achievement tier id for updating
   * @param deviceId a unique id given by the device (deviceId or accountId required)
   * @param accountId the account id of the user (deviceId or accountId required)
   * @param icon achievement tier icon image file
   * @param iconAssetId the icon assetId, if icon is provided, icon will overrule
   * @param title the title of the achievement tier
   * @param description the description of the achievement tier
   * @param goalCount the count requirement for completing the achievement tier
   * @param missionId The ID of the mission to associate with the achievement
   * @param gameId The ID of the game to associate with the achievement
   * @param packId The ID of the pack to associate with the achievement
   * @param gameLevelId The ID of the game level to associate with the achievement
   * @param gameObjectId The ID of the game object to associate with the achievement
   * @param scoreAllInstances score all instances
   */
  def updateAchievementTier(achievementTierId: Long, deviceId: Option[String] = None, accountId: Option[Long] = None, icon: Option[File] = None, iconAssetId: Option[Long] = None, title: Option[String] = None, description: Option[String] = None, goalCount: Option[Long] = None, missionId: Option[Long] = None, gameId: Option[Long] = None, packId: Option[Long] = None, gameLevelId: Option[Long] = None, gameObjectId: Option[Long] = None, scoreAllInstances: Option[Boolean] = None): ApiRequest[AchievementTierResponse] =
    ApiRequest[AchievementTierResponse](ApiMethods.POST, baseUrl, "/achievement/tier/update", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementTierId", achievementTierId)
      .withQueryParam("icon", icon)
      .withQueryParam("iconAssetId", iconAssetId)
      .withQueryParam("title", title)
      .withQueryParam("description", description)
      .withQueryParam("goalCount", goalCount)
      .withQueryParam("missionId", missionId)
      .withQueryParam("gameId", gameId)
      .withQueryParam("packId", packId)
      .withQueryParam("gameLevelId", gameLevelId)
      .withQueryParam("gameObjectId", gameObjectId)
      .withQueryParam("scoreAllInstances", scoreAllInstances)
      .withSuccessResponse[AchievementTierResponse](200)
      

  /**
   * Update user achievement progress.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param accountId the account id of the user
   * @param achievementId the achievement id (achievementId or tag required)
   * @param tag the analytic tag to identify an achievement (achievementId or tag required)
   * @param customId a custom identifier used for validation
   * @param increment the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
   * @param startDate a custom start date that the client can set (not yet used in server logic)
   * @param endDate a custom end date that the client can set (not yet used in server logic)
   * @param returnProgress determines whether to return the achievement progress response
   */
  def updateUserAchievement(accountId: Long, achievementId: Option[Long] = None, tag: Option[String] = None, customId: Option[Long] = None, increment: Option[Long] = None, startDate: Option[Long] = None, endDate: Option[Long] = None, returnProgress: Option[Boolean] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/achievement/progress/update", "application/json")
      .withQueryParam("accountId", accountId)
      .withQueryParam("achievementId", achievementId)
      .withQueryParam("tag", tag)
      .withQueryParam("customId", customId)
      .withQueryParam("increment", increment)
      .withQueryParam("startDate", startDate)
      .withQueryParam("endDate", endDate)
      .withQueryParam("returnProgress", returnProgress)
      .withSuccessResponse[SirqulResponse](200)
      



}

