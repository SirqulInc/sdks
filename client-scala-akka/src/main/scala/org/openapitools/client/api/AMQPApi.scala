/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import java.math.BigDecimal
import org.openapitools.client.model.QueueResponse
import org.openapitools.client.model.SirqulResponse
import org.openapitools.client.core._
import org.openapitools.client.core.CollectionFormats._
import org.openapitools.client.core.ApiKeyLocations._

object AMQPApi {

  def apply(baseUrl: String = "http://localhost") = new AMQPApi(baseUrl)
}

class AMQPApi(baseUrl: String) {

  /**
   * Create a connection to an existing amqp queue and register as a consumer.
   * 
   * Expected answers:
   *   code 200 : QueueResponse (successful operation)
   * 
   * @param version 
   * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
   * @param name The name of the queue to connect to
   * @param hostname The hostname of the server the queue is hosted on
   * @param username The username to access the server the queue is hosted on
   * @param password The password to access the queue to connect to
   * @param dataMapping The data mapping information in the format of AMQPRequest
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param port The port of the server the queue is hosted on
   * @param virtualHost The virtual host defined on the server the queue is associated on
   * @param exchanger The exchanger of the queue to connect to
   * @param exchangerType The exchanger type of the queue to connect to
   * @param workers The number of workers to generate 
   * @param useSSL Use SSL
   */
  def consumerCreate(version: BigDecimal, appKey: String, name: String, hostname: String, username: String, password: String, dataMapping: String, deviceId: Option[String] = None, accountId: Option[Long] = None, port: Option[Int] = None, virtualHost: Option[String] = None, exchanger: Option[String] = None, exchangerType: Option[String] = None, workers: Option[Int] = None, useSSL: Option[Boolean] = None): ApiRequest[QueueResponse] =
    ApiRequest[QueueResponse](ApiMethods.POST, baseUrl, "/api/{version}/queue/consumer/create", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("name", name)
      .withQueryParam("hostname", hostname)
      .withQueryParam("port", port)
      .withQueryParam("username", username)
      .withQueryParam("password", password)
      .withQueryParam("virtualHost", virtualHost)
      .withQueryParam("exchanger", exchanger)
      .withQueryParam("exchangerType", exchangerType)
      .withQueryParam("workers", workers)
      .withQueryParam("dataMapping", dataMapping)
      .withQueryParam("useSSL", useSSL)
      .withPathParam("version", version)
      .withSuccessResponse[QueueResponse](200)
      

  /**
   * Update an existing amqp queue's data mapping.
   * 
   * Expected answers:
   *   code 200 : QueueResponse (successful operation)
   * 
   * @param version 
   * @param appKey The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied.
   * @param queueId The queue to update
   * @param dataMapping The data mapping information in the format of AMQPRequest
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param useSSL Use SSL
   */
  def consumerUpdate(version: BigDecimal, appKey: String, queueId: Long, dataMapping: String, deviceId: Option[String] = None, accountId: Option[Long] = None, useSSL: Option[Boolean] = None): ApiRequest[QueueResponse] =
    ApiRequest[QueueResponse](ApiMethods.POST, baseUrl, "/api/{version}/queue/consumer/update", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("queueId", queueId)
      .withQueryParam("dataMapping", dataMapping)
      .withQueryParam("useSSL", useSSL)
      .withPathParam("version", version)
      .withSuccessResponse[QueueResponse](200)
      

  /**
   * Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
   * 
   * Expected answers:
   *   code 200 : QueueResponse (successful operation)
   * 
   * @param version 
   * @param appKey The application key unique to each application.
   * @param name The name of the queue to create
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param workers The number of workers to generate 
   * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
   * @param hostname The hostname of the server the queue is hosted on
   * @param port The port of the server the queue is hosted on
   * @param username The username to access the server that the queue is on
   * @param password The password to access the queue to connect to
   * @param virtualHost The virtual host defined on the server to queue
   * @param useSSL Use SSL
   */
  def queueCreate(version: BigDecimal, appKey: String, name: String, deviceId: Option[String] = None, accountId: Option[Long] = None, workers: Option[Int] = None, analyticTags: Option[String] = None, hostname: Option[String] = None, port: Option[Int] = None, username: Option[String] = None, password: Option[String] = None, virtualHost: Option[String] = None, useSSL: Option[Boolean] = None): ApiRequest[QueueResponse] =
    ApiRequest[QueueResponse](ApiMethods.POST, baseUrl, "/api/{version}/queue/create", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("name", name)
      .withQueryParam("workers", workers)
      .withQueryParam("analyticTags", analyticTags)
      .withQueryParam("hostname", hostname)
      .withQueryParam("port", port)
      .withQueryParam("username", username)
      .withQueryParam("password", password)
      .withQueryParam("virtualHost", virtualHost)
      .withQueryParam("useSSL", useSSL)
      .withPathParam("version", version)
      .withSuccessResponse[QueueResponse](200)
      

  /**
   * Delete the stored queue record and close any active connections to the AMQP servers.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param queueId The id of the queue to find
   * @param deviceId The client device ID
   * @param accountId The logged in user ID
   */
  def queueDelete(version: BigDecimal, queueId: Long, deviceId: Option[String] = None, accountId: Option[Long] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/queue/delete", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("queueId", queueId)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
   * 
   * Expected answers:
   *   code 200 : QueueResponse (successful operation)
   * 
   * @param version 
   * @param deviceId The client device ID
   * @param accountId The logged in user ID
   * @param queueId The id of the queue to find
   * @param appKey The application key the queue was assigned to
   * @param name The name of the queue to find
   * @param hostname The hostname of the queue to find
   * @param virtualHost The virtual host of the queue to find
   */
  def queueGet(version: BigDecimal, deviceId: Option[String] = None, accountId: Option[Long] = None, queueId: Option[Long] = None, appKey: Option[String] = None, name: Option[String] = None, hostname: Option[String] = None, virtualHost: Option[String] = None): ApiRequest[QueueResponse] =
    ApiRequest[QueueResponse](ApiMethods.GET, baseUrl, "/api/{version}/queue/get", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("queueId", queueId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("name", name)
      .withQueryParam("hostname", hostname)
      .withQueryParam("virtualHost", virtualHost)
      .withPathParam("version", version)
      .withSuccessResponse[QueueResponse](200)
      

  /**
   * Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
   * 
   * Expected answers:
   *   code 200 : SirqulResponse (successful operation)
   * 
   * @param version 
   * @param message The payload to send to the queue
   * @param queueId The id of the queue to publish to
   * @param appKey The application key the queue was assigned to
   * @param name The name of the queue to publish to or the analytic tag to handle if the analytic param is true
   * @param hostname The hostname of the server the queue is hosted on
   * @param virtualHost The virtual host defined on the server to queue
   */
  def queuePublish(version: BigDecimal, message: String, queueId: Option[Long] = None, appKey: Option[String] = None, name: Option[String] = None, hostname: Option[String] = None, virtualHost: Option[String] = None): ApiRequest[SirqulResponse] =
    ApiRequest[SirqulResponse](ApiMethods.POST, baseUrl, "/api/{version}/queue/publish", "application/json")
      .withQueryParam("queueId", queueId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("name", name)
      .withQueryParam("hostname", hostname)
      .withQueryParam("virtualHost", virtualHost)
      .withQueryParam("message", message)
      .withPathParam("version", version)
      .withSuccessResponse[SirqulResponse](200)
      

  /**
   * Get the queues setup for the BillableEntity's applications.
   * 
   * Expected answers:
   *   code 200 : QueueResponse (successful operation)
   * 
   * @param version 
   * @param queueId The id of the queue to find
   * @param deviceId The client device ID
   * @param accountId The logged in user ID
   * @param name The name of the queue to find
   * @param start Start of the index
   * @param limit Limit of the index
   */
  def queueSearch(version: BigDecimal, queueId: Option[Long] = None, deviceId: Option[String] = None, accountId: Option[Long] = None, name: Option[String] = None, start: Option[Int] = None, limit: Option[Int] = None): ApiRequest[QueueResponse] =
    ApiRequest[QueueResponse](ApiMethods.GET, baseUrl, "/api/{version}/queue/search", "application/json")
      .withQueryParam("queueId", queueId)
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("name", name)
      .withQueryParam("start", start)
      .withQueryParam("limit", limit)
      .withPathParam("version", version)
      .withSuccessResponse[QueueResponse](200)
      

  /**
   * Update the basic AMQP queue.
   * 
   * Expected answers:
   *   code 200 : QueueResponse (successful operation)
   * 
   * @param version 
   * @param queueId The id of the queue to update
   * @param deviceId The client deviceID
   * @param accountId The logged in user ID
   * @param appKey The application key unique to each application.
   * @param workers The number of workers to generate
   * @param analyticTags If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags
   * @param hostname The hostname of the server the queue is hosted on
   * @param port The port of the server the queue is hosted on
   * @param username The username to access the server that the queue is on
   * @param password The password to access the queue to connect to
   * @param virtualHost The virtual host defined on the server to queue
   * @param useSSL the SSL to use
   */
  def queueUpdate(version: BigDecimal, queueId: Long, deviceId: Option[String] = None, accountId: Option[Long] = None, appKey: Option[String] = None, workers: Option[Int] = None, analyticTags: Option[String] = None, hostname: Option[String] = None, port: Option[Int] = None, username: Option[String] = None, password: Option[String] = None, virtualHost: Option[String] = None, useSSL: Option[Boolean] = None): ApiRequest[QueueResponse] =
    ApiRequest[QueueResponse](ApiMethods.POST, baseUrl, "/api/{version}/queue/update", "application/json")
      .withQueryParam("deviceId", deviceId)
      .withQueryParam("accountId", accountId)
      .withQueryParam("appKey", appKey)
      .withQueryParam("queueId", queueId)
      .withQueryParam("workers", workers)
      .withQueryParam("analyticTags", analyticTags)
      .withQueryParam("hostname", hostname)
      .withQueryParam("port", port)
      .withQueryParam("username", username)
      .withQueryParam("password", password)
      .withQueryParam("virtualHost", virtualHost)
      .withQueryParam("useSSL", useSSL)
      .withPathParam("version", version)
      .withSuccessResponse[QueueResponse](200)
      



}

