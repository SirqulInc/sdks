//
// EventAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class EventAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Attend Event
    /// - POST /event/attend
    /// -  Specify whether the user is attending an event at a particular location. This can also be used as a \"check-in\" action.
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) The application of where to send notifications about the attend action (optional)
    /// - parameter listingId: (query) The scheduled broadcast or marketing experience id (optional)
    /// - parameter retailerLocationId: (query) The retailer location where the event is being held (optional)
    /// - parameter offerLocationId: (query) The actual event being held (optional)
    /// - parameter transactionId: (query) The wallet item to update the status of, if provided then ignore the listingId, retailerLocationId, and the offerLocationId (optional)
    /// - parameter status: (query) Sets whether the user is: undecided (0), attending (1), attending and checked in (2), or not attending (3) (optional)
    /// - parameter latitude: (query) The location of the status update (optional)
    /// - parameter longitude: (query) The location of the status update (optional)
    /// - returns: AnyPublisher<OfferResponse, Error> 
    open func attendEvent(deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, listingId: Int64? = nil, retailerLocationId: Int64? = nil, offerLocationId: Int64? = nil, transactionId: Int64? = nil, status: Int? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<OfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/attend"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let listingId = listingId { queryItems.append(URLQueryItem(name: "listingId", value: "\(listingId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let transactionId = transactionId { queryItems.append(URLQueryItem(name: "transactionId", value: "\(transactionId)")) } 
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: "\(status)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Event
    /// - POST /event/create
    /// - Create a private event to share with associates.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter title: (query) The event title 
    /// - parameter retailerLocationIds: (query) The retailer location to have the event at (optional)
    /// - parameter subTitle: (query) The event sub title (optional)
    /// - parameter details: (query) The event details (optional)
    /// - parameter categoryIds: (query) The categories the associate the event with (optional)
    /// - parameter filterIds: (query) The filters the associate the event with (optional)
    /// - parameter active: (query) Is this event active (optional)
    /// - parameter imageAssetId: (query) The image to show for the event (optional)
    /// - parameter redeemableStart: (query) The event start date/time (optional)
    /// - parameter redeemableEnd: (query) The event end date/time (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - returns: AnyPublisher<OfferResponse, Error> 
    open func createEvent(accountId: Int64, title: String, retailerLocationIds: String? = nil, subTitle: String? = nil, details: String? = nil, categoryIds: String? = nil, filterIds: String? = nil, active: Bool? = nil, imageAssetId: Int64? = nil, redeemableStart: Int64? = nil, redeemableEnd: Int64? = nil, metaData: String? = nil) -> AnyPublisher<OfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                queryItems.append(URLQueryItem(name: "title", value: title))
                if let subTitle = subTitle { queryItems.append(URLQueryItem(name: "subTitle", value: subTitle)) } 
                if let details = details { queryItems.append(URLQueryItem(name: "details", value: details)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let redeemableStart = redeemableStart { queryItems.append(URLQueryItem(name: "redeemableStart", value: "\(redeemableStart)")) } 
                if let redeemableEnd = redeemableEnd { queryItems.append(URLQueryItem(name: "redeemableEnd", value: "\(redeemableEnd)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Event
    /// - POST /event/delete
    /// - Delete an event that the user has permissions to.
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter eventId: (query) the id of the event to update 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteEvent(accountId: Int64, eventId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "eventId", value: "\(eventId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Event
    /// - GET /event/get
    /// - Get an event.
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter eventId: (query) The id of the event to return 
    /// - returns: AnyPublisher<OfferResponse, Error> 
    open func getEvent(accountId: Int64, eventId: Int64) -> AnyPublisher<OfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "eventId", value: "\(eventId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchEventTransactionsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case redeemableStart = "REDEEMABLE_START"
        case redeemableEnd = "REDEEMABLE_END"
        case customerId = "CUSTOMER_ID"
        case customerDisplay = "CUSTOMER_DISPLAY"
        case retailerId = "RETAILER_ID"
        case retailerName = "RETAILER_NAME"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }

    /// Search Event Attendance
    /// - GET /event/attendance/search
    /// - Searches on event type transactions. This can be used to see who is attending an event.
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter keyword: (query) The keyword to search for (optional)
    /// - parameter retailerId: (query) Filter results for this retailer (optional)
    /// - parameter retailerLocationId: (query) Filter results for this retailer location (optional)
    /// - parameter excludeRetailerLocationId: (query) Exclude results from this retailer location (optional)
    /// - parameter listingId: (query) Filter results for this event listing (optional)
    /// - parameter offerId: (query) Filter results for this offer (optional)
    /// - parameter offerLocationId: (query) Filter results for this offer location (optional)
    /// - parameter customerAccountIds: (query) Filter results by accounts (optional)
    /// - parameter affiliatedCategoryIds: (query) Comma separated list of category ids to determine whether the attendee is affiliated with the category (optional)
    /// - parameter startDate: (query) Filter on attendance starting on or after this date (milliseconds since epoch) (optional)
    /// - parameter endDate: (query) Filter on attendance starting on or before this date (milliseconds since epoch) (optional)
    /// - parameter statuses: (query) Comma separated list of transaction statuses to filter on (optional)
    /// - parameter sortField: (query) Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (optional)
    /// - parameter descending: (query) Determines whether the results are in descending order (optional)
    /// - parameter start: (query) The start index for pagination (optional)
    /// - parameter limit: (query) The limit for pagination (optional)
    /// - returns: AnyPublisher<[EventAttendanceResponse], Error> 
    open func searchEventTransactions(deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, keyword: String? = nil, retailerId: Int64? = nil, retailerLocationId: Int64? = nil, excludeRetailerLocationId: Int64? = nil, listingId: Int64? = nil, offerId: Int64? = nil, offerLocationId: Int64? = nil, customerAccountIds: String? = nil, affiliatedCategoryIds: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, statuses: String? = nil, sortField: SearchEventTransactionsSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[EventAttendanceResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/attendance/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let excludeRetailerLocationId = excludeRetailerLocationId { queryItems.append(URLQueryItem(name: "excludeRetailerLocationId", value: "\(excludeRetailerLocationId)")) } 
                if let listingId = listingId { queryItems.append(URLQueryItem(name: "listingId", value: "\(listingId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let customerAccountIds = customerAccountIds { queryItems.append(URLQueryItem(name: "customerAccountIds", value: customerAccountIds)) } 
                if let affiliatedCategoryIds = affiliatedCategoryIds { queryItems.append(URLQueryItem(name: "affiliatedCategoryIds", value: affiliatedCategoryIds)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let statuses = statuses { queryItems.append(URLQueryItem(name: "statuses", value: statuses)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[EventAttendanceResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([EventAttendanceResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchEventsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case redeemableStart = "REDEEMABLE_START"
        case redeemableEnd = "REDEEMABLE_END"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case estimatedValue = "ESTIMATED_VALUE"
        case voucherPrice = "VOUCHER_PRICE"
        case voucherDiscountPrice = "VOUCHER_DISCOUNT_PRICE"
        case fullPrice = "FULL_PRICE"
        case dicountPrice = "DICOUNT_PRICE"
        case ticketsReward = "TICKETS_REWARD"
        case availabilityDate = "AVAILABILITY_DATE"
        case releaseDate = "RELEASE_DATE"
        case retailerId = "RETAILER_ID"
        case retailerName = "RETAILER_NAME"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }

    /// Search Events
    /// - GET /event/search
    /// - Searches on events that the account has access to.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter activeOnly: (query) Return only active results (optional)
    /// - parameter categoryIds: (query) the IDs of the categories that this event is associated with (optional)
    /// - parameter filterIds: (query) the IDs of the filters that this event is associated with (optional)
    /// - parameter offerAudienceIds: (query) Offer audience ids to filter on (optional)
    /// - parameter transactionAudienceIds: (query) Transaction audience ids to filter on (optional)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter startDate: (query) Filter the events to return only those that start on or after the date (optional)
    /// - parameter endDate: (query) Filter the events to return only those that start on or before the date (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - returns: AnyPublisher<[OfferShortResponse], Error> 
    open func searchEvents(accountId: Int64, keyword: String? = nil, activeOnly: Bool? = nil, categoryIds: String? = nil, filterIds: String? = nil, offerAudienceIds: String? = nil, transactionAudienceIds: String? = nil, sortField: SearchEventsSortField? = nil, descending: Bool? = nil, startDate: Int64? = nil, endDate: Int64? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[OfferShortResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let offerAudienceIds = offerAudienceIds { queryItems.append(URLQueryItem(name: "offerAudienceIds", value: offerAudienceIds)) } 
                if let transactionAudienceIds = transactionAudienceIds { queryItems.append(URLQueryItem(name: "transactionAudienceIds", value: transactionAudienceIds)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferShortResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferShortResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Event
    /// - POST /event/update
    /// - Update a private event to share with associates.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter eventId: (query) The id of the event to update 
    /// - parameter retailerLocationIds: (query) The retailer location to have the event at (optional)
    /// - parameter title: (query) The event title (optional)
    /// - parameter subTitle: (query) The event sub title (optional)
    /// - parameter details: (query) The event details (optional)
    /// - parameter categoryIds: (query) The categories the associate the event with (optional)
    /// - parameter filterIds: (query) The filters the associate the event with (optional)
    /// - parameter active: (query) Is this event active (optional)
    /// - parameter imageAssetId: (query) The image to show for the event (optional)
    /// - parameter redeemableStart: (query) The event start date/time (optional)
    /// - parameter redeemableEnd: (query) The event end date/time (optional)
    /// - returns: AnyPublisher<OfferResponse, Error> 
    open func updateEvent(accountId: Int64, eventId: Int64, retailerLocationIds: String? = nil, title: String? = nil, subTitle: String? = nil, details: String? = nil, categoryIds: String? = nil, filterIds: String? = nil, active: Bool? = nil, imageAssetId: Int64? = nil, redeemableStart: Int64? = nil, redeemableEnd: Int64? = nil) -> AnyPublisher<OfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/event/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "eventId", value: "\(eventId)"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let subTitle = subTitle { queryItems.append(URLQueryItem(name: "subTitle", value: subTitle)) } 
                if let details = details { queryItems.append(URLQueryItem(name: "details", value: details)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let redeemableStart = redeemableStart { queryItems.append(URLQueryItem(name: "redeemableStart", value: "\(redeemableStart)")) } 
                if let redeemableEnd = redeemableEnd { queryItems.append(URLQueryItem(name: "redeemableEnd", value: "\(redeemableEnd)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
