//
// ConnectionAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ConnectionAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Add Connection
    /// - POST /api/{version}/consumer/connection/group/addConnection
    /// - Adds a connection to a group.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter groupId: (query) the group id 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionId: (query) the connection id (optional)
    /// - parameter connectionAccountId: (query) the connection account id (optional)
    /// - parameter pendingId: (query) the pending id (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func addConnectionToGroup(version: Double, returnNulls: Bool, groupId: Int64, deviceId: String? = nil, accountId: Int64? = nil, connectionId: Int64? = nil, connectionAccountId: Int64? = nil, pendingId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group/addConnection"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionId = connectionId { queryItems.append(URLQueryItem(name: "connectionId", value: "\(connectionId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let pendingId = pendingId { queryItems.append(URLQueryItem(name: "pendingId", value: "\(pendingId)")) } 
                queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Add Connections
    /// - POST /api/{version}/connection/group/addConnections
    /// - Adds a list of connections to a group.
    /// - parameter version: (path)  
    /// - parameter connectionGroupId: (query) the connection group ID 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionIds: (query) comma separated list of connection ids (optional)
    /// - parameter connectionAccountIds: (query) comma separated list of connection account ids (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func addConnectionsToGroup(version: Double, connectionGroupId: Int64, deviceId: String? = nil, accountId: Int64? = nil, connectionIds: String? = nil, connectionAccountIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/connection/group/addConnections"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionIds = connectionIds { queryItems.append(URLQueryItem(name: "connectionIds", value: connectionIds)) } 
                if let connectionAccountIds = connectionAccountIds { queryItems.append(URLQueryItem(name: "connectionAccountIds", value: connectionAccountIds)) } 
                queryItems.append(URLQueryItem(name: "connectionGroupId", value: "\(connectionGroupId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Add Connection Groups
    /// - POST /api/{version}/consumer/connection/group/addSubGroup
    /// - Add sub groups to a group.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter groupId: (query) the parent group id 
    /// - parameter subGroupIds: (query) comma separated list of group IDs to add to the parent group 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<ConnectionGroupResponse, Error> 
    open func addSubGroups(version: Double, returnNulls: Bool, groupId: Int64, subGroupIds: String, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ConnectionGroupResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group/addSubGroup"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)"))
                queryItems.append(URLQueryItem(name: "subGroupIds", value: subGroupIds))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConnectionGroupResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ConnectionGroupResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create or Update Connection
    /// - POST /api/{version}/consumer/connection/add
    /// - Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionId: (query) the connection id for editing (optional)
    /// - parameter connectionAccountId: (query) the connection account id (i.e. the account id of another user) (optional)
    /// - parameter pendingId: (query) the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps) (optional)
    /// - parameter groupId: (query) optional group id if the user wants to add this person into a group (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter isTrusted: (query) determines whether the user is trusting this account (optional)
    /// - parameter ignoreFriendRequest: (query) determines whether the user has set to ignore the user&#39;s friend request (optional)
    /// - parameter isContact: (query) determines whether the user is a contact of this account (optional)
    /// - parameter isBlocked: (query) determines whether the user is blocking this account (optional)
    /// - parameter isFollowing: (query) determines whether the user is following this account (optional)
    /// - parameter connectionResponse: (query) whether to return the connection response or not (optional)
    /// - returns: AnyPublisher<ConnectionResponse, Error> 
    open func createOrUpdateConnection(version: Double, deviceId: String? = nil, accountId: Int64? = nil, connectionId: Int64? = nil, connectionAccountId: Int64? = nil, pendingId: Int64? = nil, groupId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, isTrusted: Bool? = nil, ignoreFriendRequest: Bool? = nil, isContact: Bool? = nil, isBlocked: Bool? = nil, isFollowing: Bool? = nil, connectionResponse: Bool? = nil) -> AnyPublisher<ConnectionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/add"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionId = connectionId { queryItems.append(URLQueryItem(name: "connectionId", value: "\(connectionId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let pendingId = pendingId { queryItems.append(URLQueryItem(name: "pendingId", value: "\(pendingId)")) } 
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let isTrusted = isTrusted { queryItems.append(URLQueryItem(name: "isTrusted", value: isTrusted ? "true" : "false")) } 
                if let ignoreFriendRequest = ignoreFriendRequest { queryItems.append(URLQueryItem(name: "ignoreFriendRequest", value: ignoreFriendRequest ? "true" : "false")) } 
                if let isContact = isContact { queryItems.append(URLQueryItem(name: "isContact", value: isContact ? "true" : "false")) } 
                if let isBlocked = isBlocked { queryItems.append(URLQueryItem(name: "isBlocked", value: isBlocked ? "true" : "false")) } 
                if let isFollowing = isFollowing { queryItems.append(URLQueryItem(name: "isFollowing", value: isFollowing ? "true" : "false")) } 
                if let connectionResponse = connectionResponse { queryItems.append(URLQueryItem(name: "connectionResponse", value: connectionResponse ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConnectionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ConnectionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create or Update Connection Group
    /// - POST /api/{version}/consumer/connection/group
    /// - Creates a new private group.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter name: (query) the name of the group (optional)
    /// - parameter groupId: (query) the group id to update a group (don&#39;t pass anything in if you want to create a new group) (optional)
    /// - parameter assetId: (query) the asset to attach to the group (optional)
    /// - parameter connections: (query) comma separated list of connection IDs (optional)
    /// - parameter description: (query) the description of the group (optional)
    /// - parameter canViewProfileInfo: (query) determines whether the connections in the group can see the user&#39;s profile info (optional)
    /// - parameter canViewGameInfo: (query) determines whether the connections in the group can see the user&#39;s game info (optional)
    /// - parameter canViewFriendInfo: (query) determines whether the connections in the group can see the user&#39;s friends/connections (optional)
    /// - parameter active: (query) Sets whether the connection group is active or inactive (optional)
    /// - parameter latitude: (query) the latitude of the group (optional)
    /// - parameter longitude: (query) the longitude of the group (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func createOrUpdateGroup(version: Double, returnNulls: Bool, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, groupId: Int64? = nil, assetId: Int64? = nil, connections: String? = nil, description: String? = nil, canViewProfileInfo: Bool? = nil, canViewGameInfo: Bool? = nil, canViewFriendInfo: Bool? = nil, active: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)")) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let connections = connections { queryItems.append(URLQueryItem(name: "connections", value: connections)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let canViewProfileInfo = canViewProfileInfo { queryItems.append(URLQueryItem(name: "canViewProfileInfo", value: canViewProfileInfo ? "true" : "false")) } 
                if let canViewGameInfo = canViewGameInfo { queryItems.append(URLQueryItem(name: "canViewGameInfo", value: canViewGameInfo ? "true" : "false")) } 
                if let canViewFriendInfo = canViewFriendInfo { queryItems.append(URLQueryItem(name: "canViewFriendInfo", value: canViewFriendInfo ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Accept Follow Request
    /// - POST /api/{version}/consumer/follow/accept
    /// - Accept someone's follow request.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter connectionAccountId: (query) the account ID of the user who initiated the follow 
    /// - parameter appKey: (query) the application key for sending notifications 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func followAccept(version: Double, accountId: Int64, connectionAccountId: Int64, appKey: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/follow/accept"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Reject Follow Request
    /// - POST /api/{version}/consumer/follow/reject
    /// - Reject someone's follow request or remove them as a follower.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter connectionAccountId: (query) the account ID of the user who initiated the follow 
    /// - parameter appKey: (query) the application key for sending notifications 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func followReject(version: Double, accountId: Int64, connectionAccountId: Int64, appKey: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/follow/reject"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Remove Follower / Unfollow
    /// - POST /api/{version}/consumer/follow/remove
    /// - Unfollow someone you are following or remove them as a follower.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter connectionAccountId: (query) the account ID of the user who you want to unfollow 
    /// - parameter appKey: (query) the application key for sending notifications 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func followRemove(version: Double, accountId: Int64, connectionAccountId: Int64, appKey: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/follow/remove"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Send Follow Request
    /// - POST /api/{version}/consumer/follow/request
    /// - Send a request to follow someone.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter connectionAccountId: (query) the account ID of the user who you want to follow 
    /// - parameter appKey: (query) the application key for sending notifications 
    /// - parameter approvalNeeded: (query) determines if the other user needs to confirm the follow request (optional, default to true)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func followRequest(version: Double, accountId: Int64, connectionAccountId: Int64, appKey: String, approvalNeeded: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/follow/request"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let approvalNeeded = approvalNeeded { queryItems.append(URLQueryItem(name: "approvalNeeded", value: approvalNeeded ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Accept Friend
    /// - POST /api/{version}/consumer/friend/accept
    /// - Accept a friend request and optionally sends a notification.
    /// - parameter version: (path)  
    /// - parameter friendAccountId: (query) the friend&#39;s account id 
    /// - parameter notifyFriend: (query) determines whether to send a notification to the afflicting party 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter notificationMessage: (query) optional message to send in a notification (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func friendAccept(version: Double, friendAccountId: Int64, notifyFriend: Bool, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, notificationMessage: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/friend/accept"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "friendAccountId", value: "\(friendAccountId)"))
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "notifyFriend", value: notifyFriend ? "true" : "false"))
                if let notificationMessage = notificationMessage { queryItems.append(URLQueryItem(name: "notificationMessage", value: notificationMessage)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Decline Friend
    /// - POST /api/{version}/consumer/friend/reject
    /// - Request a friend request and optionally sends a notification.
    /// - parameter version: (path)  
    /// - parameter friendAccountId: (query) the friend&#39;s account id 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter notifyFriend: (query) determines whether to send a notification to the afflicting party (optional)
    /// - parameter notificationMessage: (query) optional message to send in a notification (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func friendReject(version: Double, friendAccountId: Int64, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, notifyFriend: Bool? = nil, notificationMessage: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/friend/reject"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "friendAccountId", value: "\(friendAccountId)"))
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let notifyFriend = notifyFriend { queryItems.append(URLQueryItem(name: "notifyFriend", value: notifyFriend ? "true" : "false")) } 
                if let notificationMessage = notificationMessage { queryItems.append(URLQueryItem(name: "notificationMessage", value: notificationMessage)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Friend
    /// - POST /api/{version}/consumer/friend/remove
    /// - Removes a friend from the user's friends list.
    /// - parameter version: (path)  
    /// - parameter friendAccountId: (query) the account ID of the friend to remove 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter notifyFriend: (query) optionally notifies the connection that they have been removed as a friend (optional)
    /// - parameter removeFromGroups: (query) optionally removes the connection from the user&#39;s groups (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func friendRemove(version: Double, friendAccountId: Int64, deviceId: String? = nil, accountId: Int64? = nil, notifyFriend: Bool? = nil, removeFromGroups: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/friend/remove"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "friendAccountId", value: "\(friendAccountId)"))
                if let notifyFriend = notifyFriend { queryItems.append(URLQueryItem(name: "notifyFriend", value: notifyFriend ? "true" : "false")) } 
                if let removeFromGroups = removeFromGroups { queryItems.append(URLQueryItem(name: "removeFromGroups", value: removeFromGroups ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Request Friend
    /// - POST /api/{version}/consumer/friend/request
    /// - Sends a friend request notification to another user.
    /// - parameter version: (path)  
    /// - parameter friendAccountId: (query) the friend&#39;s account id 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter notificationMessage: (query) optional message to send in a notification (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func friendRequest(version: Double, friendAccountId: Int64, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, notificationMessage: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/friend/request"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "friendAccountId", value: "\(friendAccountId)"))
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let notificationMessage = notificationMessage { queryItems.append(URLQueryItem(name: "notificationMessage", value: notificationMessage)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Sent Friend Requests
    /// - GET /api/{version}/consumer/connection/getRequested
    /// - Gets the connection sent friend requests.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the ID of the device (optional)
    /// - parameter accountId: (query) the id of the account (optional)
    /// - returns: AnyPublisher<ConnectionListResponse, Error> 
    open func getConnectionSentFriendRequests(version: Double, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<ConnectionListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/getRequested"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConnectionListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ConnectionListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Connections
    /// - GET /api/{version}/consumer/connection/get
    /// - Gets the connections.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter filter: (query) a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following) 
    /// - parameter sortField: (query) sorts the response list by ConnectionApiMap 
    /// - parameter descending: (query) sorts the response list by descending order if true 
    /// - parameter start: (query) start index of the pagination 
    /// - parameter limit: (query) limit of the pagination 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id (deviceId or accountId required) (optional)
    /// - parameter connectionAccountId: (query) optional parameter to search on other account&#39;s connections (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) an optional keyword to search on, this parameter is ignored if empty (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<ConnectionListResponse, Error> 
    open func getConnections(version: Double, returnNulls: Bool, filter: String, sortField: String, descending: Bool, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountId: Int64? = nil, q: String? = nil, keyword: String? = nil, i: Int? = nil, l: Int? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ConnectionListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                queryItems.append(URLQueryItem(name: "filter", value: filter))
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConnectionListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ConnectionListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Connection Group
    /// - GET /api/{version}/consumer/connection/group/details/get
    /// - parameter version: (path)  
    /// - parameter combineConnections: (query) whether to combine connections or not 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter groupId: (query) the group id (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<ConnectionGroupResponse, Error> 
    open func getGroupDetails(version: Double, combineConnections: Bool, deviceId: String? = nil, accountId: Int64? = nil, groupId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ConnectionGroupResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group/details/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let groupId = groupId { queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)")) } 
                queryItems.append(URLQueryItem(name: "combineConnections", value: combineConnections ? "true" : "false"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConnectionGroupResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ConnectionGroupResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum GroupSearchSortField: String, Codable, CaseIterable {
        case created = "CREATED"
        case updated = "UPDATED"
        case active = "ACTIVE"
        case name = "NAME"
        case description = "DESCRIPTION"
        case canViewProfileInfo = "CAN_VIEW_PROFILE_INFO"
        case canViewGameInfo = "CAN_VIEW_GAME_INFO"
        case canViewFriendInfo = "CAN_VIEW_FRIEND_INFO"
        case inviteCode = "INVITE_CODE"
        case ownerDisplay = "OWNER_DISPLAY"
        case ownerUsername = "OWNER_USERNAME"
    }

    /// Search Connection Groups
    /// - GET /api/{version}/connection/group/search
    /// - Gets a user's private groups and default groups.
    /// - parameter version: (path)  
    /// - parameter sortField: (query) the field to sort by 
    /// - parameter descending: (query) whether to return results in descending or ascending order 
    /// - parameter activeOnly: (query) to search on active only or not 
    /// - parameter start: (query) The start of the pagination 
    /// - parameter limit: (query) the limit of the pagination 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - parameter keyword: (query) keyword search string (optional)
    /// - returns: AnyPublisher<[ConnectionInfoResponse], Error> 
    open func groupSearch(version: Double, sortField: GroupSearchSortField, descending: Bool, activeOnly: Bool, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil, keyword: String? = nil) -> AnyPublisher<[ConnectionInfoResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/connection/group/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ConnectionInfoResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ConnectionInfoResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Connection
    /// - POST /api/{version}/consumer/connection/group/removeConnection
    /// - Removes the connection from group.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter groupId: (query) the group id 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionId: (query) the connection id (optional)
    /// - parameter connectionAccountId: (query) the connection account id (optional)
    /// - parameter pendingId: (query) the pending id (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removeConnectionFromGroup(version: Double, returnNulls: Bool, groupId: Int64, deviceId: String? = nil, accountId: Int64? = nil, connectionId: Int64? = nil, connectionAccountId: Int64? = nil, pendingId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group/removeConnection"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionId = connectionId { queryItems.append(URLQueryItem(name: "connectionId", value: "\(connectionId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let pendingId = pendingId { queryItems.append(URLQueryItem(name: "pendingId", value: "\(pendingId)")) } 
                queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Remove Connections
    /// - POST /api/{version}/connection/group/removeConnections
    /// - Remove a list of connections from a group.
    /// - parameter version: (path)  
    /// - parameter connectionGroupId: (query) connection group id 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionIds: (query) comma separated list of connection ids (optional)
    /// - parameter connectionAccountIds: (query) comma separated list of connection account ids (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removeConnectionsFromGroup(version: Double, connectionGroupId: Int64, deviceId: String? = nil, accountId: Int64? = nil, connectionIds: String? = nil, connectionAccountIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/connection/group/removeConnections"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionIds = connectionIds { queryItems.append(URLQueryItem(name: "connectionIds", value: connectionIds)) } 
                if let connectionAccountIds = connectionAccountIds { queryItems.append(URLQueryItem(name: "connectionAccountIds", value: connectionAccountIds)) } 
                queryItems.append(URLQueryItem(name: "connectionGroupId", value: "\(connectionGroupId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Connection Group
    /// - POST /api/{version}/consumer/connection/group/remove
    /// - Remove a user's group.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter groupId: (query) the group id 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removeGroup(version: Double, returnNulls: Bool, groupId: Int64, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group/remove"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Remove Connection Groups
    /// - POST /api/{version}/consumer/connection/group/removeSubGroup
    /// - Remove sub groups from a group
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) whether to return nulls or not 
    /// - parameter groupId: (query) the parent group id 
    /// - parameter subGroupIds: (query) comma separated list of group IDs to remove from the parent group 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removeSubGroups(version: Double, returnNulls: Bool, groupId: Int64, subGroupIds: String, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/connection/group/removeSubGroup"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "groupId", value: "\(groupId)"))
                queryItems.append(URLQueryItem(name: "subGroupIds", value: subGroupIds))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Possible Connections
    /// - GET /api/{version}/connection/search
    /// - Search for accounts that the user may not have a connection with.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) return all json attributes if true. defualt is true. 
    /// - parameter start: (query) start index of the pagination 
    /// - parameter limit: (query) limit of the pagination 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id (deviceId or accountId required) (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) keyword to search on, optional and this parameter is ignored if empt (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the public application key, if provided only looks for users of that application (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter sortField: (query) the field to sort on (optional)
    /// - parameter hasLocation: (query) whether the search has location or not (optional)
    /// - returns: AnyPublisher<ConnectionListResponse, Error> 
    open func searchConnections(version: Double, returnNulls: Bool, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, q: String? = nil, keyword: String? = nil, latitude: Double? = nil, longitude: Double? = nil, gameType: String? = nil, appKey: String? = nil, i: Int? = nil, l: Int? = nil, sortField: String? = nil, hasLocation: Bool? = nil) -> AnyPublisher<ConnectionListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/connection/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let hasLocation = hasLocation { queryItems.append(URLQueryItem(name: "hasLocation", value: hasLocation ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ConnectionListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ConnectionListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
