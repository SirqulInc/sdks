//
// GameLevelAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class GameLevelAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Game Level
    /// - POST /level/create
    /// - Create a game level. Currently does NOT support game objects.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter name: (query) The name of the level. 
    /// - parameter gameData: (query) The game level data: xml, json, or other text based format. 
    /// - parameter gameDataSuffix: (query) The game level data format type. 
    /// - parameter appKey: (query) The game application key to save the level for. (optional)
    /// - parameter description: (query) The description of the level. (optional)
    /// - parameter difficulty: (query) The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
    /// - parameter appVersion: (query) The version number of the application required to correctly load/play the level. (optional)
    /// - parameter assetImageId: (query) The asset Id of the level image. (optional)
    /// - parameter assetIconId: (query) The asset Id of the level icon. (optional)
    /// - parameter visibility: (query) Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
    /// - parameter friendGroup: (query) Make the level be readable by all friends. (optional)
    /// - parameter connectionIds: (query) Make the level be readable by connections in this list. (optional)
    /// - parameter connectionGroupIds: (query) Make the level be readable by connection groups in this list. (optional)
    /// - parameter balance: (query) Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
    /// - parameter active: (query) If true set the game level as active. Default is false. (optional)
    /// - parameter allocateTickets: (query) If true then scoring will give tickets. Default is false. (optional)
    /// - parameter ticketCount: (query) The number of tickets to reward (optional)
    /// - parameter ticketType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter points: (query) The number of points to award for completing a level (optional)
    /// - parameter tutorialTitle: (query) Title of the tutorial. (optional)
    /// - parameter tutorialMessage: (query) Message of the tutotrial. (optional)
    /// - parameter tutorialAlignment: (query) Alignment of the tutorial image. Default to NONE. Possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
    /// - parameter tutorialImageAssetId: (query) Asset id of the tutorial image. (optional)
    /// - parameter offerId: (query) id of the offer (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - returns: AnyPublisher<GameLevelResponse, Error> 
    open func createGameLevel(accountId: Int64, name: String, gameData: String, gameDataSuffix: String, appKey: String? = nil, description: String? = nil, difficulty: String? = nil, appVersion: String? = nil, assetImageId: Int64? = nil, assetIconId: Int64? = nil, visibility: String? = nil, friendGroup: Bool? = nil, connectionIds: String? = nil, connectionGroupIds: String? = nil, balance: Double? = nil, active: Bool? = nil, allocateTickets: Bool? = nil, ticketCount: Int64? = nil, ticketType: String? = nil, points: Int64? = nil, tutorialTitle: String? = nil, tutorialMessage: String? = nil, tutorialAlignment: String? = nil, tutorialImageAssetId: Int64? = nil, offerId: Int64? = nil, metaData: String? = nil) -> AnyPublisher<GameLevelResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let difficulty = difficulty { queryItems.append(URLQueryItem(name: "difficulty", value: difficulty)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let assetImageId = assetImageId { queryItems.append(URLQueryItem(name: "assetImageId", value: "\(assetImageId)")) } 
                if let assetIconId = assetIconId { queryItems.append(URLQueryItem(name: "assetIconId", value: "\(assetIconId)")) } 
                queryItems.append(URLQueryItem(name: "gameData", value: gameData))
                queryItems.append(URLQueryItem(name: "gameDataSuffix", value: gameDataSuffix))
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility)) } 
                if let friendGroup = friendGroup { queryItems.append(URLQueryItem(name: "friendGroup", value: friendGroup ? "true" : "false")) } 
                if let connectionIds = connectionIds { queryItems.append(URLQueryItem(name: "connectionIds", value: connectionIds)) } 
                if let connectionGroupIds = connectionGroupIds { queryItems.append(URLQueryItem(name: "connectionGroupIds", value: connectionGroupIds)) } 
                if let balance = balance { queryItems.append(URLQueryItem(name: "balance", value: "\(balance)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let allocateTickets = allocateTickets { queryItems.append(URLQueryItem(name: "allocateTickets", value: allocateTickets ? "true" : "false")) } 
                if let ticketCount = ticketCount { queryItems.append(URLQueryItem(name: "ticketCount", value: "\(ticketCount)")) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                if let points = points { queryItems.append(URLQueryItem(name: "points", value: "\(points)")) } 
                if let tutorialTitle = tutorialTitle { queryItems.append(URLQueryItem(name: "tutorialTitle", value: tutorialTitle)) } 
                if let tutorialMessage = tutorialMessage { queryItems.append(URLQueryItem(name: "tutorialMessage", value: tutorialMessage)) } 
                if let tutorialAlignment = tutorialAlignment { queryItems.append(URLQueryItem(name: "tutorialAlignment", value: tutorialAlignment)) } 
                if let tutorialImageAssetId = tutorialImageAssetId { queryItems.append(URLQueryItem(name: "tutorialImageAssetId", value: "\(tutorialImageAssetId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GameLevelResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GameLevelResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Game Level
    /// - POST /level/delete
    /// - Delete a game level. The level and account must be valid and have the appropirate permissions to view the content.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter levelId: (query) The id of the level to return. 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteGameLevel(accountId: Int64, levelId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Game Level
    /// - GET /level/get
    /// - Get a game level. The level and account must be valid and have the appropirate permissions to view the content.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter levelId: (query) The id of the level to return. 
    /// - parameter includeGameData: (query) If true include the game level data, otherwise don&#39;t. default is false. (optional)
    /// - returns: AnyPublisher<GameLevelResponse, Error> 
    open func getGameLevel(accountId: Int64, levelId: Int64, includeGameData: Bool? = nil) -> AnyPublisher<GameLevelResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GameLevelResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GameLevelResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Game Levels
    /// - GET /level/search
    /// - Get a list of levels for an application, just those the account has permissions to view.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) the application key 
    /// - parameter keyword: (query) Match the keyword to the owner name or level name. (optional)
    /// - parameter sortField: (query) what field to sort on (optional)
    /// - parameter descending: (query) whether to return levels in ascending or descending order (optional)
    /// - parameter start: (query) Start the result set at some index. (optional)
    /// - parameter limit: (query) Limit the result to some number. (optional)
    /// - parameter appVersion: (query) The maximum version of the level to return. (optional)
    /// - parameter includeGameData: (query) If true include the game level data, otherwise don&#39;t. default is false. (optional)
    /// - parameter filters: (query)  (optional)
    /// - returns: AnyPublisher<GameLevelListResponse, Error> 
    open func getGameLevelsByApplication(accountId: Int64, appKey: String, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, appVersion: String? = nil, includeGameData: Bool? = nil, filters: String? = nil) -> AnyPublisher<GameLevelListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                if let filters = filters { queryItems.append(URLQueryItem(name: "filters", value: filters)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GameLevelListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GameLevelListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum GetGameLevelsByBillableEntitySortField: String, Codable, CaseIterable {
        case levelActive = "LEVEL_ACTIVE"
        case levelName = "LEVEL_NAME"
        case levelDescription = "LEVEL_DESCRIPTION"
        case levelCreated = "LEVEL_CREATED"
        case levelUpdated = "LEVEL_UPDATED"
        case levelLikes = "LEVEL_LIKES"
        case levelDislikes = "LEVEL_DISLIKES"
        case levelNotes = "LEVEL_NOTES"
        case levelPlays = "LEVEL_PLAYS"
        case levelDownloads = "LEVEL_DOWNLOADS"
        case levelQuits = "LEVEL_QUITS"
        case levelCompletes = "LEVEL_COMPLETES"
        case levelVersion = "LEVEL_VERSION"
        case levelMissionType = "LEVEL_MISSION_TYPE"
        case levelOwnerDisplay = "LEVEL_OWNER_DISPLAY"
        case gameOwnerDisplay = "GAME_OWNER_DISPLAY"
        case gameTitle = "GAME_TITLE"
        case gameDescription = "GAME_DESCRIPTION"
        case gameLikes = "GAME_LIKES"
        case gameDislikes = "GAME_DISLIKES"
        case appName = "APP_NAME"
        case appScoringType = "APP_SCORING_TYPE"
    }

    /// Search Game Level by Billable Entity
    /// - GET /level/searchByBillableEntity
    /// - Searches on game levels that the logged in user has access to. A user would have access if the creator of the game level is managed under the same BillableEntity.
    /// - parameter accountId: (query) The account id of the user 
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter sortField: (query) The column to sort the search on (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter activeOnly: (query) Return only active results (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - returns: AnyPublisher<GameLevelResponse, Error> 
    open func getGameLevelsByBillableEntity(accountId: Int64, appKey: String? = nil, keyword: String? = nil, sortField: GetGameLevelsByBillableEntitySortField? = nil, descending: Bool? = nil, activeOnly: Bool? = nil, start: Int64? = nil, limit: Int64? = nil) -> AnyPublisher<GameLevelResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/searchByBillableEntity"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GameLevelResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GameLevelResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Level Questions
    /// - GET /level/questions/get
    /// - Get questions within a level.
    /// - parameter levelId: (query) the id of the level to get questions from 
    /// - parameter accountId: (query) the id of the logged in user 
    /// - returns: AnyPublisher<QuestionResponse, Error> 
    open func getQuestionsInLevel(levelId: Int64, accountId: Int64) -> AnyPublisher<QuestionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/questions/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QuestionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QuestionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Level Words
    /// - GET /level/words/get
    /// - Get words within a level.
    /// - parameter levelId: (query) the id of the level to get words for 
    /// - parameter accountId: (query) the id of the logged in user 
    /// - returns: AnyPublisher<WordzWordResponse, Error> 
    open func getWordsInLevel(levelId: Int64, accountId: Int64) -> AnyPublisher<WordzWordResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/words/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WordzWordResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(WordzWordResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Game Level
    /// - POST /level/update
    /// - Update a game level. Currently does NOT support game objects.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter levelId: (query) If update then include the level Id. 
    /// - parameter appKey: (query) The game application key to save the level for. (optional)
    /// - parameter name: (query) The name of the level. (optional)
    /// - parameter description: (query) The description of the level. (optional)
    /// - parameter difficulty: (query) The difficulty, possible values are: VERY_EASY, EASY, MEDIUM, HARD, VERY_HARD. (optional)
    /// - parameter appVersion: (query) The version number of the applicatuion required to correctly load/play the level. (optional)
    /// - parameter assetImageId: (query) The asset Id of the level image. (optional)
    /// - parameter assetIconId: (query) The asset Id of the level icon. (optional)
    /// - parameter gameData: (query) The game level data: xml, json, or other texted based format. (optional)
    /// - parameter gameDataSuffix: (query) The game level data format type. (optional)
    /// - parameter visibility: (query) Is the level visible to others, possible values are: PUBLIC, PRIVATE. (optional)
    /// - parameter friendGroup: (query) Make the level be readable by all friends. (optional)
    /// - parameter connectionIds: (query) Make the level be readable by connections in this list. (optional)
    /// - parameter connectionGroupIds: (query) Make the level be readable by connection groups in this list. (optional)
    /// - parameter balance: (query) Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
    /// - parameter active: (query) If true set the game level as active. (optional)
    /// - parameter allocateTickets: (query) If true then scoring will give tickets. (optional)
    /// - parameter ticketCount: (query) The number of tickets to reward (optional)
    /// - parameter ticketType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter points: (query) The number of points to award for completing a level (optional)
    /// - parameter tutorialTitle: (query) Title of the tutorial. (optional)
    /// - parameter tutorialMessage: (query) Message of the tutorial. (optional)
    /// - parameter tutorialAlignment: (query) Alignment of the tutorial image, possible values are: NONE, IMAGE_ABOVE, IMAGE_BELOW, IMAGE_LEFT, IMAGE_RIGHT, IMAGE_ONLY, TEXT_ONLY (optional)
    /// - parameter tutorialImageAssetId: (query) Asset id of the tutorial image. (optional)
    /// - parameter offerId: (query)  (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - returns: AnyPublisher<GameLevelResponse, Error> 
    open func updateGameLevel(accountId: Int64, levelId: Int64, appKey: String? = nil, name: String? = nil, description: String? = nil, difficulty: String? = nil, appVersion: String? = nil, assetImageId: Int64? = nil, assetIconId: Int64? = nil, gameData: String? = nil, gameDataSuffix: String? = nil, visibility: String? = nil, friendGroup: Bool? = nil, connectionIds: String? = nil, connectionGroupIds: String? = nil, balance: Double? = nil, active: Bool? = nil, allocateTickets: Bool? = nil, ticketCount: Int64? = nil, ticketType: String? = nil, points: Int64? = nil, tutorialTitle: String? = nil, tutorialMessage: String? = nil, tutorialAlignment: String? = nil, tutorialImageAssetId: Int64? = nil, offerId: Int64? = nil, metaData: String? = nil) -> AnyPublisher<GameLevelResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let difficulty = difficulty { queryItems.append(URLQueryItem(name: "difficulty", value: difficulty)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let assetImageId = assetImageId { queryItems.append(URLQueryItem(name: "assetImageId", value: "\(assetImageId)")) } 
                if let assetIconId = assetIconId { queryItems.append(URLQueryItem(name: "assetIconId", value: "\(assetIconId)")) } 
                if let gameData = gameData { queryItems.append(URLQueryItem(name: "gameData", value: gameData)) } 
                if let gameDataSuffix = gameDataSuffix { queryItems.append(URLQueryItem(name: "gameDataSuffix", value: gameDataSuffix)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility)) } 
                if let friendGroup = friendGroup { queryItems.append(URLQueryItem(name: "friendGroup", value: friendGroup ? "true" : "false")) } 
                if let connectionIds = connectionIds { queryItems.append(URLQueryItem(name: "connectionIds", value: connectionIds)) } 
                if let connectionGroupIds = connectionGroupIds { queryItems.append(URLQueryItem(name: "connectionGroupIds", value: connectionGroupIds)) } 
                if let balance = balance { queryItems.append(URLQueryItem(name: "balance", value: "\(balance)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let allocateTickets = allocateTickets { queryItems.append(URLQueryItem(name: "allocateTickets", value: allocateTickets ? "true" : "false")) } 
                if let ticketCount = ticketCount { queryItems.append(URLQueryItem(name: "ticketCount", value: "\(ticketCount)")) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                if let points = points { queryItems.append(URLQueryItem(name: "points", value: "\(points)")) } 
                if let tutorialTitle = tutorialTitle { queryItems.append(URLQueryItem(name: "tutorialTitle", value: tutorialTitle)) } 
                if let tutorialMessage = tutorialMessage { queryItems.append(URLQueryItem(name: "tutorialMessage", value: tutorialMessage)) } 
                if let tutorialAlignment = tutorialAlignment { queryItems.append(URLQueryItem(name: "tutorialAlignment", value: tutorialAlignment)) } 
                if let tutorialImageAssetId = tutorialImageAssetId { queryItems.append(URLQueryItem(name: "tutorialImageAssetId", value: "\(tutorialImageAssetId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<GameLevelResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(GameLevelResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Level Questions
    /// - POST /level/questions/update
    /// - Updates a level with question game objects.
    /// - parameter levelId: (query) the id of the level to update questions on 
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter questionIds: (query) the IDs of the questions to update 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateQuestionsInLevel(levelId: Int64, accountId: Int64, questionIds: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/questions/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "questionIds", value: questionIds))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Level Words
    /// - POST /level/words/update
    /// - Updates a level with word game objects.
    /// - parameter levelId: (query) the id of the level to update words for 
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter wordIds: (query) the ids of the words to update for the level 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateWordsInLevel(levelId: Int64, accountId: Int64, wordIds: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/level/words/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "levelId", value: "\(levelId)"))
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "wordIds", value: wordIds))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
