//
// TournamentAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class TournamentAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter splitReward
    ///
    public enum CreateTournamentSplitReward: String, Codable, CaseIterable {
        case even = "EVEN"
        case all = "ALL"
        case first = "FIRST"
        case random = "RANDOM"
    }
    ///
    /// Enum for parameter missionType
    ///
    public enum CreateTournamentMissionType: String, Codable, CaseIterable {
        case tournament = "TOURNAMENT"
        case poolplay = "POOLPLAY"
        case multistage = "MULTISTAGE"
    }
    ///
    /// Enum for parameter visibility
    ///
    public enum CreateTournamentVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }

    /// Create Tournament
    /// - POST /api/{version}/tournament/create
    /// - Create a tournament.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) The appKey the tournament is created for. 
    /// - parameter title: (query) The title of the tournament 
    /// - parameter costToPlay: (query) The number of tickets required to pay to enter the tournament 
    /// - parameter startDate: (query) The date/time to start the tournament 
    /// - parameter subType: (query) Custom string client apps can use for searching/filtering tournaments (optional)
    /// - parameter imageAssetId: (query) The asset ID to attach to the tournament (optional)
    /// - parameter secondsBetweenLevels: (query) The number of seconds in between the start of each tournament game/group (optional, default to 600)
    /// - parameter secondsForTieBreaker: (query) The number of seconds to extend the round end time in the case of a tie breaker (optional, default to 600)
    /// - parameter secondsBetweenPacks: (query) The number of seconds in between the start of each tournament round (optional, default to 86400)
    /// - parameter maximumLevelLength: (query) The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional, default to 1800)
    /// - parameter costToPlayType: (query) The type of ticket required to pay (optional)
    /// - parameter minimumToPlay: (query) The minimum number of players required to sign up for the tournament to be played (optional, default to 1)
    /// - parameter startingLimit: (query) The starting number of players for a tournament (filled with AI&#39;s) (optional)
    /// - parameter availableLimit: (query) The maximum number of players for a tournament (currently 128 but not enforced) (optional)
    /// - parameter description: (query) The description of the tournament (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter audienceIds: (query) The audiences associated with the tournament (optional)
    /// - parameter active: (query) Activate/deactivate the tournament (optional)
    /// - parameter enableBuyBack: (query) Determines whether to allow players to buy back into a tournament (optional, default to false)
    /// - parameter offerIds: (query) The list of offers to give as a reward beyond the tickets (optional)
    /// - parameter offerAssetId: (query) The artwork ID to attach to the reward tickets offers (optional)
    /// - parameter fixedReward: (query) If set then do not update the ticket reward, auto set to true if offerIds provided (optional, default to false)
    /// - parameter splitReward: (query) Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional, default to .all)
    /// - parameter allocateTickets: (query) Flag to indicate owner should receive tickets for completed missions (optional)
    /// - parameter tournamentData: (query) A text based string that will be passed into each tournament setup to populate the content (optional)
    /// - parameter missionType: (query) The style of tournament to build, options are: TOURNAMENT, POOLPLAY (optional, default to .multistage)
    /// - parameter visibility: (query) Sets the visibility flag for the tournament (optional, default to ._public)
    /// - parameter preliminaryGroups: (query) The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional, default to 1)
    /// - parameter preliminaryGroupAdvancements: (query) This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional, default to "1")
    /// - parameter enableMultipleEntries: (query) This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional, default to false)
    /// - parameter enableMultipleVotes: (query) This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional, default to false)
    /// - parameter featured: (query) This determines whether the tournament is \&quot;featured\&quot; or not (optional, default to false)
    /// - parameter winnerTag: (query) This sets what analytic tag is used when a winner is determined (optional)
    /// - parameter tieTag: (query) This sets what analytic tag is used when a tie has occurred (optional)
    /// - returns: AnyPublisher<TournamentResponse, Error> 
    open func createTournament(version: Double, accountId: Int64, appKey: String, title: String, costToPlay: Int, startDate: Int64, subType: String? = nil, imageAssetId: Int64? = nil, secondsBetweenLevels: Int? = nil, secondsForTieBreaker: Int? = nil, secondsBetweenPacks: Int? = nil, maximumLevelLength: Int? = nil, costToPlayType: String? = nil, minimumToPlay: Int? = nil, startingLimit: Int? = nil, availableLimit: Int? = nil, description: String? = nil, metaData: String? = nil, audienceIds: String? = nil, active: Bool? = nil, enableBuyBack: Bool? = nil, offerIds: String? = nil, offerAssetId: Int64? = nil, fixedReward: Bool? = nil, splitReward: CreateTournamentSplitReward? = nil, allocateTickets: Bool? = nil, tournamentData: String? = nil, missionType: CreateTournamentMissionType? = nil, visibility: CreateTournamentVisibility? = nil, preliminaryGroups: Int? = nil, preliminaryGroupAdvancements: String? = nil, enableMultipleEntries: Bool? = nil, enableMultipleVotes: Bool? = nil, featured: Bool? = nil, winnerTag: String? = nil, tieTag: String? = nil) -> AnyPublisher<TournamentResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "title", value: title))
                if let subType = subType { queryItems.append(URLQueryItem(name: "subType", value: subType)) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let secondsBetweenLevels = secondsBetweenLevels { queryItems.append(URLQueryItem(name: "secondsBetweenLevels", value: "\(secondsBetweenLevels)")) } 
                if let secondsForTieBreaker = secondsForTieBreaker { queryItems.append(URLQueryItem(name: "secondsForTieBreaker", value: "\(secondsForTieBreaker)")) } 
                if let secondsBetweenPacks = secondsBetweenPacks { queryItems.append(URLQueryItem(name: "secondsBetweenPacks", value: "\(secondsBetweenPacks)")) } 
                if let maximumLevelLength = maximumLevelLength { queryItems.append(URLQueryItem(name: "maximumLevelLength", value: "\(maximumLevelLength)")) } 
                queryItems.append(URLQueryItem(name: "costToPlay", value: "\(costToPlay)"))
                if let costToPlayType = costToPlayType { queryItems.append(URLQueryItem(name: "costToPlayType", value: costToPlayType)) } 
                if let minimumToPlay = minimumToPlay { queryItems.append(URLQueryItem(name: "minimumToPlay", value: "\(minimumToPlay)")) } 
                if let startingLimit = startingLimit { queryItems.append(URLQueryItem(name: "startingLimit", value: "\(startingLimit)")) } 
                if let availableLimit = availableLimit { queryItems.append(URLQueryItem(name: "availableLimit", value: "\(availableLimit)")) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)"))
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let enableBuyBack = enableBuyBack { queryItems.append(URLQueryItem(name: "enableBuyBack", value: enableBuyBack ? "true" : "false")) } 
                if let offerIds = offerIds { queryItems.append(URLQueryItem(name: "offerIds", value: offerIds)) } 
                if let offerAssetId = offerAssetId { queryItems.append(URLQueryItem(name: "offerAssetId", value: "\(offerAssetId)")) } 
                if let fixedReward = fixedReward { queryItems.append(URLQueryItem(name: "fixedReward", value: fixedReward ? "true" : "false")) } 
                if let splitReward = splitReward { queryItems.append(URLQueryItem(name: "splitReward", value: splitReward.rawValue)) } 
                if let allocateTickets = allocateTickets { queryItems.append(URLQueryItem(name: "allocateTickets", value: allocateTickets ? "true" : "false")) } 
                if let tournamentData = tournamentData { queryItems.append(URLQueryItem(name: "tournamentData", value: tournamentData)) } 
                if let missionType = missionType { queryItems.append(URLQueryItem(name: "missionType", value: missionType.rawValue)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let preliminaryGroups = preliminaryGroups { queryItems.append(URLQueryItem(name: "preliminaryGroups", value: "\(preliminaryGroups)")) } 
                if let preliminaryGroupAdvancements = preliminaryGroupAdvancements { queryItems.append(URLQueryItem(name: "preliminaryGroupAdvancements", value: preliminaryGroupAdvancements)) } 
                if let enableMultipleEntries = enableMultipleEntries { queryItems.append(URLQueryItem(name: "enableMultipleEntries", value: enableMultipleEntries ? "true" : "false")) } 
                if let enableMultipleVotes = enableMultipleVotes { queryItems.append(URLQueryItem(name: "enableMultipleVotes", value: enableMultipleVotes ? "true" : "false")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                if let winnerTag = winnerTag { queryItems.append(URLQueryItem(name: "winnerTag", value: winnerTag)) } 
                if let tieTag = tieTag { queryItems.append(URLQueryItem(name: "tieTag", value: tieTag)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TournamentResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(TournamentResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Tournament
    /// - POST /api/{version}/tournament/delete
    /// - Delete a tournament.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter missionId: (query) the id of the mission to delete 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteTournament(version: Double, accountId: Int64, missionId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter includeScores
    ///
    public enum GetTournamentIncludeScores: String, Codable, CaseIterable {
        case all = "ALL"
        case mine = "MINE"
    }

    /// Get Tournament
    /// - GET /api/{version}/tournament/get
    /// - Get a tournament.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The id of the logged in user 
    /// - parameter missionId: (query) The id of the mission to return (either missionId or joinCode is required) (optional)
    /// - parameter joinCode: (query) Optional identifier for getting the tournament (either missionId or joinCode is required) (optional)
    /// - parameter includeScores: (query) Determines which type of scores are returned. Possible values include: ALL, MINE (optional)
    /// - parameter objectPreviewSize: (query) Determines the max number of game objects that will get returned for each game level response (optional, default to 50)
    /// - returns: AnyPublisher<TournamentResponse, Error> 
    open func getTournament(version: Double, accountId: Int64, missionId: Int64? = nil, joinCode: String? = nil, includeScores: GetTournamentIncludeScores? = nil, objectPreviewSize: Int? = nil) -> AnyPublisher<TournamentResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let joinCode = joinCode { queryItems.append(URLQueryItem(name: "joinCode", value: joinCode)) } 
                if let includeScores = includeScores { queryItems.append(URLQueryItem(name: "includeScores", value: includeScores.rawValue)) } 
                if let objectPreviewSize = objectPreviewSize { queryItems.append(URLQueryItem(name: "objectPreviewSize", value: "\(objectPreviewSize)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TournamentResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(TournamentResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchObjectsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case playerScoreCount = "PLAYER_SCORE_COUNT"
    }

    /// Search Tournament Objects
    /// - GET /api/{version}/tournament/object/search
    /// - Search on game objects of tournaments
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account ID 
    /// - parameter gameLevelId: (query) the game level id to filter results by 
    /// - parameter sortField: (query) the field to sort by (optional, default to .playerScoreCount)
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order (optional, default to true)
    /// - parameter start: (query) the start index for pagination (optional, default to 0)
    /// - parameter limit: (query) the limit for pagination (optional, default to 20)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func searchObjects(version: Double, accountId: Int64, gameLevelId: Int64, sortField: SearchObjectsSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/object/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)"))
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter missionType
    ///
    public enum SearchRoundsMissionType: String, Codable, CaseIterable {
        case tournament = "TOURNAMENT"
        case poolplay = "POOLPLAY"
    }

    /// Search Tournament Rounds
    /// - GET /api/{version}/tournament/round/search
    /// - Search for the user's tournament games.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account ID 
    /// - parameter appKey: (query) the application key 
    /// - parameter status: (query) comma separated list of statuses to filter results by (optional, default to "ACCEPTED,ACTIVE")
    /// - parameter missionType: (query) The style of tournament to search for, options are: TOURNAMENT, POOLPLAY (optional)
    /// - parameter currentOnly: (query) search for games that are flagged current only (optional, default to true)
    /// - parameter visibilities: (query) Filter tournament rounds by the mission visibility flag (optional, default to "PUBLIC")
    /// - parameter start: (query) the start index for pagination (optional, default to 0)
    /// - parameter limit: (query) the limit for pagination (optional, default to 20)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func searchRounds(version: Double, accountId: Int64, appKey: String, status: String? = nil, missionType: SearchRoundsMissionType? = nil, currentOnly: Bool? = nil, visibilities: String? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/round/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: status)) } 
                if let missionType = missionType { queryItems.append(URLQueryItem(name: "missionType", value: missionType.rawValue)) } 
                if let currentOnly = currentOnly { queryItems.append(URLQueryItem(name: "currentOnly", value: currentOnly ? "true" : "false")) } 
                if let visibilities = visibilities { queryItems.append(URLQueryItem(name: "visibilities", value: visibilities)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter filter
    ///
    public enum SearchTournamentsFilter: String, Codable, CaseIterable {
        case all = "ALL"
        case upcoming = "UPCOMING"
        case past = "PAST"
        case present = "PRESENT"
        case active = "ACTIVE"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum SearchTournamentsSortField: String, Codable, CaseIterable {
        case active = "ACTIVE"
        case title = "TITLE"
        case description = "DESCRIPTION"
        case created = "CREATED"
        case updated = "UPDATED"
        case missionType = "MISSION_TYPE"
        case ownerDisplay = "OWNER_DISPLAY"
        case startDate = "START_DATE"
        case endDate = "END_DATE"
        case startingLimit = "STARTING_LIMIT"
        case availableLimit = "AVAILABLE_LIMIT"
        case inviteCount = "INVITE_COUNT"
        case acceptedCount = "ACCEPTED_COUNT"
    }

    /// Search Tournaments
    /// - GET /api/{version}/tournament/search
    /// - Search for tournaments
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) The application key 
    /// - parameter keyword: (query) the keyword to search tournament on (optional)
    /// - parameter subType: (query) filter results by subType (optional)
    /// - parameter includeInactive: (query) whether to include inactives in the search or not (optional, default to false)
    /// - parameter missionTypes: (query) comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE (optional, default to "MULTISTAGE,TOURNAMENT,POOLPLAY")
    /// - parameter filter: (query) filter tournaments by the tournament&#39;s current state (optional, default to .upcoming)
    /// - parameter sortField: (query) which field to sort on (optional, default to .startDate)
    /// - parameter descending: (query) Determines whether to return results in descending order. The default value will be true if the filter is \&quot;PAST\&quot;, otherwise the default value will be false. (optional)
    /// - parameter visibility: (query) Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE (optional, default to "PUBLIC")
    /// - parameter start: (query) Start the result set at some index. (optional, default to 0)
    /// - parameter limit: (query) Limit the result to some number (optional, default to 20)
    /// - returns: AnyPublisher<MissionShortResponse, Error> 
    open func searchTournaments(version: Double, accountId: Int64, appKey: String, keyword: String? = nil, subType: String? = nil, includeInactive: Bool? = nil, missionTypes: String? = nil, filter: SearchTournamentsFilter? = nil, sortField: SearchTournamentsSortField? = nil, descending: Bool? = nil, visibility: String? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<MissionShortResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let subType = subType { queryItems.append(URLQueryItem(name: "subType", value: subType)) } 
                if let includeInactive = includeInactive { queryItems.append(URLQueryItem(name: "includeInactive", value: includeInactive ? "true" : "false")) } 
                if let missionTypes = missionTypes { queryItems.append(URLQueryItem(name: "missionTypes", value: missionTypes)) } 
                if let filter = filter { queryItems.append(URLQueryItem(name: "filter", value: filter.rawValue)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MissionShortResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MissionShortResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Submit Tournament Score
    /// - POST /api/{version}/tournament/score
    /// - Submit an array of scores for a tournament match. 
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user account ID. 
    /// - parameter appKey: (query) The application key. 
    /// - parameter missionId: (query) The missionId to score for 
    /// - parameter gameId: (query) The gameId to score for 
    /// - parameter packId: (query) The packId to score for 
    /// - parameter scores: (query) a JSON Array of scores to submit for a tournament match &#x60;&#x60;&#x60;json [   {     \&quot;accountId\&quot;: 2,     \&quot;points\&quot;: 3   },   {     \&quot;accountId\&quot;: 1777662,     \&quot;points\&quot;: 7   } ] &#x60;&#x60;&#x60;  
    /// - parameter gameLevelId: (query) The gameLevelId to score for (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func submitTournamentScore(version: Double, accountId: Int64, appKey: String, missionId: Int64, gameId: Int64, packId: Int64, scores: String, gameLevelId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/score"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)"))
                queryItems.append(URLQueryItem(name: "gameId", value: "\(gameId)"))
                queryItems.append(URLQueryItem(name: "packId", value: "\(packId)"))
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                queryItems.append(URLQueryItem(name: "scores", value: scores))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Submit a vote for a multi-stage album tournament.
    /// - POST /api/{version}/tournament/vote
    /// - Submit a vote for a multi-stage album tournament.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) The application to target 
    /// - parameter missionId: (query) The tournament&#39;s primary id 
    /// - parameter gameObjectId: (query) The tournament game object the user wants to vote on 
    /// - parameter deviceId: (query) The unique id of the device making the request (optional) (optional)
    /// - parameter checkIfDeviceAlreadyVoted: (query) When true, check if the device already voted to prevent duplicate votes from the same device (optional, default to false)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func submitTournamentVote(version: Double, accountId: Int64, appKey: String, missionId: Int64, gameObjectId: Int64, deviceId: String? = nil, checkIfDeviceAlreadyVoted: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/vote"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)"))
                queryItems.append(URLQueryItem(name: "gameObjectId", value: "\(gameObjectId)"))
                if let checkIfDeviceAlreadyVoted = checkIfDeviceAlreadyVoted { queryItems.append(URLQueryItem(name: "checkIfDeviceAlreadyVoted", value: checkIfDeviceAlreadyVoted ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Substitute Tournament Player
    /// - POST /api/{version}/tournament/substitute
    /// - Service to replace the user's opponent in the current level - pack - mission with an AI account.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter missionId: (query) the id of the mission 
    /// - parameter packId: (query) the id of the pack 
    /// - parameter gameLevelId: (query) the id of the game level 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func substituteTournamentPlayer(version: Double, accountId: Int64, missionId: Int64, packId: Int64, gameLevelId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/substitute"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)"))
                queryItems.append(URLQueryItem(name: "packId", value: "\(packId)"))
                queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter splitReward
    ///
    public enum UpdateTournamentSplitReward: String, Codable, CaseIterable {
        case even = "EVEN"
        case all = "ALL"
        case first = "FIRST"
        case random = "RANDOM"
    }
    ///
    /// Enum for parameter visibility
    ///
    public enum UpdateTournamentVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }

    /// Update Tournament
    /// - POST /api/{version}/tournament/update
    /// - Update a tournament.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter missionId: (query) The mission/tournament to update 
    /// - parameter title: (query) The title of the tournament (optional)
    /// - parameter subType: (query) Custom string client apps can use for searching/filtering missions (optional)
    /// - parameter imageAssetId: (query) The asset ID to attach to the tournament (optional)
    /// - parameter secondsBetweenLevels: (query) The number of seconds in between the start of each tournament game (optional)
    /// - parameter secondsForTieBreaker: (query) The number of seconds to extend the round end time in the case of a tie breaker (optional)
    /// - parameter secondsBetweenPacks: (query) The number of seconds in between the start of each tournament round (optional)
    /// - parameter maximumLevelLength: (query) The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity (optional)
    /// - parameter costToPlay: (query) The number of tickets required to pay to enter the tournament (optional)
    /// - parameter costToPlayType: (query) The type of ticket required to pay (optional)
    /// - parameter minimumToPlay: (query) The minimum number of players required to sign up for the tournament to be played (optional)
    /// - parameter startingLimit: (query) The starting number of players for a tournament (filled with AI&#39;s) (optional)
    /// - parameter availableLimit: (query) The maximum number of players for a tournament (currently 128 but not enforced) (optional)
    /// - parameter description: (query) The description of the tournament (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter startDate: (query) The date/time to start the tournament (optional)
    /// - parameter audienceIds: (query) The audiences associated with the tournament (optional)
    /// - parameter active: (query) Activate/deactivate the mission (optional)
    /// - parameter enableBuyBack: (query) Determines whether to allow players to buy back into a tournament (optional)
    /// - parameter offerIds: (query) The list of offers to give as a reward beyond the tickets (optional)
    /// - parameter offerAssetId: (query) The artwork ID to attach to the reward offer (optional)
    /// - parameter fixedReward: (query) If set then do not update the ticket reward, auto set to true if offerIds provided (optional)
    /// - parameter splitReward: (query) Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored (optional)
    /// - parameter allocateTickets: (query) Flag to indicate owner should receive tickets for completed missions (optional)
    /// - parameter tournamentData: (query) A text based string that will be passed into each tournament setup to populate the content (optional)
    /// - parameter visibility: (query) Sets the visibility flag for the tournament (optional)
    /// - parameter preliminaryGroups: (query) The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number) (optional)
    /// - parameter preliminaryGroupAdvancements: (query) This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers) (optional)
    /// - parameter enableMultipleEntries: (query) This determines if multiple submissions/entries are allowed in a multi-stage album tournament (optional)
    /// - parameter enableMultipleVotes: (query) This determines if users are allowed to vote multiple times per group in a multi-stage album tournament (optional)
    /// - parameter featured: (query) This determines whether the tournament is \&quot;featured\&quot; or not (optional)
    /// - parameter winnerTag: (query) This sets what analytic tag is used when a winner is determined (optional)
    /// - parameter tieTag: (query) This sets what analytic tag is used when a winner is determined (optional)
    /// - returns: AnyPublisher<TournamentResponse, Error> 
    open func updateTournament(version: Double, accountId: Int64, missionId: Int64, title: String? = nil, subType: String? = nil, imageAssetId: Int64? = nil, secondsBetweenLevels: Int? = nil, secondsForTieBreaker: Int? = nil, secondsBetweenPacks: Int? = nil, maximumLevelLength: Int? = nil, costToPlay: Int? = nil, costToPlayType: String? = nil, minimumToPlay: Int? = nil, startingLimit: Int? = nil, availableLimit: Int? = nil, description: String? = nil, metaData: String? = nil, startDate: Int64? = nil, audienceIds: String? = nil, active: Bool? = nil, enableBuyBack: Bool? = nil, offerIds: String? = nil, offerAssetId: Int64? = nil, fixedReward: Bool? = nil, splitReward: UpdateTournamentSplitReward? = nil, allocateTickets: Bool? = nil, tournamentData: String? = nil, visibility: UpdateTournamentVisibility? = nil, preliminaryGroups: Int? = nil, preliminaryGroupAdvancements: String? = nil, enableMultipleEntries: Bool? = nil, enableMultipleVotes: Bool? = nil, featured: Bool? = nil, winnerTag: String? = nil, tieTag: String? = nil) -> AnyPublisher<TournamentResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tournament/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)"))
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let subType = subType { queryItems.append(URLQueryItem(name: "subType", value: subType)) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let secondsBetweenLevels = secondsBetweenLevels { queryItems.append(URLQueryItem(name: "secondsBetweenLevels", value: "\(secondsBetweenLevels)")) } 
                if let secondsForTieBreaker = secondsForTieBreaker { queryItems.append(URLQueryItem(name: "secondsForTieBreaker", value: "\(secondsForTieBreaker)")) } 
                if let secondsBetweenPacks = secondsBetweenPacks { queryItems.append(URLQueryItem(name: "secondsBetweenPacks", value: "\(secondsBetweenPacks)")) } 
                if let maximumLevelLength = maximumLevelLength { queryItems.append(URLQueryItem(name: "maximumLevelLength", value: "\(maximumLevelLength)")) } 
                if let costToPlay = costToPlay { queryItems.append(URLQueryItem(name: "costToPlay", value: "\(costToPlay)")) } 
                if let costToPlayType = costToPlayType { queryItems.append(URLQueryItem(name: "costToPlayType", value: costToPlayType)) } 
                if let minimumToPlay = minimumToPlay { queryItems.append(URLQueryItem(name: "minimumToPlay", value: "\(minimumToPlay)")) } 
                if let startingLimit = startingLimit { queryItems.append(URLQueryItem(name: "startingLimit", value: "\(startingLimit)")) } 
                if let availableLimit = availableLimit { queryItems.append(URLQueryItem(name: "availableLimit", value: "\(availableLimit)")) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let enableBuyBack = enableBuyBack { queryItems.append(URLQueryItem(name: "enableBuyBack", value: enableBuyBack ? "true" : "false")) } 
                if let offerIds = offerIds { queryItems.append(URLQueryItem(name: "offerIds", value: offerIds)) } 
                if let offerAssetId = offerAssetId { queryItems.append(URLQueryItem(name: "offerAssetId", value: "\(offerAssetId)")) } 
                if let fixedReward = fixedReward { queryItems.append(URLQueryItem(name: "fixedReward", value: fixedReward ? "true" : "false")) } 
                if let splitReward = splitReward { queryItems.append(URLQueryItem(name: "splitReward", value: splitReward.rawValue)) } 
                if let allocateTickets = allocateTickets { queryItems.append(URLQueryItem(name: "allocateTickets", value: allocateTickets ? "true" : "false")) } 
                if let tournamentData = tournamentData { queryItems.append(URLQueryItem(name: "tournamentData", value: tournamentData)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let preliminaryGroups = preliminaryGroups { queryItems.append(URLQueryItem(name: "preliminaryGroups", value: "\(preliminaryGroups)")) } 
                if let preliminaryGroupAdvancements = preliminaryGroupAdvancements { queryItems.append(URLQueryItem(name: "preliminaryGroupAdvancements", value: preliminaryGroupAdvancements)) } 
                if let enableMultipleEntries = enableMultipleEntries { queryItems.append(URLQueryItem(name: "enableMultipleEntries", value: enableMultipleEntries ? "true" : "false")) } 
                if let enableMultipleVotes = enableMultipleVotes { queryItems.append(URLQueryItem(name: "enableMultipleVotes", value: enableMultipleVotes ? "true" : "false")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                if let winnerTag = winnerTag { queryItems.append(URLQueryItem(name: "winnerTag", value: winnerTag)) } 
                if let tieTag = tieTag { queryItems.append(URLQueryItem(name: "tieTag", value: tieTag)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TournamentResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(TournamentResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
