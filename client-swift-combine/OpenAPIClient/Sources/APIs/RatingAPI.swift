//
// RatingAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RatingAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Rating
    /// - POST /rating/create
    /// - This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.
    /// - parameter ratableType: (query) The ratable object type {RETAILER_LOCATION} 
    /// - parameter ratableId: (query) The id of the ratable object 
    /// - parameter ratingValue: (query) The integer value of 0-100 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter categoryId: (query)  (optional)
    /// - parameter display: (query) A subject title for the user rating (limited to 255 characters) (optional)
    /// - parameter description: (query) The description of the rating (optional)
    /// - parameter locationDescription: (query) The description of the location (optional)
    /// - parameter latitude: (query) The current location of the user (optional)
    /// - parameter longitude: (query) The current location of the user (optional)
    /// - returns: AnyPublisher<RatingResponse, Error> 
    open func createRating(ratableType: String, ratableId: Int64, ratingValue: Int, deviceId: String? = nil, accountId: Int64? = nil, categoryId: Int64? = nil, display: String? = nil, description: String? = nil, locationDescription: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<RatingResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/rating/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "ratableType", value: ratableType))
                queryItems.append(URLQueryItem(name: "ratableId", value: "\(ratableId)"))
                queryItems.append(URLQueryItem(name: "ratingValue", value: "\(ratingValue)"))
                if let categoryId = categoryId { queryItems.append(URLQueryItem(name: "categoryId", value: "\(categoryId)")) } 
                if let display = display { queryItems.append(URLQueryItem(name: "display", value: display)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RatingResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RatingResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Rating
    /// - POST /rating/delete
    /// - Sets a rating as deleted.
    /// - parameter ratingId: (query) The ID of the rating to delete 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteRating(ratingId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/rating/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "ratingId", value: "\(ratingId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchLocationRatingIndexesSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case ratableType = "RATABLE_TYPE"
        case ratableId = "RATABLE_ID"
        case ratableDisplay = "RATABLE_DISPLAY"
        case categoryId = "CATEGORY_ID"
        case categoryName = "CATEGORY_NAME"
        case categoryShortName = "CATEGORY_SHORT_NAME"
        case categoryDisplay = "CATEGORY_DISPLAY"
        case count = "COUNT"
        case summation = "SUMMATION"
        case average = "AVERAGE"
        case value = "VALUE"
    }
    ///
    /// Enum for parameter distanceUnit
    ///
    public enum SearchLocationRatingIndexesDistanceUnit: String, Codable, CaseIterable {
        case miles = "MILES"
        case kilometers = "KILOMETERS"
    }

    /// Search Location Rating Indexes
    /// - GET /location/rating/index/search
    /// - Search for retailer locations by averages near you.
    /// - parameter categoryIds: (query) Comma separated list of category ids to filter the results by (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter locationType: (query) The type of location to filter the results by (optional)
    /// - parameter sortField: (query) The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE} (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - parameter searchRange: (query) The search radius in kilometers to filter results (optional)
    /// - parameter latitude: (query) The current location of the user (optional)
    /// - parameter longitude: (query) The current location of the user (optional)
    /// - parameter returnOverallRating: (query) Determines whether to return the overall rating record instead (optional)
    /// - parameter distanceUnit: (query)  (optional)
    /// - parameter returnRetailer: (query) whether to return the retailer or not (optional)
    /// - parameter returnAssets: (query) whether to return the assets or not (optional)
    /// - parameter returnOffers: (query) whether to return the offers or not (optional)
    /// - parameter returnCategories: (query) whether to return the categories or not (optional)
    /// - parameter returnFilters: (query) whether to return the filters or not (optional)
    /// - returns: AnyPublisher<[RatingIndexResponse], Error> 
    open func searchLocationRatingIndexes(categoryIds: String? = nil, keyword: String? = nil, locationType: String? = nil, sortField: SearchLocationRatingIndexesSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, searchRange: Double? = nil, latitude: Double? = nil, longitude: Double? = nil, returnOverallRating: Bool? = nil, distanceUnit: SearchLocationRatingIndexesDistanceUnit? = nil, returnRetailer: Bool? = nil, returnAssets: Bool? = nil, returnOffers: Bool? = nil, returnCategories: Bool? = nil, returnFilters: Bool? = nil) -> AnyPublisher<[RatingIndexResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/location/rating/index/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let searchRange = searchRange { queryItems.append(URLQueryItem(name: "searchRange", value: "\(searchRange)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let returnOverallRating = returnOverallRating { queryItems.append(URLQueryItem(name: "returnOverallRating", value: returnOverallRating ? "true" : "false")) } 
                if let distanceUnit = distanceUnit { queryItems.append(URLQueryItem(name: "distanceUnit", value: distanceUnit.rawValue)) } 
                if let returnRetailer = returnRetailer { queryItems.append(URLQueryItem(name: "returnRetailer", value: returnRetailer ? "true" : "false")) } 
                if let returnAssets = returnAssets { queryItems.append(URLQueryItem(name: "returnAssets", value: returnAssets ? "true" : "false")) } 
                if let returnOffers = returnOffers { queryItems.append(URLQueryItem(name: "returnOffers", value: returnOffers ? "true" : "false")) } 
                if let returnCategories = returnCategories { queryItems.append(URLQueryItem(name: "returnCategories", value: returnCategories ? "true" : "false")) } 
                if let returnFilters = returnFilters { queryItems.append(URLQueryItem(name: "returnFilters", value: returnFilters ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RatingIndexResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RatingIndexResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter ratableType
    ///
    public enum SearchRatingIndexesRatableType: String, Codable, CaseIterable {
        case locatable = "LOCATABLE"
        case reservable = "RESERVABLE"
        case permissionable = "PERMISSIONABLE"
        case notable = "NOTABLE"
        case assetable = "ASSETABLE"
        case likable = "LIKABLE"
        case flagable = "FLAGABLE"
        case favoritable = "FAVORITABLE"
        case ratable = "RATABLE"
        case album = "ALBUM"
        case collection = "COLLECTION"
        case application = "APPLICATION"
        case applicationSetting = "APPLICATION_SETTING"
        case applicationCert = "APPLICATION_CERT"
        case applicationPlacement = "APPLICATION_PLACEMENT"
        case account = "ACCOUNT"
        case accountSetting = "ACCOUNT_SETTING"
        case gameLevel = "GAME_LEVEL"
        case pack = "PACK"
        case mission = "MISSION"
        case tournament = "TOURNAMENT"
        case asset = "ASSET"
        case albumContest = "ALBUM_CONTEST"
        case themeDescriptor = "THEME_DESCRIPTOR"
        case offer = "OFFER"
        case offerLocation = "OFFER_LOCATION"
        case event = "EVENT"
        case retailer = "RETAILER"
        case retailerLocation = "RETAILER_LOCATION"
        case note = "NOTE"
        case creative = "CREATIVE"
        case favorite = "FAVORITE"
        case like = "LIKE"
        case rating = "RATING"
        case analytic = "ANALYTIC"
        case thirdPartyCredential = "THIRD_PARTY_CREDENTIAL"
        case thirdPartyNetwork = "THIRD_PARTY_NETWORK"
        case region = "REGION"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum SearchRatingIndexesSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case ratableType = "RATABLE_TYPE"
        case ratableId = "RATABLE_ID"
        case ratableDisplay = "RATABLE_DISPLAY"
        case categoryId = "CATEGORY_ID"
        case categoryName = "CATEGORY_NAME"
        case categoryShortName = "CATEGORY_SHORT_NAME"
        case categoryDisplay = "CATEGORY_DISPLAY"
        case count = "COUNT"
        case summation = "SUMMATION"
        case average = "AVERAGE"
        case value = "VALUE"
    }

    /// Search Rating Indexes
    /// - GET /rating/index/search
    /// - Search for ratable items by averages.
    /// - parameter ratableType: (query) Filter results by a ratable type {RETAILER_LOCATION} 
    /// - parameter ratableIds: (query) Comma separated list of ratable ids to filter the resuts by (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids to filter the results by (optional)
    /// - parameter secondaryType: (query)  (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter sortField: (query) The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE} (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - parameter latitude: (query)  (optional)
    /// - parameter longitude: (query)  (optional)
    /// - parameter returnRatable: (query) Determines whether to return the ratable object in the response (optional)
    /// - parameter returnOverallRating: (query) Determines whether to return the overall rating record instead (optional)
    /// - returns: AnyPublisher<[RatingIndexResponse], Error> 
    open func searchRatingIndexes(ratableType: SearchRatingIndexesRatableType, ratableIds: String? = nil, categoryIds: String? = nil, secondaryType: String? = nil, keyword: String? = nil, sortField: SearchRatingIndexesSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, latitude: Double? = nil, longitude: Double? = nil, returnRatable: Bool? = nil, returnOverallRating: Bool? = nil) -> AnyPublisher<[RatingIndexResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/rating/index/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "ratableType", value: ratableType.rawValue))
                if let ratableIds = ratableIds { queryItems.append(URLQueryItem(name: "ratableIds", value: ratableIds)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let secondaryType = secondaryType { queryItems.append(URLQueryItem(name: "secondaryType", value: secondaryType)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let returnRatable = returnRatable { queryItems.append(URLQueryItem(name: "returnRatable", value: returnRatable ? "true" : "false")) } 
                if let returnOverallRating = returnOverallRating { queryItems.append(URLQueryItem(name: "returnOverallRating", value: returnOverallRating ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RatingIndexResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RatingIndexResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchRatingsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case ownerDisplay = "OWNER_DISPLAY"
        case ratableType = "RATABLE_TYPE"
        case ratableId = "RATABLE_ID"
        case ratableDisplay = "RATABLE_DISPLAY"
        case categoryId = "CATEGORY_ID"
        case categoryName = "CATEGORY_NAME"
        case categoryShortName = "CATEGORY_SHORT_NAME"
        case categoryDisplay = "CATEGORY_DISPLAY"
        case value = "VALUE"
    }

    /// Search Ratings
    /// - GET /rating/search
    /// - Search for ratings on a ratable object.
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter filterAccountId: (query) Filter results for a particular account (optional)
    /// - parameter ratableType: (query) The ratable object type {RETAILER_LOCATION} (optional)
    /// - parameter ratableId: (query) The id of the ratable object (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids to filter the results by (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter sortField: (query) The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE} (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - returns: AnyPublisher<[RatingResponse], Error> 
    open func searchRatings(deviceId: String? = nil, accountId: Int64? = nil, filterAccountId: Int64? = nil, ratableType: String? = nil, ratableId: Int64? = nil, categoryIds: String? = nil, keyword: String? = nil, sortField: SearchRatingsSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[RatingResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/rating/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let filterAccountId = filterAccountId { queryItems.append(URLQueryItem(name: "filterAccountId", value: "\(filterAccountId)")) } 
                if let ratableType = ratableType { queryItems.append(URLQueryItem(name: "ratableType", value: ratableType)) } 
                if let ratableId = ratableId { queryItems.append(URLQueryItem(name: "ratableId", value: "\(ratableId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RatingResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RatingResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Rating
    /// - POST /rating/update
    /// - Update an existing rating. Only the creator of the rating have permission to update.
    /// - parameter ratingId: (query) The id of the rating (Note: this is not the ratable object id) 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter ratingValue: (query) The rating value to update (optional)
    /// - parameter categoryId: (query)  (optional)
    /// - parameter display: (query) A subject title for the user rating (limited to 255 characters) (optional)
    /// - parameter description: (query) The description of the rating (optional)
    /// - parameter locationDescription: (query) The description of the location (optional)
    /// - parameter latitude: (query) The current location of the user (optional)
    /// - parameter longitude: (query) The current location of the user (optional)
    /// - returns: AnyPublisher<RatingResponse, Error> 
    open func updateRating(ratingId: Int64, deviceId: String? = nil, accountId: Int64? = nil, ratingValue: Int? = nil, categoryId: Int64? = nil, display: String? = nil, description: String? = nil, locationDescription: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<RatingResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/rating/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "ratingId", value: "\(ratingId)"))
                if let ratingValue = ratingValue { queryItems.append(URLQueryItem(name: "ratingValue", value: "\(ratingValue)")) } 
                if let categoryId = categoryId { queryItems.append(URLQueryItem(name: "categoryId", value: "\(categoryId)")) } 
                if let display = display { queryItems.append(URLQueryItem(name: "display", value: display)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RatingResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RatingResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
