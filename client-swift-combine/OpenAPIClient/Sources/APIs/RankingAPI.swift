//
// RankingAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RankingAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Search Historical Rankings
    /// - GET /ranking/historical/search
    /// - Get historical leaderboard rankings by time-frame.
    /// - parameter appKey: (query) the application key for filtering results by application 
    /// - parameter rankType: (query) the rank type to return 
    /// - parameter startDate: (query) timestamp in milliseconds to filter results with 
    /// - parameter endDate: (query) timestamp in milliseconds to filter results with 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (optional)
    /// - parameter sortField: (query) determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
    /// - parameter descending: (query) determines whether to return results in ascending or descending order (optional, default to true)
    /// - parameter start: (query) the start index for pagination (optional, default to 0)
    /// - parameter limit: (query) the limit for pagination (optional, default to 100)
    /// - returns: AnyPublisher<RankFullResponse, Error> 
    open func getHistoricalRankings(appKey: String, rankType: String, startDate: Int64, endDate: Int64, deviceId: String? = nil, accountId: Int64? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<RankFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/ranking/historical/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "rankType", value: rankType))
                queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)"))
                queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)"))
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RankFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RankFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Rankings
    /// - GET /ranking/search
    /// - Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the application key for filtering results by application (required for non-EXECUTIVE users) (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) keyword to search for (optional)
    /// - parameter rankType: (query) a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (optional, default to "POINTS,DOWNLOADS,INVITATIONS")
    /// - parameter leaderboardMode: (query) the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (optional, default to "GLOBAL")
    /// - parameter withinAccountIds: (query) comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (optional)
    /// - parameter returnUserRank: (query) determines whether to return the user&#39;s current rank in the response. This can be turned off for sequential paginated requests. (optional, default to true)
    /// - parameter albumId: (query) album id to use when performing CUSTOM filters (optional)
    /// - parameter audienceId: (query) audience id to use when performing CUSTOM filters (optional)
    /// - parameter sortField: (query) determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (optional, default to "TOTAL")
    /// - parameter descending: (query) determines whether to return results in ascending or descending order (optional, default to true)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter start: (query) the start index for pagination (optional, default to 0)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter limit: (query) the limit for pagination (optional, default to 100)
    /// - returns: AnyPublisher<RankFullResponse, Error> 
    open func getRankings(deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, q: String? = nil, keyword: String? = nil, rankType: String? = nil, leaderboardMode: String? = nil, withinAccountIds: String? = nil, returnUserRank: Bool? = nil, albumId: Int64? = nil, audienceId: Int64? = nil, sortField: String? = nil, descending: Bool? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil) -> AnyPublisher<RankFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/ranking/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let leaderboardMode = leaderboardMode { queryItems.append(URLQueryItem(name: "leaderboardMode", value: leaderboardMode)) } 
                if let withinAccountIds = withinAccountIds { queryItems.append(URLQueryItem(name: "withinAccountIds", value: withinAccountIds)) } 
                if let returnUserRank = returnUserRank { queryItems.append(URLQueryItem(name: "returnUserRank", value: returnUserRank ? "true" : "false")) } 
                if let albumId = albumId { queryItems.append(URLQueryItem(name: "albumId", value: "\(albumId)")) } 
                if let audienceId = audienceId { queryItems.append(URLQueryItem(name: "audienceId", value: "\(audienceId)")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RankFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RankFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Personal Rankings
    /// - POST /ranking/personal/ranks
    /// - Returns the user's ranks for one or more rank types and modes.
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (optional)
    /// - parameter appKey: (query) the application key for filtering results by application (required) (optional)
    /// - parameter rankType: (query) pass in all rankTypes and children rankTypes (optional)
    /// - parameter returnUserRank: (query) determines whether to return the user&#39;s current rank in the response, for each rankType (optional, default to false)
    /// - parameter leaderboardMode: (query) the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional, default to "GLOBAL")
    /// - parameter sortField: (query) determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (optional, default to "TOTAL")
    /// - parameter keyword: (query) keyword to search for (on rankType) (optional)
    /// - parameter descending: (query) determines whether to return results in descending order (optional, default to true)
    /// - parameter start: (query) the start index for pagination (optional, default to 0)
    /// - parameter limit: (query) the limit for pagination (optional, default to 100)
    /// - returns: AnyPublisher<[String: Any], Error> 
    open func getUserRank(deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, rankType: String? = nil, returnUserRank: Bool? = nil, leaderboardMode: String? = nil, sortField: String? = nil, keyword: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[String: Any], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/ranking/personal/ranks"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let returnUserRank = returnUserRank { queryItems.append(URLQueryItem(name: "returnUserRank", value: returnUserRank ? "true" : "false")) } 
                if let leaderboardMode = leaderboardMode { queryItems.append(URLQueryItem(name: "leaderboardMode", value: leaderboardMode)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[String: Any], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    if let object = try JSONSerialization.jsonObject(with: response.data, options: []) as? [String: Any] {
                        return object
                    } else {
                        throw OpenAPITransportError.invalidResponseMappingError(data: response.data)
                    }
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Override User Rank
    /// - POST /ranking/override
    /// - Allows an admin of an application to override a user's scores for a leaderboard.
    /// - parameter accountId: (query) the logged in user&#39;s account id (must have permissions to manage data for the application) 
    /// - parameter ownerAccountId: (query) the end user&#39;s account id to override 
    /// - parameter appKey: (query) the application key the leaderboard is for 
    /// - parameter rankType: (query) the rankType of the leaderboard 
    /// - parameter totalScore: (query) the total score to update (optional)
    /// - parameter totalCount: (query) the total count to update (optional)
    /// - parameter totalTime: (query) the total time to update (optional)
    /// - parameter dailyScore: (query) the daily score to update (optional)
    /// - parameter dailyCount: (query) the daily count to update (optional)
    /// - parameter dailyTime: (query) the daily time to update (optional)
    /// - parameter weeklyScore: (query) the weekly score to update (optional)
    /// - parameter weeklyCount: (query) the weekly count to update (optional)
    /// - parameter weeklyTime: (query) the weekly time to update (optional)
    /// - parameter monthlyScore: (query) the monthly score to update (optional)
    /// - parameter monthlyCount: (query) the monthly count to update (optional)
    /// - parameter monthlyTime: (query) the monthly time to update (optional)
    /// - parameter topScore: (query) the top score to update (optional)
    /// - parameter lowestScore: (query) the lowest score to update (optional)
    /// - parameter streakCount: (query) the streak count to update (optional)
    /// - parameter streakBestCount: (query) the best streak count to update (optional)
    /// - parameter startDate: (query) the start date to update (optional)
    /// - parameter endDate: (query) the end date to update (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func overrideUserRank(accountId: Int64, ownerAccountId: Int64, appKey: String, rankType: String, totalScore: Int64? = nil, totalCount: Int64? = nil, totalTime: Int64? = nil, dailyScore: Int64? = nil, dailyCount: Int64? = nil, dailyTime: Int64? = nil, weeklyScore: Int64? = nil, weeklyCount: Int64? = nil, weeklyTime: Int64? = nil, monthlyScore: Int64? = nil, monthlyCount: Int64? = nil, monthlyTime: Int64? = nil, topScore: Int64? = nil, lowestScore: Int64? = nil, streakCount: Int64? = nil, streakBestCount: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/ranking/override"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "ownerAccountId", value: "\(ownerAccountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "rankType", value: rankType))
                if let totalScore = totalScore { queryItems.append(URLQueryItem(name: "totalScore", value: "\(totalScore)")) } 
                if let totalCount = totalCount { queryItems.append(URLQueryItem(name: "totalCount", value: "\(totalCount)")) } 
                if let totalTime = totalTime { queryItems.append(URLQueryItem(name: "totalTime", value: "\(totalTime)")) } 
                if let dailyScore = dailyScore { queryItems.append(URLQueryItem(name: "dailyScore", value: "\(dailyScore)")) } 
                if let dailyCount = dailyCount { queryItems.append(URLQueryItem(name: "dailyCount", value: "\(dailyCount)")) } 
                if let dailyTime = dailyTime { queryItems.append(URLQueryItem(name: "dailyTime", value: "\(dailyTime)")) } 
                if let weeklyScore = weeklyScore { queryItems.append(URLQueryItem(name: "weeklyScore", value: "\(weeklyScore)")) } 
                if let weeklyCount = weeklyCount { queryItems.append(URLQueryItem(name: "weeklyCount", value: "\(weeklyCount)")) } 
                if let weeklyTime = weeklyTime { queryItems.append(URLQueryItem(name: "weeklyTime", value: "\(weeklyTime)")) } 
                if let monthlyScore = monthlyScore { queryItems.append(URLQueryItem(name: "monthlyScore", value: "\(monthlyScore)")) } 
                if let monthlyCount = monthlyCount { queryItems.append(URLQueryItem(name: "monthlyCount", value: "\(monthlyCount)")) } 
                if let monthlyTime = monthlyTime { queryItems.append(URLQueryItem(name: "monthlyTime", value: "\(monthlyTime)")) } 
                if let topScore = topScore { queryItems.append(URLQueryItem(name: "topScore", value: "\(topScore)")) } 
                if let lowestScore = lowestScore { queryItems.append(URLQueryItem(name: "lowestScore", value: "\(lowestScore)")) } 
                if let streakCount = streakCount { queryItems.append(URLQueryItem(name: "streakCount", value: "\(streakCount)")) } 
                if let streakBestCount = streakBestCount { queryItems.append(URLQueryItem(name: "streakBestCount", value: "\(streakBestCount)")) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Ranking
    /// - POST /ranking/update
    /// - Update the rank value 
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter appKey: (query) the application key for filtering results by application 
    /// - parameter rankType: (query) a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS 
    /// - parameter increment: (query) the value to increment (optional, default to 1)
    /// - parameter timeIncrement: (query) the time value to increment (optional)
    /// - parameter tag: (query) the analytic tag for this achievement (used to validate scores) (optional)
    /// - parameter startDate: (query) custom date you can save along with the score for the user (optional)
    /// - parameter endDate: (query) custom date you can save along with the score for the user (optional)
    /// - parameter updateGlobal: (query) update the global rankings if true, default is false (optional)
    /// - parameter createLeaderboard: (query) create the leaderboard if it does not exist (default false) (optional, default to false)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateRankings(accountId: Int64, appKey: String, rankType: String, increment: Int64? = nil, timeIncrement: Int64? = nil, tag: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, updateGlobal: Bool? = nil, createLeaderboard: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/ranking/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "rankType", value: rankType))
                if let increment = increment { queryItems.append(URLQueryItem(name: "increment", value: "\(increment)")) } 
                if let timeIncrement = timeIncrement { queryItems.append(URLQueryItem(name: "timeIncrement", value: "\(timeIncrement)")) } 
                if let tag = tag { queryItems.append(URLQueryItem(name: "tag", value: tag)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let updateGlobal = updateGlobal { queryItems.append(URLQueryItem(name: "updateGlobal", value: updateGlobal ? "true" : "false")) } 
                if let createLeaderboard = createLeaderboard { queryItems.append(URLQueryItem(name: "createLeaderboard", value: createLeaderboard ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
