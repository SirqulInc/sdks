//
// AssetAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AssetAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Download Asset
    /// - GET /api/{version}/asset/download/{filename}
    /// - Downloads an asset from the server for assets that have been uploaded to the server.
    /// - parameter version: (path)  
    /// - parameter filename: (path) the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId} 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func assetDownload(version: Double, filename: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/download/{filename}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{filename}", with: filename)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter adSize
    ///
    public enum AssetMorphAdSize: String, Codable, CaseIterable {
        case config = "CONFIG"
        case banner = "BANNER"
        case leaderboard = "LEADERBOARD"
        case skyscraper = "SKYSCRAPER"
        case video = "VIDEO"
        case zip = "ZIP"
        case interstitial = "INTERSTITIAL"
        case custom1 = "CUSTOM1"
        case custom2 = "CUSTOM2"
        case custom3 = "CUSTOM3"
        case custom4 = "CUSTOM4"
        case custom5 = "CUSTOM5"
        case custom6 = "CUSTOM6"
        case custom7 = "CUSTOM7"
        case custom8 = "CUSTOM8"
        case custom9 = "CUSTOM9"
        case custom10 = "CUSTOM10"
    }

    /// Convert Offer to Creative
    /// - POST /api/{version}/asset/morph
    /// - Converts an offer image + text into a creative image.
    /// - parameter version: (path)  
    /// - parameter offerId: (query) offer id used for inserting offer text/flavor 
    /// - parameter adSize: (query) the ad size used for selecting a format for the creative image 
    /// - parameter creativeId: (query) used for inserting the newly created image into (optional)
    /// - parameter width: (query) total width of the creative image (optional)
    /// - parameter height: (query) total height of the creative image (optional)
    /// - parameter backgroundSize: (query) the size of the background (optional)
    /// - parameter template: (query) the template to use (optional)
    /// - returns: AnyPublisher<AssetShortResponse, Error> 
    open func assetMorph(version: Double, offerId: Int64, adSize: AssetMorphAdSize, creativeId: Int64? = nil, width: Int? = nil, height: Int? = nil, backgroundSize: String? = nil, template: String? = nil) -> AnyPublisher<AssetShortResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/morph"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)"))
                if let creativeId = creativeId { queryItems.append(URLQueryItem(name: "creativeId", value: "\(creativeId)")) } 
                queryItems.append(URLQueryItem(name: "adSize", value: adSize.rawValue))
                if let width = width { queryItems.append(URLQueryItem(name: "width", value: "\(width)")) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: "\(height)")) } 
                if let backgroundSize = backgroundSize { queryItems.append(URLQueryItem(name: "backgroundSize", value: backgroundSize)) } 
                if let template = template { queryItems.append(URLQueryItem(name: "template", value: template)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssetShortResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssetShortResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Asset
    /// - POST /api/{version}/asset/create
    /// - Uploads an asset to server and returns an asset id which can be used to assign to various objects.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) to return nulls (optional)
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter albumId: (query) the album the asset will be added to (optional) (optional)
    /// - parameter collectionId: (query) Deprecated: use collections via the collection endpoints. (optional)
    /// - parameter addToDefaultAlbum: (query) Whether to add to a default album (optional)
    /// - parameter addToMediaLibrary: (query) Whether to add to the media library (optional)
    /// - parameter versionCode: (query) the version code (optional)
    /// - parameter versionName: (query) the version name (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter caption: (query) the caption (optional) (optional)
    /// - parameter assetType: (query) the asset type (optional)
    /// - parameter approvalStatus: (query) approval status for the asset (optional)
    /// - parameter assignedAccountId: (query) account id assigned to the asset (optional)
    /// - parameter media: (query) a MultipartFile containing the mimetype, etc (optional)
    /// - parameter mediaUrl: (query) this can be used if the \&quot;media\&quot; is a link (optional) (optional)
    /// - parameter mediaString: (query) the media content as a string (optional) (optional)
    /// - parameter mediaStringFileName: (query) file name for mediaString (optional) (optional)
    /// - parameter mediaStringContentType: (query) content type for mediaString (optional) (optional)
    /// - parameter mediaHeight: (query) the media height (optional) (optional)
    /// - parameter mediaWidth: (query) the media width (optional) (optional)
    /// - parameter attachedMedia: (query) a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
    /// - parameter attachedMediaUrl: (query) this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
    /// - parameter attachedMediaString: (query) attached media content as a string (optional) (optional)
    /// - parameter attachedMediaStringFileName: (query) file name for attachedMediaString (optional) (optional)
    /// - parameter attachedMediaStringContentType: (query) content type for attachedMediaString (optional) (optional)
    /// - parameter attachedMediaHeight: (query) the attached media height (optional) (optional)
    /// - parameter attachedMediaWidth: (query) the attached media width (optional) (optional)
    /// - parameter locationDescription: (query) the location description (optional) (optional)
    /// - parameter app: (query) Deprecated: app parameter (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter searchTags: (query) the search tags (optional)
    /// - parameter latitude: (query) the latitude (optional) (optional)
    /// - parameter longitude: (query) the longitude (optional) (optional)
    /// - returns: AnyPublisher<AssetResponse, Error> 
    open func createAsset(version: Double, returnNulls: Bool? = nil, deviceId: String? = nil, accountId: Int64? = nil, albumId: Int64? = nil, collectionId: Int64? = nil, addToDefaultAlbum: String? = nil, addToMediaLibrary: Bool? = nil, versionCode: Int? = nil, versionName: String? = nil, metaData: String? = nil, caption: String? = nil, assetType: String? = nil, approvalStatus: String? = nil, assignedAccountId: Int64? = nil, media: Data? = nil, mediaUrl: String? = nil, mediaString: String? = nil, mediaStringFileName: String? = nil, mediaStringContentType: String? = nil, mediaHeight: Int? = nil, mediaWidth: Int? = nil, attachedMedia: Data? = nil, attachedMediaUrl: String? = nil, attachedMediaString: String? = nil, attachedMediaStringFileName: String? = nil, attachedMediaStringContentType: String? = nil, attachedMediaHeight: Int? = nil, attachedMediaWidth: Int? = nil, locationDescription: String? = nil, app: String? = nil, appKey: String? = nil, searchTags: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<AssetResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let returnNulls = returnNulls { queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let albumId = albumId { queryItems.append(URLQueryItem(name: "albumId", value: "\(albumId)")) } 
                if let collectionId = collectionId { queryItems.append(URLQueryItem(name: "collectionId", value: "\(collectionId)")) } 
                if let addToDefaultAlbum = addToDefaultAlbum { queryItems.append(URLQueryItem(name: "addToDefaultAlbum", value: addToDefaultAlbum)) } 
                if let addToMediaLibrary = addToMediaLibrary { queryItems.append(URLQueryItem(name: "addToMediaLibrary", value: addToMediaLibrary ? "true" : "false")) } 
                if let versionCode = versionCode { queryItems.append(URLQueryItem(name: "versionCode", value: "\(versionCode)")) } 
                if let versionName = versionName { queryItems.append(URLQueryItem(name: "versionName", value: versionName)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let caption = caption { queryItems.append(URLQueryItem(name: "caption", value: caption)) } 
                if let assetType = assetType { queryItems.append(URLQueryItem(name: "assetType", value: assetType)) } 
                if let approvalStatus = approvalStatus { queryItems.append(URLQueryItem(name: "approvalStatus", value: approvalStatus)) } 
                if let assignedAccountId = assignedAccountId { queryItems.append(URLQueryItem(name: "assignedAccountId", value: "\(assignedAccountId)")) } 
                if let media = media { queryItems.append(URLQueryItem(name: "media", value: )) } 
                if let mediaUrl = mediaUrl { queryItems.append(URLQueryItem(name: "mediaUrl", value: mediaUrl)) } 
                if let mediaString = mediaString { queryItems.append(URLQueryItem(name: "mediaString", value: mediaString)) } 
                if let mediaStringFileName = mediaStringFileName { queryItems.append(URLQueryItem(name: "mediaStringFileName", value: mediaStringFileName)) } 
                if let mediaStringContentType = mediaStringContentType { queryItems.append(URLQueryItem(name: "mediaStringContentType", value: mediaStringContentType)) } 
                if let mediaHeight = mediaHeight { queryItems.append(URLQueryItem(name: "mediaHeight", value: "\(mediaHeight)")) } 
                if let mediaWidth = mediaWidth { queryItems.append(URLQueryItem(name: "mediaWidth", value: "\(mediaWidth)")) } 
                if let attachedMedia = attachedMedia { queryItems.append(URLQueryItem(name: "attachedMedia", value: )) } 
                if let attachedMediaUrl = attachedMediaUrl { queryItems.append(URLQueryItem(name: "attachedMediaUrl", value: attachedMediaUrl)) } 
                if let attachedMediaString = attachedMediaString { queryItems.append(URLQueryItem(name: "attachedMediaString", value: attachedMediaString)) } 
                if let attachedMediaStringFileName = attachedMediaStringFileName { queryItems.append(URLQueryItem(name: "attachedMediaStringFileName", value: attachedMediaStringFileName)) } 
                if let attachedMediaStringContentType = attachedMediaStringContentType { queryItems.append(URLQueryItem(name: "attachedMediaStringContentType", value: attachedMediaStringContentType)) } 
                if let attachedMediaHeight = attachedMediaHeight { queryItems.append(URLQueryItem(name: "attachedMediaHeight", value: "\(attachedMediaHeight)")) } 
                if let attachedMediaWidth = attachedMediaWidth { queryItems.append(URLQueryItem(name: "attachedMediaWidth", value: "\(attachedMediaWidth)")) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let app = app { queryItems.append(URLQueryItem(name: "app", value: app)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssetResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssetResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Asset
    /// - POST /api/{version}/asset/delete
    /// - Delete an asset.
    /// - parameter version: (path)  
    /// - parameter assetId: (query) the id of the asset to delete 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteAsset(version: Double, assetId: String, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "assetId", value: assetId))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Asset
    /// - GET /api/{version}/asset/get
    /// - Gets the full asset response including attached likes and notes.
    /// - parameter version: (path)  
    /// - parameter assetId: (query) the asset ID 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter noteDescending: (query) determines whether the notes on the asset are in descending order (optional, default to false)
    /// - returns: AnyPublisher<AssetFullResponse, Error> 
    open func getAsset(version: Double, assetId: Int64, deviceId: String? = nil, accountId: Int64? = nil, noteDescending: Bool? = nil) -> AnyPublisher<AssetFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)"))
                if let noteDescending = noteDescending { queryItems.append(URLQueryItem(name: "noteDescending", value: noteDescending ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssetFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssetFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Remove Asset from Collection
    /// - POST /api/{version}/asset/remove
    /// - Remove assets from collections
    /// - parameter version: (path)  
    /// - parameter assetId: (query) the id of the asset to remove 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter albumId: (query) the album id to remove the asset from (optional)
    /// - parameter collectionId: (query) the collection id to remove the asset from (optional)
    /// - parameter removeFromDefaultAlbums: (query) remove from the user&#39;s profile album (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removeAsset(version: Double, assetId: String, deviceId: String? = nil, accountId: Int64? = nil, albumId: Int64? = nil, collectionId: Int64? = nil, removeFromDefaultAlbums: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/remove"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let albumId = albumId { queryItems.append(URLQueryItem(name: "albumId", value: "\(albumId)")) } 
                if let collectionId = collectionId { queryItems.append(URLQueryItem(name: "collectionId", value: "\(collectionId)")) } 
                queryItems.append(URLQueryItem(name: "assetId", value: assetId))
                if let removeFromDefaultAlbums = removeFromDefaultAlbums { queryItems.append(URLQueryItem(name: "removeFromDefaultAlbums", value: removeFromDefaultAlbums ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Assets
    /// - GET /api/{version}/asset/search
    /// - Searches for assets
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter albumIds: (query) comma separated list of album ids to search on (optional)
    /// - parameter assetIds: (query) comma separated list of asset ids to search on (optional)
    /// - parameter appKey: (query) the application key to filter results by application. (optional)
    /// - parameter mediaType: (query) filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT (optional)
    /// - parameter mimeType: (query) filter results by mime type (optional)
    /// - parameter keyword: (query) keyword search string (optional)
    /// - parameter versionCode: (query) filter results by version code (optional)
    /// - parameter versionName: (query) filter results by version name (optional)
    /// - parameter updatedSince: (query) return items that have been updated since this date (time-stamp in milliseconds) (optional)
    /// - parameter updatedBefore: (query) return items that have been updated before this date (time-stamp in milliseconds) (optional)
    /// - parameter sortField: (query) the field to sort by. See AssetApiMap (optional)
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order (optional)
    /// - parameter searchMediaLibrary: (query) determines whether to search on the media library album (optional)
    /// - parameter filterByBillable: (query) filter results by billable entity (optional)
    /// - parameter activeOnly: (query) if only searching for active assets (optional)
    /// - parameter returnApp: (query) determines whether to include the application response as part of the asset response (optional)
    /// - parameter start: (query) the start index for pagination (optional)
    /// - parameter limit: (query) the limit for pagination (there is a hard limit of 200) (optional)
    /// - parameter searchMode: (query) search mode for index (SearchIndexMode) (optional)
    /// - parameter assetType: (query) filter by asset type (optional)
    /// - parameter approvalStatus: (query) filter by approval status (optional)
    /// - parameter assignedAccountId: (query) filter results by an assigned account id (optional)
    /// - returns: AnyPublisher<[AssetResponse], Error> 
    open func searchAssets(version: Double, deviceId: String? = nil, accountId: Int64? = nil, albumIds: String? = nil, assetIds: String? = nil, appKey: String? = nil, mediaType: String? = nil, mimeType: String? = nil, keyword: String? = nil, versionCode: Int? = nil, versionName: String? = nil, updatedSince: Int64? = nil, updatedBefore: Int64? = nil, sortField: String? = nil, descending: Bool? = nil, searchMediaLibrary: Bool? = nil, filterByBillable: Bool? = nil, activeOnly: Bool? = nil, returnApp: Bool? = nil, start: Int? = nil, limit: Int? = nil, searchMode: String? = nil, assetType: String? = nil, approvalStatus: String? = nil, assignedAccountId: Int64? = nil) -> AnyPublisher<[AssetResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let albumIds = albumIds { queryItems.append(URLQueryItem(name: "albumIds", value: albumIds)) } 
                if let assetIds = assetIds { queryItems.append(URLQueryItem(name: "assetIds", value: assetIds)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let mediaType = mediaType { queryItems.append(URLQueryItem(name: "mediaType", value: mediaType)) } 
                if let mimeType = mimeType { queryItems.append(URLQueryItem(name: "mimeType", value: mimeType)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let versionCode = versionCode { queryItems.append(URLQueryItem(name: "versionCode", value: "\(versionCode)")) } 
                if let versionName = versionName { queryItems.append(URLQueryItem(name: "versionName", value: versionName)) } 
                if let updatedSince = updatedSince { queryItems.append(URLQueryItem(name: "updatedSince", value: "\(updatedSince)")) } 
                if let updatedBefore = updatedBefore { queryItems.append(URLQueryItem(name: "updatedBefore", value: "\(updatedBefore)")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let searchMediaLibrary = searchMediaLibrary { queryItems.append(URLQueryItem(name: "searchMediaLibrary", value: searchMediaLibrary ? "true" : "false")) } 
                if let filterByBillable = filterByBillable { queryItems.append(URLQueryItem(name: "filterByBillable", value: filterByBillable ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let returnApp = returnApp { queryItems.append(URLQueryItem(name: "returnApp", value: returnApp ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let searchMode = searchMode { queryItems.append(URLQueryItem(name: "searchMode", value: searchMode)) } 
                if let assetType = assetType { queryItems.append(URLQueryItem(name: "assetType", value: assetType)) } 
                if let approvalStatus = approvalStatus { queryItems.append(URLQueryItem(name: "approvalStatus", value: approvalStatus)) } 
                if let assignedAccountId = assignedAccountId { queryItems.append(URLQueryItem(name: "assignedAccountId", value: "\(assignedAccountId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AssetResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AssetResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Asset
    /// - POST /api/{version}/asset/update
    /// - Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.
    /// - parameter version: (path)  
    /// - parameter assetId: (query) the ID of the asset to update 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter albumId: (query) the ID of the album to check user permissions (optional)
    /// - parameter attachedAssetId: (query) the ID of the attached asset (optional)
    /// - parameter versionCode: (query) the version code (optional)
    /// - parameter versionName: (query) the version name (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter caption: (query) the caption (optional)
    /// - parameter assetType: (query) the asset type (optional)
    /// - parameter approvalStatus: (query) approval status for the asset (optional)
    /// - parameter assignedAccountId: (query) account id assigned to the asset (optional)
    /// - parameter media: (query) a MultipartFile containing the mimetype, etc (optional)
    /// - parameter mediaUrl: (query) this can be used if the \&quot;media\&quot; is a link (optional) (optional)
    /// - parameter mediaString: (query) the media content as a string (optional) (optional)
    /// - parameter mediaStringFileName: (query) file name for mediaString (optional) (optional)
    /// - parameter mediaStringContentType: (query) content type for mediaString (optional) (optional)
    /// - parameter mediaHeight: (query) the media height (optional) (optional)
    /// - parameter mediaWidth: (query) the media width (optional) (optional)
    /// - parameter attachedMedia: (query) a MultipartFile containing an asset that the \&quot;media\&quot; file references (optional). Example: to upload a video the \&quot;media\&quot; file should contain a screen capture and the \&quot;attachedMedia\&quot; should be the actual video. (optional)
    /// - parameter attachedMediaUrl: (query) this can be used if the \&quot;attachedMedia\&quot; is a link (i.e. a Youtube video, etc) (optional) (optional)
    /// - parameter attachedMediaString: (query) attached media content as a string (optional) (optional)
    /// - parameter attachedMediaStringFileName: (query) file name for attachedMediaString (optional) (optional)
    /// - parameter attachedMediaStringContentType: (query) content type for attachedMediaString (optional) (optional)
    /// - parameter attachedMediaHeight: (query) the attached media height (optional) (optional)
    /// - parameter attachedMediaWidth: (query) the attached media width (optional) (optional)
    /// - parameter locationDescription: (query) the location description (optional)
    /// - parameter searchTags: (query) search tags (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter latitude: (query) latitude used to update the asset&#39;s location (optional)
    /// - parameter longitude: (query) longitude used to update the asset&#39;s location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateAsset(version: Double, assetId: Int64, deviceId: String? = nil, accountId: Int64? = nil, albumId: Int64? = nil, attachedAssetId: Int64? = nil, versionCode: Int? = nil, versionName: String? = nil, metaData: String? = nil, caption: String? = nil, assetType: String? = nil, approvalStatus: String? = nil, assignedAccountId: Int64? = nil, media: Data? = nil, mediaUrl: String? = nil, mediaString: String? = nil, mediaStringFileName: String? = nil, mediaStringContentType: String? = nil, mediaHeight: Int? = nil, mediaWidth: Int? = nil, attachedMedia: Data? = nil, attachedMediaUrl: String? = nil, attachedMediaString: String? = nil, attachedMediaStringFileName: String? = nil, attachedMediaStringContentType: String? = nil, attachedMediaHeight: Int? = nil, attachedMediaWidth: Int? = nil, locationDescription: String? = nil, searchTags: String? = nil, appKey: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/asset/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)"))
                if let albumId = albumId { queryItems.append(URLQueryItem(name: "albumId", value: "\(albumId)")) } 
                if let attachedAssetId = attachedAssetId { queryItems.append(URLQueryItem(name: "attachedAssetId", value: "\(attachedAssetId)")) } 
                if let versionCode = versionCode { queryItems.append(URLQueryItem(name: "versionCode", value: "\(versionCode)")) } 
                if let versionName = versionName { queryItems.append(URLQueryItem(name: "versionName", value: versionName)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let caption = caption { queryItems.append(URLQueryItem(name: "caption", value: caption)) } 
                if let assetType = assetType { queryItems.append(URLQueryItem(name: "assetType", value: assetType)) } 
                if let approvalStatus = approvalStatus { queryItems.append(URLQueryItem(name: "approvalStatus", value: approvalStatus)) } 
                if let assignedAccountId = assignedAccountId { queryItems.append(URLQueryItem(name: "assignedAccountId", value: "\(assignedAccountId)")) } 
                if let media = media { queryItems.append(URLQueryItem(name: "media", value: )) } 
                if let mediaUrl = mediaUrl { queryItems.append(URLQueryItem(name: "mediaUrl", value: mediaUrl)) } 
                if let mediaString = mediaString { queryItems.append(URLQueryItem(name: "mediaString", value: mediaString)) } 
                if let mediaStringFileName = mediaStringFileName { queryItems.append(URLQueryItem(name: "mediaStringFileName", value: mediaStringFileName)) } 
                if let mediaStringContentType = mediaStringContentType { queryItems.append(URLQueryItem(name: "mediaStringContentType", value: mediaStringContentType)) } 
                if let mediaHeight = mediaHeight { queryItems.append(URLQueryItem(name: "mediaHeight", value: "\(mediaHeight)")) } 
                if let mediaWidth = mediaWidth { queryItems.append(URLQueryItem(name: "mediaWidth", value: "\(mediaWidth)")) } 
                if let attachedMedia = attachedMedia { queryItems.append(URLQueryItem(name: "attachedMedia", value: )) } 
                if let attachedMediaUrl = attachedMediaUrl { queryItems.append(URLQueryItem(name: "attachedMediaUrl", value: attachedMediaUrl)) } 
                if let attachedMediaString = attachedMediaString { queryItems.append(URLQueryItem(name: "attachedMediaString", value: attachedMediaString)) } 
                if let attachedMediaStringFileName = attachedMediaStringFileName { queryItems.append(URLQueryItem(name: "attachedMediaStringFileName", value: attachedMediaStringFileName)) } 
                if let attachedMediaStringContentType = attachedMediaStringContentType { queryItems.append(URLQueryItem(name: "attachedMediaStringContentType", value: attachedMediaStringContentType)) } 
                if let attachedMediaHeight = attachedMediaHeight { queryItems.append(URLQueryItem(name: "attachedMediaHeight", value: "\(attachedMediaHeight)")) } 
                if let attachedMediaWidth = attachedMediaWidth { queryItems.append(URLQueryItem(name: "attachedMediaWidth", value: "\(attachedMediaWidth)")) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
