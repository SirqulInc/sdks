//
// BillingInfoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class BillingInfoAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Update Payment Method
    /// - POST /billing/update
    /// - Update a method of payment. If the paymentMethodId is not passed in then will update their default payment method.
    /// - parameter accountId: (query) The account used to perform the the request 
    /// - parameter paymentMethodId: (query) Payment Method Id (optional)
    /// - parameter accountName: (query) the name of the account (optional)
    /// - parameter firstName: (query) First Name that the account is filed as (optional)
    /// - parameter lastName: (query) Last Name that the account is filed as (optional)
    /// - parameter address: (query) Address that the account is filed as (optional)
    /// - parameter city: (query) City that the account is filed as (optional)
    /// - parameter state: (query) State that the account is filed as (optional)
    /// - parameter postalCode: (query) Postal Code that the account is filed as (optional)
    /// - parameter country: (query) Country that the account is filed as (optional)
    /// - parameter phone: (query) Phone that the account is filed as (optional)
    /// - parameter creditCardNumber: (query) The full credit card number to store on file (optional)
    /// - parameter expirationDate: (query) The credit card expiration date YYYY-MM (optional)
    /// - parameter ccv: (query) The 3 digit confirmation code (optional)
    /// - parameter accountNumber: (query) The bank account number (optional)
    /// - parameter bankName: (query) The bank name (optional)
    /// - parameter routingNumber: (query) Routing Number (optional)
    /// - parameter defaultPaymentMethod: (query) Default Payment Method (optional)
    /// - parameter paymentMethodNickname: (query) Payment Method Nickname (optional)
    /// - parameter taxId: (query) Tax Id (optional)
    /// - parameter providerCustomerProfileId: (query) Provider customer profile Id (optional)
    /// - parameter providerPaymentProfileId: (query) Provider customer payment profile Id (optional)
    /// - parameter metaData: (query) Meta Data (optional)
    /// - returns: AnyPublisher<PaymentTypesResponse, Error> 
    open func addPaymentMethod(accountId: Int64, paymentMethodId: Int64? = nil, accountName: String? = nil, firstName: String? = nil, lastName: String? = nil, address: String? = nil, city: String? = nil, state: String? = nil, postalCode: String? = nil, country: String? = nil, phone: String? = nil, creditCardNumber: String? = nil, expirationDate: String? = nil, ccv: String? = nil, accountNumber: String? = nil, bankName: String? = nil, routingNumber: String? = nil, defaultPaymentMethod: Bool? = nil, paymentMethodNickname: String? = nil, taxId: String? = nil, providerCustomerProfileId: String? = nil, providerPaymentProfileId: String? = nil, metaData: String? = nil) -> AnyPublisher<PaymentTypesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/billing/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                if let accountName = accountName { queryItems.append(URLQueryItem(name: "accountName", value: accountName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let address = address { queryItems.append(URLQueryItem(name: "address", value: address)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let phone = phone { queryItems.append(URLQueryItem(name: "phone", value: phone)) } 
                if let creditCardNumber = creditCardNumber { queryItems.append(URLQueryItem(name: "creditCardNumber", value: creditCardNumber)) } 
                if let expirationDate = expirationDate { queryItems.append(URLQueryItem(name: "expirationDate", value: expirationDate)) } 
                if let ccv = ccv { queryItems.append(URLQueryItem(name: "ccv", value: ccv)) } 
                if let accountNumber = accountNumber { queryItems.append(URLQueryItem(name: "accountNumber", value: accountNumber)) } 
                if let bankName = bankName { queryItems.append(URLQueryItem(name: "bankName", value: bankName)) } 
                if let routingNumber = routingNumber { queryItems.append(URLQueryItem(name: "routingNumber", value: routingNumber)) } 
                if let defaultPaymentMethod = defaultPaymentMethod { queryItems.append(URLQueryItem(name: "defaultPaymentMethod", value: defaultPaymentMethod ? "true" : "false")) } 
                if let paymentMethodNickname = paymentMethodNickname { queryItems.append(URLQueryItem(name: "paymentMethodNickname", value: paymentMethodNickname)) } 
                if let taxId = taxId { queryItems.append(URLQueryItem(name: "taxId", value: taxId)) } 
                if let providerCustomerProfileId = providerCustomerProfileId { queryItems.append(URLQueryItem(name: "providerCustomerProfileId", value: providerCustomerProfileId)) } 
                if let providerPaymentProfileId = providerPaymentProfileId { queryItems.append(URLQueryItem(name: "providerPaymentProfileId", value: providerPaymentProfileId)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaymentTypesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PaymentTypesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Payment Method
    /// - POST /billing/create
    /// - Add a new method of payment.
    /// - parameter accountId: (query) The account used to perform the the request 
    /// - parameter accountName: (query) Account Name of the credit card user (optional)
    /// - parameter firstName: (query) The first name on the credit card (optional)
    /// - parameter lastName: (query) The last name on the credit card (optional)
    /// - parameter address: (query) The billing address of the credit card (optional)
    /// - parameter city: (query) The billing city of the credit card (optional)
    /// - parameter state: (query) The billing state of the credit card (optional)
    /// - parameter postalCode: (query) The billing zip code of the credit card (optional)
    /// - parameter country: (query) Country of the credit card (optional)
    /// - parameter phone: (query) The billing phone of the credit card (optional)
    /// - parameter creditCardNumber: (query) The full credit card number to store on file (optional)
    /// - parameter expirationDate: (query) The credit card expiration date YYYY-MM (optional)
    /// - parameter ccv: (query) The 3 digit confirmation code (optional)
    /// - parameter accountNumber: (query) The bank account number (optional)
    /// - parameter bankName: (query) The bank name (optional)
    /// - parameter routingNumber: (query) The bank routing number (optional)
    /// - parameter paymentMethodNickname: (query) The nickname to give the payment method (optional)
    /// - parameter taxId: (query) Tax Id (optional)
    /// - parameter defaultPaymentMethod: (query) Whether this should be the default payment method (optional, default to true)
    /// - parameter authToken: (query) An authorization token for providers that provide this (like Amazon Payments) (optional)
    /// - parameter provider: (query) The payment provider (see PaymentMethodProvider) (optional, default to "AUTHORIZE_NET")
    /// - parameter providerCustomerProfileId: (query) Provider customer profile Id (optional)
    /// - parameter providerPaymentProfileId: (query) Provider customer payment profile Id (optional)
    /// - parameter metaData: (query) Meta Data (optional)
    /// - parameter appKey: (query) Application Key (optional)
    /// - returns: AnyPublisher<PaymentTypesResponse, Error> 
    open func createPaymentMethod(accountId: Int64, accountName: String? = nil, firstName: String? = nil, lastName: String? = nil, address: String? = nil, city: String? = nil, state: String? = nil, postalCode: String? = nil, country: String? = nil, phone: String? = nil, creditCardNumber: String? = nil, expirationDate: String? = nil, ccv: String? = nil, accountNumber: String? = nil, bankName: String? = nil, routingNumber: String? = nil, paymentMethodNickname: String? = nil, taxId: String? = nil, defaultPaymentMethod: Bool? = nil, authToken: String? = nil, provider: String? = nil, providerCustomerProfileId: String? = nil, providerPaymentProfileId: String? = nil, metaData: String? = nil, appKey: String? = nil) -> AnyPublisher<PaymentTypesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/billing/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let accountName = accountName { queryItems.append(URLQueryItem(name: "accountName", value: accountName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let address = address { queryItems.append(URLQueryItem(name: "address", value: address)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let phone = phone { queryItems.append(URLQueryItem(name: "phone", value: phone)) } 
                if let creditCardNumber = creditCardNumber { queryItems.append(URLQueryItem(name: "creditCardNumber", value: creditCardNumber)) } 
                if let expirationDate = expirationDate { queryItems.append(URLQueryItem(name: "expirationDate", value: expirationDate)) } 
                if let ccv = ccv { queryItems.append(URLQueryItem(name: "ccv", value: ccv)) } 
                if let accountNumber = accountNumber { queryItems.append(URLQueryItem(name: "accountNumber", value: accountNumber)) } 
                if let bankName = bankName { queryItems.append(URLQueryItem(name: "bankName", value: bankName)) } 
                if let routingNumber = routingNumber { queryItems.append(URLQueryItem(name: "routingNumber", value: routingNumber)) } 
                if let paymentMethodNickname = paymentMethodNickname { queryItems.append(URLQueryItem(name: "paymentMethodNickname", value: paymentMethodNickname)) } 
                if let taxId = taxId { queryItems.append(URLQueryItem(name: "taxId", value: taxId)) } 
                if let defaultPaymentMethod = defaultPaymentMethod { queryItems.append(URLQueryItem(name: "defaultPaymentMethod", value: defaultPaymentMethod ? "true" : "false")) } 
                if let authToken = authToken { queryItems.append(URLQueryItem(name: "authToken", value: authToken)) } 
                if let provider = provider { queryItems.append(URLQueryItem(name: "provider", value: provider)) } 
                if let providerCustomerProfileId = providerCustomerProfileId { queryItems.append(URLQueryItem(name: "providerCustomerProfileId", value: providerCustomerProfileId)) } 
                if let providerPaymentProfileId = providerPaymentProfileId { queryItems.append(URLQueryItem(name: "providerPaymentProfileId", value: providerPaymentProfileId)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaymentTypesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PaymentTypesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Smart Contract
    /// - POST /billing/crypto/transfer
    /// - Adds a smart contract.
    /// - parameter accountId: (query) The account used to perform the the request 
    /// - parameter tokenName: (query) The token name 
    /// - parameter tokenSymbol: (query) The token symbol 
    /// - parameter paymentMethodId: (query) The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
    /// - returns: AnyPublisher<PaymentTypesResponse, Error> 
    open func createSmartContract(accountId: Int64, tokenName: String, tokenSymbol: String, paymentMethodId: Int64? = nil) -> AnyPublisher<PaymentTypesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/billing/crypto/transfer"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                queryItems.append(URLQueryItem(name: "tokenName", value: tokenName))
                queryItems.append(URLQueryItem(name: "tokenSymbol", value: tokenSymbol))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaymentTypesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PaymentTypesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Crypto Balances
    /// - GET /billing/crypto/get
    /// - Get the cypto balance details for a user
    /// - parameter accountId: (query) The account used to perform the the request 
    /// - parameter ownerAccountId: (query) The account to retreive balances for (optional)
    /// - parameter paymentMethodId: (query) The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
    /// - returns: AnyPublisher<PaymentTypesResponse, Error> 
    open func getCryptoBalance(accountId: Int64, ownerAccountId: Int64? = nil, paymentMethodId: Int64? = nil) -> AnyPublisher<PaymentTypesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/billing/crypto/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let ownerAccountId = ownerAccountId { queryItems.append(URLQueryItem(name: "ownerAccountId", value: "\(ownerAccountId)")) } 
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaymentTypesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PaymentTypesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Payment Method
    /// - GET /billing/get
    /// - Get the details of the user's payment method or their current default method of payment
    /// - parameter accountId: (query) The account used to perform the the request 
    /// - parameter paymentMethodId: (query) The payment method to return details on. If this is not set, then the user&#39;s default payment method will be returned. (optional)
    /// - parameter getCurrentBalance: (query) Determines whether to get the user&#39;s current balance for the requested payment method option (not all payment method options support this) (optional)
    /// - returns: AnyPublisher<PaymentTypesResponse, Error> 
    open func getPaymentMethod(accountId: Int64, paymentMethodId: Int64? = nil, getCurrentBalance: Bool? = nil) -> AnyPublisher<PaymentTypesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/billing/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                if let getCurrentBalance = getCurrentBalance { queryItems.append(URLQueryItem(name: "getCurrentBalance", value: getCurrentBalance ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaymentTypesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PaymentTypesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Payment Methods
    /// - GET /billing/search
    /// - Search the payment methods of an account
    /// - parameter accountId: (query) Account Id to search on 
    /// - parameter provider: (query) Provider to search on (optional, default to "AUTHORIZE_NET")
    /// - parameter type: (query) the type to search on (optional)
    /// - parameter keyword: (query) the keyword to search on (optional)
    /// - parameter sortField: (query) the sort field to use for the search (optional, default to "UPDATED")
    /// - parameter descending: (query) if the results should be in descending order (optional, default to true)
    /// - parameter start: (query) the start of the search (optional, default to 0)
    /// - parameter limit: (query) the limit of the search (optional, default to 5)
    /// - returns: AnyPublisher<PaymentTypesResponse, Error> 
    open func searchPaymentMethod(accountId: Int64, provider: String? = nil, type: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<PaymentTypesResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/billing/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let provider = provider { queryItems.append(URLQueryItem(name: "provider", value: provider)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PaymentTypesResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PaymentTypesResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
