//
// EmployeeAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class EmployeeAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Assign Employee
    /// - POST /employee/assign
    /// - Assign An existing account to be an employee
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter managerAccountId: (query) The account id of the manager to assign under 
    /// - parameter employeeAccountId: (query) The account id of the user to be assigned as employee 
    /// - parameter role: (query) The role to assign to the employee (e.g. RETAILER or RETAILER_LIMITED) (optional)
    /// - returns: AnyPublisher<EmployeeResponse, Error> 
    open func assignEmployee(accountId: Int64, managerAccountId: Int64, employeeAccountId: Int64, role: String? = nil) -> AnyPublisher<EmployeeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/assign"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "managerAccountId", value: "\(managerAccountId)"))
                queryItems.append(URLQueryItem(name: "employeeAccountId", value: "\(employeeAccountId)"))
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmployeeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(EmployeeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Assign Employee to Location
    /// - POST /employee/assignToLocation
    /// - Assign or unassign the account to a retailer location.
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter retailerLocationId: (query) The retailer location to apply the change to 
    /// - parameter employeeAccountId: (query) The account id of the user to apply the change to (optional)
    /// - parameter assign: (query) If true (default) assign to the location, otherwise remove from the retailer (optional, default to true)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func assignToLocationEmployee(accountId: Int64, retailerLocationId: Int64, employeeAccountId: Int64? = nil, assign: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/assignToLocation"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let employeeAccountId = employeeAccountId { queryItems.append(URLQueryItem(name: "employeeAccountId", value: "\(employeeAccountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)"))
                if let assign = assign { queryItems.append(URLQueryItem(name: "assign", value: assign ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter gender
    ///
    public enum CreateEmployeeGender: String, Codable, CaseIterable {
        case male = "MALE"
        case female = "FEMALE"
        case any = "ANY"
    }

    /// Create Employee
    /// - POST /employee/create
    /// - Create a new account record with the provided information.
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter managerAccountId: (query) The account id of the manager to assign under 
    /// - parameter username: (query) The username/email for the new user. This must be unique across the entire the system. 
    /// - parameter password: (query) The password for the new user 
    /// - parameter name: (query) a name field (optional)
    /// - parameter prefixName: (query) The name prefix; Mr, Mrs, etc (optional)
    /// - parameter firstName: (query) The first name (optional)
    /// - parameter middleName: (query) The middle name (optional)
    /// - parameter lastName: (query) The last name (optional)
    /// - parameter suffixName: (query) The name suffix; Jr, Sr, III, etc (optional)
    /// - parameter title: (query) The title of the user (optional)
    /// - parameter aboutUs: (query) Additional about/biography text (optional)
    /// - parameter assetId: (query) the asset id to set the user&#39;s profile image (optional)
    /// - parameter gender: (query) The gender (optional)
    /// - parameter homePhone: (query) The home phone number (optional)
    /// - parameter cellPhone: (query) The cellular phone number (optional)
    /// - parameter cellPhoneCarrier: (query) The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. (optional)
    /// - parameter businessPhone: (query) The business phone number (optional)
    /// - parameter emailAddress: (query) The user&#39;s contact email address (NOT the username) (optional)
    /// - parameter streetAddress: (query) The street address of the user&#39;s contact location (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the user&#39;s contact location (optional)
    /// - parameter state: (query) The state of the user&#39;s contact location (optional)
    /// - parameter zipcode: (query) The zipcode of the user&#39;s contact location (optional)
    /// - parameter country: (query) The country of the user&#39;s contact location (optional)
    /// - parameter role: (query) The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
    /// - parameter retailerLocationIds: (query) the retailer location IDs the employee is associated with (optional)
    /// - parameter settingsAppKey: (query) Determines whether to return the application settings for the employee for a particular application (optional)
    /// - parameter appBlob: (query) external custom client defined data (per Application) (optional)
    /// - parameter assignedDeviceId: (query) The device id to assign to the user (used for IPS beacon tracking) (optional)
    /// - returns: AnyPublisher<EmployeeResponse, Error> 
    open func createEmployee(accountId: Int64, managerAccountId: Int64, username: String, password: String, name: String? = nil, prefixName: String? = nil, firstName: String? = nil, middleName: String? = nil, lastName: String? = nil, suffixName: String? = nil, title: String? = nil, aboutUs: String? = nil, assetId: Int64? = nil, gender: CreateEmployeeGender? = nil, homePhone: String? = nil, cellPhone: String? = nil, cellPhoneCarrier: String? = nil, businessPhone: String? = nil, emailAddress: String? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, country: String? = nil, role: String? = nil, retailerLocationIds: String? = nil, settingsAppKey: String? = nil, appBlob: String? = nil, assignedDeviceId: String? = nil) -> AnyPublisher<EmployeeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "managerAccountId", value: "\(managerAccountId)"))
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let prefixName = prefixName { queryItems.append(URLQueryItem(name: "prefixName", value: prefixName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let middleName = middleName { queryItems.append(URLQueryItem(name: "middleName", value: middleName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let suffixName = suffixName { queryItems.append(URLQueryItem(name: "suffixName", value: suffixName)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let aboutUs = aboutUs { queryItems.append(URLQueryItem(name: "aboutUs", value: aboutUs)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender.rawValue)) } 
                if let homePhone = homePhone { queryItems.append(URLQueryItem(name: "homePhone", value: homePhone)) } 
                if let cellPhone = cellPhone { queryItems.append(URLQueryItem(name: "cellPhone", value: cellPhone)) } 
                if let cellPhoneCarrier = cellPhoneCarrier { queryItems.append(URLQueryItem(name: "cellPhoneCarrier", value: cellPhoneCarrier)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let zipcode = zipcode { queryItems.append(URLQueryItem(name: "zipcode", value: zipcode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let settingsAppKey = settingsAppKey { queryItems.append(URLQueryItem(name: "settingsAppKey", value: settingsAppKey)) } 
                if let appBlob = appBlob { queryItems.append(URLQueryItem(name: "appBlob", value: appBlob)) } 
                if let assignedDeviceId = assignedDeviceId { queryItems.append(URLQueryItem(name: "assignedDeviceId", value: assignedDeviceId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmployeeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(EmployeeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Employee
    /// - POST /employee/delete
    /// - Set the deleted date field which marks the record as deleted.
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter employeeAccountId: (query) the id of the employee to delete 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteEmployee(accountId: Int64, employeeAccountId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "employeeAccountId", value: "\(employeeAccountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Employee
    /// - POST /employee/get
    /// - Get the account record for the account id provided.
    /// - parameter accountId: (query) the id of logged in user 
    /// - parameter employeeAccountId: (query) the id of the employee account to get 
    /// - parameter settingsAppKey: (query) Determines whether to return the application settings for the employee for a particular application (optional)
    /// - returns: AnyPublisher<EmployeeResponse, Error> 
    open func getEmployee(accountId: Int64, employeeAccountId: Int64, settingsAppKey: String? = nil) -> AnyPublisher<EmployeeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "employeeAccountId", value: "\(employeeAccountId)"))
                if let settingsAppKey = settingsAppKey { queryItems.append(URLQueryItem(name: "settingsAppKey", value: settingsAppKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmployeeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(EmployeeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchEmployeesSortField: String, Codable, CaseIterable {
        case id = "ID"
        case display = "DISPLAY"
        case created = "CREATED"
        case updated = "UPDATED"
        case active = "ACTIVE"
        case deleted = "DELETED"
        case lastLoggedIn = "LAST_LOGGED_IN"
        case contactEmail = "CONTACT_EMAIL"
        case accountType = "ACCOUNT_TYPE"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case retailerName = "RETAILER_NAME"
    }

    /// Search Employees
    /// - POST /employee/search
    /// - Use the accountId to determine the associated BillableEntity. From there get a list of all accounts associated as managers/employees.
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter role: (query) The role to limit the search to: RETAILER or RETAILER_LIMITED. Leave empty to search on both roles. (optional)
    /// - parameter retailerId: (query) Filters employees by retailer (optional)
    /// - parameter retailerLocationId: (query) Filter employees by retailer locations (optional)
    /// - parameter q: (query) Deprecated parameter (optional)
    /// - parameter keyword: (query) an optional keyword to search on; ignored if empty (optional)
    /// - parameter sortField: (query) The field to sort by. Possible values include: DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME (optional)
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional, default to false)
    /// - parameter i: (query) Deprecated parameter (optional)
    /// - parameter start: (query) Start the result set at some index (optional, default to 0)
    /// - parameter l: (query) Deprecated parameter (optional)
    /// - parameter limit: (query) Limit the result to some number (optional, default to 20)
    /// - parameter activeOnly: (query) Filter results to only return active employees (optional, default to true)
    /// - parameter managedOnly: (query) Filter results to only employees that you manage (optional)
    /// - parameter settingsAppKey: (query) Determines whether to return the application settings for the employee for a particular application (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids to filter results (optional)
    /// - parameter query: (query) Legacy/reporting query parameter used for formatting employee responses (optional)
    /// - returns: AnyPublisher<[EmployeeResponse], Error> 
    open func searchEmployees(accountId: Int64, role: String? = nil, retailerId: Int64? = nil, retailerLocationId: Int64? = nil, q: String? = nil, keyword: String? = nil, sortField: SearchEmployeesSortField? = nil, descending: Bool? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, managedOnly: Bool? = nil, settingsAppKey: String? = nil, categoryIds: String? = nil, query: String? = nil) -> AnyPublisher<[EmployeeResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let managedOnly = managedOnly { queryItems.append(URLQueryItem(name: "managedOnly", value: managedOnly ? "true" : "false")) } 
                if let settingsAppKey = settingsAppKey { queryItems.append(URLQueryItem(name: "settingsAppKey", value: settingsAppKey)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let query = query { queryItems.append(URLQueryItem(name: "query", value: query)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[EmployeeResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([EmployeeResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Unassign Employee
    /// - POST /employee/unassign
    /// - Unassign An existing account to be an employee
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter employeeAccountId: (query) The account id of the user to be unassigned 
    /// - returns: AnyPublisher<EmployeeResponse, Error> 
    open func unassignEmployee(accountId: Int64, employeeAccountId: Int64) -> AnyPublisher<EmployeeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/unassign"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "employeeAccountId", value: "\(employeeAccountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmployeeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(EmployeeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter gender
    ///
    public enum UpdateEmployeeGender: String, Codable, CaseIterable {
        case male = "MALE"
        case female = "FEMALE"
        case any = "ANY"
    }

    /// Update Employee
    /// - POST /employee/update
    /// - Update the account record with the provided information.
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter employeeAccountId: (query) the id of the employee account 
    /// - parameter managerAccountId: (query) The account id of the manager to assign under (optional)
    /// - parameter name: (query) a name field (optional)
    /// - parameter prefixName: (query) The name prefix; Mr, Mrs, etc (optional)
    /// - parameter firstName: (query) The first name (optional)
    /// - parameter middleName: (query) The middle name (optional)
    /// - parameter lastName: (query) The last name (optional)
    /// - parameter suffixName: (query) The name suffix; Jr, Sr, III, etc (optional)
    /// - parameter title: (query) The title of the user (optional)
    /// - parameter assetId: (query) the asset id to set the user&#39;s profile image (optional)
    /// - parameter gender: (query) The gender {MALE, FEMALE, ANY} (optional)
    /// - parameter homePhone: (query) The home phone number (optional)
    /// - parameter cellPhone: (query) The cellular phone number (optional)
    /// - parameter cellPhoneCarrier: (query) The cellular service provider. This is required for sending SMS. Leave this empty if the provider is not on the list of supported carriers. Supported Carriers: {ATT, QWEST, T_MOBILE, VERIZON, SPRINT, VIRIGIN_MOBILE, NEXTEL, ALLTEL, METRO_PCS, POWERTEL, BOOST_MOBILE, SUNCOM, TRACFONE, US_CELLULAR} (optional)
    /// - parameter businessPhone: (query) The business phone number (optional)
    /// - parameter emailAddress: (query) The user&#39;s contact email address (NOT the username) (optional)
    /// - parameter streetAddress: (query) The street address of the user&#39;s contact location (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the user&#39;s contact location (optional)
    /// - parameter state: (query) The state of the user&#39;s contact location (optional)
    /// - parameter zipcode: (query) The zipcode of the user&#39;s contact location (optional)
    /// - parameter country: (query) The country of the user&#39;s contact location (optional)
    /// - parameter role: (query) The role; RETAILER or RETAILER_LIMITED, defaulted to RETAILER_LIMITED (optional)
    /// - parameter active: (query) Sets whether the employee is active or inactive (optional)
    /// - parameter password: (query) Sets the password for the employee (optional)
    /// - parameter retailerLocationIds: (query) Sets which retailer locations the employee is assigned to (optional)
    /// - parameter settingsAppKey: (query) Determines whether to return the application settings for the employee for a particular application (optional)
    /// - parameter appBlob: (query) external custom client defined data (per Application) (optional)
    /// - parameter assignedDeviceId: (query) The device id to assign to the user (used for IPS beacon tracking) (optional)
    /// - returns: AnyPublisher<EmployeeResponse, Error> 
    open func updateEmployee(accountId: Int64, employeeAccountId: Int64, managerAccountId: Int64? = nil, name: String? = nil, prefixName: String? = nil, firstName: String? = nil, middleName: String? = nil, lastName: String? = nil, suffixName: String? = nil, title: String? = nil, assetId: Int64? = nil, gender: UpdateEmployeeGender? = nil, homePhone: String? = nil, cellPhone: String? = nil, cellPhoneCarrier: String? = nil, businessPhone: String? = nil, emailAddress: String? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, country: String? = nil, role: String? = nil, active: Bool? = nil, password: String? = nil, retailerLocationIds: String? = nil, settingsAppKey: String? = nil, appBlob: String? = nil, assignedDeviceId: String? = nil) -> AnyPublisher<EmployeeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/employee/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "employeeAccountId", value: "\(employeeAccountId)"))
                if let managerAccountId = managerAccountId { queryItems.append(URLQueryItem(name: "managerAccountId", value: "\(managerAccountId)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let prefixName = prefixName { queryItems.append(URLQueryItem(name: "prefixName", value: prefixName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let middleName = middleName { queryItems.append(URLQueryItem(name: "middleName", value: middleName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let suffixName = suffixName { queryItems.append(URLQueryItem(name: "suffixName", value: suffixName)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender.rawValue)) } 
                if let homePhone = homePhone { queryItems.append(URLQueryItem(name: "homePhone", value: homePhone)) } 
                if let cellPhone = cellPhone { queryItems.append(URLQueryItem(name: "cellPhone", value: cellPhone)) } 
                if let cellPhoneCarrier = cellPhoneCarrier { queryItems.append(URLQueryItem(name: "cellPhoneCarrier", value: cellPhoneCarrier)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let zipcode = zipcode { queryItems.append(URLQueryItem(name: "zipcode", value: zipcode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let password = password { queryItems.append(URLQueryItem(name: "password", value: password)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let settingsAppKey = settingsAppKey { queryItems.append(URLQueryItem(name: "settingsAppKey", value: settingsAppKey)) } 
                if let appBlob = appBlob { queryItems.append(URLQueryItem(name: "appBlob", value: appBlob)) } 
                if let assignedDeviceId = assignedDeviceId { queryItems.append(URLQueryItem(name: "assignedDeviceId", value: assignedDeviceId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<EmployeeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(EmployeeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
