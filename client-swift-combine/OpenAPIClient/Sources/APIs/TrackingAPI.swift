//
// TrackingAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class TrackingAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Batch Tracking
    /// - POST /api/{version}/tracking/batch/create
    /// - Batch create tracking legs
    /// - parameter version: (path)  
    /// - parameter data: (query) JSON array of tracking legs &#x60;&#x60;&#x60;json [   \&quot;distance\&quot;: \&quot;0.08\&quot;,   \&quot;duration\&quot;: \&quot;10000\&quot;,   \&quot;startLatitude\&quot;: \&quot;47.614603\&quot;,   \&quot;startLongitude\&quot;: \&quot;-122.350518\&quot;,   \&quot;endLatitude\&quot;: \&quot;47.614384\&quot;,   \&quot;endLongitude\&quot;: \&quot;-122.349161\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endDate\&quot;: \&quot;1361924020000\&quot;,   \&quot;steps\&quot;: [     {       \&quot;distance\&quot;: \&quot;0.03\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614603\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,       \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614941\&quot;,       \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;endDate\&quot;: \&quot;1361924015000\&quot;     },{       \&quot;distance\&quot;: \&quot;0.05\&quot;,       \&quot;duration\&quot;: \&quot;5000\&quot;,       \&quot;startLat\&quot;: \&quot;47.614941\&quot;,       \&quot;startLng\&quot;: \&quot;-122.350062\&quot;,       \&quot;startDate\&quot;: \&quot;1361924015000\&quot;,       \&quot;endLat\&quot;: \&quot;47.614384\&quot;,       \&quot;endLng\&quot;: \&quot;-122.349161\&quot;,       \&quot;endDate\&quot;: \&quot;1361924020000\&quot;     }   ] ] &#x60;&#x60;&#x60;  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter generateAccounts: (query) Whether to generate accounts for tracking entries when the owner does not exist (optional)
    /// - parameter updateAccountLocations: (query) Whether to update the account&#39;s current location from the incoming tracking data (optional)
    /// - parameter defaultTag: (query) The default tag to apply to incoming legs when no tag is provided (optional, default to "PASSIVE")
    /// - parameter slaveUID: (query)  (optional)
    /// - returns: AnyPublisher<[Leg], Error> 
    open func batchSaveTracking(version: Double, data: String, deviceId: String? = nil, accountId: Int64? = nil, generateAccounts: Bool? = nil, updateAccountLocations: Bool? = nil, defaultTag: String? = nil, slaveUID: String? = nil) -> AnyPublisher<[Leg], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/batch/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "data", value: data))
                if let generateAccounts = generateAccounts { queryItems.append(URLQueryItem(name: "generateAccounts", value: generateAccounts ? "true" : "false")) } 
                if let updateAccountLocations = updateAccountLocations { queryItems.append(URLQueryItem(name: "updateAccountLocations", value: updateAccountLocations ? "true" : "false")) } 
                if let defaultTag = defaultTag { queryItems.append(URLQueryItem(name: "defaultTag", value: defaultTag)) } 
                if let slaveUID = slaveUID { queryItems.append(URLQueryItem(name: "slaveUID", value: slaveUID)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Leg], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Leg].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter distanceUnit
    ///
    public enum GetPredictedLocationsDistanceUnit: String, Codable, CaseIterable {
        case miles = "MILES"
        case kilometers = "KILOMETERS"
    }
    ///
    /// Enum for parameter sortOrder
    ///
    public enum GetPredictedLocationsSortOrder: String, Codable, CaseIterable {
        case matches = "MATCHES"
        case distance = "DISTANCE"
        case weighted = "WEIGHTED"
    }

    /// Get Predicted Locations
    /// - GET /api/{version}/tracking/predicted/get
    /// - Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the customer 
    /// - parameter latitude: (query) latitude to return a more likely result set based on the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude to return a more likely result set based on the user&#39;s current location (optional)
    /// - parameter dateCheck: (query) Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, the current date will be used. (optional)
    /// - parameter hourCheck: (query) Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
    /// - parameter threshold: (query) The minimum number matches in 1 hour to be considered a likely location. (optional, default to 1)
    /// - parameter distanceUnit: (query) Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to .miles)
    /// - parameter searchRange: (query) Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
    /// - parameter sortOrder: (query) The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED} (optional, default to .matches)
    /// - returns: AnyPublisher<PredictedLocationResponse, Error> 
    open func getPredictedLocations(version: Double, accountId: Int64, latitude: Double? = nil, longitude: Double? = nil, dateCheck: Int64? = nil, hourCheck: String? = nil, threshold: Int64? = nil, distanceUnit: GetPredictedLocationsDistanceUnit? = nil, searchRange: Double? = nil, sortOrder: GetPredictedLocationsSortOrder? = nil) -> AnyPublisher<PredictedLocationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/predicted/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let dateCheck = dateCheck { queryItems.append(URLQueryItem(name: "dateCheck", value: "\(dateCheck)")) } 
                if let hourCheck = hourCheck { queryItems.append(URLQueryItem(name: "hourCheck", value: hourCheck)) } 
                if let threshold = threshold { queryItems.append(URLQueryItem(name: "threshold", value: "\(threshold)")) } 
                if let distanceUnit = distanceUnit { queryItems.append(URLQueryItem(name: "distanceUnit", value: distanceUnit.rawValue)) } 
                if let searchRange = searchRange { queryItems.append(URLQueryItem(name: "searchRange", value: "\(searchRange)")) } 
                if let sortOrder = sortOrder { queryItems.append(URLQueryItem(name: "sortOrder", value: sortOrder.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PredictedLocationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PredictedLocationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Tracking Path
    /// - GET /api/{version}/tracking/path/get
    /// - Get the path (lat/long coordinates) between 2 steps previously logged for a customer.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the customer 
    /// - parameter startStepId: (query) The stepId to begin from 
    /// - parameter endStepId: (query) The stepId to end with 
    /// - returns: AnyPublisher<[StepResponse], Error> 
    open func getPredictedPath(version: Double, accountId: Int64, startStepId: Int64, endStepId: Int64) -> AnyPublisher<[StepResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/path/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "startStepId", value: "\(startStepId)"))
                queryItems.append(URLQueryItem(name: "endStepId", value: "\(endStepId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[StepResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([StepResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter distanceUnit
    ///
    public enum GetPreferredLocationsDistanceUnit: String, Codable, CaseIterable {
        case miles = "MILES"
        case kilometers = "KILOMETERS"
    }

    /// Search Preferred Locations
    /// - GET /api/{version}/tracking/preferred/search
    /// - Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the customer 
    /// - parameter latitude: (query) latitude to return a more likely result set based on the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude to return a more likely result set based on the user&#39;s current location (optional)
    /// - parameter dateCheck: (query) Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow&#39;s date (timestamp in milliseconds). If no value is passed in, results from all time will be returned. (optional)
    /// - parameter hourCheck: (query) Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \&quot;8,9,10,11,17,18,19,20\&quot;. (optional)
    /// - parameter sortField: (query) Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location (optional, default to "PREFERRED_DATE")
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional, default to true)
    /// - parameter start: (query) The start index for pagination (optional, default to 0)
    /// - parameter limit: (query) The limit for pagination (optional, default to 20)
    /// - parameter searchRange: (query) Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \&quot;0\&quot; (zero) will ignore the radius restriction. (optional, default to 0)
    /// - parameter distanceUnit: (query) Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS} (optional, default to .miles)
    /// - returns: AnyPublisher<[PreferredLocationResponse], Error> 
    open func getPreferredLocations(version: Double, accountId: Int64, latitude: Double? = nil, longitude: Double? = nil, dateCheck: Int64? = nil, hourCheck: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, searchRange: Double? = nil, distanceUnit: GetPreferredLocationsDistanceUnit? = nil) -> AnyPublisher<[PreferredLocationResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/preferred/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let dateCheck = dateCheck { queryItems.append(URLQueryItem(name: "dateCheck", value: "\(dateCheck)")) } 
                if let hourCheck = hourCheck { queryItems.append(URLQueryItem(name: "hourCheck", value: hourCheck)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let searchRange = searchRange { queryItems.append(URLQueryItem(name: "searchRange", value: "\(searchRange)")) } 
                if let distanceUnit = distanceUnit { queryItems.append(URLQueryItem(name: "distanceUnit", value: distanceUnit.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[PreferredLocationResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([PreferredLocationResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Tracking
    /// - GET /api/{version}/tracking/search
    /// - Retrieve tracking data to be able to show where a user has been.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter ownerId: (query) the account id of the person the user wants to tracking data for (optional)
    /// - parameter trackingDeviceId: (query) the id of the tracking device (optional)
    /// - parameter startDate: (query) the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned. (optional)
    /// - parameter endDate: (query) the end date in (UTC milliseconds) to filter the tracking results (optional)
    /// - parameter tags: (query) filter results by tag (optional)
    /// - parameter getLastPoint: (query) gets the last known location of the user (optional, default to false)
    /// - returns: AnyPublisher<[LegResponse], Error> 
    open func getTrackingLegs(version: Double, deviceId: String? = nil, accountId: Int64? = nil, ownerId: Int64? = nil, trackingDeviceId: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, tags: String? = nil, getLastPoint: Bool? = nil) -> AnyPublisher<[LegResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let ownerId = ownerId { queryItems.append(URLQueryItem(name: "ownerId", value: "\(ownerId)")) } 
                if let trackingDeviceId = trackingDeviceId { queryItems.append(URLQueryItem(name: "trackingDeviceId", value: trackingDeviceId)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let getLastPoint = getLastPoint { queryItems.append(URLQueryItem(name: "getLastPoint", value: getLastPoint ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[LegResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([LegResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Tracking Leg
    /// - POST /api/{version}/tracking/leg/create
    /// - Send tracking points to be able to generate pathing data
    /// - parameter version: (path)  
    /// - parameter startLat: (query) the latitude of the first point 
    /// - parameter startLng: (query) the longitude of the first point 
    /// - parameter startDate: (query) the start date (in UTC milliseconds) of the first point 
    /// - parameter endLat: (query) the latitude of the last point 
    /// - parameter endLng: (query) the longitude of the last point 
    /// - parameter endDate: (query) the end date (in UTC milliseconds) of the last point 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter distance: (query) the total distance (optional)
    /// - parameter duration: (query) the total duration (optional)
    /// - parameter steps: (query) JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. &#x60;&#x60;&#x60;json [{   \&quot;distance\&quot;: \&quot;0.03\&quot;,   \&quot;duration\&quot;: \&quot;5000\&quot;,   \&quot;startLat\&quot;: \&quot;47.614603\&quot;,   \&quot;startLng\&quot;: \&quot;-122.350518\&quot;,   \&quot;startDate\&quot;: \&quot;1361924010000\&quot;,   \&quot;endLat\&quot;: \&quot;47.614941\&quot;,   \&quot;endLng\&quot;: \&quot;-122.350062\&quot;,   \&quot;endDate\&quot;: \&quot;1361924015000\&quot; }] &#x60;&#x60;&#x60;  (optional)
    /// - parameter tags: (query) name the leg for searching (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func saveTrackingLeg(version: Double, startLat: Double, startLng: Double, startDate: Int64, endLat: Double, endLng: Double, endDate: Int64, deviceId: String? = nil, accountId: Int64? = nil, distance: Double? = nil, duration: Int64? = nil, steps: String? = nil, tags: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/leg/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let distance = distance { queryItems.append(URLQueryItem(name: "distance", value: "\(distance)")) } 
                if let duration = duration { queryItems.append(URLQueryItem(name: "duration", value: "\(duration)")) } 
                queryItems.append(URLQueryItem(name: "startLat", value: "\(startLat)"))
                queryItems.append(URLQueryItem(name: "startLng", value: "\(startLng)"))
                queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)"))
                queryItems.append(URLQueryItem(name: "endLat", value: "\(endLat)"))
                queryItems.append(URLQueryItem(name: "endLng", value: "\(endLng)"))
                queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)"))
                if let steps = steps { queryItems.append(URLQueryItem(name: "steps", value: steps)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Tracking Step
    /// - POST /api/{version}/tracking/step/create
    /// - Send tracking points to be able to generate pathing data
    /// - parameter version: (path)  
    /// - parameter legId: (query) the leg to add the step to 
    /// - parameter startLat: (query) the latitude of the first point 
    /// - parameter startLng: (query) the longitude of the first point 
    /// - parameter startDate: (query) the start date (in UTC milliseconds) of the first point 
    /// - parameter endLat: (query) the latitude of the last point 
    /// - parameter endLng: (query) the longitude of the last point 
    /// - parameter endDate: (query) the end date (in UTC milliseconds) of the last point 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter distance: (query) the total distance (optional)
    /// - parameter duration: (query) the total duration (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func saveTrackingStep(version: Double, legId: Int64, startLat: Double, startLng: Double, startDate: Int64, endLat: Double, endLng: Double, endDate: Int64, deviceId: String? = nil, accountId: Int64? = nil, distance: Double? = nil, duration: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/step/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "legId", value: "\(legId)"))
                if let distance = distance { queryItems.append(URLQueryItem(name: "distance", value: "\(distance)")) } 
                if let duration = duration { queryItems.append(URLQueryItem(name: "duration", value: "\(duration)")) } 
                queryItems.append(URLQueryItem(name: "startLat", value: "\(startLat)"))
                queryItems.append(URLQueryItem(name: "startLng", value: "\(startLng)"))
                queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)"))
                queryItems.append(URLQueryItem(name: "endLat", value: "\(endLat)"))
                queryItems.append(URLQueryItem(name: "endLng", value: "\(endLng)"))
                queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// List Tracking
    /// - GET /api/{version}/tracking/list
    /// - Search for all accounts that have tracking legs data by the given constraints.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user 
    /// - parameter keyword: (query) Used for LIKE search of first or last name on the acocunt (optional)
    /// - parameter startDate: (query) Range to begin in UTC milliseconds (optional)
    /// - parameter endDate: (query) Range to end in UTC milliseconds (optional)
    /// - parameter tags: (query) Exact match on tag field of Legs&#39;s searchTag (optional)
    /// - parameter audienceIds: (query)  (optional)
    /// - parameter latitude: (query) Origin latitude to perform searching constraints with given range (optional)
    /// - parameter longitude: (query) Origin longitude to perform searching constraints with given range (optional)
    /// - parameter range: (query) The radius, in miles, to perform the search for (optional, default to 5)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY} (optional, default to "LEG_START_DATE")
    /// - parameter descending: (query) The order to return the results. Default is false, which will return the results in ascending order. (optional, default to true)
    /// - parameter start: (query) The index into the record set to start with. Default is 0. (optional, default to 0)
    /// - parameter limit: (query) The total number of records to return. Default is 20. (optional, default to 20)
    /// - parameter activeOnly: (query) Determines whether to return only active results. Default is false. (optional, default to false)
    /// - returns: AnyPublisher<[AccountMiniResponse], Error> 
    open func searchAccountsWithTrackingLegs(version: Double, accountId: Int64, keyword: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, tags: String? = nil, audienceIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil, range: Double? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil) -> AnyPublisher<[AccountMiniResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/list"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let range = range { queryItems.append(URLQueryItem(name: "range", value: "\(range)")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AccountMiniResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AccountMiniResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Tracking (Billable)
    /// - GET /api/{version}/tracking/searchByBillable
    /// - Retrieve tracking data for billable/account scoped queries.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id to search tracking for 
    /// - parameter appKey: (query) The application key 
    /// - parameter trackingDeviceId: (query) The id of the tracking device (optional)
    /// - parameter startDate: (query) The start date in (UTC milliseconds) to filter the tracking results (optional)
    /// - parameter endDate: (query) The end date in (UTC milliseconds) to filter the tracking results (optional)
    /// - parameter tags: (query) Filter results by tag (optional)
    /// - parameter start: (query) The start index for pagination (optional, default to 0)
    /// - parameter limit: (query) The limit for pagination (optional, default to 100)
    /// - returns: AnyPublisher<[LegResponse], Error> 
    open func searchTrackingLegs(version: Double, accountId: Int64, appKey: String, trackingDeviceId: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, tags: String? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[LegResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/tracking/searchByBillable"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let trackingDeviceId = trackingDeviceId { queryItems.append(URLQueryItem(name: "trackingDeviceId", value: trackingDeviceId)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[LegResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([LegResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
