//
// CreativeAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class CreativeAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Add Preview
    /// - POST /creative/addpreview
    /// - Enable this ad for preview for this account.
    /// - parameter accountId: (query) the id of the account 
    /// - parameter creativeId: (query) The id of the creative that want to enable preview. The type of the creative should be CONFIG, otherwise no action will be applied. 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func addPreview(accountId: Int64, creativeId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/addpreview"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "creativeId", value: "\(creativeId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Find Missions
    /// - GET /ads/find
    /// - Get a set of ad filtered by the parameters provided.
    /// - parameter appKey: (query) The application key, if provided return missions specific for the app. Will always return mission levels that are app agnostic. 
    /// - parameter randomize: (query) return a random set of results, default is true. If false returns in nature order. 
    /// - parameter targetedAdsOnly: (query) return only ads targets to the specific app, no global ads. 
    /// - parameter type: (query) The type of ads to get, possible values are: BANNER, LEADERBOARD, SKYSCRAPER, FULL, VIDEO, ZIP, CONFIG. Use this instead of suffix. (optional)
    /// - parameter accountId: (query) The logged in user. (optional)
    /// - parameter appVersion: (query) The version of the application, will not return levels newer than the appVersion. (optional)
    /// - parameter latitude: (query) The current location of the requesting device (optional)
    /// - parameter longitude: (query) The current location of the requesting device (optional)
    /// - parameter device: (query) Should use deviceId if possible. The name of the requesting device; possible values are: Android, iPhone, iPad, iPod, etc. use /audience/devices for list. (optional)
    /// - parameter deviceIdentifier: (query) The device ID of the requesting device, use /audience/devices for list (optional)
    /// - parameter deviceVersion: (query) The requesting device version; examples are: 2.3, 5.1.4, 6.1.4. Supports X, X.X, or X.X.X formated string. (optional)
    /// - parameter start: (query) The index into the record set to start with. (optional)
    /// - parameter limit: (query) The total number of record to return. (optional)
    /// - parameter includeAudiences: (query) If true then return the audience data in the response. Default is false. (optional)
    /// - parameter allocatesTickets: (query) If true/false only return missions whose game levels allocate (or don&#39;t allocate) tickets. Do not provide a value to return both. (optional)
    /// - parameter missionIds: (query) return only ads from the specified campaigns. (optional)
    /// - returns: AnyPublisher<[MissionResponse], Error> 
    open func adsFind(appKey: String, randomize: Bool, targetedAdsOnly: Bool, type: String? = nil, accountId: Int64? = nil, appVersion: String? = nil, latitude: Double? = nil, longitude: Double? = nil, device: String? = nil, deviceIdentifier: Int64? = nil, deviceVersion: String? = nil, start: Int? = nil, limit: Int? = nil, includeAudiences: Bool? = nil, allocatesTickets: Bool? = nil, missionIds: String? = nil) -> AnyPublisher<[MissionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/ads/find"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let device = device { queryItems.append(URLQueryItem(name: "device", value: device)) } 
                if let deviceIdentifier = deviceIdentifier { queryItems.append(URLQueryItem(name: "deviceIdentifier", value: "\(deviceIdentifier)")) } 
                if let deviceVersion = deviceVersion { queryItems.append(URLQueryItem(name: "deviceVersion", value: deviceVersion)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let includeAudiences = includeAudiences { queryItems.append(URLQueryItem(name: "includeAudiences", value: includeAudiences ? "true" : "false")) } 
                if let allocatesTickets = allocatesTickets { queryItems.append(URLQueryItem(name: "allocatesTickets", value: allocatesTickets ? "true" : "false")) } 
                queryItems.append(URLQueryItem(name: "randomize", value: randomize ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "targetedAdsOnly", value: targetedAdsOnly ? "true" : "false"))
                if let missionIds = missionIds { queryItems.append(URLQueryItem(name: "missionIds", value: missionIds)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[MissionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([MissionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Creative
    /// - POST /creative/create
    /// - Create a creative
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter name: (query) The name of the level. 
    /// - parameter active: (query) If true set the game level as active. Default is false. 
    /// - parameter waitForAsset: (query) determines whether the response will wait until the asset gets created 
    /// - parameter description: (query) The description of the level. (optional)
    /// - parameter assetImageId: (query) The asset Id of the level image. (optional)
    /// - parameter action: (query) This parameter is deprecated. deprecated use data field (optional)
    /// - parameter data: (query) The creative data, json based format depending on type. If not using action then data is required. (optional)
    /// - parameter suffix: (query) This parameter is deprecated. deprecated use type field (optional)
    /// - parameter type: (query) The type of creative. If not using suffix then type is required. (optional)
    /// - parameter balance: (query) Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
    /// - parameter referenceId: (query) if creative related so some other content provided the id (optional)
    /// - parameter appVersion: (query) The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives. (optional)
    /// - parameter missionId: (query) Assign the creative to a campaign for timing and audience matching. (optional)
    /// - parameter offerId: (query) the id of the offer (optional)
    /// - returns: AnyPublisher<CreativeResponse, Error> 
    open func createCreative(accountId: Int64, name: String, active: Bool, waitForAsset: Bool, description: String? = nil, assetImageId: Int64? = nil, action: String? = nil, data: String? = nil, suffix: String? = nil, type: String? = nil, balance: Double? = nil, referenceId: Int64? = nil, appVersion: String? = nil, missionId: Int64? = nil, offerId: Int64? = nil) -> AnyPublisher<CreativeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let assetImageId = assetImageId { queryItems.append(URLQueryItem(name: "assetImageId", value: "\(assetImageId)")) } 
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action)) } 
                if let data = data { queryItems.append(URLQueryItem(name: "data", value: data)) } 
                if let suffix = suffix { queryItems.append(URLQueryItem(name: "suffix", value: suffix)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let balance = balance { queryItems.append(URLQueryItem(name: "balance", value: "\(balance)")) } 
                queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false"))
                if let referenceId = referenceId { queryItems.append(URLQueryItem(name: "referenceId", value: "\(referenceId)")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                queryItems.append(URLQueryItem(name: "waitForAsset", value: waitForAsset ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CreativeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CreativeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Creative
    /// - POST /creative/delete
    /// - Delete a creative
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter creativeId: (query) the id of the creative to delete 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteCreative(accountId: Int64, creativeId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "creativeId", value: "\(creativeId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Creative
    /// - GET /creative/get
    /// - Get a creative
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter creativeId: (query) the ID of the creative to get 
    /// - returns: AnyPublisher<CreativeResponse, Error> 
    open func getCreative(accountId: Int64, creativeId: Int64) -> AnyPublisher<CreativeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "creativeId", value: "\(creativeId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CreativeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CreativeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Creatives
    /// - GET /creative/search
    /// - Get a list of levels for an application, just those the account has permissions to view.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) the application key 
    /// - parameter start: (query) Start the result set at some index. 
    /// - parameter limit: (query) Limit the result to some number. 
    /// - parameter missionId: (query) Creatives contained in the provided mission. (optional)
    /// - parameter keyword: (query) Match the keyword to the owner name or level name. (optional)
    /// - returns: AnyPublisher<[CreativeResponse], Error> 
    open func getCreativesByApplication(accountId: Int64, appKey: String, start: Int, limit: Int, missionId: Int64? = nil, keyword: String? = nil) -> AnyPublisher<[CreativeResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[CreativeResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([CreativeResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Remove Preview
    /// - POST /creative/removepreview
    /// - Remove this ad for preview for this account.
    /// - parameter accountId: (query) the ID of the logged in user 
    /// - parameter creativeId: (query) the ID of the creative to remove preview 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removePreview(accountId: Int64, creativeId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/removepreview"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "creativeId", value: "\(creativeId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Creative
    /// - POST /creative/update
    /// - Update a creative
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter creativeId: (query) the creative Id to upate. 
    /// - parameter name: (query) The name of the level. (optional)
    /// - parameter description: (query) The description of the level. (optional)
    /// - parameter assetImageId: (query) The asset Id of the level image. (optional)
    /// - parameter action: (query) This parameter is deprecated. deprecated use data field (optional)
    /// - parameter data: (query) The creative data, json based format depending on type (optional)
    /// - parameter suffix: (query) This parameter is deprecated. deprecated use type field (optional)
    /// - parameter type: (query) The type of creative. (optional)
    /// - parameter balance: (query) Set the amount of money available to spend, once 0 deactivate level. Set to a negative value for unlimited. (optional)
    /// - parameter active: (query) If true set the game level as active. Default is false. (optional)
    /// - parameter referenceId: (query) if creative related so some other content provided the id (optional)
    /// - parameter appVersion: (query) The version of the application, will not return creatives newer than the appVersion. Only used when requesting application configuration creatives. (optional)
    /// - parameter missionId: (query) Assign the creative to a campaign for timing and audience matching. (optional)
    /// - returns: AnyPublisher<CreativeResponse, Error> 
    open func updateCreative(accountId: Int64, creativeId: Int64, name: String? = nil, description: String? = nil, assetImageId: Int64? = nil, action: String? = nil, data: String? = nil, suffix: String? = nil, type: String? = nil, balance: Double? = nil, active: Bool? = nil, referenceId: Int64? = nil, appVersion: String? = nil, missionId: Int64? = nil) -> AnyPublisher<CreativeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/creative/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "creativeId", value: "\(creativeId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let assetImageId = assetImageId { queryItems.append(URLQueryItem(name: "assetImageId", value: "\(assetImageId)")) } 
                if let action = action { queryItems.append(URLQueryItem(name: "action", value: action)) } 
                if let data = data { queryItems.append(URLQueryItem(name: "data", value: data)) } 
                if let suffix = suffix { queryItems.append(URLQueryItem(name: "suffix", value: suffix)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let balance = balance { queryItems.append(URLQueryItem(name: "balance", value: "\(balance)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let referenceId = referenceId { queryItems.append(URLQueryItem(name: "referenceId", value: "\(referenceId)")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CreativeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CreativeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
