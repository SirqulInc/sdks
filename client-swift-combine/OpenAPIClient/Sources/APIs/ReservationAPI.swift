//
// ReservationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ReservationAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Reservation
    /// - POST /api/{version}/reservation/create
    /// - Creates a reservation on an offer object
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter startDate: (query) The start date (optional)
    /// - parameter endDate: (query) The end date (optional)
    /// - parameter offerId: (query) The id of the offer being added (offerId or offeLocationId required) (optional)
    /// - parameter offerLocationId: (query) The id of the offer location being added (offerId or offeLocationId required) (optional)
    /// - parameter appKey: (query) The application requesting the reservation (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func createReservation(version: Double, deviceId: String? = nil, accountId: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, offerId: Int64? = nil, offerLocationId: Int64? = nil, appKey: String? = nil, metaData: String? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/reservation/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Reservation
    /// - POST /api/{version}/reservation/delete
    /// - Deleted a reservation on a reservation object
    /// - parameter version: (path)  
    /// - parameter reservationId: (query) The reservation id 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func deleteReservation(version: Double, reservationId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/reservation/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "reservationId", value: "\(reservationId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter reservableType
    ///
    public enum ReservableAvailabilityReservableType: String, Codable, CaseIterable {
        case locatable = "LOCATABLE"
        case reservable = "RESERVABLE"
        case permissionable = "PERMISSIONABLE"
        case notable = "NOTABLE"
        case assetable = "ASSETABLE"
        case likable = "LIKABLE"
        case flagable = "FLAGABLE"
        case favoritable = "FAVORITABLE"
        case ratable = "RATABLE"
        case album = "ALBUM"
        case collection = "COLLECTION"
        case application = "APPLICATION"
        case applicationSetting = "APPLICATION_SETTING"
        case applicationCert = "APPLICATION_CERT"
        case applicationPlacement = "APPLICATION_PLACEMENT"
        case account = "ACCOUNT"
        case accountSetting = "ACCOUNT_SETTING"
        case gameLevel = "GAME_LEVEL"
        case pack = "PACK"
        case mission = "MISSION"
        case tournament = "TOURNAMENT"
        case asset = "ASSET"
        case albumContest = "ALBUM_CONTEST"
        case themeDescriptor = "THEME_DESCRIPTOR"
        case offer = "OFFER"
        case offerLocation = "OFFER_LOCATION"
        case event = "EVENT"
        case retailer = "RETAILER"
        case retailerLocation = "RETAILER_LOCATION"
        case note = "NOTE"
        case creative = "CREATIVE"
        case favorite = "FAVORITE"
        case like = "LIKE"
        case rating = "RATING"
        case analytic = "ANALYTIC"
        case thirdPartyCredential = "THIRD_PARTY_CREDENTIAL"
        case thirdPartyNetwork = "THIRD_PARTY_NETWORK"
        case region = "REGION"
    }

    /// Update Availability
    /// - POST /api/{version}/reservable/availability/update
    /// - parameter version: (path)  
    /// - parameter reservableId: (query) the id of the reservation 
    /// - parameter reservableType: (query) the type of reservation 
    /// - parameter deviceId: (query) the device id of the reservation (optional)
    /// - parameter accountId: (query) the id of the logged in user (optional)
    /// - parameter availability: (query) Availability (optional)
    /// - parameter availabilitySummary: (query) Availability Summary (optional)
    /// - returns: AnyPublisher<[AvailabilityResponse], Error> 
    open func reservableAvailability(version: Double, reservableId: Int64, reservableType: ReservableAvailabilityReservableType, deviceId: String? = nil, accountId: Int64? = nil, availability: String? = nil, availabilitySummary: String? = nil) -> AnyPublisher<[AvailabilityResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/reservable/availability/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "reservableId", value: "\(reservableId)"))
                queryItems.append(URLQueryItem(name: "reservableType", value: reservableType.rawValue))
                if let availability = availability { queryItems.append(URLQueryItem(name: "availability", value: availability)) } 
                if let availabilitySummary = availabilitySummary { queryItems.append(URLQueryItem(name: "availabilitySummary", value: availabilitySummary)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AvailabilityResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AvailabilityResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter reservableType
    ///
    public enum SearchAvailabilityReservableType: String, Codable, CaseIterable {
        case locatable = "LOCATABLE"
        case reservable = "RESERVABLE"
        case permissionable = "PERMISSIONABLE"
        case notable = "NOTABLE"
        case assetable = "ASSETABLE"
        case likable = "LIKABLE"
        case flagable = "FLAGABLE"
        case favoritable = "FAVORITABLE"
        case ratable = "RATABLE"
        case album = "ALBUM"
        case collection = "COLLECTION"
        case application = "APPLICATION"
        case applicationSetting = "APPLICATION_SETTING"
        case applicationCert = "APPLICATION_CERT"
        case applicationPlacement = "APPLICATION_PLACEMENT"
        case account = "ACCOUNT"
        case accountSetting = "ACCOUNT_SETTING"
        case gameLevel = "GAME_LEVEL"
        case pack = "PACK"
        case mission = "MISSION"
        case tournament = "TOURNAMENT"
        case asset = "ASSET"
        case albumContest = "ALBUM_CONTEST"
        case themeDescriptor = "THEME_DESCRIPTOR"
        case offer = "OFFER"
        case offerLocation = "OFFER_LOCATION"
        case event = "EVENT"
        case retailer = "RETAILER"
        case retailerLocation = "RETAILER_LOCATION"
        case note = "NOTE"
        case creative = "CREATIVE"
        case favorite = "FAVORITE"
        case like = "LIKE"
        case rating = "RATING"
        case analytic = "ANALYTIC"
        case thirdPartyCredential = "THIRD_PARTY_CREDENTIAL"
        case thirdPartyNetwork = "THIRD_PARTY_NETWORK"
        case region = "REGION"
    }

    /// Search Availability
    /// - GET /api/{version}/reservable/availability/search
    /// - parameter version: (path)  
    /// - parameter reservableId: (query) the id of the reservation 
    /// - parameter reservableType: (query) the reservable type 
    /// - parameter deviceId: (query) the device ID that the reservation is on (optional)
    /// - parameter accountId: (query) the id of the logged in user (optional)
    /// - parameter startDate: (query) the start date of the reservation (optional)
    /// - parameter endDate: (query) the end date of the reservation (optional)
    /// - parameter start: (query) the start of the index and/or pagination (optional, default to 0)
    /// - parameter limit: (query) the limit of the index and/or pagination (optional, default to 100)
    /// - returns: AnyPublisher<[AvailabilityResponse], Error> 
    open func searchAvailability(version: Double, reservableId: Int64, reservableType: SearchAvailabilityReservableType, deviceId: String? = nil, accountId: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[AvailabilityResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/reservable/availability/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "reservableId", value: "\(reservableId)"))
                queryItems.append(URLQueryItem(name: "reservableType", value: reservableType.rawValue))
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AvailabilityResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AvailabilityResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter reservableType
    ///
    public enum SearchReservationsReservableType: String, Codable, CaseIterable {
        case locatable = "LOCATABLE"
        case reservable = "RESERVABLE"
        case permissionable = "PERMISSIONABLE"
        case notable = "NOTABLE"
        case assetable = "ASSETABLE"
        case likable = "LIKABLE"
        case flagable = "FLAGABLE"
        case favoritable = "FAVORITABLE"
        case ratable = "RATABLE"
        case album = "ALBUM"
        case collection = "COLLECTION"
        case application = "APPLICATION"
        case applicationSetting = "APPLICATION_SETTING"
        case applicationCert = "APPLICATION_CERT"
        case applicationPlacement = "APPLICATION_PLACEMENT"
        case account = "ACCOUNT"
        case accountSetting = "ACCOUNT_SETTING"
        case gameLevel = "GAME_LEVEL"
        case pack = "PACK"
        case mission = "MISSION"
        case tournament = "TOURNAMENT"
        case asset = "ASSET"
        case albumContest = "ALBUM_CONTEST"
        case themeDescriptor = "THEME_DESCRIPTOR"
        case offer = "OFFER"
        case offerLocation = "OFFER_LOCATION"
        case event = "EVENT"
        case retailer = "RETAILER"
        case retailerLocation = "RETAILER_LOCATION"
        case note = "NOTE"
        case creative = "CREATIVE"
        case favorite = "FAVORITE"
        case like = "LIKE"
        case rating = "RATING"
        case analytic = "ANALYTIC"
        case thirdPartyCredential = "THIRD_PARTY_CREDENTIAL"
        case thirdPartyNetwork = "THIRD_PARTY_NETWORK"
        case region = "REGION"
    }

    /// Search Reservations
    /// - GET /api/{version}/reservation/search
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) Device Id (optional)
    /// - parameter appKey: (query) Appilcation Key (optional)
    /// - parameter accountId: (query) the id of the logged in user (optional)
    /// - parameter filterAccountId: (query) filter reservations by account ID (optional)
    /// - parameter reservableId: (query) the reservation ID (optional)
    /// - parameter reservableType: (query) the type of reservation (optional)
    /// - parameter keyword: (query) the keyword to search the reservation on (optional)
    /// - parameter startDate: (query) the start date of the reservation search (optional)
    /// - parameter endDate: (query) the end date of the reservation search (optional)
    /// - parameter start: (query) the start of the index and/or pagination (optional, default to 0)
    /// - parameter limit: (query) the limit of the index and/or pagination (optional, default to 100)
    /// - returns: AnyPublisher<[ReservationResponse], Error> 
    open func searchReservations(version: Double, deviceId: String? = nil, appKey: String? = nil, accountId: Int64? = nil, filterAccountId: Int64? = nil, reservableId: Int64? = nil, reservableType: SearchReservationsReservableType? = nil, keyword: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[ReservationResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/reservation/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let filterAccountId = filterAccountId { queryItems.append(URLQueryItem(name: "filterAccountId", value: "\(filterAccountId)")) } 
                if let reservableId = reservableId { queryItems.append(URLQueryItem(name: "reservableId", value: "\(reservableId)")) } 
                if let reservableType = reservableType { queryItems.append(URLQueryItem(name: "reservableType", value: reservableType.rawValue)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ReservationResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ReservationResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter reservableType
    ///
    public enum SearchScheduleReservableType: String, Codable, CaseIterable {
        case locatable = "LOCATABLE"
        case reservable = "RESERVABLE"
        case permissionable = "PERMISSIONABLE"
        case notable = "NOTABLE"
        case assetable = "ASSETABLE"
        case likable = "LIKABLE"
        case flagable = "FLAGABLE"
        case favoritable = "FAVORITABLE"
        case ratable = "RATABLE"
        case album = "ALBUM"
        case collection = "COLLECTION"
        case application = "APPLICATION"
        case applicationSetting = "APPLICATION_SETTING"
        case applicationCert = "APPLICATION_CERT"
        case applicationPlacement = "APPLICATION_PLACEMENT"
        case account = "ACCOUNT"
        case accountSetting = "ACCOUNT_SETTING"
        case gameLevel = "GAME_LEVEL"
        case pack = "PACK"
        case mission = "MISSION"
        case tournament = "TOURNAMENT"
        case asset = "ASSET"
        case albumContest = "ALBUM_CONTEST"
        case themeDescriptor = "THEME_DESCRIPTOR"
        case offer = "OFFER"
        case offerLocation = "OFFER_LOCATION"
        case event = "EVENT"
        case retailer = "RETAILER"
        case retailerLocation = "RETAILER_LOCATION"
        case note = "NOTE"
        case creative = "CREATIVE"
        case favorite = "FAVORITE"
        case like = "LIKE"
        case rating = "RATING"
        case analytic = "ANALYTIC"
        case thirdPartyCredential = "THIRD_PARTY_CREDENTIAL"
        case thirdPartyNetwork = "THIRD_PARTY_NETWORK"
        case region = "REGION"
    }

    /// Search Schedule
    /// - GET /api/{version}/reservable/schedule/search
    /// - parameter version: (path)  
    /// - parameter reservableId: (query) the id of the reservation 
    /// - parameter reservableType: (query) the reservation type 
    /// - parameter startDate: (query) the start date of the reservation 
    /// - parameter endDate: (query) the end date of the reservation 
    /// - parameter deviceId: (query) the id of the device that the reservation is on (optional)
    /// - parameter accountId: (query) the id of the logged in user (optional)
    /// - parameter timeBucketMins: (query) the length of time in minutes to search on for reservation (optional, default to 30)
    /// - returns: AnyPublisher<[TimeSlotResponse], Error> 
    open func searchSchedule(version: Double, reservableId: Int64, reservableType: SearchScheduleReservableType, startDate: Int64, endDate: Int64, deviceId: String? = nil, accountId: Int64? = nil, timeBucketMins: Int? = nil) -> AnyPublisher<[TimeSlotResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/reservable/schedule/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "reservableId", value: "\(reservableId)"))
                queryItems.append(URLQueryItem(name: "reservableType", value: reservableType.rawValue))
                queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)"))
                queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)"))
                if let timeBucketMins = timeBucketMins { queryItems.append(URLQueryItem(name: "timeBucketMins", value: "\(timeBucketMins)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[TimeSlotResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([TimeSlotResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
