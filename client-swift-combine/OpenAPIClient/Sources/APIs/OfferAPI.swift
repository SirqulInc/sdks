//
// OfferAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class OfferAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Update Offer Locations
    /// - POST /retailer/offer/location/batchUpdate
    /// - Batch update offer locations.
    /// - parameter data: (query) JSON string in the following format: &#x60;&#x60;&#x60;json [{   \&quot;offerLocationId\&quot;: 1705,   \&quot;latitude\&quot;: 54.0,   \&quot;longitude\&quot;: -122.0,   \&quot;altitude\&quot;: 1.0,   \&quot;locationDetail\&quot;: \&quot;floor 1\&quot;,   \&quot;locationDescription\&quot;: \&quot;behind the Coke sign\&quot; }, {   \&quot;offerLocationId\&quot;: 1704,   \&quot;latitude\&quot;: 54.1,   \&quot;longitude\&quot;: -122.1 }] &#x60;&#x60;&#x60;  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func batchUpdateOfferLocations(data: String, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/location/batchUpdate"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "data", value: data))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter barcodeType
    ///
    public enum CreateOfferBarcodeType: String, Codable, CaseIterable {
        case _none = "NONE"
        case upc = "UPC"
        case code128 = "CODE_128"
        case qr = "QR"
        case customMedia = "CUSTOM_MEDIA"
    }
    ///
    /// Enum for parameter offerType
    ///
    public enum CreateOfferOfferType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum CreateOfferSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }
    ///
    /// Enum for parameter offerVisibility
    ///
    public enum CreateOfferOfferVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }
    ///
    /// Enum for parameter productType
    ///
    public enum CreateOfferProductType: String, Codable, CaseIterable {
        case apparel = "APPAREL"
        case appliances = "APPLIANCES"
        case apps = "APPS"
        case artsCrafts = "ARTS_CRAFTS"
        case automotive = "AUTOMOTIVE"
        case baby = "BABY"
        case beauty = "BEAUTY"
        case books = "BOOKS"
        case classical = "CLASSICAL"
        case collectibles = "COLLECTIBLES"
        case dvd = "DVD"
        case electronics = "ELECTRONICS"
        case giftCards = "GIFT_CARDS"
        case gourmetFood = "GOURMET_FOOD"
        case grocery = "GROCERY"
        case healthPersonalCare = "HEALTH_PERSONAL_CARE"
        case homeGarden = "HOME_GARDEN"
        case industrial = "INDUSTRIAL"
        case jewelry = "JEWELRY"
        case kitchen = "KITCHEN"
        case lawnGarden = "LAWN_GARDEN"
        case magazines = "MAGAZINES"
        case miscellaneous = "MISCELLANEOUS"
        case musicalInstruments = "MUSICAL_INSTRUMENTS"
        case officeProducts = "OFFICE_PRODUCTS"
        case other = "OTHER"
        case outdoorLiving = "OUTDOOR_LIVING"
        case pcHardware = "PC_HARDWARE"
        case petSupplies = "PET_SUPPLIES"
        case shoes = "SHOES"
        case software = "SOFTWARE"
        case sportingGoods = "SPORTING_GOODS"
        case tools = "TOOLS"
        case toys = "TOYS"
        case videoGames = "VIDEO_GAMES"
        case watches = "WATCHES"
        case wireless = "WIRELESS"
        case wirelessAccessories = "WIRELESS_ACCESSORIES"
    }
    ///
    /// Enum for parameter conditionType
    ///
    public enum CreateOfferConditionType: String, Codable, CaseIterable {
        case new = "NEW"
        case used = "USED"
        case refurbished = "REFURBISHED"
        case other = "OTHER"
    }
    ///
    /// Enum for parameter unit
    ///
    public enum CreateOfferUnit: String, Codable, CaseIterable {
        case milimeter = "MILIMETER"
        case centimeter = "CENTIMETER"
        case meter = "METER"
        case inch = "INCH"
        case foot = "FOOT"
        case yard = "YARD"
    }
    ///
    /// Enum for parameter mediaType
    ///
    public enum CreateOfferMediaType: String, Codable, CaseIterable {
        case apk = "APK"
        case application = "APPLICATION"
        case image = "IMAGE"
        case audio = "AUDIO"
        case video = "VIDEO"
        case multipart = "MULTIPART"
        case barCode = "BAR_CODE"
        case text = "TEXT"
        case other = "OTHER"
    }

    /// Create Offer
    /// - POST /retailer/offer/create
    /// - Create an offer and assign it to the provided retailer locations.
    /// - parameter includeOfferLocations: (query) If true return all the offer locations associated with the offer 
    /// - parameter title: (query) The title (255 char limit) 
    /// - parameter barcodeType: (query) The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} 
    /// - parameter noExpiration: (query) Overrides the expiration date so that the offer does not expire 
    /// - parameter availableLimit: (query) The limit of how many times the offer can be used by consumers 
    /// - parameter availableLimitPerUser: (query) The limit of how many times a user can used the same offer 
    /// - parameter addedLimit: (query) The limit of how many times the offer can be added to consumer wallets 
    /// - parameter viewLimit: (query) The limit of how many times the offer can be viewed 
    /// - parameter maxPrints: (query) The maximum number of times the offer can be printed 
    /// - parameter ticketPrice: (query) The cost of the offer in tickets 
    /// - parameter fullPrice: (query) The retail/full price cost of the offer in real currency 
    /// - parameter discountPrice: (query) The cost of the offer at a discounted price (what the consumer pays) 
    /// - parameter offerType: (query) The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE} 
    /// - parameter specialOfferType: (query) The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} 
    /// - parameter offerVisibility: (query) The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} 
    /// - parameter active: (query) Sets the active flag 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id (deviceId or accountId required) (optional)
    /// - parameter tags: (query) Custom string field for doing full-text searches (optional)
    /// - parameter parentOfferId: (query) the parent offer id (optional)
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
    /// - parameter offerLocations: (query) A list of json data that has offer location specific values. (optional)
    /// - parameter subTitle: (query) The sub title (255 char limit) (optional)
    /// - parameter details: (query) The details (optional)
    /// - parameter subDetails: (query) A string for custom details (255 char limit) (optional)
    /// - parameter finePrint: (query) The fine print (optional)
    /// - parameter barcodeEntry: (query) The bar code entry string (optional)
    /// - parameter externalRedeemOptions: (query) An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
    /// - parameter externalUrl: (query) The clickUrl of the offer (optional)
    /// - parameter externalId: (query) an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
    /// - parameter ticketsRewardType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter ticketsReward: (query) Determines how many tickets are awarded (optional)
    /// - parameter activated: (query) The date of when the offer will be visible to consumers (optional)
    /// - parameter expires: (query) The date of when the offer expires (optional)
    /// - parameter ticketPriceType: (query) the type of ticket needed to buy offer (optional)
    /// - parameter showRemaining: (query) show remaining offers available (optional)
    /// - parameter showRedeemed: (query) show how many offers have been redeemed (optional)
    /// - parameter replaced: (query)  (optional)
    /// - parameter featured: (query) flag if offer is featured or not (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids (optional)
    /// - parameter filterIds: (query) Comma separated list of filter ids (optional)
    /// - parameter barcodeAssetId: (query) The id of the barcode asset (optional)
    /// - parameter imageAssetId: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId1: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId2: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId3: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId4: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId5: (query) The id of the an offer asset (optional)
    /// - parameter publisher: (query) The maker of the item. (optional)
    /// - parameter redeemableStart: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter redeemableEnd: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter brand: (query) The brand. OfferType PRODUCT only. (optional)
    /// - parameter productType: (query) The product type. OfferType PRODUCT only. (optional)
    /// - parameter conditionType: (query) The condition. OfferType PRODUCT only. (optional)
    /// - parameter isbn: (query) The ISBN id. OfferType PRODUCT only. (optional)
    /// - parameter asin: (query) The ASIN id. OfferType PRODUCT only. (optional)
    /// - parameter catalogNumbers: (query) The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
    /// - parameter department: (query) The department name. The OfferType PRODUCT only. (optional)
    /// - parameter features: (query) The list of features, comma seperated. OfferType PRODUCT only. (optional)
    /// - parameter minimumPrice: (query) The MAP price. OfferType PRODUCT only. (optional)
    /// - parameter width: (query) The width of the item. OfferType PRODUCT only. (optional)
    /// - parameter height: (query) The height of the item. OfferType PRODUCT only. (optional)
    /// - parameter depth: (query) The depth of the item. OfferType PRODUCT only. (optional)
    /// - parameter weight: (query) The weight of the item. OfferType PRODUCT only. (optional)
    /// - parameter unit: (query) The unit of measurement. OfferType PRODUCT only. (optional)
    /// - parameter studio: (query) The studio name. OfferType PRODUCT only. (optional)
    /// - parameter parentalRating: (query) The parental control rating. OfferType PRODUCT only. (optional)
    /// - parameter publishDate: (query) The date published. OfferType PRODUCT only. (optional)
    /// - parameter availabilityDate: (query) The date available. OfferType PRODUCT only. (optional)
    /// - parameter sizeId: (query)  (optional)
    /// - parameter listingId: (query) The ID of the event listing (optional)
    /// - parameter mediaType: (query) the media type of the offer (optional)
    /// - parameter duration: (query) The total playing time of the media item. OfferType MEDIA only. (optional)
    /// - parameter author: (query) The created/author of the media item. OfferType MEDIA only. (optional)
    /// - parameter releaseDate: (query) The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
    /// - parameter collectionIds: (query)  (optional)
    /// - parameter rebootTimeHour: (query) The reboot hour time ranging from 0 to 23 (optional)
    /// - parameter rebootTimeMinute: (query) The reboot minute time ranging from 0 to 59 (optional)
    /// - parameter idleTimeoutInSecond: (query) If the device is idle for idleTimeoutInSecond then the device should timeout (optional)
    /// - parameter serialNumber: (query) The serial number on the device (optional)
    /// - parameter udid: (query) The unique device id for the device (optional)
    /// - parameter deviceType: (query) The type of the device, for example: \&quot;Kiosk\&quot;, \&quot;Beacon\&quot;. (optional)
    /// - parameter devicePower: (query) Edysen device power level setting (optional)
    /// - parameter deviceInterference: (query) Edysen device inteference setting (optional)
    /// - parameter availability: (query)  (optional)
    /// - parameter availabilitySummary: (query)  (optional)
    /// - returns: AnyPublisher<RetailerOfferResponse, Error> 
    open func createOffer(includeOfferLocations: Bool, title: String, barcodeType: CreateOfferBarcodeType, noExpiration: Bool, availableLimit: Int, availableLimitPerUser: Int, addedLimit: Int, viewLimit: Int, maxPrints: Int, ticketPrice: Int64, fullPrice: Double, discountPrice: Double, offerType: CreateOfferOfferType, specialOfferType: CreateOfferSpecialOfferType, offerVisibility: CreateOfferOfferVisibility, active: Bool, deviceId: String? = nil, accountId: Int64? = nil, tags: String? = nil, parentOfferId: Int64? = nil, retailerLocationIds: String? = nil, offerLocations: String? = nil, subTitle: String? = nil, details: String? = nil, subDetails: String? = nil, finePrint: String? = nil, barcodeEntry: String? = nil, externalRedeemOptions: String? = nil, externalUrl: String? = nil, externalId: String? = nil, ticketsRewardType: String? = nil, ticketsReward: Int64? = nil, activated: Int64? = nil, expires: Int64? = nil, ticketPriceType: String? = nil, showRemaining: Bool? = nil, showRedeemed: Bool? = nil, replaced: Bool? = nil, featured: Bool? = nil, categoryIds: String? = nil, filterIds: String? = nil, barcodeAssetId: Int64? = nil, imageAssetId: Int64? = nil, imageAssetId1: Int64? = nil, imageAssetId2: Int64? = nil, imageAssetId3: Int64? = nil, imageAssetId4: Int64? = nil, imageAssetId5: Int64? = nil, publisher: String? = nil, redeemableStart: Int64? = nil, redeemableEnd: Int64? = nil, brand: String? = nil, productType: CreateOfferProductType? = nil, conditionType: CreateOfferConditionType? = nil, isbn: String? = nil, asin: String? = nil, catalogNumbers: String? = nil, department: String? = nil, features: String? = nil, minimumPrice: Double? = nil, width: Double? = nil, height: Double? = nil, depth: Double? = nil, weight: Double? = nil, unit: CreateOfferUnit? = nil, studio: String? = nil, parentalRating: String? = nil, publishDate: Int64? = nil, availabilityDate: Int64? = nil, sizeId: Int64? = nil, listingId: Int64? = nil, mediaType: CreateOfferMediaType? = nil, duration: Int? = nil, author: String? = nil, releaseDate: Int64? = nil, collectionIds: String? = nil, rebootTimeHour: Int? = nil, rebootTimeMinute: Int? = nil, idleTimeoutInSecond: Int? = nil, serialNumber: String? = nil, udid: String? = nil, deviceType: String? = nil, devicePower: Double? = nil, deviceInterference: Double? = nil, availability: String? = nil, availabilitySummary: String? = nil) -> AnyPublisher<RetailerOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let parentOfferId = parentOfferId { queryItems.append(URLQueryItem(name: "parentOfferId", value: "\(parentOfferId)")) } 
                queryItems.append(URLQueryItem(name: "includeOfferLocations", value: includeOfferLocations ? "true" : "false"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let offerLocations = offerLocations { queryItems.append(URLQueryItem(name: "offerLocations", value: offerLocations)) } 
                queryItems.append(URLQueryItem(name: "title", value: title))
                if let subTitle = subTitle { queryItems.append(URLQueryItem(name: "subTitle", value: subTitle)) } 
                if let details = details { queryItems.append(URLQueryItem(name: "details", value: details)) } 
                if let subDetails = subDetails { queryItems.append(URLQueryItem(name: "subDetails", value: subDetails)) } 
                if let finePrint = finePrint { queryItems.append(URLQueryItem(name: "finePrint", value: finePrint)) } 
                queryItems.append(URLQueryItem(name: "barcodeType", value: barcodeType.rawValue))
                if let barcodeEntry = barcodeEntry { queryItems.append(URLQueryItem(name: "barcodeEntry", value: barcodeEntry)) } 
                if let externalRedeemOptions = externalRedeemOptions { queryItems.append(URLQueryItem(name: "externalRedeemOptions", value: externalRedeemOptions)) } 
                if let externalUrl = externalUrl { queryItems.append(URLQueryItem(name: "externalUrl", value: externalUrl)) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let ticketsRewardType = ticketsRewardType { queryItems.append(URLQueryItem(name: "ticketsRewardType", value: ticketsRewardType)) } 
                if let ticketsReward = ticketsReward { queryItems.append(URLQueryItem(name: "ticketsReward", value: "\(ticketsReward)")) } 
                if let activated = activated { queryItems.append(URLQueryItem(name: "activated", value: "\(activated)")) } 
                if let expires = expires { queryItems.append(URLQueryItem(name: "expires", value: "\(expires)")) } 
                queryItems.append(URLQueryItem(name: "noExpiration", value: noExpiration ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "availableLimit", value: "\(availableLimit)"))
                queryItems.append(URLQueryItem(name: "availableLimitPerUser", value: "\(availableLimitPerUser)"))
                queryItems.append(URLQueryItem(name: "addedLimit", value: "\(addedLimit)"))
                queryItems.append(URLQueryItem(name: "viewLimit", value: "\(viewLimit)"))
                queryItems.append(URLQueryItem(name: "maxPrints", value: "\(maxPrints)"))
                if let ticketPriceType = ticketPriceType { queryItems.append(URLQueryItem(name: "ticketPriceType", value: ticketPriceType)) } 
                queryItems.append(URLQueryItem(name: "ticketPrice", value: "\(ticketPrice)"))
                queryItems.append(URLQueryItem(name: "fullPrice", value: "\(fullPrice)"))
                queryItems.append(URLQueryItem(name: "discountPrice", value: "\(discountPrice)"))
                if let showRemaining = showRemaining { queryItems.append(URLQueryItem(name: "showRemaining", value: showRemaining ? "true" : "false")) } 
                if let showRedeemed = showRedeemed { queryItems.append(URLQueryItem(name: "showRedeemed", value: showRedeemed ? "true" : "false")) } 
                if let replaced = replaced { queryItems.append(URLQueryItem(name: "replaced", value: replaced ? "true" : "false")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                queryItems.append(URLQueryItem(name: "offerType", value: offerType.rawValue))
                queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue))
                queryItems.append(URLQueryItem(name: "offerVisibility", value: offerVisibility.rawValue))
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false"))
                if let barcodeAssetId = barcodeAssetId { queryItems.append(URLQueryItem(name: "barcodeAssetId", value: "\(barcodeAssetId)")) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let imageAssetId1 = imageAssetId1 { queryItems.append(URLQueryItem(name: "imageAssetId1", value: "\(imageAssetId1)")) } 
                if let imageAssetId2 = imageAssetId2 { queryItems.append(URLQueryItem(name: "imageAssetId2", value: "\(imageAssetId2)")) } 
                if let imageAssetId3 = imageAssetId3 { queryItems.append(URLQueryItem(name: "imageAssetId3", value: "\(imageAssetId3)")) } 
                if let imageAssetId4 = imageAssetId4 { queryItems.append(URLQueryItem(name: "imageAssetId4", value: "\(imageAssetId4)")) } 
                if let imageAssetId5 = imageAssetId5 { queryItems.append(URLQueryItem(name: "imageAssetId5", value: "\(imageAssetId5)")) } 
                if let publisher = publisher { queryItems.append(URLQueryItem(name: "publisher", value: publisher)) } 
                if let redeemableStart = redeemableStart { queryItems.append(URLQueryItem(name: "redeemableStart", value: "\(redeemableStart)")) } 
                if let redeemableEnd = redeemableEnd { queryItems.append(URLQueryItem(name: "redeemableEnd", value: "\(redeemableEnd)")) } 
                if let brand = brand { queryItems.append(URLQueryItem(name: "brand", value: brand)) } 
                if let productType = productType { queryItems.append(URLQueryItem(name: "productType", value: productType.rawValue)) } 
                if let conditionType = conditionType { queryItems.append(URLQueryItem(name: "conditionType", value: conditionType.rawValue)) } 
                if let isbn = isbn { queryItems.append(URLQueryItem(name: "isbn", value: isbn)) } 
                if let asin = asin { queryItems.append(URLQueryItem(name: "asin", value: asin)) } 
                if let catalogNumbers = catalogNumbers { queryItems.append(URLQueryItem(name: "catalogNumbers", value: catalogNumbers)) } 
                if let department = department { queryItems.append(URLQueryItem(name: "department", value: department)) } 
                if let features = features { queryItems.append(URLQueryItem(name: "features", value: features)) } 
                if let minimumPrice = minimumPrice { queryItems.append(URLQueryItem(name: "minimumPrice", value: "\(minimumPrice)")) } 
                if let width = width { queryItems.append(URLQueryItem(name: "width", value: "\(width)")) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: "\(height)")) } 
                if let depth = depth { queryItems.append(URLQueryItem(name: "depth", value: "\(depth)")) } 
                if let weight = weight { queryItems.append(URLQueryItem(name: "weight", value: "\(weight)")) } 
                if let unit = unit { queryItems.append(URLQueryItem(name: "unit", value: unit.rawValue)) } 
                if let studio = studio { queryItems.append(URLQueryItem(name: "studio", value: studio)) } 
                if let parentalRating = parentalRating { queryItems.append(URLQueryItem(name: "parentalRating", value: parentalRating)) } 
                if let publishDate = publishDate { queryItems.append(URLQueryItem(name: "publishDate", value: "\(publishDate)")) } 
                if let availabilityDate = availabilityDate { queryItems.append(URLQueryItem(name: "availabilityDate", value: "\(availabilityDate)")) } 
                if let sizeId = sizeId { queryItems.append(URLQueryItem(name: "sizeId", value: "\(sizeId)")) } 
                if let listingId = listingId { queryItems.append(URLQueryItem(name: "listingId", value: "\(listingId)")) } 
                if let mediaType = mediaType { queryItems.append(URLQueryItem(name: "mediaType", value: mediaType.rawValue)) } 
                if let duration = duration { queryItems.append(URLQueryItem(name: "duration", value: "\(duration)")) } 
                if let author = author { queryItems.append(URLQueryItem(name: "author", value: author)) } 
                if let releaseDate = releaseDate { queryItems.append(URLQueryItem(name: "releaseDate", value: "\(releaseDate)")) } 
                if let collectionIds = collectionIds { queryItems.append(URLQueryItem(name: "collectionIds", value: collectionIds)) } 
                if let rebootTimeHour = rebootTimeHour { queryItems.append(URLQueryItem(name: "rebootTimeHour", value: "\(rebootTimeHour)")) } 
                if let rebootTimeMinute = rebootTimeMinute { queryItems.append(URLQueryItem(name: "rebootTimeMinute", value: "\(rebootTimeMinute)")) } 
                if let idleTimeoutInSecond = idleTimeoutInSecond { queryItems.append(URLQueryItem(name: "idleTimeoutInSecond", value: "\(idleTimeoutInSecond)")) } 
                if let serialNumber = serialNumber { queryItems.append(URLQueryItem(name: "serialNumber", value: serialNumber)) } 
                if let udid = udid { queryItems.append(URLQueryItem(name: "udid", value: udid)) } 
                if let deviceType = deviceType { queryItems.append(URLQueryItem(name: "deviceType", value: deviceType)) } 
                if let devicePower = devicePower { queryItems.append(URLQueryItem(name: "devicePower", value: "\(devicePower)")) } 
                if let deviceInterference = deviceInterference { queryItems.append(URLQueryItem(name: "deviceInterference", value: "\(deviceInterference)")) } 
                if let availability = availability { queryItems.append(URLQueryItem(name: "availability", value: availability)) } 
                if let availabilitySummary = availabilitySummary { queryItems.append(URLQueryItem(name: "availabilitySummary", value: availabilitySummary)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Offer
    /// - POST /retailer/offer/delete
    /// - Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.
    /// - parameter offerId: (query) The ID of the offer to be deleted 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account used to perform the delete, must have rights to edit the offer. (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteOffer(offerId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Offer Location
    /// - POST /retailer/offer/location/delete
    /// - Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.
    /// - parameter offerLocationId: (query) The ID of the offer location to be deleted 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account used to perform the delete, must have rights to edit the offer location. (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteOfferLocation(offerLocationId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/location/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Offer
    /// - GET /retailer/offer/get
    /// - Gets the details of an offer that the user has access to.
    /// - parameter offerId: (query) The id of the offer 
    /// - parameter includeOfferLocations: (query)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<RetailerOfferResponse, Error> 
    open func getOffer(offerId: Int64, includeOfferLocations: Bool, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<RetailerOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)"))
                queryItems.append(URLQueryItem(name: "includeOfferLocations", value: includeOfferLocations ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Offer
    /// - GET /offer/get
    /// - Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.
    /// - parameter deviceId: (query) The device id for returning account information (i.e. favorites) (optional)
    /// - parameter accountId: (query) The account id for returning account information (i.e. favorites) (optional)
    /// - parameter offerId: (query) The offer id (either offeLocationId or offerId must be provided) (optional)
    /// - parameter offerLocationId: (query) The offer location id (either offeLocationId or offerId must be provided) (optional)
    /// - parameter distance: (query) The distance of the offer from the user&#39;s current location (this is returned when the offer is searched) (optional)
    /// - parameter latitude: (query) The latitude to calculate distance from the offer (optional)
    /// - parameter longitude: (query) The longitude to calculate distance from the offer (optional)
    /// - parameter includeOfferLocations: (query) Determines whether to return offer locations for the offer (optional, default to false)
    /// - parameter includeRetailerLocations: (query) Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work) (optional, default to false)
    /// - parameter includeChildOffers: (query) Determines whether to include child offers in the response (optional, default to false)
    /// - returns: AnyPublisher<OfferResponse, Error> 
    open func getOfferDetails(deviceId: String? = nil, accountId: Int64? = nil, offerId: Int64? = nil, offerLocationId: Int64? = nil, distance: Double? = nil, latitude: Double? = nil, longitude: Double? = nil, includeOfferLocations: Bool? = nil, includeRetailerLocations: Bool? = nil, includeChildOffers: Bool? = nil) -> AnyPublisher<OfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/offer/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let distance = distance { queryItems.append(URLQueryItem(name: "distance", value: "\(distance)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let includeOfferLocations = includeOfferLocations { queryItems.append(URLQueryItem(name: "includeOfferLocations", value: includeOfferLocations ? "true" : "false")) } 
                if let includeRetailerLocations = includeRetailerLocations { queryItems.append(URLQueryItem(name: "includeRetailerLocations", value: includeRetailerLocations ? "true" : "false")) } 
                if let includeChildOffers = includeChildOffers { queryItems.append(URLQueryItem(name: "includeChildOffers", value: includeChildOffers ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter distanceUnit
    ///
    public enum GetOfferListCountsDistanceUnit: String, Codable, CaseIterable {
        case miles = "MILES"
        case kilometers = "KILOMETERS"
    }

    /// Get Offers (Counts)
    /// - GET /offer/lists/count
    /// - Gets the offer list counts.
    /// - parameter latitude: (query) The latitude of where the search will center at 
    /// - parameter longitude: (query) The longitude of where the search will center at 
    /// - parameter searchRange: (query) The range of the search (optional, default to 5)
    /// - parameter distanceUnit: (query) The units to use for distance calculations (e.g. MILES, KILOMETERS) (optional, default to .miles)
    /// - returns: AnyPublisher<ListCountResponse, Error> 
    open func getOfferListCounts(latitude: Double, longitude: Double, searchRange: Double? = nil, distanceUnit: GetOfferListCountsDistanceUnit? = nil) -> AnyPublisher<ListCountResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/offer/lists/count"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)"))
                queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)"))
                if let searchRange = searchRange { queryItems.append(URLQueryItem(name: "searchRange", value: "\(searchRange)")) } 
                if let distanceUnit = distanceUnit { queryItems.append(URLQueryItem(name: "distanceUnit", value: distanceUnit.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ListCountResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ListCountResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Offer Location
    /// - GET /offer/location/get
    /// - Gets the offer location by offer location id or udid (of a device)
    /// - parameter offerLocationId: (query) the id of the offer location to get (optional)
    /// - parameter udid: (query) the UDID of the device (optional)
    /// - returns: AnyPublisher<OfferShortResponse, Error> 
    open func getOfferLocation(offerLocationId: Int64? = nil, udid: String? = nil) -> AnyPublisher<OfferShortResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/offer/location/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let udid = udid { queryItems.append(URLQueryItem(name: "udid", value: udid)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferShortResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferShortResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum GetOfferLocationsForRetailersSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case offerId = "OFFER_ID"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case retailerId = "RETAILER_ID"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }
    ///
    /// Enum for parameter offerType
    ///
    public enum GetOfferLocationsForRetailersOfferType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum GetOfferLocationsForRetailersSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }
    ///
    /// Enum for parameter deviceStatus
    ///
    public enum GetOfferLocationsForRetailersDeviceStatus: String, Codable, CaseIterable {
        case running = "RUNNING"
        case warning = "WARNING"
        case down = "DOWN"
    }

    /// Search Offer Locations
    /// - GET /retailer/offer/location/search
    /// - Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.
    /// - parameter sortField: (query) The column to sort the results on. Default is \&quot;TITLE\&quot;, which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} 
    /// - parameter descending: (query) The order to return the results. Default is false, which will return the results in ascending order. 
    /// - parameter start: (query) The index into the record set to start with. Default is 0. 
    /// - parameter limit: (query) The total number of records to return. Default is 20. 
    /// - parameter activeOnly: (query) Determines whether to return only active results. Default is false. 
    /// - parameter includeRetailerLocation: (query)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter retailerId: (query) Filter results for a specific retailer (optional)
    /// - parameter retailerLocationId: (query) Filter results for a specific retailer location (optional)
    /// - parameter offerType: (query) Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers (optional)
    /// - parameter specialOfferType: (query) Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials (optional)
    /// - parameter barcodeType: (query)  (optional)
    /// - parameter barcodeEntry: (query)  (optional)
    /// - parameter isbn: (query)  (optional)
    /// - parameter asin: (query)  (optional)
    /// - parameter deviceStatus: (query) Edysen device status, running, warning, or down (optional)
    /// - parameter needsNotificationSent: (query)  (optional)
    /// - parameter lastNotificationSent: (query)  (optional)
    /// - returns: AnyPublisher<[OfferShortResponse], Error> 
    open func getOfferLocationsForRetailers(sortField: GetOfferLocationsForRetailersSortField, descending: Bool, start: Int, limit: Int, activeOnly: Bool, includeRetailerLocation: Bool, deviceId: String? = nil, accountId: Int64? = nil, keyword: String? = nil, retailerId: Int64? = nil, retailerLocationId: Int64? = nil, offerType: GetOfferLocationsForRetailersOfferType? = nil, specialOfferType: GetOfferLocationsForRetailersSpecialOfferType? = nil, barcodeType: String? = nil, barcodeEntry: String? = nil, isbn: String? = nil, asin: String? = nil, deviceStatus: GetOfferLocationsForRetailersDeviceStatus? = nil, needsNotificationSent: Bool? = nil, lastNotificationSent: Int64? = nil) -> AnyPublisher<[OfferShortResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/location/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let offerType = offerType { queryItems.append(URLQueryItem(name: "offerType", value: offerType.rawValue)) } 
                if let specialOfferType = specialOfferType { queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includeRetailerLocation", value: includeRetailerLocation ? "true" : "false"))
                if let barcodeType = barcodeType { queryItems.append(URLQueryItem(name: "barcodeType", value: barcodeType)) } 
                if let barcodeEntry = barcodeEntry { queryItems.append(URLQueryItem(name: "barcodeEntry", value: barcodeEntry)) } 
                if let isbn = isbn { queryItems.append(URLQueryItem(name: "isbn", value: isbn)) } 
                if let asin = asin { queryItems.append(URLQueryItem(name: "asin", value: asin)) } 
                if let deviceStatus = deviceStatus { queryItems.append(URLQueryItem(name: "deviceStatus", value: deviceStatus.rawValue)) } 
                if let needsNotificationSent = needsNotificationSent { queryItems.append(URLQueryItem(name: "needsNotificationSent", value: needsNotificationSent ? "true" : "false")) } 
                if let lastNotificationSent = lastNotificationSent { queryItems.append(URLQueryItem(name: "lastNotificationSent", value: "\(lastNotificationSent)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferShortResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferShortResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter offerVisibility
    ///
    public enum GetOffersForRetailersOfferVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum GetOffersForRetailersSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case redeemableStart = "REDEEMABLE_START"
        case redeemableEnd = "REDEEMABLE_END"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case estimatedValue = "ESTIMATED_VALUE"
        case voucherPrice = "VOUCHER_PRICE"
        case voucherDiscountPrice = "VOUCHER_DISCOUNT_PRICE"
        case fullPrice = "FULL_PRICE"
        case dicountPrice = "DICOUNT_PRICE"
        case ticketsReward = "TICKETS_REWARD"
        case availabilityDate = "AVAILABILITY_DATE"
        case releaseDate = "RELEASE_DATE"
        case retailerId = "RETAILER_ID"
        case retailerName = "RETAILER_NAME"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }
    ///
    /// Enum for parameter couponType
    ///
    public enum GetOffersForRetailersCouponType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter offerType
    ///
    public enum GetOffersForRetailersOfferType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum GetOffersForRetailersSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }
    ///
    /// Enum for parameter deviceStatus
    ///
    public enum GetOffersForRetailersDeviceStatus: String, Codable, CaseIterable {
        case running = "RUNNING"
        case warning = "WARNING"
        case down = "DOWN"
    }

    /// Search Offers
    /// - GET /retailer/offer/search
    /// - Searches on offers that the account has access to.
    /// - parameter offerVisibility: (query)  
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY 
    /// - parameter descending: (query) The order to return the search results 
    /// - parameter start: (query) The record to begin the return set on 
    /// - parameter limit: (query) The number of records to return 
    /// - parameter availableOnly: (query) Return only results that are currently being promoted (is activated and not expired) 
    /// - parameter activeOnly: (query) Return only active results 
    /// - parameter includeCategories: (query)  
    /// - parameter includeFilters: (query)  
    /// - parameter includeOfferLocations: (query)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter categoryIds: (query)  (optional)
    /// - parameter filterIds: (query)  (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter retailerId: (query) the id of the retailer (optional)
    /// - parameter retailerLocationId: (query) the id of the retailer location (optional)
    /// - parameter couponType: (query) This parameter is deprecated. (optional)
    /// - parameter offerType: (query) This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers (optional)
    /// - parameter offerTypes: (query) Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE} (optional)
    /// - parameter specialOfferType: (query) Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter barcodeType: (query)  (optional)
    /// - parameter barcodeEntry: (query)  (optional)
    /// - parameter isbn: (query)  (optional)
    /// - parameter asin: (query)  (optional)
    /// - parameter deviceStatus: (query) Edysen device status (optional)
    /// - parameter needsNotificationSent: (query)  (optional)
    /// - parameter lastNotificationSent: (query)  (optional)
    /// - returns: AnyPublisher<[OfferResponse], Error> 
    open func getOffersForRetailers(offerVisibility: GetOffersForRetailersOfferVisibility, sortField: GetOffersForRetailersSortField, descending: Bool, start: Int, limit: Int, availableOnly: Bool, activeOnly: Bool, includeCategories: Bool, includeFilters: Bool, includeOfferLocations: Bool, deviceId: String? = nil, accountId: Int64? = nil, categoryIds: String? = nil, filterIds: String? = nil, q: String? = nil, keyword: String? = nil, retailerId: Int64? = nil, retailerLocationId: Int64? = nil, couponType: GetOffersForRetailersCouponType? = nil, offerType: GetOffersForRetailersOfferType? = nil, offerTypes: String? = nil, specialOfferType: GetOffersForRetailersSpecialOfferType? = nil, i: Int? = nil, l: Int? = nil, barcodeType: String? = nil, barcodeEntry: String? = nil, isbn: String? = nil, asin: String? = nil, deviceStatus: GetOffersForRetailersDeviceStatus? = nil, needsNotificationSent: Bool? = nil, lastNotificationSent: Int64? = nil) -> AnyPublisher<[OfferResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let couponType = couponType { queryItems.append(URLQueryItem(name: "couponType", value: couponType.rawValue)) } 
                if let offerType = offerType { queryItems.append(URLQueryItem(name: "offerType", value: offerType.rawValue)) } 
                if let offerTypes = offerTypes { queryItems.append(URLQueryItem(name: "offerTypes", value: offerTypes)) } 
                if let specialOfferType = specialOfferType { queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue)) } 
                queryItems.append(URLQueryItem(name: "offerVisibility", value: offerVisibility.rawValue))
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "availableOnly", value: availableOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includeCategories", value: includeCategories ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includeFilters", value: includeFilters ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includeOfferLocations", value: includeOfferLocations ? "true" : "false"))
                if let barcodeType = barcodeType { queryItems.append(URLQueryItem(name: "barcodeType", value: barcodeType)) } 
                if let barcodeEntry = barcodeEntry { queryItems.append(URLQueryItem(name: "barcodeEntry", value: barcodeEntry)) } 
                if let isbn = isbn { queryItems.append(URLQueryItem(name: "isbn", value: isbn)) } 
                if let asin = asin { queryItems.append(URLQueryItem(name: "asin", value: asin)) } 
                if let deviceStatus = deviceStatus { queryItems.append(URLQueryItem(name: "deviceStatus", value: deviceStatus.rawValue)) } 
                if let needsNotificationSent = needsNotificationSent { queryItems.append(URLQueryItem(name: "needsNotificationSent", value: needsNotificationSent ? "true" : "false")) } 
                if let lastNotificationSent = lastNotificationSent { queryItems.append(URLQueryItem(name: "lastNotificationSent", value: "\(lastNotificationSent)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Offer Transaction
    /// - POST /retailer/offer/transaction/update
    /// - Redeems an offer.
    /// - parameter offerTransactionId: (query) the OfferTransaction ID of the transaction being redeemed 
    /// - parameter status: (query) the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter offerLocationId: (query) the OfferLocation ID where the offer is being redeemed (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func redeemOfferTransaction(offerTransactionId: Int64, status: Int, deviceId: String? = nil, accountId: Int64? = nil, offerLocationId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/transaction/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "offerTransactionId", value: "\(offerTransactionId)"))
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                queryItems.append(URLQueryItem(name: "status", value: "\(status)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchOfferTransactionsForRetailersSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case redeemableStart = "REDEEMABLE_START"
        case redeemableEnd = "REDEEMABLE_END"
        case customerId = "CUSTOMER_ID"
        case customerDisplay = "CUSTOMER_DISPLAY"
        case retailerId = "RETAILER_ID"
        case retailerName = "RETAILER_NAME"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }
    ///
    /// Enum for parameter couponType
    ///
    public enum SearchOfferTransactionsForRetailersCouponType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter offerType
    ///
    public enum SearchOfferTransactionsForRetailersOfferType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum SearchOfferTransactionsForRetailersSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }

    /// Search Offer Transactions
    /// - GET /retailer/offer/transaction/search
    /// - Searches on offer transactions for offers that the account has access to.
    /// - parameter sortField: (query) Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} 
    /// - parameter descending: (query) Determines whether the results are in descending order 
    /// - parameter start: (query) The start index for pagination 
    /// - parameter limit: (query) The limit for pagination 
    /// - parameter activeOnly: (query) Determines whether to only return active offer transactions 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) The keyword to search for (optional)
    /// - parameter retailerId: (query) Filter results for this retailer (optional)
    /// - parameter retailerLocationId: (query) Filter results for this retailer location (optional)
    /// - parameter offerId: (query) Filter results for this offer (optional)
    /// - parameter offerLocationId: (query) Filter results for this offer location (optional)
    /// - parameter redeemed: (query) if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1) (optional)
    /// - parameter reservationsOnly: (query) returns only reservation transactions if true (optional)
    /// - parameter couponType: (query) This parameter is deprecated. (optional)
    /// - parameter offerType: (query) Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers (optional)
    /// - parameter specialOfferType: (query) Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials (optional)
    /// - parameter customerAccountIds: (query) Filter results by accounts (optional)
    /// - parameter categoryIds: (query)  (optional)
    /// - parameter redeemableStartDate: (query)  (optional)
    /// - parameter redeemableEndDate: (query)  (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - returns: AnyPublisher<[OfferTransactionResponse], Error> 
    open func searchOfferTransactionsForRetailers(sortField: SearchOfferTransactionsForRetailersSortField, descending: Bool, start: Int, limit: Int, activeOnly: Bool, deviceId: String? = nil, accountId: Int64? = nil, q: String? = nil, keyword: String? = nil, retailerId: Int64? = nil, retailerLocationId: Int64? = nil, offerId: Int64? = nil, offerLocationId: Int64? = nil, redeemed: Bool? = nil, reservationsOnly: Bool? = nil, couponType: SearchOfferTransactionsForRetailersCouponType? = nil, offerType: SearchOfferTransactionsForRetailersOfferType? = nil, specialOfferType: SearchOfferTransactionsForRetailersSpecialOfferType? = nil, customerAccountIds: String? = nil, categoryIds: String? = nil, redeemableStartDate: Int64? = nil, redeemableEndDate: Int64? = nil, i: Int? = nil, l: Int? = nil) -> AnyPublisher<[OfferTransactionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/transaction/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let redeemed = redeemed { queryItems.append(URLQueryItem(name: "redeemed", value: redeemed ? "true" : "false")) } 
                if let reservationsOnly = reservationsOnly { queryItems.append(URLQueryItem(name: "reservationsOnly", value: reservationsOnly ? "true" : "false")) } 
                if let couponType = couponType { queryItems.append(URLQueryItem(name: "couponType", value: couponType.rawValue)) } 
                if let offerType = offerType { queryItems.append(URLQueryItem(name: "offerType", value: offerType.rawValue)) } 
                if let specialOfferType = specialOfferType { queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue)) } 
                if let customerAccountIds = customerAccountIds { queryItems.append(URLQueryItem(name: "customerAccountIds", value: customerAccountIds)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let redeemableStartDate = redeemableStartDate { queryItems.append(URLQueryItem(name: "redeemableStartDate", value: "\(redeemableStartDate)")) } 
                if let redeemableEndDate = redeemableEndDate { queryItems.append(URLQueryItem(name: "redeemableEndDate", value: "\(redeemableEndDate)")) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferTransactionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferTransactionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter recommendationType
    ///
    public enum SearchOffersForConsumerRecommendationType: String, Codable, CaseIterable {
        case wallet = "WALLET"
        case clicks = "CLICKS"
        case blended = "BLENDED"
    }
    ///
    /// Enum for parameter distanceUnit
    ///
    public enum SearchOffersForConsumerDistanceUnit: String, Codable, CaseIterable {
        case miles = "MILES"
        case kilometers = "KILOMETERS"
    }
    ///
    /// Enum for parameter groupBy
    ///
    public enum SearchOffersForConsumerGroupBy: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case offerId = "OFFER_ID"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case retailerId = "RETAILER_ID"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }

    /// Search Offers
    /// - GET /offer/lists
    /// - Searches for offers as a consumer.
    /// - parameter latitude: (query) The latitude of where the search will center at 
    /// - parameter longitude: (query) The longitude of where the search will center at 
    /// - parameter recommendationType: (query) The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available 
    /// - parameter locationId: (query) This parameter is deprecated. The location id 
    /// - parameter start: (query) The start index for pagination 
    /// - parameter limit: (query) The limit for pagination 
    /// - parameter maxRecommendations: (query)  
    /// - parameter distanceUnit: (query)  
    /// - parameter appKey: (query) The application key used to identify the application (optional)
    /// - parameter deviceId: (query) The device id for returning account information (i.e. offer transactions made by the user) (optional)
    /// - parameter accountId: (query) The account id for returning account information (i.e. offer transactions made by the user) (optional)
    /// - parameter searchRange: (query) The range of the search (optional, default to 5)
    /// - parameter tags: (query) Does a full-text search on tags (optional)
    /// - parameter supportedPostalCodes: (query) supported postal codes (optional)
    /// - parameter keyword: (query) The keyword to filter results by (optional)
    /// - parameter categories: (query) Comma separate list of category ids (optional)
    /// - parameter filters: (query) Comma separated list of filter ids (optional)
    /// - parameter offerTypes: (query) Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE} (optional, default to "COUPON, VOUCHER")
    /// - parameter type: (query) The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
    /// - parameter sortField: (query) The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations (optional)
    /// - parameter recommendOfferIds: (query) Return recommendations based on these offers IDs (optional)
    /// - parameter retailerLocationIds: (query) Only return offer locations for the specific retailer locations. (optional)
    /// - parameter offerId: (query) Only return offer locations for the specific offer. (optional)
    /// - parameter includeMission: (query) If true include the mission response as part of the offer. Default is false. (optional)
    /// - parameter includeCategories: (query) If true include the category list response as part of the offer. Default is false. (optional)
    /// - parameter includeFilters: (query) If true include the filter list response as part of the offer. Default is false. (optional)
    /// - parameter includeExpired: (query) If true then ignore the expired dates. Default is false. (optional)
    /// - parameter includeFavorite: (query) If true then ignore the favorite. Default is false. (optional)
    /// - parameter closestOfferOnly: (query) This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon (optional)
    /// - parameter searchExpression: (query)  (optional)
    /// - parameter groupBy: (query) groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy&#x3D;OFFER_ID and sortField&#x3D;DISTANCE (to sort by distance). (optional)
    /// - returns: AnyPublisher<OfferListResponse, Error> 
    open func searchOffersForConsumer(latitude: Double, longitude: Double, recommendationType: SearchOffersForConsumerRecommendationType, locationId: Int64, start: Int, limit: Int, maxRecommendations: Int, distanceUnit: SearchOffersForConsumerDistanceUnit, appKey: String? = nil, deviceId: String? = nil, accountId: Int64? = nil, searchRange: Double? = nil, tags: String? = nil, supportedPostalCodes: String? = nil, keyword: String? = nil, categories: String? = nil, filters: String? = nil, offerTypes: String? = nil, type: String? = nil, sortField: String? = nil, recommendOfferIds: String? = nil, retailerLocationIds: String? = nil, offerId: Int64? = nil, includeMission: Bool? = nil, includeCategories: Bool? = nil, includeFilters: Bool? = nil, includeExpired: Bool? = nil, includeFavorite: Bool? = nil, closestOfferOnly: Bool? = nil, searchExpression: String? = nil, groupBy: SearchOffersForConsumerGroupBy? = nil) -> AnyPublisher<OfferListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/offer/lists"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)"))
                queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)"))
                if let searchRange = searchRange { queryItems.append(URLQueryItem(name: "searchRange", value: "\(searchRange)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let supportedPostalCodes = supportedPostalCodes { queryItems.append(URLQueryItem(name: "supportedPostalCodes", value: supportedPostalCodes)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let categories = categories { queryItems.append(URLQueryItem(name: "categories", value: categories)) } 
                if let filters = filters { queryItems.append(URLQueryItem(name: "filters", value: filters)) } 
                if let offerTypes = offerTypes { queryItems.append(URLQueryItem(name: "offerTypes", value: offerTypes)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let recommendOfferIds = recommendOfferIds { queryItems.append(URLQueryItem(name: "recommendOfferIds", value: recommendOfferIds)) } 
                queryItems.append(URLQueryItem(name: "recommendationType", value: recommendationType.rawValue))
                queryItems.append(URLQueryItem(name: "locationId", value: "\(locationId)"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let includeMission = includeMission { queryItems.append(URLQueryItem(name: "includeMission", value: includeMission ? "true" : "false")) } 
                if let includeCategories = includeCategories { queryItems.append(URLQueryItem(name: "includeCategories", value: includeCategories ? "true" : "false")) } 
                if let includeFilters = includeFilters { queryItems.append(URLQueryItem(name: "includeFilters", value: includeFilters ? "true" : "false")) } 
                if let includeExpired = includeExpired { queryItems.append(URLQueryItem(name: "includeExpired", value: includeExpired ? "true" : "false")) } 
                if let includeFavorite = includeFavorite { queryItems.append(URLQueryItem(name: "includeFavorite", value: includeFavorite ? "true" : "false")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "maxRecommendations", value: "\(maxRecommendations)"))
                queryItems.append(URLQueryItem(name: "distanceUnit", value: distanceUnit.rawValue))
                if let closestOfferOnly = closestOfferOnly { queryItems.append(URLQueryItem(name: "closestOfferOnly", value: closestOfferOnly ? "true" : "false")) } 
                if let searchExpression = searchExpression { queryItems.append(URLQueryItem(name: "searchExpression", value: searchExpression)) } 
                if let groupBy = groupBy { queryItems.append(URLQueryItem(name: "groupBy", value: groupBy.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Offers (Top)
    /// - GET /offer/top
    /// - Gets the top active offers.
    /// - parameter start: (query) The index into the record set to start with. Default is 0. (optional, default to 0)
    /// - parameter limit: (query) The total number of record to return. Default id 20. (optional, default to 20)
    /// - returns: AnyPublisher<OfferListResponse, Error> 
    open func topOfferTransactions(start: Int? = nil, limit: Int? = nil) -> AnyPublisher<OfferListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/offer/top"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter barcodeType
    ///
    public enum UpdateOfferBarcodeType: String, Codable, CaseIterable {
        case _none = "NONE"
        case upc = "UPC"
        case code128 = "CODE_128"
        case qr = "QR"
        case customMedia = "CUSTOM_MEDIA"
    }
    ///
    /// Enum for parameter offerType
    ///
    public enum UpdateOfferOfferType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum UpdateOfferSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }
    ///
    /// Enum for parameter offerVisibility
    ///
    public enum UpdateOfferOfferVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }
    ///
    /// Enum for parameter productType
    ///
    public enum UpdateOfferProductType: String, Codable, CaseIterable {
        case apparel = "APPAREL"
        case appliances = "APPLIANCES"
        case apps = "APPS"
        case artsCrafts = "ARTS_CRAFTS"
        case automotive = "AUTOMOTIVE"
        case baby = "BABY"
        case beauty = "BEAUTY"
        case books = "BOOKS"
        case classical = "CLASSICAL"
        case collectibles = "COLLECTIBLES"
        case dvd = "DVD"
        case electronics = "ELECTRONICS"
        case giftCards = "GIFT_CARDS"
        case gourmetFood = "GOURMET_FOOD"
        case grocery = "GROCERY"
        case healthPersonalCare = "HEALTH_PERSONAL_CARE"
        case homeGarden = "HOME_GARDEN"
        case industrial = "INDUSTRIAL"
        case jewelry = "JEWELRY"
        case kitchen = "KITCHEN"
        case lawnGarden = "LAWN_GARDEN"
        case magazines = "MAGAZINES"
        case miscellaneous = "MISCELLANEOUS"
        case musicalInstruments = "MUSICAL_INSTRUMENTS"
        case officeProducts = "OFFICE_PRODUCTS"
        case other = "OTHER"
        case outdoorLiving = "OUTDOOR_LIVING"
        case pcHardware = "PC_HARDWARE"
        case petSupplies = "PET_SUPPLIES"
        case shoes = "SHOES"
        case software = "SOFTWARE"
        case sportingGoods = "SPORTING_GOODS"
        case tools = "TOOLS"
        case toys = "TOYS"
        case videoGames = "VIDEO_GAMES"
        case watches = "WATCHES"
        case wireless = "WIRELESS"
        case wirelessAccessories = "WIRELESS_ACCESSORIES"
    }
    ///
    /// Enum for parameter conditionType
    ///
    public enum UpdateOfferConditionType: String, Codable, CaseIterable {
        case new = "NEW"
        case used = "USED"
        case refurbished = "REFURBISHED"
        case other = "OTHER"
    }
    ///
    /// Enum for parameter unit
    ///
    public enum UpdateOfferUnit: String, Codable, CaseIterable {
        case milimeter = "MILIMETER"
        case centimeter = "CENTIMETER"
        case meter = "METER"
        case inch = "INCH"
        case foot = "FOOT"
        case yard = "YARD"
    }
    ///
    /// Enum for parameter mediaType
    ///
    public enum UpdateOfferMediaType: String, Codable, CaseIterable {
        case apk = "APK"
        case application = "APPLICATION"
        case image = "IMAGE"
        case audio = "AUDIO"
        case video = "VIDEO"
        case multipart = "MULTIPART"
        case barCode = "BAR_CODE"
        case text = "TEXT"
        case other = "OTHER"
    }

    /// Update Offer
    /// - POST /retailer/offer/update
    /// - Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.
    /// - parameter offerId: (query) The offer to update 
    /// - parameter includeOfferLocations: (query) If true return all the offer locations associated with the offer 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) (optional)
    /// - parameter parentOfferId: (query)  (optional)
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
    /// - parameter offerLocations: (query) A list of json data that has offer location specific values. (optional)
    /// - parameter tags: (query) Custom string field for doing full-text searches (optional)
    /// - parameter title: (query) The title (255 char limit) (optional)
    /// - parameter subTitle: (query) The sub title (255 char limit) (optional)
    /// - parameter details: (query) The details (optional)
    /// - parameter subDetails: (query) A string for custom details (255 char limit) (optional)
    /// - parameter finePrint: (query) The fine print (optional)
    /// - parameter barcodeType: (query) The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
    /// - parameter barcodeEntry: (query) The bar code entry string (optional)
    /// - parameter externalRedeemOptions: (query) An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
    /// - parameter externalUrl: (query) The clickUrl of the offer (optional)
    /// - parameter externalId: (query)  (optional)
    /// - parameter ticketsRewardType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter ticketsReward: (query) Determines how many tickets are awarded (optional)
    /// - parameter activated: (query) The date of when the offer will be visible to consumers (optional)
    /// - parameter expires: (query) The date of when the offer expires (optional)
    /// - parameter noExpiration: (query) Overrides the expiration date so that the offer does not expire (optional)
    /// - parameter availableLimit: (query) The limit of how many times the offer can be used by consumers (optional)
    /// - parameter availableLimitPerUser: (query) The limit of how many times a user can used the same offer (optional)
    /// - parameter addedLimit: (query) The limit of how many times the offer can be added to consumer wallets (optional)
    /// - parameter viewLimit: (query)  (optional)
    /// - parameter maxPrints: (query) The maximum number of times the offer can be printed (optional)
    /// - parameter ticketPriceType: (query) the type of ticket needed to buy the offer (optional)
    /// - parameter ticketPrice: (query) The cost of the offer in tickets (optional)
    /// - parameter fullPrice: (query) The retail/full price cost of the offer in real currency (optional)
    /// - parameter discountPrice: (query) The cost of the offer at a discounted price (what the consumer pays) (optional)
    /// - parameter showRemaining: (query) show remaining offers available (optional)
    /// - parameter showRedeemed: (query) show how many offers have been redeemed (optional)
    /// - parameter replaced: (query)  (optional)
    /// - parameter featured: (query) whether the offer is featured or not (optional)
    /// - parameter offerType: (query) The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT} (optional)
    /// - parameter specialOfferType: (query) The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
    /// - parameter offerVisibility: (query) The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids (optional)
    /// - parameter filterIds: (query) Comma separated list of filter ids (optional)
    /// - parameter active: (query) Sets the active flag (optional)
    /// - parameter barcodeAssetId: (query) The id of the barcode asset (optional)
    /// - parameter imageAssetId: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId1: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId2: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId3: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId4: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId5: (query) The id of the an offer asset (optional)
    /// - parameter publisher: (query) The maker of the item. (optional)
    /// - parameter redeemableStart: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter redeemableEnd: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter brand: (query) The brand. OfferType PRODUCT only. (optional)
    /// - parameter productType: (query) The product type. OfferType PRODUCT only. (optional)
    /// - parameter conditionType: (query) The condition. OfferType PRODUCT only. (optional)
    /// - parameter isbn: (query) The ISBN id. OfferType PRODUCT only. (optional)
    /// - parameter asin: (query) The ASIN id. OfferType PRODUCT only. (optional)
    /// - parameter catalogNumbers: (query) The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
    /// - parameter department: (query) The department name. The OfferType PRODUCT only. (optional)
    /// - parameter features: (query) The list of features, comma seperated. OfferType PRODUCT only. (optional)
    /// - parameter minimumPrice: (query) The MAP price. OfferType PRODUCT only. (optional)
    /// - parameter width: (query) The width of the item. OfferType PRODUCT only. (optional)
    /// - parameter height: (query) The height of the item. OfferType PRODUCT only. (optional)
    /// - parameter depth: (query) The depth of the item. OfferType PRODUCT only. (optional)
    /// - parameter weight: (query) The weight of the item. OfferType PRODUCT only. (optional)
    /// - parameter unit: (query) The unit of measurement. OfferType PRODUCT only. (optional)
    /// - parameter studio: (query) The studio name. OfferType PRODUCT only. (optional)
    /// - parameter parentalRating: (query) The parental control rating. OfferType PRODUCT only. (optional)
    /// - parameter publishDate: (query) The date published. OfferType PRODUCT only. (optional)
    /// - parameter availabilityDate: (query) The date available. OfferType PRODUCT only. (optional)
    /// - parameter sizeId: (query) The size Id. OfferType PRODUCT only. (optional)
    /// - parameter listingId: (query) The ID of the event listing (optional)
    /// - parameter mediaType: (query)  (optional)
    /// - parameter duration: (query) The total playing time of the media item. OfferType MEDIA only. (optional)
    /// - parameter author: (query) The created/author of the media item. OfferType MEDIA only. (optional)
    /// - parameter releaseDate: (query) The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
    /// - parameter collectionIds: (query)  (optional)
    /// - parameter rebootTimeHour: (query) The reboot hour time ranging from 0 to 23 (optional)
    /// - parameter rebootTimeMinute: (query) The reboot minute time ranging from 0 to 59 (optional)
    /// - parameter idleTimeoutInSecond: (query) If the device is idle for idleTimeoutInSecond then the device should timeout (optional)
    /// - parameter serialNumber: (query) The serial number on the device (optional)
    /// - parameter udid: (query) The unique device id for the device (optional)
    /// - parameter deviceType: (query) The type of the device, for example: \&quot;Kiosk\&quot;, \&quot;Beacon\&quot;. (optional)
    /// - parameter devicePower: (query) RSSI reading at 1 meter from device (-10 to -140) (optional)
    /// - parameter deviceInterference: (query)  (optional)
    /// - parameter availability: (query)  (optional)
    /// - parameter availabilitySummary: (query)  (optional)
    /// - returns: AnyPublisher<RetailerOfferResponse, Error> 
    open func updateOffer(offerId: Int64, includeOfferLocations: Bool, deviceId: String? = nil, accountId: Int64? = nil, parentOfferId: Int64? = nil, retailerLocationIds: String? = nil, offerLocations: String? = nil, tags: String? = nil, title: String? = nil, subTitle: String? = nil, details: String? = nil, subDetails: String? = nil, finePrint: String? = nil, barcodeType: UpdateOfferBarcodeType? = nil, barcodeEntry: String? = nil, externalRedeemOptions: String? = nil, externalUrl: String? = nil, externalId: String? = nil, ticketsRewardType: String? = nil, ticketsReward: Int64? = nil, activated: Int64? = nil, expires: Int64? = nil, noExpiration: Bool? = nil, availableLimit: Int? = nil, availableLimitPerUser: Int? = nil, addedLimit: Int? = nil, viewLimit: Int? = nil, maxPrints: Int? = nil, ticketPriceType: String? = nil, ticketPrice: Int64? = nil, fullPrice: Double? = nil, discountPrice: Double? = nil, showRemaining: Bool? = nil, showRedeemed: Bool? = nil, replaced: Bool? = nil, featured: Bool? = nil, offerType: UpdateOfferOfferType? = nil, specialOfferType: UpdateOfferSpecialOfferType? = nil, offerVisibility: UpdateOfferOfferVisibility? = nil, categoryIds: String? = nil, filterIds: String? = nil, active: Bool? = nil, barcodeAssetId: Int64? = nil, imageAssetId: Int64? = nil, imageAssetId1: Int64? = nil, imageAssetId2: Int64? = nil, imageAssetId3: Int64? = nil, imageAssetId4: Int64? = nil, imageAssetId5: Int64? = nil, publisher: String? = nil, redeemableStart: Int64? = nil, redeemableEnd: Int64? = nil, brand: String? = nil, productType: UpdateOfferProductType? = nil, conditionType: UpdateOfferConditionType? = nil, isbn: String? = nil, asin: String? = nil, catalogNumbers: String? = nil, department: String? = nil, features: String? = nil, minimumPrice: Double? = nil, width: Double? = nil, height: Double? = nil, depth: Double? = nil, weight: Double? = nil, unit: UpdateOfferUnit? = nil, studio: String? = nil, parentalRating: String? = nil, publishDate: Int64? = nil, availabilityDate: Int64? = nil, sizeId: Int64? = nil, listingId: Int64? = nil, mediaType: UpdateOfferMediaType? = nil, duration: Int? = nil, author: String? = nil, releaseDate: Int64? = nil, collectionIds: String? = nil, rebootTimeHour: Int? = nil, rebootTimeMinute: Int? = nil, idleTimeoutInSecond: Int? = nil, serialNumber: String? = nil, udid: String? = nil, deviceType: String? = nil, devicePower: Double? = nil, deviceInterference: Double? = nil, availability: String? = nil, availabilitySummary: String? = nil) -> AnyPublisher<RetailerOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)"))
                if let parentOfferId = parentOfferId { queryItems.append(URLQueryItem(name: "parentOfferId", value: "\(parentOfferId)")) } 
                queryItems.append(URLQueryItem(name: "includeOfferLocations", value: includeOfferLocations ? "true" : "false"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let offerLocations = offerLocations { queryItems.append(URLQueryItem(name: "offerLocations", value: offerLocations)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let subTitle = subTitle { queryItems.append(URLQueryItem(name: "subTitle", value: subTitle)) } 
                if let details = details { queryItems.append(URLQueryItem(name: "details", value: details)) } 
                if let subDetails = subDetails { queryItems.append(URLQueryItem(name: "subDetails", value: subDetails)) } 
                if let finePrint = finePrint { queryItems.append(URLQueryItem(name: "finePrint", value: finePrint)) } 
                if let barcodeType = barcodeType { queryItems.append(URLQueryItem(name: "barcodeType", value: barcodeType.rawValue)) } 
                if let barcodeEntry = barcodeEntry { queryItems.append(URLQueryItem(name: "barcodeEntry", value: barcodeEntry)) } 
                if let externalRedeemOptions = externalRedeemOptions { queryItems.append(URLQueryItem(name: "externalRedeemOptions", value: externalRedeemOptions)) } 
                if let externalUrl = externalUrl { queryItems.append(URLQueryItem(name: "externalUrl", value: externalUrl)) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let ticketsRewardType = ticketsRewardType { queryItems.append(URLQueryItem(name: "ticketsRewardType", value: ticketsRewardType)) } 
                if let ticketsReward = ticketsReward { queryItems.append(URLQueryItem(name: "ticketsReward", value: "\(ticketsReward)")) } 
                if let activated = activated { queryItems.append(URLQueryItem(name: "activated", value: "\(activated)")) } 
                if let expires = expires { queryItems.append(URLQueryItem(name: "expires", value: "\(expires)")) } 
                if let noExpiration = noExpiration { queryItems.append(URLQueryItem(name: "noExpiration", value: noExpiration ? "true" : "false")) } 
                if let availableLimit = availableLimit { queryItems.append(URLQueryItem(name: "availableLimit", value: "\(availableLimit)")) } 
                if let availableLimitPerUser = availableLimitPerUser { queryItems.append(URLQueryItem(name: "availableLimitPerUser", value: "\(availableLimitPerUser)")) } 
                if let addedLimit = addedLimit { queryItems.append(URLQueryItem(name: "addedLimit", value: "\(addedLimit)")) } 
                if let viewLimit = viewLimit { queryItems.append(URLQueryItem(name: "viewLimit", value: "\(viewLimit)")) } 
                if let maxPrints = maxPrints { queryItems.append(URLQueryItem(name: "maxPrints", value: "\(maxPrints)")) } 
                if let ticketPriceType = ticketPriceType { queryItems.append(URLQueryItem(name: "ticketPriceType", value: ticketPriceType)) } 
                if let ticketPrice = ticketPrice { queryItems.append(URLQueryItem(name: "ticketPrice", value: "\(ticketPrice)")) } 
                if let fullPrice = fullPrice { queryItems.append(URLQueryItem(name: "fullPrice", value: "\(fullPrice)")) } 
                if let discountPrice = discountPrice { queryItems.append(URLQueryItem(name: "discountPrice", value: "\(discountPrice)")) } 
                if let showRemaining = showRemaining { queryItems.append(URLQueryItem(name: "showRemaining", value: showRemaining ? "true" : "false")) } 
                if let showRedeemed = showRedeemed { queryItems.append(URLQueryItem(name: "showRedeemed", value: showRedeemed ? "true" : "false")) } 
                if let replaced = replaced { queryItems.append(URLQueryItem(name: "replaced", value: replaced ? "true" : "false")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                if let offerType = offerType { queryItems.append(URLQueryItem(name: "offerType", value: offerType.rawValue)) } 
                if let specialOfferType = specialOfferType { queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue)) } 
                if let offerVisibility = offerVisibility { queryItems.append(URLQueryItem(name: "offerVisibility", value: offerVisibility.rawValue)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let barcodeAssetId = barcodeAssetId { queryItems.append(URLQueryItem(name: "barcodeAssetId", value: "\(barcodeAssetId)")) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let imageAssetId1 = imageAssetId1 { queryItems.append(URLQueryItem(name: "imageAssetId1", value: "\(imageAssetId1)")) } 
                if let imageAssetId2 = imageAssetId2 { queryItems.append(URLQueryItem(name: "imageAssetId2", value: "\(imageAssetId2)")) } 
                if let imageAssetId3 = imageAssetId3 { queryItems.append(URLQueryItem(name: "imageAssetId3", value: "\(imageAssetId3)")) } 
                if let imageAssetId4 = imageAssetId4 { queryItems.append(URLQueryItem(name: "imageAssetId4", value: "\(imageAssetId4)")) } 
                if let imageAssetId5 = imageAssetId5 { queryItems.append(URLQueryItem(name: "imageAssetId5", value: "\(imageAssetId5)")) } 
                if let publisher = publisher { queryItems.append(URLQueryItem(name: "publisher", value: publisher)) } 
                if let redeemableStart = redeemableStart { queryItems.append(URLQueryItem(name: "redeemableStart", value: "\(redeemableStart)")) } 
                if let redeemableEnd = redeemableEnd { queryItems.append(URLQueryItem(name: "redeemableEnd", value: "\(redeemableEnd)")) } 
                if let brand = brand { queryItems.append(URLQueryItem(name: "brand", value: brand)) } 
                if let productType = productType { queryItems.append(URLQueryItem(name: "productType", value: productType.rawValue)) } 
                if let conditionType = conditionType { queryItems.append(URLQueryItem(name: "conditionType", value: conditionType.rawValue)) } 
                if let isbn = isbn { queryItems.append(URLQueryItem(name: "isbn", value: isbn)) } 
                if let asin = asin { queryItems.append(URLQueryItem(name: "asin", value: asin)) } 
                if let catalogNumbers = catalogNumbers { queryItems.append(URLQueryItem(name: "catalogNumbers", value: catalogNumbers)) } 
                if let department = department { queryItems.append(URLQueryItem(name: "department", value: department)) } 
                if let features = features { queryItems.append(URLQueryItem(name: "features", value: features)) } 
                if let minimumPrice = minimumPrice { queryItems.append(URLQueryItem(name: "minimumPrice", value: "\(minimumPrice)")) } 
                if let width = width { queryItems.append(URLQueryItem(name: "width", value: "\(width)")) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: "\(height)")) } 
                if let depth = depth { queryItems.append(URLQueryItem(name: "depth", value: "\(depth)")) } 
                if let weight = weight { queryItems.append(URLQueryItem(name: "weight", value: "\(weight)")) } 
                if let unit = unit { queryItems.append(URLQueryItem(name: "unit", value: unit.rawValue)) } 
                if let studio = studio { queryItems.append(URLQueryItem(name: "studio", value: studio)) } 
                if let parentalRating = parentalRating { queryItems.append(URLQueryItem(name: "parentalRating", value: parentalRating)) } 
                if let publishDate = publishDate { queryItems.append(URLQueryItem(name: "publishDate", value: "\(publishDate)")) } 
                if let availabilityDate = availabilityDate { queryItems.append(URLQueryItem(name: "availabilityDate", value: "\(availabilityDate)")) } 
                if let sizeId = sizeId { queryItems.append(URLQueryItem(name: "sizeId", value: "\(sizeId)")) } 
                if let listingId = listingId { queryItems.append(URLQueryItem(name: "listingId", value: "\(listingId)")) } 
                if let mediaType = mediaType { queryItems.append(URLQueryItem(name: "mediaType", value: mediaType.rawValue)) } 
                if let duration = duration { queryItems.append(URLQueryItem(name: "duration", value: "\(duration)")) } 
                if let author = author { queryItems.append(URLQueryItem(name: "author", value: author)) } 
                if let releaseDate = releaseDate { queryItems.append(URLQueryItem(name: "releaseDate", value: "\(releaseDate)")) } 
                if let collectionIds = collectionIds { queryItems.append(URLQueryItem(name: "collectionIds", value: collectionIds)) } 
                if let rebootTimeHour = rebootTimeHour { queryItems.append(URLQueryItem(name: "rebootTimeHour", value: "\(rebootTimeHour)")) } 
                if let rebootTimeMinute = rebootTimeMinute { queryItems.append(URLQueryItem(name: "rebootTimeMinute", value: "\(rebootTimeMinute)")) } 
                if let idleTimeoutInSecond = idleTimeoutInSecond { queryItems.append(URLQueryItem(name: "idleTimeoutInSecond", value: "\(idleTimeoutInSecond)")) } 
                if let serialNumber = serialNumber { queryItems.append(URLQueryItem(name: "serialNumber", value: serialNumber)) } 
                if let udid = udid { queryItems.append(URLQueryItem(name: "udid", value: udid)) } 
                if let deviceType = deviceType { queryItems.append(URLQueryItem(name: "deviceType", value: deviceType)) } 
                if let devicePower = devicePower { queryItems.append(URLQueryItem(name: "devicePower", value: "\(devicePower)")) } 
                if let deviceInterference = deviceInterference { queryItems.append(URLQueryItem(name: "deviceInterference", value: "\(deviceInterference)")) } 
                if let availability = availability { queryItems.append(URLQueryItem(name: "availability", value: availability)) } 
                if let availabilitySummary = availabilitySummary { queryItems.append(URLQueryItem(name: "availabilitySummary", value: availabilitySummary)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Activate Offer
    /// - POST /retailer/offer/status
    /// - Sets the activated date on offers. This will make offers visible for consumers.
    /// - parameter offerIds: (query) Comma separated list of offer ids 
    /// - parameter active: (query) Determines whether to make the offer active as well 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account used to perform the activation, must have rights to edit the offer. (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateOfferStatus(offerIds: String, active: Bool, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/offer/status"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "offerIds", value: offerIds))
                queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
