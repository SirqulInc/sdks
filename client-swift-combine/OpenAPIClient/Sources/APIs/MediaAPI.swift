//
// MediaAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class MediaAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter barcodeType
    ///
    public enum CreateMediaBarcodeType: String, Codable, CaseIterable {
        case _none = "NONE"
        case upc = "UPC"
        case code128 = "CODE_128"
        case qr = "QR"
        case customMedia = "CUSTOM_MEDIA"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum CreateMediaSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }
    ///
    /// Enum for parameter offerVisibility
    ///
    public enum CreateMediaOfferVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }
    ///
    /// Enum for parameter conditionType
    ///
    public enum CreateMediaConditionType: String, Codable, CaseIterable {
        case new = "NEW"
        case used = "USED"
        case refurbished = "REFURBISHED"
        case other = "OTHER"
    }
    ///
    /// Enum for parameter mediaType
    ///
    public enum CreateMediaMediaType: String, Codable, CaseIterable {
        case apk = "APK"
        case application = "APPLICATION"
        case image = "IMAGE"
        case audio = "AUDIO"
        case video = "VIDEO"
        case multipart = "MULTIPART"
        case barCode = "BAR_CODE"
        case text = "TEXT"
        case other = "OTHER"
    }

    /// Create Media
    /// - POST /media/create
    /// - Create a media offering.
    /// - parameter accountId: (query) The account id of the logged in user 
    /// - parameter title: (query) The title (255 char limit) 
    /// - parameter barcodeType: (query) The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} 
    /// - parameter noExpiration: (query) Overrides the expiration date so that the offer does not expire 
    /// - parameter availableLimit: (query) The limit of how many times the offer can be used by consumers 
    /// - parameter availableLimitPerUser: (query) The limit of how many times a user can used the same offer 
    /// - parameter addedLimit: (query) The limit of how many times the offer can be added to consumer wallets 
    /// - parameter viewLimit: (query) The limit of how many times the offer can be viewed 
    /// - parameter maxPrints: (query) The maximum number of times the offer can be printed 
    /// - parameter ticketPrice: (query) The cost of the offer in tickets 
    /// - parameter fullPrice: (query) The retail/full price cost of the offer in real currency 
    /// - parameter discountPrice: (query) The cost of the offer at a discounted price (what the consumer pays) 
    /// - parameter specialOfferType: (query) The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} 
    /// - parameter offerVisibility: (query) The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} 
    /// - parameter active: (query) Sets the active flag 
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
    /// - parameter subTitle: (query) The sub title (255 char limit) (optional)
    /// - parameter details: (query) The details of the media (optional)
    /// - parameter subDetails: (query) A string for custom details (255 char limit) (optional)
    /// - parameter finePrint: (query) The fine print of the media (optional)
    /// - parameter barcodeEntry: (query) The bar code entry string (optional)
    /// - parameter externalRedeemOptions: (query) An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer (optional)
    /// - parameter externalUrl: (query) The clickUrl of the offer (optional)
    /// - parameter ticketsRewardType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter ticketsReward: (query) Determines how many tickets are awarded (optional)
    /// - parameter activated: (query) The date of when the offer will be visible to consumers (optional)
    /// - parameter expires: (query) The date of when the offer expires (optional)
    /// - parameter ticketPriceType: (query) the type of ticket needed to buy offer (optional)
    /// - parameter showRemaining: (query) show how many of the media is remaining (if there is a limit) (optional)
    /// - parameter showRedeemed: (query) show how many of the media has been redeemed (optional)
    /// - parameter replaced: (query) if the media has been replaced (optional)
    /// - parameter featured: (query) if the media should be featured or not (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids (optional)
    /// - parameter filterIds: (query) Comma separated list of filter ids (optional)
    /// - parameter barcodeAssetId: (query) The id of the barcode asset (optional)
    /// - parameter imageAssetId: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId1: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId2: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId3: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId4: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId5: (query) The id of the an offer asset (optional)
    /// - parameter publisher: (query) The maker of the item. (optional)
    /// - parameter redeemableStart: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter redeemableEnd: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter conditionType: (query) The condition type of the media (optional)
    /// - parameter isbn: (query) The ISBN id (optional)
    /// - parameter asin: (query) The ASIN id (optional)
    /// - parameter catalogNumbers: (query) The list of catelog numbers, comma seperated (optional)
    /// - parameter parentalRating: (query) The parental control rating (optional)
    /// - parameter availabilityDate: (query) The date the media is available to use (optional)
    /// - parameter mediaType: (query) the media type (optional)
    /// - parameter duration: (query) The total playing time of the media item (optional)
    /// - parameter author: (query) The created/author of the media item (optional)
    /// - parameter releaseDate: (query) The date/time of when the media item was originally released (optional)
    /// - parameter collectionIds: (query) the IDs of the collections this media should be assigned to (optional)
    /// - parameter availability: (query) ability to assign if this media should active or not (optional)
    /// - parameter availabilitySummary: (query) ability to assign when the media expires (optional)
    /// - returns: AnyPublisher<MediaOfferResponse, Error> 
    open func createMedia(accountId: Int64, title: String, barcodeType: CreateMediaBarcodeType, noExpiration: Bool, availableLimit: Int, availableLimitPerUser: Int, addedLimit: Int, viewLimit: Int, maxPrints: Int, ticketPrice: Int64, fullPrice: Double, discountPrice: Double, specialOfferType: CreateMediaSpecialOfferType, offerVisibility: CreateMediaOfferVisibility, active: Bool, retailerLocationIds: String? = nil, subTitle: String? = nil, details: String? = nil, subDetails: String? = nil, finePrint: String? = nil, barcodeEntry: String? = nil, externalRedeemOptions: String? = nil, externalUrl: String? = nil, ticketsRewardType: String? = nil, ticketsReward: Int64? = nil, activated: Int64? = nil, expires: Int64? = nil, ticketPriceType: String? = nil, showRemaining: Bool? = nil, showRedeemed: Bool? = nil, replaced: Bool? = nil, featured: Bool? = nil, categoryIds: String? = nil, filterIds: String? = nil, barcodeAssetId: Int64? = nil, imageAssetId: Int64? = nil, imageAssetId1: Int64? = nil, imageAssetId2: Int64? = nil, imageAssetId3: Int64? = nil, imageAssetId4: Int64? = nil, imageAssetId5: Int64? = nil, publisher: String? = nil, redeemableStart: Int64? = nil, redeemableEnd: Int64? = nil, conditionType: CreateMediaConditionType? = nil, isbn: String? = nil, asin: String? = nil, catalogNumbers: String? = nil, parentalRating: String? = nil, availabilityDate: Int64? = nil, mediaType: CreateMediaMediaType? = nil, duration: Int? = nil, author: String? = nil, releaseDate: Int64? = nil, collectionIds: String? = nil, availability: String? = nil, availabilitySummary: String? = nil) -> AnyPublisher<MediaOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/media/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                queryItems.append(URLQueryItem(name: "title", value: title))
                if let subTitle = subTitle { queryItems.append(URLQueryItem(name: "subTitle", value: subTitle)) } 
                if let details = details { queryItems.append(URLQueryItem(name: "details", value: details)) } 
                if let subDetails = subDetails { queryItems.append(URLQueryItem(name: "subDetails", value: subDetails)) } 
                if let finePrint = finePrint { queryItems.append(URLQueryItem(name: "finePrint", value: finePrint)) } 
                queryItems.append(URLQueryItem(name: "barcodeType", value: barcodeType.rawValue))
                if let barcodeEntry = barcodeEntry { queryItems.append(URLQueryItem(name: "barcodeEntry", value: barcodeEntry)) } 
                if let externalRedeemOptions = externalRedeemOptions { queryItems.append(URLQueryItem(name: "externalRedeemOptions", value: externalRedeemOptions)) } 
                if let externalUrl = externalUrl { queryItems.append(URLQueryItem(name: "externalUrl", value: externalUrl)) } 
                if let ticketsRewardType = ticketsRewardType { queryItems.append(URLQueryItem(name: "ticketsRewardType", value: ticketsRewardType)) } 
                if let ticketsReward = ticketsReward { queryItems.append(URLQueryItem(name: "ticketsReward", value: "\(ticketsReward)")) } 
                if let activated = activated { queryItems.append(URLQueryItem(name: "activated", value: "\(activated)")) } 
                if let expires = expires { queryItems.append(URLQueryItem(name: "expires", value: "\(expires)")) } 
                queryItems.append(URLQueryItem(name: "noExpiration", value: noExpiration ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "availableLimit", value: "\(availableLimit)"))
                queryItems.append(URLQueryItem(name: "availableLimitPerUser", value: "\(availableLimitPerUser)"))
                queryItems.append(URLQueryItem(name: "addedLimit", value: "\(addedLimit)"))
                queryItems.append(URLQueryItem(name: "viewLimit", value: "\(viewLimit)"))
                queryItems.append(URLQueryItem(name: "maxPrints", value: "\(maxPrints)"))
                if let ticketPriceType = ticketPriceType { queryItems.append(URLQueryItem(name: "ticketPriceType", value: ticketPriceType)) } 
                queryItems.append(URLQueryItem(name: "ticketPrice", value: "\(ticketPrice)"))
                queryItems.append(URLQueryItem(name: "fullPrice", value: "\(fullPrice)"))
                queryItems.append(URLQueryItem(name: "discountPrice", value: "\(discountPrice)"))
                if let showRemaining = showRemaining { queryItems.append(URLQueryItem(name: "showRemaining", value: showRemaining ? "true" : "false")) } 
                if let showRedeemed = showRedeemed { queryItems.append(URLQueryItem(name: "showRedeemed", value: showRedeemed ? "true" : "false")) } 
                if let replaced = replaced { queryItems.append(URLQueryItem(name: "replaced", value: replaced ? "true" : "false")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue))
                queryItems.append(URLQueryItem(name: "offerVisibility", value: offerVisibility.rawValue))
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false"))
                if let barcodeAssetId = barcodeAssetId { queryItems.append(URLQueryItem(name: "barcodeAssetId", value: "\(barcodeAssetId)")) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let imageAssetId1 = imageAssetId1 { queryItems.append(URLQueryItem(name: "imageAssetId1", value: "\(imageAssetId1)")) } 
                if let imageAssetId2 = imageAssetId2 { queryItems.append(URLQueryItem(name: "imageAssetId2", value: "\(imageAssetId2)")) } 
                if let imageAssetId3 = imageAssetId3 { queryItems.append(URLQueryItem(name: "imageAssetId3", value: "\(imageAssetId3)")) } 
                if let imageAssetId4 = imageAssetId4 { queryItems.append(URLQueryItem(name: "imageAssetId4", value: "\(imageAssetId4)")) } 
                if let imageAssetId5 = imageAssetId5 { queryItems.append(URLQueryItem(name: "imageAssetId5", value: "\(imageAssetId5)")) } 
                if let publisher = publisher { queryItems.append(URLQueryItem(name: "publisher", value: publisher)) } 
                if let redeemableStart = redeemableStart { queryItems.append(URLQueryItem(name: "redeemableStart", value: "\(redeemableStart)")) } 
                if let redeemableEnd = redeemableEnd { queryItems.append(URLQueryItem(name: "redeemableEnd", value: "\(redeemableEnd)")) } 
                if let conditionType = conditionType { queryItems.append(URLQueryItem(name: "conditionType", value: conditionType.rawValue)) } 
                if let isbn = isbn { queryItems.append(URLQueryItem(name: "isbn", value: isbn)) } 
                if let asin = asin { queryItems.append(URLQueryItem(name: "asin", value: asin)) } 
                if let catalogNumbers = catalogNumbers { queryItems.append(URLQueryItem(name: "catalogNumbers", value: catalogNumbers)) } 
                if let parentalRating = parentalRating { queryItems.append(URLQueryItem(name: "parentalRating", value: parentalRating)) } 
                if let availabilityDate = availabilityDate { queryItems.append(URLQueryItem(name: "availabilityDate", value: "\(availabilityDate)")) } 
                if let mediaType = mediaType { queryItems.append(URLQueryItem(name: "mediaType", value: mediaType.rawValue)) } 
                if let duration = duration { queryItems.append(URLQueryItem(name: "duration", value: "\(duration)")) } 
                if let author = author { queryItems.append(URLQueryItem(name: "author", value: author)) } 
                if let releaseDate = releaseDate { queryItems.append(URLQueryItem(name: "releaseDate", value: "\(releaseDate)")) } 
                if let collectionIds = collectionIds { queryItems.append(URLQueryItem(name: "collectionIds", value: collectionIds)) } 
                if let availability = availability { queryItems.append(URLQueryItem(name: "availability", value: availability)) } 
                if let availabilitySummary = availabilitySummary { queryItems.append(URLQueryItem(name: "availabilitySummary", value: availabilitySummary)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MediaOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MediaOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Media
    /// - POST /media/delete
    /// - Delete a media offering that the user has permissions to.
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter mediaId: (query) the ID of the media to delete 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteMedia(accountId: Int64, mediaId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/media/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "mediaId", value: "\(mediaId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Media Get
    /// - GET /media/get
    /// - Get a media offering.
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter mediaId: (query) the id of the media to get 
    /// - returns: AnyPublisher<MediaOfferResponse, Error> 
    open func getMedia(accountId: Int64, mediaId: Int64) -> AnyPublisher<MediaOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/media/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "mediaId", value: "\(mediaId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MediaOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MediaOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchMediaSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case redeemableStart = "REDEEMABLE_START"
        case redeemableEnd = "REDEEMABLE_END"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case estimatedValue = "ESTIMATED_VALUE"
        case voucherPrice = "VOUCHER_PRICE"
        case voucherDiscountPrice = "VOUCHER_DISCOUNT_PRICE"
        case fullPrice = "FULL_PRICE"
        case dicountPrice = "DICOUNT_PRICE"
        case ticketsReward = "TICKETS_REWARD"
        case availabilityDate = "AVAILABILITY_DATE"
        case releaseDate = "RELEASE_DATE"
        case retailerId = "RETAILER_ID"
        case retailerName = "RETAILER_NAME"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }

    /// Search Media
    /// - GET /media/search
    /// - Searches on events that the account has access to.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter activeOnly: (query) Return only active results 
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE 
    /// - parameter descending: (query) The order to return the search results 
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter categoryIds: (query)  (optional)
    /// - parameter filterIds: (query)  (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - returns: AnyPublisher<[MediaOfferResponse], Error> 
    open func searchMedia(accountId: Int64, activeOnly: Bool, sortField: SearchMediaSortField, descending: Bool, keyword: String? = nil, categoryIds: String? = nil, filterIds: String? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[MediaOfferResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/media/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[MediaOfferResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([MediaOfferResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter barcodeType
    ///
    public enum UpdateMediaBarcodeType: String, Codable, CaseIterable {
        case _none = "NONE"
        case upc = "UPC"
        case code128 = "CODE_128"
        case qr = "QR"
        case customMedia = "CUSTOM_MEDIA"
    }
    ///
    /// Enum for parameter specialOfferType
    ///
    public enum UpdateMediaSpecialOfferType: String, Codable, CaseIterable {
        case all = "ALL"
        case reservable = "RESERVABLE"
        case regularOffer = "REGULAR_OFFER"
        case actNow = "ACT_NOW"
        case getThereNow = "GET_THERE_NOW"
        case sqoot = "SQOOT"
        case tickets = "TICKETS"
        case yipit = "YIPIT"
    }
    ///
    /// Enum for parameter offerVisibility
    ///
    public enum UpdateMediaOfferVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case listable = "LISTABLE"
        case rewardable = "REWARDABLE"
        case triggerable = "TRIGGERABLE"
        case _private = "PRIVATE"
    }
    ///
    /// Enum for parameter conditionType
    ///
    public enum UpdateMediaConditionType: String, Codable, CaseIterable {
        case new = "NEW"
        case used = "USED"
        case refurbished = "REFURBISHED"
        case other = "OTHER"
    }
    ///
    /// Enum for parameter mediaType
    ///
    public enum UpdateMediaMediaType: String, Codable, CaseIterable {
        case apk = "APK"
        case application = "APPLICATION"
        case image = "IMAGE"
        case audio = "AUDIO"
        case video = "VIDEO"
        case multipart = "MULTIPART"
        case barCode = "BAR_CODE"
        case text = "TEXT"
        case other = "OTHER"
    }

    /// Update Media
    /// - POST /media/update
    /// - Update a media offering.
    /// - parameter accountId: (query) The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) 
    /// - parameter mediaId: (query)  
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location ids. This will assign the offer to these retailer locations. (optional)
    /// - parameter offerLocations: (query) A list of json data that has offer location specific values. (optional)
    /// - parameter title: (query) The title (255 char limit) (optional)
    /// - parameter subTitle: (query) The sub title (255 char limit) (optional)
    /// - parameter details: (query) The details (optional)
    /// - parameter subDetails: (query) A string for custom details (255 char limit) (optional)
    /// - parameter finePrint: (query) The fine print (optional)
    /// - parameter barcodeType: (query) The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (optional)
    /// - parameter barcodeEntry: (query) The bar code entry string (optional)
    /// - parameter externalRedeemOptions: (query) An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer. (optional)
    /// - parameter externalUrl: (query) The clickUrl of the offer (optional)
    /// - parameter ticketsRewardType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter ticketsReward: (query) Determines how many tickets are awarded (optional)
    /// - parameter activated: (query) The date of when the offer will be visible to consumers (optional)
    /// - parameter expires: (query) The date of when the offer expires (optional)
    /// - parameter noExpiration: (query) Overrides the expiration date so that the offer does not expire (optional)
    /// - parameter availableLimit: (query) The limit of how many times the offer can be used by consumers (optional)
    /// - parameter availableLimitPerUser: (query) The limit of how many times a user can used the same offer (optional)
    /// - parameter addedLimit: (query) The limit of how many times the offer can be added to consumer wallets (optional)
    /// - parameter viewLimit: (query)  (optional)
    /// - parameter maxPrints: (query) The maximum number of times the offer can be printed (optional)
    /// - parameter ticketPriceType: (query) the type of ticket needed to buy the offer (optional)
    /// - parameter ticketPrice: (query) The cost of the offer in tickets (optional)
    /// - parameter fullPrice: (query) The retail/full price cost of the offer in real currency (optional)
    /// - parameter discountPrice: (query) The cost of the offer at a discounted price (what the consumer pays) (optional)
    /// - parameter showRemaining: (query) The show remaining (optional)
    /// - parameter showRedeemed: (query) The show redeemed (optional)
    /// - parameter replaced: (query) The replaced (optional)
    /// - parameter featured: (query) The featured (optional)
    /// - parameter specialOfferType: (query) The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (optional)
    /// - parameter offerVisibility: (query) The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (optional)
    /// - parameter categoryIds: (query) Comma separated list of category ids (optional)
    /// - parameter filterIds: (query) Comma separated list of filter ids (optional)
    /// - parameter active: (query) Sets the active flag (optional)
    /// - parameter barcodeAssetId: (query) The id of the barcode asset (optional)
    /// - parameter imageAssetId: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId1: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId2: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId3: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId4: (query) The id of the an offer asset (optional)
    /// - parameter imageAssetId5: (query) The id of the an offer asset (optional)
    /// - parameter publisher: (query) The maker of the item. (optional)
    /// - parameter redeemableStart: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter redeemableEnd: (query) The redeemable start date/time of the offer. (optional)
    /// - parameter conditionType: (query) The condition. OfferType PRODUCT only. (optional)
    /// - parameter isbn: (query) The ISBN id. OfferType PRODUCT only. (optional)
    /// - parameter asin: (query) The ASIN id. OfferType PRODUCT only. (optional)
    /// - parameter catalogNumbers: (query) The list of catelog numbers, comma seperated. OfferType PRODUCT only. (optional)
    /// - parameter availabilityDate: (query) The date available. OfferType PRODUCT only. (optional)
    /// - parameter parentalRating: (query) The parental control rating. OfferType PRODUCT only. (optional)
    /// - parameter mediaType: (query)  (optional)
    /// - parameter duration: (query) The total playing time of the media item. OfferType MEDIA only. (optional)
    /// - parameter author: (query) The created/author of the media item. OfferType MEDIA only. (optional)
    /// - parameter releaseDate: (query) The date/time of when the media item was originally released. OfferType MEDIA only. (optional)
    /// - parameter collectionIds: (query)  (optional)
    /// - parameter availability: (query)  (optional)
    /// - parameter availabilitySummary: (query)  (optional)
    /// - returns: AnyPublisher<MediaOfferResponse, Error> 
    open func updateMedia(accountId: Int64, mediaId: Int64, retailerLocationIds: String? = nil, offerLocations: String? = nil, title: String? = nil, subTitle: String? = nil, details: String? = nil, subDetails: String? = nil, finePrint: String? = nil, barcodeType: UpdateMediaBarcodeType? = nil, barcodeEntry: String? = nil, externalRedeemOptions: String? = nil, externalUrl: String? = nil, ticketsRewardType: String? = nil, ticketsReward: Int64? = nil, activated: Int64? = nil, expires: Int64? = nil, noExpiration: Bool? = nil, availableLimit: Int? = nil, availableLimitPerUser: Int? = nil, addedLimit: Int? = nil, viewLimit: Int? = nil, maxPrints: Int? = nil, ticketPriceType: String? = nil, ticketPrice: Int64? = nil, fullPrice: Double? = nil, discountPrice: Double? = nil, showRemaining: Bool? = nil, showRedeemed: Bool? = nil, replaced: Bool? = nil, featured: Bool? = nil, specialOfferType: UpdateMediaSpecialOfferType? = nil, offerVisibility: UpdateMediaOfferVisibility? = nil, categoryIds: String? = nil, filterIds: String? = nil, active: Bool? = nil, barcodeAssetId: Int64? = nil, imageAssetId: Int64? = nil, imageAssetId1: Int64? = nil, imageAssetId2: Int64? = nil, imageAssetId3: Int64? = nil, imageAssetId4: Int64? = nil, imageAssetId5: Int64? = nil, publisher: String? = nil, redeemableStart: Int64? = nil, redeemableEnd: Int64? = nil, conditionType: UpdateMediaConditionType? = nil, isbn: String? = nil, asin: String? = nil, catalogNumbers: String? = nil, availabilityDate: Int64? = nil, parentalRating: String? = nil, mediaType: UpdateMediaMediaType? = nil, duration: Int? = nil, author: String? = nil, releaseDate: Int64? = nil, collectionIds: String? = nil, availability: String? = nil, availabilitySummary: String? = nil) -> AnyPublisher<MediaOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/media/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "mediaId", value: "\(mediaId)"))
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let offerLocations = offerLocations { queryItems.append(URLQueryItem(name: "offerLocations", value: offerLocations)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let subTitle = subTitle { queryItems.append(URLQueryItem(name: "subTitle", value: subTitle)) } 
                if let details = details { queryItems.append(URLQueryItem(name: "details", value: details)) } 
                if let subDetails = subDetails { queryItems.append(URLQueryItem(name: "subDetails", value: subDetails)) } 
                if let finePrint = finePrint { queryItems.append(URLQueryItem(name: "finePrint", value: finePrint)) } 
                if let barcodeType = barcodeType { queryItems.append(URLQueryItem(name: "barcodeType", value: barcodeType.rawValue)) } 
                if let barcodeEntry = barcodeEntry { queryItems.append(URLQueryItem(name: "barcodeEntry", value: barcodeEntry)) } 
                if let externalRedeemOptions = externalRedeemOptions { queryItems.append(URLQueryItem(name: "externalRedeemOptions", value: externalRedeemOptions)) } 
                if let externalUrl = externalUrl { queryItems.append(URLQueryItem(name: "externalUrl", value: externalUrl)) } 
                if let ticketsRewardType = ticketsRewardType { queryItems.append(URLQueryItem(name: "ticketsRewardType", value: ticketsRewardType)) } 
                if let ticketsReward = ticketsReward { queryItems.append(URLQueryItem(name: "ticketsReward", value: "\(ticketsReward)")) } 
                if let activated = activated { queryItems.append(URLQueryItem(name: "activated", value: "\(activated)")) } 
                if let expires = expires { queryItems.append(URLQueryItem(name: "expires", value: "\(expires)")) } 
                if let noExpiration = noExpiration { queryItems.append(URLQueryItem(name: "noExpiration", value: noExpiration ? "true" : "false")) } 
                if let availableLimit = availableLimit { queryItems.append(URLQueryItem(name: "availableLimit", value: "\(availableLimit)")) } 
                if let availableLimitPerUser = availableLimitPerUser { queryItems.append(URLQueryItem(name: "availableLimitPerUser", value: "\(availableLimitPerUser)")) } 
                if let addedLimit = addedLimit { queryItems.append(URLQueryItem(name: "addedLimit", value: "\(addedLimit)")) } 
                if let viewLimit = viewLimit { queryItems.append(URLQueryItem(name: "viewLimit", value: "\(viewLimit)")) } 
                if let maxPrints = maxPrints { queryItems.append(URLQueryItem(name: "maxPrints", value: "\(maxPrints)")) } 
                if let ticketPriceType = ticketPriceType { queryItems.append(URLQueryItem(name: "ticketPriceType", value: ticketPriceType)) } 
                if let ticketPrice = ticketPrice { queryItems.append(URLQueryItem(name: "ticketPrice", value: "\(ticketPrice)")) } 
                if let fullPrice = fullPrice { queryItems.append(URLQueryItem(name: "fullPrice", value: "\(fullPrice)")) } 
                if let discountPrice = discountPrice { queryItems.append(URLQueryItem(name: "discountPrice", value: "\(discountPrice)")) } 
                if let showRemaining = showRemaining { queryItems.append(URLQueryItem(name: "showRemaining", value: showRemaining ? "true" : "false")) } 
                if let showRedeemed = showRedeemed { queryItems.append(URLQueryItem(name: "showRedeemed", value: showRedeemed ? "true" : "false")) } 
                if let replaced = replaced { queryItems.append(URLQueryItem(name: "replaced", value: replaced ? "true" : "false")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                if let specialOfferType = specialOfferType { queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType.rawValue)) } 
                if let offerVisibility = offerVisibility { queryItems.append(URLQueryItem(name: "offerVisibility", value: offerVisibility.rawValue)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let barcodeAssetId = barcodeAssetId { queryItems.append(URLQueryItem(name: "barcodeAssetId", value: "\(barcodeAssetId)")) } 
                if let imageAssetId = imageAssetId { queryItems.append(URLQueryItem(name: "imageAssetId", value: "\(imageAssetId)")) } 
                if let imageAssetId1 = imageAssetId1 { queryItems.append(URLQueryItem(name: "imageAssetId1", value: "\(imageAssetId1)")) } 
                if let imageAssetId2 = imageAssetId2 { queryItems.append(URLQueryItem(name: "imageAssetId2", value: "\(imageAssetId2)")) } 
                if let imageAssetId3 = imageAssetId3 { queryItems.append(URLQueryItem(name: "imageAssetId3", value: "\(imageAssetId3)")) } 
                if let imageAssetId4 = imageAssetId4 { queryItems.append(URLQueryItem(name: "imageAssetId4", value: "\(imageAssetId4)")) } 
                if let imageAssetId5 = imageAssetId5 { queryItems.append(URLQueryItem(name: "imageAssetId5", value: "\(imageAssetId5)")) } 
                if let publisher = publisher { queryItems.append(URLQueryItem(name: "publisher", value: publisher)) } 
                if let redeemableStart = redeemableStart { queryItems.append(URLQueryItem(name: "redeemableStart", value: "\(redeemableStart)")) } 
                if let redeemableEnd = redeemableEnd { queryItems.append(URLQueryItem(name: "redeemableEnd", value: "\(redeemableEnd)")) } 
                if let conditionType = conditionType { queryItems.append(URLQueryItem(name: "conditionType", value: conditionType.rawValue)) } 
                if let isbn = isbn { queryItems.append(URLQueryItem(name: "isbn", value: isbn)) } 
                if let asin = asin { queryItems.append(URLQueryItem(name: "asin", value: asin)) } 
                if let catalogNumbers = catalogNumbers { queryItems.append(URLQueryItem(name: "catalogNumbers", value: catalogNumbers)) } 
                if let availabilityDate = availabilityDate { queryItems.append(URLQueryItem(name: "availabilityDate", value: "\(availabilityDate)")) } 
                if let parentalRating = parentalRating { queryItems.append(URLQueryItem(name: "parentalRating", value: parentalRating)) } 
                if let mediaType = mediaType { queryItems.append(URLQueryItem(name: "mediaType", value: mediaType.rawValue)) } 
                if let duration = duration { queryItems.append(URLQueryItem(name: "duration", value: "\(duration)")) } 
                if let author = author { queryItems.append(URLQueryItem(name: "author", value: author)) } 
                if let releaseDate = releaseDate { queryItems.append(URLQueryItem(name: "releaseDate", value: "\(releaseDate)")) } 
                if let collectionIds = collectionIds { queryItems.append(URLQueryItem(name: "collectionIds", value: collectionIds)) } 
                if let availability = availability { queryItems.append(URLQueryItem(name: "availability", value: availability)) } 
                if let availabilitySummary = availabilitySummary { queryItems.append(URLQueryItem(name: "availabilitySummary", value: availabilitySummary)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MediaOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MediaOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
