//
// MissionInviteAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class MissionInviteAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Mission Invite
    /// - POST /api/{version}/mission/invite/create
    /// - Create the mission invite. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter missionId: (query) The mission to find the invite for. (optional)
    /// - parameter joinCode: (query) code to be entered for user to join the mission (optional)
    /// - parameter includeGameData: (query) Include the game level data with the mission. (optional)
    /// - returns: AnyPublisher<MissionResponse, Error> 
    open func createMissionInvite(version: Double, deviceId: String? = nil, accountId: Int64? = nil, missionId: Int64? = nil, joinCode: String? = nil, includeGameData: Bool? = nil) -> AnyPublisher<MissionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/mission/invite/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let joinCode = joinCode { queryItems.append(URLQueryItem(name: "joinCode", value: joinCode)) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MissionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MissionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Mission Invite
    /// - POST /api/{version}/mission/invite/delete
    /// - Update the mission invite status to quit.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter missionId: (query) The mission to find the invite for (missionId or missionInviteId requried). (optional)
    /// - parameter missionInviteId: (query) The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried). (optional)
    /// - parameter includeGameData: (query) Include the game level data with the mission. (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteMissionInvite(version: Double, deviceId: String? = nil, accountId: Int64? = nil, missionId: Int64? = nil, missionInviteId: Int64? = nil, includeGameData: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/mission/invite/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let missionInviteId = missionInviteId { queryItems.append(URLQueryItem(name: "missionInviteId", value: "\(missionInviteId)")) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Mission Invite
    /// - GET /api/{version}/mission/invite/get
    /// - Get the mission invite. An account can only be invited to a mission one time.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter missionId: (query) The mission to find the invite for (missionId or missionInviteId requried). (optional)
    /// - parameter missionInviteId: (query) The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried). (optional)
    /// - parameter includeGameData: (query) Include the game level data with the mission. (optional)
    /// - parameter includeScores: (query) include the scores with the mission (optional)
    /// - returns: AnyPublisher<MissionResponse, Error> 
    open func getMissionInvite(version: Double, deviceId: String? = nil, accountId: Int64? = nil, missionId: Int64? = nil, missionInviteId: Int64? = nil, includeGameData: Bool? = nil, includeScores: String? = nil) -> AnyPublisher<MissionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/mission/invite/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let missionInviteId = missionInviteId { queryItems.append(URLQueryItem(name: "missionInviteId", value: "\(missionInviteId)")) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                if let includeScores = includeScores { queryItems.append(URLQueryItem(name: "includeScores", value: includeScores)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MissionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MissionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Mission Invites
    /// - GET /api/{version}/mission/invite/search
    /// - Get a list of mission invites that the account has.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter appKey: (query) the app to retrieve the data for, use your application key. (optional)
    /// - parameter appVersion: (query) the application version, used to version the game level data (optional)
    /// - parameter missionId: (query) the mission id to filter on (optional)
    /// - parameter status: (query) The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED} (optional)
    /// - parameter lastUpdated: (query) Only return invites that have been updated since this date/time (long) (optional)
    /// - parameter start: (query) The index into the record set to start with. (optional)
    /// - parameter limit: (query) The total number of record to return. (optional)
    /// - parameter keyword: (query) the keyword to search on (optional)
    /// - parameter missionTypes: (query)  (optional)
    /// - parameter filterByBillable: (query) filter results by the account&#39;s billable (optional)
    /// - parameter includeGameData: (query) Include the game level data with the mission. (optional)
    /// - returns: AnyPublisher<[MissionResponse], Error> 
    open func searchMissionInvites(version: Double, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, appVersion: String? = nil, missionId: Int64? = nil, status: String? = nil, lastUpdated: Int64? = nil, start: Int? = nil, limit: Int? = nil, keyword: String? = nil, missionTypes: String? = nil, filterByBillable: Bool? = nil, includeGameData: Bool? = nil) -> AnyPublisher<[MissionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/mission/invite/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: status)) } 
                if let lastUpdated = lastUpdated { queryItems.append(URLQueryItem(name: "lastUpdated", value: "\(lastUpdated)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let missionTypes = missionTypes { queryItems.append(URLQueryItem(name: "missionTypes", value: missionTypes)) } 
                if let filterByBillable = filterByBillable { queryItems.append(URLQueryItem(name: "filterByBillable", value: filterByBillable ? "true" : "false")) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[MissionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([MissionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Mission Invite
    /// - POST /api/{version}/mission/invite/update
    /// - Update the mission invite status. An account can only be invited to a mission one time. For missions that require user submission and reviewing the permissionableType and permissionableId need to be provided.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter missionId: (query) The mission to find the invite for (missionId or missionInviteId requried). (optional)
    /// - parameter missionInviteId: (query) The mission invite id. This checks on the user&#39;s billable for permission (missionId or missionInviteId requried). (optional)
    /// - parameter packId: (query) the pack id to find the invite for (optional)
    /// - parameter gameLevelId: (query) the game level id to find the invite for (optional)
    /// - parameter status: (query) The invite status to filter for, comma separated list {AVAILABLE, PENDING, UPDATED, ACCEPTED, ACTIVE, QUIT, COMPLETED, PENDING_REVIEW, REJECTED} (optional)
    /// - parameter permissionableType: (query) This is the content type for missions that require user submission. Note that user submitted content must require a status of PENDING_REVIEW to be accpeted. {ACCOUNT, GAMELEVEL, COLLECTION, ALBUM_CONTEST, THEME_DESCRIPTOR, ALBUM} (optional)
    /// - parameter permissionableId: (query) The id of the content being submitted. (optional)
    /// - parameter includeGameData: (query) Include the game level data with the mission. (optional)
    /// - returns: AnyPublisher<MissionResponse, Error> 
    open func updateMissionInvite(version: Double, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, missionId: Int64? = nil, missionInviteId: Int64? = nil, packId: Int64? = nil, gameLevelId: Int64? = nil, status: String? = nil, permissionableType: String? = nil, permissionableId: Int64? = nil, includeGameData: Bool? = nil) -> AnyPublisher<MissionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/mission/invite/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let missionInviteId = missionInviteId { queryItems.append(URLQueryItem(name: "missionInviteId", value: "\(missionInviteId)")) } 
                if let packId = packId { queryItems.append(URLQueryItem(name: "packId", value: "\(packId)")) } 
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: status)) } 
                if let permissionableType = permissionableType { queryItems.append(URLQueryItem(name: "permissionableType", value: permissionableType)) } 
                if let permissionableId = permissionableId { queryItems.append(URLQueryItem(name: "permissionableId", value: "\(permissionableId)")) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<MissionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(MissionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
