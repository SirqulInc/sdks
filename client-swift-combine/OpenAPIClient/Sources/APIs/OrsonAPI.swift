//
// OrsonAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class OrsonAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Add Movie
    /// - POST /api/{version}/orson/ai/addMovie
    /// - Add a movie to be indexed for Topics. Indexing a movie analyses the content and incorporates it into the topics model for future /topics calls. This does not store the movie file long-term.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter movieName: (query) Movie Name 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter tags: (query) A user defined list (comma-delimited) of tags associated with the movie (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiAddMovieResponse, Error> 
    open func addMovie(version: Double, accountId: Int64, movieName: String, thirdPartyAccountId: String? = nil, tags: String? = nil, file: Data? = nil, url: String? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiAddMovieResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/addMovie"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                queryItems.append(URLQueryItem(name: "movieName", value: movieName))
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiAddMovieResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiAddMovieResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Docs
    /// - GET /api/{version}/orson/ai/docs
    /// - Takes in a text string representing one or more sentences and it returns a list of documents which are related to the provided document.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter doc: (query) Doc 
    /// - parameter returnTopics: (query) Return Topics (optional)
    /// - parameter limit: (query) Limit (optional)
    /// - parameter offset: (query) Offset (optional)
    /// - returns: AnyPublisher<OrsonAiProtoResponse, Error> 
    open func aiDocs(version: Double, accountId: Int64, doc: String, returnTopics: Bool? = nil, limit: Int? = nil, offset: Int? = nil) -> AnyPublisher<OrsonAiProtoResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/docs"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "doc", value: doc))
                if let returnTopics = returnTopics { queryItems.append(URLQueryItem(name: "return_topics", value: returnTopics ? "true" : "false")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let offset = offset { queryItems.append(URLQueryItem(name: "offset", value: "\(offset)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiProtoResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiProtoResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Find images
    /// - GET /api/{version}/orson/ai/img
    /// - Returns a list of URIs of images that match the text.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter text: (query) Text 
    /// - parameter parseFlag: (query) Parse Flag (optional)
    /// - parameter fetchFlag: (query) Fetch Flag (optional)
    /// - parameter size: (query) Size (optional)
    /// - returns: AnyPublisher<OrsonAiProtoResponse, Error> 
    open func aiFindImages(version: Double, accountId: Int64, text: String, parseFlag: String? = nil, fetchFlag: String? = nil, size: String? = nil) -> AnyPublisher<OrsonAiProtoResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/img"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "text", value: text))
                if let parseFlag = parseFlag { queryItems.append(URLQueryItem(name: "parse_flag", value: parseFlag)) } 
                if let fetchFlag = fetchFlag { queryItems.append(URLQueryItem(name: "fetch_flag", value: fetchFlag)) } 
                if let size = size { queryItems.append(URLQueryItem(name: "size", value: size)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiProtoResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiProtoResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Tags
    /// - GET /api/{version}/orson/ai/tags
    /// - Search the tags column of user provided tags using this endpoint.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter tags: (query) Tags 
    /// - parameter conditional: (query) Conditional (optional)
    /// - parameter limit: (query) Limit (optional)
    /// - parameter offset: (query) Offset (optional)
    /// - returns: AnyPublisher<OrsonAiProtoResponse, Error> 
    open func aiTags(version: Double, accountId: Int64, tags: String, conditional: String? = nil, limit: Int? = nil, offset: Int? = nil) -> AnyPublisher<OrsonAiProtoResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/tags"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "tags", value: tags))
                if let conditional = conditional { queryItems.append(URLQueryItem(name: "conditional", value: conditional)) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let offset = offset { queryItems.append(URLQueryItem(name: "offset", value: "\(offset)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiProtoResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiProtoResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Text
    /// - GET /api/{version}/orson/ai/text
    /// - Search the movie text column of movie text using this endpoint.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter terms: (query) Terms 
    /// - parameter conditional: (query) Conditional (optional)
    /// - parameter limit: (query) Limit (optional)
    /// - parameter offset: (query) Offset (optional)
    /// - returns: AnyPublisher<OrsonAiProtoResponse, Error> 
    open func aiText(version: Double, accountId: Int64, terms: String, conditional: String? = nil, limit: Int? = nil, offset: Int? = nil) -> AnyPublisher<OrsonAiProtoResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/text"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "terms", value: terms))
                if let conditional = conditional { queryItems.append(URLQueryItem(name: "conditional", value: conditional)) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let offset = offset { queryItems.append(URLQueryItem(name: "offset", value: "\(offset)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiProtoResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiProtoResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Batch Analysis
    /// - POST /api/{version}/orson/ai/batch
    /// - Run several types of analysis on an audio or video file in a single API call, instead of calling several operations for the same file..
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter limit: (query) The number of topics to return (optional)
    /// - parameter operations: (query) The comma-delimited list of A/V batch analysis operations to run on this file. Possible values: Transcript,Topics,Emotions (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiBatchResponse, Error> 
    open func batch(version: Double, accountId: Int64, thirdPartyAccountId: String? = nil, limit: Int? = nil, operations: String? = nil, file: Data? = nil, url: String? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiBatchResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/batch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let operations = operations { queryItems.append(URLQueryItem(name: "operations", value: operations)) } 
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiBatchResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiBatchResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Creates an instant episode
    /// - POST /api/{version}/orson/stories/episodes/instant
    /// - Creates an instant episode for a given StoryStrip by providing all necessary inputs, interview recordings, and pictures, kicking off a render immediately.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter data: (query) Request Data String 
    /// - returns: AnyPublisher<OrsonEpisodeResponse, Error> 
    open func createInstantEpisode(version: Double, accountId: Int64, data: String) -> AnyPublisher<OrsonEpisodeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/stories/episodes/instant"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "data", value: data))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonEpisodeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonEpisodeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create VoiceCanvas images
    /// - POST /api/{version}/orson/ai/voiceCanvas
    /// - Create VoiceCanvas images for provided text, file upload, or file URL
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter dimensions: (query) Enum: \&quot;256x256\&quot; \&quot;512x512\&quot; \&quot;1024x1024\&quot; 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter text: (query) Provide a transcript or previously extracted topics for image generation (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter parseFlag: (query) When false, uses the raw value from text instead of identifying topics to fetch/generate from (optional)
    /// - parameter fetchFlag: (query) When true, fetches images instead of generating them (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiVoiceCanvasResponse, Error> 
    open func createVoiceCanvas(version: Double, accountId: Int64, dimensions: String, thirdPartyAccountId: String? = nil, text: String? = nil, file: Data? = nil, url: String? = nil, parseFlag: Bool? = nil, fetchFlag: Bool? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiVoiceCanvasResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/voiceCanvas"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                queryItems.append(URLQueryItem(name: "dimensions", value: dimensions))
                if let text = text { queryItems.append(URLQueryItem(name: "text", value: text)) } 
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let parseFlag = parseFlag { queryItems.append(URLQueryItem(name: "parseFlag", value: parseFlag ? "true" : "false")) } 
                if let fetchFlag = fetchFlag { queryItems.append(URLQueryItem(name: "fetchFlag", value: fetchFlag ? "true" : "false")) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiVoiceCanvasResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiVoiceCanvasResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Detect emotions
    /// - POST /api/{version}/orson/ai/emotion
    /// - Detects emotions in an audio or video recording.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiEmotionsResponse, Error> 
    open func emotion(version: Double, accountId: Int64, thirdPartyAccountId: String? = nil, file: Data? = nil, url: String? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiEmotionsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/emotion"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiEmotionsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiEmotionsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Add Movie Result
    /// - GET /api/{version}/orson/ai/addMovie/{requestId}
    /// - Get the result of an in progress Add Movie request from an earlier POST.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiAddMovieResponse, Error> 
    open func getAddMovieResult(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiAddMovieResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/addMovie/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiAddMovieResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiAddMovieResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Batch Analysis Results
    /// - GET /api/{version}/orson/ai/batch/{requestId}
    /// - Gets the completed Video Batch results, if done, or an error or status update if not.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiBatchResponse, Error> 
    open func getBatch(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiBatchResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/batch/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiBatchResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiBatchResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Emotion Results
    /// - GET /api/{version}/orson/ai/emotion/{requestId}
    /// - Checks the Emotion analysis and returns in progress, results, or error.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiEmotionsResponse, Error> 
    open func getEmotion(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiEmotionsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/emotion/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiEmotionsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiEmotionsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Check episode status
    /// - GET /api/{version}/orson/stories/episodes/{episodeId}/status
    /// - Gets a summary of the episode's status, including any renders.
    /// - parameter version: (path)  
    /// - parameter episodeId: (path) Episode ID 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonEpisodeResponse, Error> 
    open func getEpisodeStatus(version: Double, episodeId: Int64, accountId: Int64) -> AnyPublisher<OrsonEpisodeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/stories/episodes/{episodeId}/status"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{episodeId}", with: "\(episodeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonEpisodeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonEpisodeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Check episode status
    /// - GET /api/{version}/orson/stories/renders/{renderId}/status
    /// - Gets a summary of the episode's status, including any renders.
    /// - parameter version: (path)  
    /// - parameter renderId: (path) Render ID 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonRenderResponse, Error> 
    open func getRenderStatus(version: Double, renderId: String, accountId: Int64) -> AnyPublisher<OrsonRenderResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/stories/renders/{renderId}/status"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{renderId}", with: renderId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonRenderResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonRenderResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Speach to Text Result
    /// - GET /api/{version}/orson/ai/stt/{requestId}
    /// - The results of the video transcription and optional translation.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiSTTResponse, Error> 
    open func getSTT(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiSTTResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/stt/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiSTTResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiSTTResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Text to Speach Result
    /// - GET /api/{version}/orson/ai/tts/{requestId}
    /// - Check the status of an in progress Text-to-Speech call or download the result.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiTTSResponse, Error> 
    open func getTTS(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiTTSResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/tts/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiTTSResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiTTSResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get TechTune Results
    /// - GET /api/{version}/orson/ai/techTune/{requestId}
    /// - Get a result or continue waiting for a pending request for TechTune analysis.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiTechTuneResponse, Error> 
    open func getTechTune(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiTechTuneResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/techTune/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiTechTuneResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiTechTuneResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Topics
    /// - GET /api/{version}/orson/ai/topics/{requestId}
    /// - Get the result of an in progress Topics Analysis from an earlier POST.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiTopicsResponse, Error> 
    open func getTopics(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiTopicsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/topics/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiTopicsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiTopicsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get VoiceCanvas images
    /// - GET /api/{version}/orson/ai/voiceCanvas/{requestId}
    /// - Get a result or continue waiting for a pending request for VoiceCanvas Images.
    /// - parameter version: (path)  
    /// - parameter requestId: (path) Orson Request Id 
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - returns: AnyPublisher<OrsonAiVoiceCanvasResponse, Error> 
    open func getVoiceCanvas(version: Double, requestId: String, accountId: Int64) -> AnyPublisher<OrsonAiVoiceCanvasResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/voiceCanvas/{requestId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                localVarPath = localVarPath.replacingOccurrences(of: "{requestId}", with: requestId)
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiVoiceCanvasResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiVoiceCanvasResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Starts a StoryStitch video render
    /// - POST /api/{version}/orson/stories/renders
    /// - Starts a StoryStitch video render to produce your final video, returning the status details.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter data: (query) Request Data String 
    /// - returns: AnyPublisher<OrsonRenderResponse, Error> 
    open func startVideoRender(version: Double, accountId: Int64, data: String) -> AnyPublisher<OrsonRenderResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/stories/renders"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "data", value: data))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonRenderResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonRenderResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Speach to Text
    /// - POST /api/{version}/orson/ai/stt
    /// - Accepts a movie URL or uploaded file and transcribes it. You also have the option to translate it into one of our additional supported languages.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter sourceLanguage: (query) Source Language (optional)
    /// - parameter targetLanguage: (query) Target Language (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiSTTResponse, Error> 
    open func stt(version: Double, accountId: Int64, thirdPartyAccountId: String? = nil, sourceLanguage: String? = nil, targetLanguage: String? = nil, file: Data? = nil, url: String? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiSTTResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/stt"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                if let sourceLanguage = sourceLanguage { queryItems.append(URLQueryItem(name: "sourceLanguage", value: sourceLanguage)) } 
                if let targetLanguage = targetLanguage { queryItems.append(URLQueryItem(name: "targetLanguage", value: targetLanguage)) } 
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiSTTResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiSTTResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Summarize Topics
    /// - POST /api/{version}/orson/ai/topics
    /// - Takes in a string of text sentences (also known as a document) and returns a list of associated topics and their proximity score.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter doc: (query) The text to get topics for. (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter limit: (query) The number of results to return (optional)
    /// - parameter offset: (query) The starting offset into the total result set to start from (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiTopicsResponse, Error> 
    open func summarizeTopics(version: Double, accountId: Int64, thirdPartyAccountId: String? = nil, doc: String? = nil, file: Data? = nil, url: String? = nil, limit: Int? = nil, offset: Int? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiTopicsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/topics"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                if let doc = doc { queryItems.append(URLQueryItem(name: "doc", value: doc)) } 
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let offset = offset { queryItems.append(URLQueryItem(name: "offset", value: "\(offset)")) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiTopicsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiTopicsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Detect Technical Issues
    /// - POST /api/{version}/orson/ai/techTune
    /// - Analyses a movie file to detect technical issues, such as too few people in frame.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter numFacesExpected: (query) Number of expected faces 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter file: (query) An uploaded recording to analyze (Currently limited to 10MB) (optional)
    /// - parameter url: (query) A recording file to download and analyze (Size limit: 1GB) (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiTechTuneResponse, Error> 
    open func techTune(version: Double, accountId: Int64, numFacesExpected: Int, thirdPartyAccountId: String? = nil, file: Data? = nil, url: String? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiTechTuneResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/techTune"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                queryItems.append(URLQueryItem(name: "numFacesExpected", value: "\(numFacesExpected)"))
                if let file = file { queryItems.append(URLQueryItem(name: "file", value: )) } 
                if let url = url { queryItems.append(URLQueryItem(name: "url", value: url)) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiTechTuneResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiTechTuneResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Text to Speach
    /// - POST /api/{version}/orson/ai/tts
    /// - Creates an audio file for the given text, with the option of language and voice selection.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) Sirqul Account Id 
    /// - parameter text: (query) Text 
    /// - parameter thirdPartyAccountId: (query) A third-party account id that is meaningful to your systems (optional)
    /// - parameter language: (query) The language to use for the speaker and incoming text (optional)
    /// - parameter voice: (query) A language-specific voice to use, or picks the language default if not provided (optional)
    /// - parameter callback: (query) When provided, Orson will return a 202 and POST the results to this URL when complete instead of holding the Request open (optional)
    /// - returns: AnyPublisher<OrsonAiTTSResponse, Error> 
    open func tts(version: Double, accountId: Int64, text: String, thirdPartyAccountId: String? = nil, language: String? = nil, voice: String? = nil, callback: String? = nil) -> AnyPublisher<OrsonAiTTSResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/orson/ai/tts"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let thirdPartyAccountId = thirdPartyAccountId { queryItems.append(URLQueryItem(name: "thirdPartyAccountId", value: thirdPartyAccountId)) } 
                queryItems.append(URLQueryItem(name: "text", value: text))
                if let language = language { queryItems.append(URLQueryItem(name: "language", value: language)) } 
                if let voice = voice { queryItems.append(URLQueryItem(name: "voice", value: voice)) } 
                if let callback = callback { queryItems.append(URLQueryItem(name: "callback", value: callback)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrsonAiTTSResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrsonAiTTSResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
