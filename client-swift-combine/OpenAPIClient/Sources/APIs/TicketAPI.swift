//
// TicketAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class TicketAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Get Ticket Count
    /// - GET /api/{version}/ticket/count
    /// - Gets the ticket count.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the id of the device that owns the tickets (optional)
    /// - parameter accountId: (query) the id of the account that owns the tickets (optional)
    /// - parameter gameType: (query) this is deprecated. (optional)
    /// - parameter appKey: (query) the applicationkey (optional)
    /// - parameter ticketType: (query) the type of ticket (optional)
    /// - returns: AnyPublisher<CountResponse, Error> 
    open func getTicketCount(version: Double, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, ticketType: String? = nil) -> AnyPublisher<CountResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/ticket/count"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CountResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CountResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Ticket List
    /// - GET /api/{version}/ticket/getList
    /// - Gets the list of tickets.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the id of the device that owns the tickets (optional)
    /// - parameter accountId: (query) the id of the account that owns the tickets (optional)
    /// - parameter ticketObjectType: (query) comma separated list of TicketObjectType (optional)
    /// - parameter actionType: (query) comma separated list of TicketActionType (optional)
    /// - parameter ticketIds: (query) the ids of the tickets to get (optional)
    /// - parameter objectIds: (query) the ids of the objects to get (optional)
    /// - parameter receiptTokens: (query)  (optional)
    /// - parameter gameType: (query)  (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - returns: AnyPublisher<TicketListResponse, Error> 
    open func getTicketList(version: Double, deviceId: String? = nil, accountId: Int64? = nil, ticketObjectType: String? = nil, actionType: String? = nil, ticketIds: String? = nil, objectIds: String? = nil, receiptTokens: String? = nil, gameType: String? = nil, appKey: String? = nil) -> AnyPublisher<TicketListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/ticket/getList"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let ticketObjectType = ticketObjectType { queryItems.append(URLQueryItem(name: "ticketObjectType", value: ticketObjectType)) } 
                if let actionType = actionType { queryItems.append(URLQueryItem(name: "actionType", value: actionType)) } 
                if let ticketIds = ticketIds { queryItems.append(URLQueryItem(name: "ticketIds", value: ticketIds)) } 
                if let objectIds = objectIds { queryItems.append(URLQueryItem(name: "objectIds", value: objectIds)) } 
                if let receiptTokens = receiptTokens { queryItems.append(URLQueryItem(name: "receiptTokens", value: receiptTokens)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TicketListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(TicketListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Gift Tickets
    /// - POST /api/{version}/purchase/gift
    /// - Gift tickets to another user.
    /// - parameter version: (path)  
    /// - parameter receiverAccountId: (query) the id of the account receiving the tickets 
    /// - parameter ticketId: (query) the id of the tickets 
    /// - parameter deviceId: (query) the id of the device (optional)
    /// - parameter accountId: (query) the id of the gift owner (optional)
    /// - parameter assetId: (query) the id of the asset (optional)
    /// - parameter customMessage: (query) a message that can be written to go along with the gift (optional)
    /// - parameter gameType: (query) the type of game associated with the tickets (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func giftPurchase(version: Double, receiverAccountId: Int64, ticketId: Int64, deviceId: String? = nil, accountId: Int64? = nil, assetId: Int64? = nil, customMessage: String? = nil, gameType: String? = nil, appKey: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/purchase/gift"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "receiverAccountId", value: "\(receiverAccountId)"))
                queryItems.append(URLQueryItem(name: "ticketId", value: "\(ticketId)"))
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let customMessage = customMessage { queryItems.append(URLQueryItem(name: "customMessage", value: customMessage)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Save Ticket
    /// - POST /api/{version}/ticket/save
    /// - Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.
    /// - parameter version: (path)  
    /// - parameter actionType: (query) the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER 
    /// - parameter ticketObjectType: (query) the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM 
    /// - parameter returnNulls: (query) whether to return nulls or not (optional)
    /// - parameter deviceId: (query) the device id that owns the tickets (optional)
    /// - parameter accountId: (query) the account id that owns the tickets (optional)
    /// - parameter gameType: (query) This parameter is deprecated. deprecated, use the appKey (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter objectId: (query) the ID of the item being purchased (optional)
    /// - parameter purchaseCode: (query) a unique string identifier defined by the application owner or Executive (optional)
    /// - parameter receiptToken: (query) a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
    /// - parameter receiptData: (query) the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format. (optional)
    /// - parameter count: (query) the count of tickets (optional)
    /// - parameter ticketType: (query) the ticket type (optional)
    /// - parameter purchaseProvider: (query) the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
    /// - parameter purchaseType: (query) a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
    /// - parameter returnProfileResponse: (query) returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
    /// - parameter includeProfileResponse: (query) if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
    /// - parameter appVersion: (query) the application version (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func saveTicket(version: Double, actionType: String, ticketObjectType: String, returnNulls: Bool? = nil, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, objectId: Int64? = nil, purchaseCode: String? = nil, receiptToken: String? = nil, receiptData: String? = nil, count: Int64? = nil, ticketType: String? = nil, purchaseProvider: String? = nil, purchaseType: String? = nil, returnProfileResponse: Bool? = nil, includeProfileResponse: Bool? = nil, appVersion: String? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/ticket/save"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let returnNulls = returnNulls { queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "actionType", value: actionType))
                queryItems.append(URLQueryItem(name: "ticketObjectType", value: ticketObjectType))
                if let objectId = objectId { queryItems.append(URLQueryItem(name: "objectId", value: "\(objectId)")) } 
                if let purchaseCode = purchaseCode { queryItems.append(URLQueryItem(name: "purchaseCode", value: purchaseCode)) } 
                if let receiptToken = receiptToken { queryItems.append(URLQueryItem(name: "receiptToken", value: receiptToken)) } 
                if let receiptData = receiptData { queryItems.append(URLQueryItem(name: "receiptData", value: receiptData)) } 
                if let count = count { queryItems.append(URLQueryItem(name: "count", value: "\(count)")) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                if let purchaseProvider = purchaseProvider { queryItems.append(URLQueryItem(name: "purchaseProvider", value: purchaseProvider)) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                if let returnProfileResponse = returnProfileResponse { queryItems.append(URLQueryItem(name: "returnProfileResponse", value: returnProfileResponse ? "true" : "false")) } 
                if let includeProfileResponse = includeProfileResponse { queryItems.append(URLQueryItem(name: "includeProfileResponse", value: includeProfileResponse ? "true" : "false")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Save Ticket with Reciept
    /// - POST /api/{version}/ticket/save/fileUpload
    /// - Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post
    /// - parameter version: (path)  
    /// - parameter actionType: (query) the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER } 
    /// - parameter ticketObjectType: (query) the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM} 
    /// - parameter receiptData: (query) the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format. 
    /// - parameter returnNulls: (query) whether to return nulls or not (optional)
    /// - parameter deviceId: (query) the device id (optional)
    /// - parameter accountId: (query) the account id (optional)
    /// - parameter gameType: (query) This parameter is deprecated. deprecated, use the appKey (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter objectId: (query) the ID of the item being purchased (optional)
    /// - parameter purchaseCode: (query) a unique string identifier defined by the application owner or Executive (optional)
    /// - parameter receiptToken: (query) a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc) (optional)
    /// - parameter count: (query) the count of tickets (optional)
    /// - parameter ticketType: (query) the ticket type (optional)
    /// - parameter purchaseProvider: (query) the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE} (optional)
    /// - parameter purchaseType: (query) a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE } (optional)
    /// - parameter returnProfileResponse: (query) returns a ProfileResponse if true, otherwise will return an AppResponse (optional)
    /// - parameter includeProfileResponse: (query) if returnProfileResponse is false, will return an AppResponse with profile data if true (optional)
    /// - parameter appVersion: (query) the application version (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func saveTicketViaFileUpload(version: Double, actionType: String, ticketObjectType: String, receiptData: Data, returnNulls: Bool? = nil, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, objectId: Int64? = nil, purchaseCode: String? = nil, receiptToken: String? = nil, count: Int64? = nil, ticketType: String? = nil, purchaseProvider: String? = nil, purchaseType: String? = nil, returnProfileResponse: Bool? = nil, includeProfileResponse: Bool? = nil, appVersion: String? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/ticket/save/fileUpload"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let returnNulls = returnNulls { queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "actionType", value: actionType))
                queryItems.append(URLQueryItem(name: "ticketObjectType", value: ticketObjectType))
                if let objectId = objectId { queryItems.append(URLQueryItem(name: "objectId", value: "\(objectId)")) } 
                if let purchaseCode = purchaseCode { queryItems.append(URLQueryItem(name: "purchaseCode", value: purchaseCode)) } 
                if let receiptToken = receiptToken { queryItems.append(URLQueryItem(name: "receiptToken", value: receiptToken)) } 
                queryItems.append(URLQueryItem(name: "receiptData", value: ))
                if let count = count { queryItems.append(URLQueryItem(name: "count", value: "\(count)")) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                if let purchaseProvider = purchaseProvider { queryItems.append(URLQueryItem(name: "purchaseProvider", value: purchaseProvider)) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                if let returnProfileResponse = returnProfileResponse { queryItems.append(URLQueryItem(name: "returnProfileResponse", value: returnProfileResponse ? "true" : "false")) } 
                if let includeProfileResponse = includeProfileResponse { queryItems.append(URLQueryItem(name: "includeProfileResponse", value: includeProfileResponse ? "true" : "false")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Ticket Offers
    /// - GET /api/{version}/ticket/ticketoffers
    /// - Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.
    /// - parameter version: (path)  
    /// - returns: AnyPublisher<TicketOfferResponse, Error> 
    open func ticketOffers(version: Double) -> AnyPublisher<TicketOfferResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/ticket/ticketoffers"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<TicketOfferResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(TicketOfferResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
