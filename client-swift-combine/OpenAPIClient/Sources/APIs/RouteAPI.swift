//
// RouteAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RouteAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Approve Route
    /// - POST /route/{routeId}/approve
    /// - Approve a route
    /// - parameter routeId: (path) the id of the route to approve 
    /// - returns: AnyPublisher<Route, Error> 
    open func approveRoute(routeId: Int64) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/approve"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Copy Route
    /// - POST /route/{routeId}/copy
    /// - Make an copy of the given route with optional overriding properties
    /// - parameter routeId: (path) the id of the route to duplicate 
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<Route, Error> 
    open func copyRoute(routeId: Int64, body: Route? = nil) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/copy"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Route
    /// - POST /route
    /// - Create new route
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<Route, Error> 
    open func createRoute(body: Route? = nil) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/route"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Route Directions
    /// - PUT /route/{routeId}/directions
    /// - Regenerate the directions of a route
    /// - parameter routeId: (path) the id of the route to update directions for 
    /// - returns: AnyPublisher<[Direction], Error> 
    open func createRouteDirections(routeId: Int64) -> AnyPublisher<[Direction], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/directions"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Direction], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Direction].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Route Polyline
    /// - PUT /route/{routeId}/polyline
    /// - Update the polyline of the requested route
    /// - parameter routeId: (path) the id of the route to create a polyline for 
    /// - returns: AnyPublisher<Route, Error> 
    open func createRoutePolyline(routeId: Int64) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/polyline"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Route
    /// - DELETE /route/{routeId}
    /// - Delete an existing route
    /// - parameter routeId: (path) the id of the route 
    /// - returns: AnyPublisher<Void, Error> 
    open func deleteRoute(routeId: Int64) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Disapprove Route
    /// - POST /route/{routeId}/disapprove
    /// - Disapprove a route
    /// - parameter routeId: (path) the id of the route to reject 
    /// - returns: AnyPublisher<Route, Error> 
    open func disapproveRoute(routeId: Int64) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/disapprove"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Route
    /// - GET /route/{routeId}
    /// - Get an existing route
    /// - parameter routeId: (path) the id of the route to get 
    /// - parameter showInheritedProperties: (query) return inherited properties from parent or not 
    /// - returns: AnyPublisher<Route, Error> 
    open func getRoute(routeId: Int64, showInheritedProperties: Bool) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "showInheritedProperties", value: showInheritedProperties ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Route Directions
    /// - GET /route/{routeId}/directions
    /// - Get the directions of a route
    /// - parameter routeId: (path) the id of the route to get directions for 
    /// - returns: AnyPublisher<[Direction], Error> 
    open func getRouteDirections(routeId: Int64) -> AnyPublisher<[Direction], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/directions"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Direction], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Direction].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Route Shipments
    /// - GET /route/{routeId}/shipments
    /// - Get the shipments on the requested route
    /// - parameter routeId: (path) the id of the route to get shipments for 
    /// - returns: AnyPublisher<[Shipment], Error> 
    open func getRouteShipments(routeId: Int64) -> AnyPublisher<[Shipment], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/shipments"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Shipment], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Shipment].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Route Stop
    /// - GET /route/{routeId}/stop/{stopId}
    /// - Get the specific stop on a route
    /// - parameter routeId: (path) the id of the route to get stops for 
    /// - parameter stopId: (path) the id of the specific stop on the route 
    /// - returns: AnyPublisher<Stop, Error> 
    open func getRouteStop(routeId: Int64, stopId: Int64) -> AnyPublisher<Stop, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stop/{stopId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                localVarPath = localVarPath.replacingOccurrences(of: "{stopId}", with: "\(stopId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Stop, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Stop.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Route Stops
    /// - GET /route/{routeId}/stops
    /// - The stops of the route requested
    /// - parameter routeId: (path) the id of the route 
    /// - parameter confirmedOnly: (query) only get stops that have been confirmed or not 
    /// - returns: AnyPublisher<[Stop], Error> 
    open func getRouteStops(routeId: Int64, confirmedOnly: Bool) -> AnyPublisher<[Stop], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stops"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "confirmedOnly", value: confirmedOnly ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Stop], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Stop].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Shipments At Stop
    /// - GET /route/{routeId}/stop/{stopId}/shipments
    /// - Get the list of shipments on the requested route at a stop
    /// - parameter routeId: (path) the id of the route 
    /// - parameter stopId: (path) the id of the stop to get shipments on 
    /// - returns: AnyPublisher<[Shipment], Error> 
    open func getShipmentsAtStop(routeId: Int64, stopId: Int64) -> AnyPublisher<[Shipment], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stop/{stopId}/shipments"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                localVarPath = localVarPath.replacingOccurrences(of: "{stopId}", with: "\(stopId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Shipment], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Shipment].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Optimize Route
    /// - POST /route/{routeId}/optimize
    /// - Optimize a route. The optimization method based on how the server is configured.
    /// - parameter routeId: (path) the id of the route to optimize 
    /// - returns: AnyPublisher<Void, Error> 
    open func optimizeRoute(routeId: Int64) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/optimize"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Stop
    /// - DELETE /route/{routeId}/stop/{stopId}
    /// - Delete a stop on a route
    /// - parameter routeId: (path) the id of the route 
    /// - parameter stopId: (path) the id of the specific stop to delete on the route 
    /// - returns: AnyPublisher<Void, Error> 
    open func removeStop(routeId: Int64, stopId: Int64) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stop/{stopId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                localVarPath = localVarPath.replacingOccurrences(of: "{stopId}", with: "\(stopId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "DELETE"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Reorder Route Stops
    /// - PATCH /route/{routeId}/stops/reorder
    /// - Reordering the stops on the route with and update route distance, time, direction, and polyline
    /// - parameter routeId: (path) the id of the route 
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<[Stop], Error> 
    open func reorderRouteStopsPatch(routeId: Int64, body: [Stop]? = nil) -> AnyPublisher<[Stop], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stops/reorder"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PATCH"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Stop], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Stop].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Reorder Route Stops
    /// - POST /route/{routeId}/stops/reorder
    /// - Reordering the stops on the route with and update route distance, time, direction, and polyline
    /// - parameter routeId: (path) the id of the route 
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<[Stop], Error> 
    open func reorderRouteStopsPost(routeId: Int64, body: [Stop]? = nil) -> AnyPublisher<[Stop], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stops/reorder"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Stop], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Stop].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Routes
    /// - GET /route
    /// - Search for routes.
    /// - parameter sortField: (query) The field to sort by 
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order 
    /// - parameter start: (query) The start index for pagination 
    /// - parameter limit: (query) The limit for pagination 
    /// - parameter activeOnly: (query) Return only active results 
    /// - parameter includesEmpty: (query) Include empty routes or not 
    /// - parameter rootOnly: (query) Only return root instance routes 
    /// - parameter showInheritedProperties: (query) Display root route properties 
    /// - parameter hubId: (query) Filter results by service hub (optional)
    /// - parameter programId: (query) Filter results by program (optional)
    /// - parameter scheduledStart: (query) The start date to filter the results by (optional)
    /// - parameter scheduledEnd: (query) The end date to filter the results by (optional)
    /// - parameter updatedStart: (query) The lower bound of updated date (optional)
    /// - parameter updatedEnd: (query) The upper bound of updated date (optional)
    /// - parameter featured: (query) The route is featured or not (optional)
    /// - parameter seatCount: (query) Has at least this many seat available (optional)
    /// - parameter approved: (query) Has been approved or not (optional)
    /// - parameter started: (query) Has started or not (optional)
    /// - parameter completed: (query) Has completed or not (optional)
    /// - parameter valid: (query) Is valid or not (optional)
    /// - parameter parentId: (query) If it is a recurring route based on the parent route (optional)
    /// - returns: AnyPublisher<[Route], Error> 
    open func searchRoutes(sortField: String, descending: Bool, start: Int, limit: Int, activeOnly: Bool, includesEmpty: Bool, rootOnly: Bool, showInheritedProperties: Bool, hubId: Int64? = nil, programId: Int64? = nil, scheduledStart: Int64? = nil, scheduledEnd: Int64? = nil, updatedStart: Int64? = nil, updatedEnd: Int64? = nil, featured: Bool? = nil, seatCount: Int? = nil, approved: Bool? = nil, started: Bool? = nil, completed: Bool? = nil, valid: Bool? = nil, parentId: Int64? = nil) -> AnyPublisher<[Route], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/route"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let hubId = hubId { queryItems.append(URLQueryItem(name: "hubId", value: "\(hubId)")) } 
                if let programId = programId { queryItems.append(URLQueryItem(name: "programId", value: "\(programId)")) } 
                if let scheduledStart = scheduledStart { queryItems.append(URLQueryItem(name: "scheduledStart", value: "\(scheduledStart)")) } 
                if let scheduledEnd = scheduledEnd { queryItems.append(URLQueryItem(name: "scheduledEnd", value: "\(scheduledEnd)")) } 
                if let updatedStart = updatedStart { queryItems.append(URLQueryItem(name: "updatedStart", value: "\(updatedStart)")) } 
                if let updatedEnd = updatedEnd { queryItems.append(URLQueryItem(name: "updatedEnd", value: "\(updatedEnd)")) } 
                if let featured = featured { queryItems.append(URLQueryItem(name: "featured", value: featured ? "true" : "false")) } 
                if let seatCount = seatCount { queryItems.append(URLQueryItem(name: "seatCount", value: "\(seatCount)")) } 
                if let approved = approved { queryItems.append(URLQueryItem(name: "approved", value: approved ? "true" : "false")) } 
                if let started = started { queryItems.append(URLQueryItem(name: "started", value: started ? "true" : "false")) } 
                if let completed = completed { queryItems.append(URLQueryItem(name: "completed", value: completed ? "true" : "false")) } 
                if let valid = valid { queryItems.append(URLQueryItem(name: "valid", value: valid ? "true" : "false")) } 
                if let parentId = parentId { queryItems.append(URLQueryItem(name: "parentId", value: "\(parentId)")) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includesEmpty", value: includesEmpty ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "rootOnly", value: rootOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "showInheritedProperties", value: showInheritedProperties ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[Route], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([Route].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Set Driver
    /// - POST /route/{id}/driver/{driverId}
    /// - Update the driver of the route.
    /// - parameter id: (path) the id of the route 
    /// - parameter driverId: (path) the id of the driver 
    /// - returns: AnyPublisher<Void, Error> 
    open func setDriver(id: Int64, driverId: Int64) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{id}/driver/{driverId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{id}", with: "\(id)")
                localVarPath = localVarPath.replacingOccurrences(of: "{driverId}", with: "\(driverId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Route
    /// - PUT /route/{routeId}
    /// - Update an existing route
    /// - parameter routeId: (path) the id of the route 
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<Route, Error> 
    open func updateRoute(routeId: Int64, body: Route? = nil) -> AnyPublisher<Route, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Route, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(Route.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Route Stop
    /// - PUT /route/{routeId}/stop/{stopId}
    /// - Update a stop on a specified route
    /// - parameter routeId: (path) the id of the route to update stops for 
    /// - parameter stopId: (path) the id of the specific stop to update on the route 
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<Void, Error> 
    open func updateRouteStop(routeId: Int64, stopId: Int64, body: Stop? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/route/{routeId}/stop/{stopId}"
                localVarPath = localVarPath.replacingOccurrences(of: "{routeId}", with: "\(routeId)")
                localVarPath = localVarPath.replacingOccurrences(of: "{stopId}", with: "\(stopId)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "PUT"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
