//
// RetailerLocationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RetailerLocationAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Retailer Location (Consumer)
    /// - POST /api/{version}/location/create
    /// - Creates a location record for an application that can support crowd sourced locations.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) the application key 
    /// - parameter name: (query) The name of the retailer location 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter streetAddress: (query) The street address of the retailer location (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the retailer location (optional)
    /// - parameter state: (query) The state of the retailer location (optional)
    /// - parameter postalCode: (query) The postal code of the retailer location (optional)
    /// - parameter country: (query) the country of the retailer location (optional)
    /// - parameter businessPhone: (query) The business phone (optional)
    /// - parameter businessPhoneExt: (query) The business phone extension (optional)
    /// - parameter website: (query) The website of the retailer location (optional)
    /// - parameter email: (query) The email of the retailer location (optional)
    /// - parameter detailsHeader: (query) A brief description about the retailer location (255 character limit) (optional)
    /// - parameter detailsBody: (query) A detailed description about the retailer location (optional)
    /// - parameter hours: (query) The hours of operation (optional)
    /// - parameter tags: (query) Custom string field for doing full-text searches (optional)
    /// - parameter logoAssetId: (query) The retailer location logo asset id (optional)
    /// - parameter picture1AssetId: (query) An asset id (optional)
    /// - parameter picture2AssetId: (query) An asset id (optional)
    /// - parameter categoryIds: (query) Comma separated list of category IDs used to filter retailer locations by categories (optional)
    /// - parameter filterIds: (query) Comma separated list of filter IDs used to filter retailer locations (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter publicLocation: (query) Whether the location is public (optional)
    /// - parameter active: (query) whether the retailer location created should be active or not (optional)
    /// - parameter locationType: (query) External custom type identifier (optional)
    /// - parameter latitude: (query) The latitude to center the search on (optional)
    /// - parameter longitude: (query) The longitude to center the search on (optional)
    /// - returns: AnyPublisher<RetailerLocationResponse, Error> 
    open func createRetailerLocationConsumer(version: Double, appKey: String, name: String, deviceId: String? = nil, accountId: Int64? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, postalCode: String? = nil, country: String? = nil, businessPhone: String? = nil, businessPhoneExt: String? = nil, website: String? = nil, email: String? = nil, detailsHeader: String? = nil, detailsBody: String? = nil, hours: String? = nil, tags: String? = nil, logoAssetId: Int64? = nil, picture1AssetId: Int64? = nil, picture2AssetId: Int64? = nil, categoryIds: String? = nil, filterIds: String? = nil, metaData: String? = nil, publicLocation: Bool? = nil, active: Bool? = nil, locationType: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<RetailerLocationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/location/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let businessPhoneExt = businessPhoneExt { queryItems.append(URLQueryItem(name: "businessPhoneExt", value: businessPhoneExt)) } 
                if let website = website { queryItems.append(URLQueryItem(name: "website", value: website)) } 
                if let email = email { queryItems.append(URLQueryItem(name: "email", value: email)) } 
                if let detailsHeader = detailsHeader { queryItems.append(URLQueryItem(name: "detailsHeader", value: detailsHeader)) } 
                if let detailsBody = detailsBody { queryItems.append(URLQueryItem(name: "detailsBody", value: detailsBody)) } 
                if let hours = hours { queryItems.append(URLQueryItem(name: "hours", value: hours)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let logoAssetId = logoAssetId { queryItems.append(URLQueryItem(name: "logoAssetId", value: "\(logoAssetId)")) } 
                if let picture1AssetId = picture1AssetId { queryItems.append(URLQueryItem(name: "picture1AssetId", value: "\(picture1AssetId)")) } 
                if let picture2AssetId = picture2AssetId { queryItems.append(URLQueryItem(name: "picture2AssetId", value: "\(picture2AssetId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let publicLocation = publicLocation { queryItems.append(URLQueryItem(name: "publicLocation", value: publicLocation ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerLocationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerLocationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter responseFormat
    ///
    public enum CreateRetailerLocationsResponseFormat: String, Codable, CaseIterable {
        case html = "HTML"
        case xml = "XML"
        case json = "JSON"
        case csv = "CSV"
    }

    /// Create Retailer Location
    /// - POST /api/{version}/retailer/location/create
    /// - Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
    /// - parameter version: (path)  
    /// - parameter retailerId: (query) The ID of the retailer 
    /// - parameter name: (query) The name of the retailer location 
    /// - parameter streetAddress: (query) The street address of the retailer location 
    /// - parameter city: (query) The city of the retailer location 
    /// - parameter state: (query) The state of the retailer location 
    /// - parameter postalCode: (query) The postal code of the retailer location 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter country: (query) the country of the retailer location (optional)
    /// - parameter businessPhone: (query) The business phone number of the retailer location (optional)
    /// - parameter businessPhoneExt: (query) The business phone extension (optional)
    /// - parameter website: (query) The website of the retailer location (optional)
    /// - parameter email: (query) The email of the retailer location (optional)
    /// - parameter internalId: (query) An internal identifier used by the retailer (optional)
    /// - parameter detailsHeader: (query) A brief description about the retailer location (255 character limit) (optional)
    /// - parameter detailsBody: (query) A detailed description about the retailer location (optional)
    /// - parameter hours: (query) The hours of operation (optional)
    /// - parameter logo: (query) The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
    /// - parameter logoAssetId: (query) The retailer location logo asset id (optional)
    /// - parameter picture1: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture1AssetId: (query) An asset id (optional)
    /// - parameter picture2: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture2AssetId: (query) An asset id (optional)
    /// - parameter categoryIds: (query) Comma separated list of category IDs used to filter retailer locations by categories (optional)
    /// - parameter filterIds: (query) Comma separated list of filter IDs used to filter retailer locations (optional)
    /// - parameter latitude: (query) the latitude of the retailer location (optional)
    /// - parameter longitude: (query) the longitude of the retailer location (optional)
    /// - parameter building: (query)  (optional)
    /// - parameter googlePlaceId: (query) the ID of the Google Place that this retailer location is assigned to (optional)
    /// - parameter yelpId: (query) the Yelp ID that this retailer location is assigned to (optional)
    /// - parameter active: (query) whether the retailer location should be active or inactive (optional)
    /// - parameter publicLocation: (query) Sets whether the location is public or not (optional)
    /// - parameter locationType: (query) External custom type identifier (optional)
    /// - parameter audienceIds: (query) Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
    /// - parameter audienceIdsToAdd: (query) Comma separated list of audience IDs to add to the retailer location (optional)
    /// - parameter audienceIdsToRemove: (query) Comma separated list of audience IDs to remove from the retailer location (optional)
    /// - parameter responseFormat: (query) The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
    /// - parameter responseIncludes: (query) Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE) (optional)
    /// - returns: AnyPublisher<RetailerLocationResponse, Error> 
    open func createRetailerLocations(version: Double, retailerId: Int64, name: String, streetAddress: String, city: String, state: String, postalCode: String, deviceId: String? = nil, accountId: Int64? = nil, streetAddress2: String? = nil, country: String? = nil, businessPhone: String? = nil, businessPhoneExt: String? = nil, website: String? = nil, email: String? = nil, internalId: String? = nil, detailsHeader: String? = nil, detailsBody: String? = nil, hours: String? = nil, logo: Data? = nil, logoAssetId: Int64? = nil, picture1: Data? = nil, picture1AssetId: Int64? = nil, picture2: Data? = nil, picture2AssetId: Int64? = nil, categoryIds: String? = nil, filterIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil, building: String? = nil, googlePlaceId: String? = nil, yelpId: String? = nil, active: Bool? = nil, publicLocation: Bool? = nil, locationType: String? = nil, audienceIds: String? = nil, audienceIdsToAdd: String? = nil, audienceIdsToRemove: String? = nil, responseFormat: CreateRetailerLocationsResponseFormat? = nil, responseIncludes: String? = nil) -> AnyPublisher<RetailerLocationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)"))
                queryItems.append(URLQueryItem(name: "name", value: name))
                queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress))
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                queryItems.append(URLQueryItem(name: "city", value: city))
                queryItems.append(URLQueryItem(name: "state", value: state))
                queryItems.append(URLQueryItem(name: "postalCode", value: postalCode))
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let businessPhoneExt = businessPhoneExt { queryItems.append(URLQueryItem(name: "businessPhoneExt", value: businessPhoneExt)) } 
                if let website = website { queryItems.append(URLQueryItem(name: "website", value: website)) } 
                if let email = email { queryItems.append(URLQueryItem(name: "email", value: email)) } 
                if let internalId = internalId { queryItems.append(URLQueryItem(name: "internalId", value: internalId)) } 
                if let detailsHeader = detailsHeader { queryItems.append(URLQueryItem(name: "detailsHeader", value: detailsHeader)) } 
                if let detailsBody = detailsBody { queryItems.append(URLQueryItem(name: "detailsBody", value: detailsBody)) } 
                if let hours = hours { queryItems.append(URLQueryItem(name: "hours", value: hours)) } 
                if let logo = logo { queryItems.append(URLQueryItem(name: "logo", value: )) } 
                if let logoAssetId = logoAssetId { queryItems.append(URLQueryItem(name: "logoAssetId", value: "\(logoAssetId)")) } 
                if let picture1 = picture1 { queryItems.append(URLQueryItem(name: "picture1", value: )) } 
                if let picture1AssetId = picture1AssetId { queryItems.append(URLQueryItem(name: "picture1AssetId", value: "\(picture1AssetId)")) } 
                if let picture2 = picture2 { queryItems.append(URLQueryItem(name: "picture2", value: )) } 
                if let picture2AssetId = picture2AssetId { queryItems.append(URLQueryItem(name: "picture2AssetId", value: "\(picture2AssetId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let building = building { queryItems.append(URLQueryItem(name: "building", value: building)) } 
                if let googlePlaceId = googlePlaceId { queryItems.append(URLQueryItem(name: "googlePlaceId", value: googlePlaceId)) } 
                if let yelpId = yelpId { queryItems.append(URLQueryItem(name: "yelpId", value: yelpId)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let publicLocation = publicLocation { queryItems.append(URLQueryItem(name: "publicLocation", value: publicLocation ? "true" : "false")) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let audienceIdsToAdd = audienceIdsToAdd { queryItems.append(URLQueryItem(name: "audienceIdsToAdd", value: audienceIdsToAdd)) } 
                if let audienceIdsToRemove = audienceIdsToRemove { queryItems.append(URLQueryItem(name: "audienceIdsToRemove", value: audienceIdsToRemove)) } 
                if let responseFormat = responseFormat { queryItems.append(URLQueryItem(name: "responseFormat", value: responseFormat.rawValue)) } 
                if let responseIncludes = responseIncludes { queryItems.append(URLQueryItem(name: "responseIncludes", value: responseIncludes)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerLocationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerLocationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Retailer Location
    /// - POST /api/{version}/retailer/location/delete
    /// - Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the device id (optional)
    /// - parameter accountId: (query) the id of the logged in user (optional)
    /// - parameter retailerLocationId: (query) the id of the retailer location to delete (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteRetailerLocation(version: Double, deviceId: String? = nil, accountId: Int64? = nil, retailerLocationId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Retailer Location
    /// - GET /api/{version}/retailer/location/get
    /// - Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.
    /// - parameter version: (path)  
    /// - parameter retailerLocationId: (query) The ID of the retailer location 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter retailerLocationToken: (query) the unique token of the retailer location (optional)
    /// - returns: AnyPublisher<RetailerLocationResponse, Error> 
    open func getRetailerLocation(version: Double, retailerLocationId: Int64, deviceId: String? = nil, accountId: Int64? = nil, retailerLocationToken: String? = nil) -> AnyPublisher<RetailerLocationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)"))
                if let retailerLocationToken = retailerLocationToken { queryItems.append(URLQueryItem(name: "retailerLocationToken", value: retailerLocationToken)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerLocationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerLocationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Retailer Location (Consumer)
    /// - GET /api/{version}/location/get
    /// - Gets the details of a retailer location as a consumer.
    /// - parameter version: (path)  
    /// - parameter retailerLocationId: (query) The retailer location id 
    /// - parameter deviceId: (query) The device id for returning account information (i.e. favorites) (optional)
    /// - parameter accountId: (query) The account id for returning account information (i.e. favorites) (optional)
    /// - returns: AnyPublisher<RetailerLocationResponse, Error> 
    open func getRetailerLocationConsumer(version: Double, retailerLocationId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<RetailerLocationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/location/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerLocationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerLocationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter distanceUnit
    ///
    public enum IndexedRetailerLocationDistanceSearchDistanceUnit: String, Codable, CaseIterable {
        case miles = "MILES"
        case kilometers = "KILOMETERS"
    }

    /// Distance Search Retailer Locations (Indexed)
    /// - GET /api/{version}/retailer/location/idistancesearch
    /// - Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.
    /// - parameter version: (path)  
    /// - parameter latitude: (query) The latitude to center the search on 
    /// - parameter longitude: (query) The longitude to center the search on 
    /// - parameter searchRange: (query) The search range in the distanceUnit specified; default is MILES. 
    /// - parameter start: (query) The start index for pagination 
    /// - parameter limit: (query) The limit for pagination 
    /// - parameter accountId: (query) The account id of the user (optional)
    /// - parameter address: (query) Used to return results using this address as the center (optional)
    /// - parameter hasOffers: (query) boolean to indicate whether to include retailer locations that have no offers (optional)
    /// - parameter categories: (query) Comma separate list of category ids (optional)
    /// - parameter filters: (query) Comma separated list of filter ids (optional)
    /// - parameter audiences: (query) Comma separated list of audience ids (optional)
    /// - parameter retailerIds: (query) Comma separated list of retailer ids (optional)
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location ids (optional)
    /// - parameter tags: (query) Does a full-text search on tags (optional)
    /// - parameter locationType: (query) Location type filter (optional)
    /// - parameter sortField: (query) The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) Search by keyword (optional)
    /// - parameter keywordOperator: (query) Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
    /// - parameter searchExpression: (query) Search expression to further refine results (optional)
    /// - parameter distanceUnit: (query) Unit of distance (optional)
    /// - parameter returnFavorited: (query) (deprecated) return favorited flag (optional)
    /// - parameter returnRetailer: (query) Return retailer info (optional)
    /// - parameter returnAssets: (query) Return assets (optional)
    /// - parameter returnOffers: (query) Return offers (optional)
    /// - parameter returnCategories: (query) Return categories (optional)
    /// - parameter returnFilters: (query) Return filters (optional)
    /// - parameter returnAudiences: (query) Return audiences (optional)
    /// - parameter returnQrCode: (query) Return QR code info (optional)
    /// - parameter returnExternalCategoryData: (query) Return external category data (optional)
    /// - parameter includeFavorite: (query) Include favorites in response (optional)
    /// - parameter includeLiked: (query) Include liked flag in response (optional)
    /// - parameter includeRating: (query) Include rating info in response (optional)
    /// - returns: AnyPublisher<[RetailerLocationResponse], Error> 
    open func indexedRetailerLocationDistanceSearch(version: Double, latitude: Double, longitude: Double, searchRange: Double, start: Int, limit: Int, accountId: Int64? = nil, address: String? = nil, hasOffers: Bool? = nil, categories: String? = nil, filters: String? = nil, audiences: String? = nil, retailerIds: String? = nil, retailerLocationIds: String? = nil, tags: String? = nil, locationType: String? = nil, sortField: String? = nil, descending: Bool? = nil, q: String? = nil, keyword: String? = nil, keywordOperator: String? = nil, searchExpression: String? = nil, distanceUnit: IndexedRetailerLocationDistanceSearchDistanceUnit? = nil, returnFavorited: Bool? = nil, returnRetailer: Bool? = nil, returnAssets: Bool? = nil, returnOffers: Bool? = nil, returnCategories: Bool? = nil, returnFilters: Bool? = nil, returnAudiences: Bool? = nil, returnQrCode: Bool? = nil, returnExternalCategoryData: Bool? = nil, includeFavorite: Bool? = nil, includeLiked: Bool? = nil, includeRating: Bool? = nil) -> AnyPublisher<[RetailerLocationResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/idistancesearch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)"))
                queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)"))
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let address = address { queryItems.append(URLQueryItem(name: "address", value: address)) } 
                queryItems.append(URLQueryItem(name: "searchRange", value: "\(searchRange)"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let hasOffers = hasOffers { queryItems.append(URLQueryItem(name: "hasOffers", value: hasOffers ? "true" : "false")) } 
                if let categories = categories { queryItems.append(URLQueryItem(name: "categories", value: categories)) } 
                if let filters = filters { queryItems.append(URLQueryItem(name: "filters", value: filters)) } 
                if let audiences = audiences { queryItems.append(URLQueryItem(name: "audiences", value: audiences)) } 
                if let retailerIds = retailerIds { queryItems.append(URLQueryItem(name: "retailerIds", value: retailerIds)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let keywordOperator = keywordOperator { queryItems.append(URLQueryItem(name: "keywordOperator", value: keywordOperator)) } 
                if let searchExpression = searchExpression { queryItems.append(URLQueryItem(name: "searchExpression", value: searchExpression)) } 
                if let distanceUnit = distanceUnit { queryItems.append(URLQueryItem(name: "distanceUnit", value: distanceUnit.rawValue)) } 
                if let returnFavorited = returnFavorited { queryItems.append(URLQueryItem(name: "returnFavorited", value: returnFavorited ? "true" : "false")) } 
                if let returnRetailer = returnRetailer { queryItems.append(URLQueryItem(name: "returnRetailer", value: returnRetailer ? "true" : "false")) } 
                if let returnAssets = returnAssets { queryItems.append(URLQueryItem(name: "returnAssets", value: returnAssets ? "true" : "false")) } 
                if let returnOffers = returnOffers { queryItems.append(URLQueryItem(name: "returnOffers", value: returnOffers ? "true" : "false")) } 
                if let returnCategories = returnCategories { queryItems.append(URLQueryItem(name: "returnCategories", value: returnCategories ? "true" : "false")) } 
                if let returnFilters = returnFilters { queryItems.append(URLQueryItem(name: "returnFilters", value: returnFilters ? "true" : "false")) } 
                if let returnAudiences = returnAudiences { queryItems.append(URLQueryItem(name: "returnAudiences", value: returnAudiences ? "true" : "false")) } 
                if let returnQrCode = returnQrCode { queryItems.append(URLQueryItem(name: "returnQrCode", value: returnQrCode ? "true" : "false")) } 
                if let returnExternalCategoryData = returnExternalCategoryData { queryItems.append(URLQueryItem(name: "returnExternalCategoryData", value: returnExternalCategoryData ? "true" : "false")) } 
                if let includeFavorite = includeFavorite { queryItems.append(URLQueryItem(name: "includeFavorite", value: includeFavorite ? "true" : "false")) } 
                if let includeLiked = includeLiked { queryItems.append(URLQueryItem(name: "includeLiked", value: includeLiked ? "true" : "false")) } 
                if let includeRating = includeRating { queryItems.append(URLQueryItem(name: "includeRating", value: includeRating ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RetailerLocationResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RetailerLocationResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Keyword Search Retailer Locations (Indexed)
    /// - GET /api/{version}/retailer/location/isearch
    /// - Retailer location (faster) indexed search. This searches all retailer locations.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (optional)
    /// - parameter start: (query) The start index for pagination (optional)
    /// - parameter limit: (query) The limit for pagination (optional)
    /// - parameter hasOffers: (query) boolean to indicate whether to include retailer locations that have no offers (optional)
    /// - parameter categories: (query) Comma separate list of category ids (optional)
    /// - parameter filters: (query) Comma separated list of filter ids (optional)
    /// - parameter audiences: (query) Comma separated list of audience ids (optional)
    /// - parameter retailerIds: (query) Comma separated list of retailer ids (optional)
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location ids (optional)
    /// - parameter tags: (query) Does a full-text search on tags (optional)
    /// - parameter locationType: (query) Location type filter (optional)
    /// - parameter sortField: (query) The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME (optional)
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) Search by keyword (optional)
    /// - parameter keywordOperator: (query) Determines the operator used when there are multiple words in the &#39;keyword&#39; parameter (optional)
    /// - parameter searchExpression: (query) Search expression to further refine results (optional)
    /// - parameter returnRetailer: (query) Return retailer info (optional)
    /// - parameter returnAssets: (query) Return assets (optional)
    /// - parameter returnOffers: (query) Return offers (optional)
    /// - parameter returnCategories: (query) Return categories (optional)
    /// - parameter returnFilters: (query) Return filters (optional)
    /// - parameter returnAudiences: (query) Return audiences (optional)
    /// - parameter returnQrCode: (query) Return QR code info (optional)
    /// - parameter returnExternalCategoryData: (query) Return external category data (optional)
    /// - parameter includeFavorite: (query) Include favorites in response (optional)
    /// - parameter includeLiked: (query) Include liked flag in response (optional)
    /// - parameter includeRating: (query) Include rating info in response (optional)
    /// - returns: AnyPublisher<[RetailerLocationResponse], Error> 
    open func indexedRetailerLocationSearch(version: Double, accountId: Int64? = nil, start: Int? = nil, limit: Int? = nil, hasOffers: Bool? = nil, categories: String? = nil, filters: String? = nil, audiences: String? = nil, retailerIds: String? = nil, retailerLocationIds: String? = nil, tags: String? = nil, locationType: String? = nil, sortField: String? = nil, descending: Bool? = nil, q: String? = nil, keyword: String? = nil, keywordOperator: String? = nil, searchExpression: String? = nil, returnRetailer: Bool? = nil, returnAssets: Bool? = nil, returnOffers: Bool? = nil, returnCategories: Bool? = nil, returnFilters: Bool? = nil, returnAudiences: Bool? = nil, returnQrCode: Bool? = nil, returnExternalCategoryData: Bool? = nil, includeFavorite: Bool? = nil, includeLiked: Bool? = nil, includeRating: Bool? = nil) -> AnyPublisher<[RetailerLocationResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/isearch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let hasOffers = hasOffers { queryItems.append(URLQueryItem(name: "hasOffers", value: hasOffers ? "true" : "false")) } 
                if let categories = categories { queryItems.append(URLQueryItem(name: "categories", value: categories)) } 
                if let filters = filters { queryItems.append(URLQueryItem(name: "filters", value: filters)) } 
                if let audiences = audiences { queryItems.append(URLQueryItem(name: "audiences", value: audiences)) } 
                if let retailerIds = retailerIds { queryItems.append(URLQueryItem(name: "retailerIds", value: retailerIds)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let keywordOperator = keywordOperator { queryItems.append(URLQueryItem(name: "keywordOperator", value: keywordOperator)) } 
                if let searchExpression = searchExpression { queryItems.append(URLQueryItem(name: "searchExpression", value: searchExpression)) } 
                if let returnRetailer = returnRetailer { queryItems.append(URLQueryItem(name: "returnRetailer", value: returnRetailer ? "true" : "false")) } 
                if let returnAssets = returnAssets { queryItems.append(URLQueryItem(name: "returnAssets", value: returnAssets ? "true" : "false")) } 
                if let returnOffers = returnOffers { queryItems.append(URLQueryItem(name: "returnOffers", value: returnOffers ? "true" : "false")) } 
                if let returnCategories = returnCategories { queryItems.append(URLQueryItem(name: "returnCategories", value: returnCategories ? "true" : "false")) } 
                if let returnFilters = returnFilters { queryItems.append(URLQueryItem(name: "returnFilters", value: returnFilters ? "true" : "false")) } 
                if let returnAudiences = returnAudiences { queryItems.append(URLQueryItem(name: "returnAudiences", value: returnAudiences ? "true" : "false")) } 
                if let returnQrCode = returnQrCode { queryItems.append(URLQueryItem(name: "returnQrCode", value: returnQrCode ? "true" : "false")) } 
                if let returnExternalCategoryData = returnExternalCategoryData { queryItems.append(URLQueryItem(name: "returnExternalCategoryData", value: returnExternalCategoryData ? "true" : "false")) } 
                if let includeFavorite = includeFavorite { queryItems.append(URLQueryItem(name: "includeFavorite", value: includeFavorite ? "true" : "false")) } 
                if let includeLiked = includeLiked { queryItems.append(URLQueryItem(name: "includeLiked", value: includeLiked ? "true" : "false")) } 
                if let includeRating = includeRating { queryItems.append(URLQueryItem(name: "includeRating", value: includeRating ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RetailerLocationResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RetailerLocationResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchRetailerLocationsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case retailerId = "RETAILER_ID"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
        case addressStreet = "ADDRESS_STREET"
        case addressCity = "ADDRESS_CITY"
        case addressState = "ADDRESS_STATE"
        case addressPostalCode = "ADDRESS_POSTAL_CODE"
        case addressCountry = "ADDRESS_COUNTRY"
        case name = "NAME"
        case code = "CODE"
    }

    /// Search Retailer Locations (Owned)
    /// - GET /api/{version}/retailer/location/search
    /// - Searches on retailer locations that the account has access to.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter retailerIds: (query) Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers. (optional)
    /// - parameter retailerLocationIds: (query) Comma separated list of retailer location IDs (optional)
    /// - parameter locationType: (query) Location type filter (optional)
    /// - parameter sortField: (query) The column to sort the search on (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - parameter showPublicLocations: (query) Whether to include public locations in the results (optional)
    /// - parameter activeOnly: (query) Return only active results (optional)
    /// - parameter returnRetailer: (query) Return retailer info (optional)
    /// - parameter returnAssets: (query) Return assets (optional)
    /// - parameter returnOffers: (query) Return offers (optional)
    /// - parameter returnCategories: (query) Return categories (optional)
    /// - parameter returnFilters: (query) Return filters (optional)
    /// - parameter returnAudiences: (query) Return audiences (optional)
    /// - parameter returnQrCode: (query) Return QR code info (optional)
    /// - parameter includeFavorite: (query) Include favorites in response (optional)
    /// - parameter includeLiked: (query) Include liked flag in response (optional)
    /// - parameter includeRating: (query) Include rating info in response (optional)
    /// - returns: AnyPublisher<[RetailerLocationResponse], Error> 
    open func searchRetailerLocations(version: Double, deviceId: String? = nil, accountId: Int64? = nil, q: String? = nil, keyword: String? = nil, retailerIds: String? = nil, retailerLocationIds: String? = nil, locationType: String? = nil, sortField: SearchRetailerLocationsSortField? = nil, descending: Bool? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil, showPublicLocations: Bool? = nil, activeOnly: Bool? = nil, returnRetailer: Bool? = nil, returnAssets: Bool? = nil, returnOffers: Bool? = nil, returnCategories: Bool? = nil, returnFilters: Bool? = nil, returnAudiences: Bool? = nil, returnQrCode: Bool? = nil, includeFavorite: Bool? = nil, includeLiked: Bool? = nil, includeRating: Bool? = nil) -> AnyPublisher<[RetailerLocationResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let retailerIds = retailerIds { queryItems.append(URLQueryItem(name: "retailerIds", value: retailerIds)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let showPublicLocations = showPublicLocations { queryItems.append(URLQueryItem(name: "showPublicLocations", value: showPublicLocations ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let returnRetailer = returnRetailer { queryItems.append(URLQueryItem(name: "returnRetailer", value: returnRetailer ? "true" : "false")) } 
                if let returnAssets = returnAssets { queryItems.append(URLQueryItem(name: "returnAssets", value: returnAssets ? "true" : "false")) } 
                if let returnOffers = returnOffers { queryItems.append(URLQueryItem(name: "returnOffers", value: returnOffers ? "true" : "false")) } 
                if let returnCategories = returnCategories { queryItems.append(URLQueryItem(name: "returnCategories", value: returnCategories ? "true" : "false")) } 
                if let returnFilters = returnFilters { queryItems.append(URLQueryItem(name: "returnFilters", value: returnFilters ? "true" : "false")) } 
                if let returnAudiences = returnAudiences { queryItems.append(URLQueryItem(name: "returnAudiences", value: returnAudiences ? "true" : "false")) } 
                if let returnQrCode = returnQrCode { queryItems.append(URLQueryItem(name: "returnQrCode", value: returnQrCode ? "true" : "false")) } 
                if let includeFavorite = includeFavorite { queryItems.append(URLQueryItem(name: "includeFavorite", value: includeFavorite ? "true" : "false")) } 
                if let includeLiked = includeLiked { queryItems.append(URLQueryItem(name: "includeLiked", value: includeLiked ? "true" : "false")) } 
                if let includeRating = includeRating { queryItems.append(URLQueryItem(name: "includeRating", value: includeRating ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RetailerLocationResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RetailerLocationResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter responseFormat
    ///
    public enum UpdateRetailerLocationsResponseFormat: String, Codable, CaseIterable {
        case html = "HTML"
        case xml = "XML"
        case json = "JSON"
        case csv = "CSV"
    }

    /// Update Retailer Location
    /// - POST /api/{version}/retailer/location/update
    /// - Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.
    /// - parameter version: (path)  
    /// - parameter retailerLocationId: (query) The ID of the retailer location 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter name: (query) The name of the retailer location (optional)
    /// - parameter streetAddress: (query) The street address of the retailer location (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the retailer location (optional)
    /// - parameter state: (query) The state of the retailer location (optional)
    /// - parameter postalCode: (query) The postal code of the retailer location (optional)
    /// - parameter country: (query) the country of the retailer location (optional)
    /// - parameter businessPhone: (query) The business phone number of the retailer location (optional)
    /// - parameter businessPhoneExt: (query) The business phone extension of the retailer location (optional)
    /// - parameter website: (query) The website of the retailer location (optional)
    /// - parameter email: (query) The email of the retailer location (optional)
    /// - parameter internalId: (query) An internal identifier used by the retailer (optional)
    /// - parameter detailsHeader: (query) A brief description about the retailer location (255 character limit) (optional)
    /// - parameter detailsBody: (query) A detailed description about the retailer location (optional)
    /// - parameter hours: (query) The hours of operation (optional)
    /// - parameter logo: (query) The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
    /// - parameter logoAssetId: (query) The retailer location logo asset id (optional)
    /// - parameter picture1: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture1AssetId: (query) An asset id (optional)
    /// - parameter picture2: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture2AssetId: (query) An asset id (optional)
    /// - parameter categoryIds: (query) Comma separated list of category IDs used to filter retailer locations by categories (optional)
    /// - parameter filterIds: (query) Comma separated list of filter IDs used to filter retailer locations (optional)
    /// - parameter latitude: (query) the latituede of the retailer location (optional)
    /// - parameter longitude: (query) the longitude of the retailer location (optional)
    /// - parameter building: (query)  (optional)
    /// - parameter googlePlaceId: (query) the Google Place ID that the retailer location is associated with (optional)
    /// - parameter yelpId: (query) the Yelp ID that the retailer location is associated with (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter paymentProvider: (query) Specifies which payment provider Sirqul will use when making payments (optional)
    /// - parameter active: (query) Sets whether the retailer is active or inactive (hidden from consumers) (optional)
    /// - parameter publicLocation: (query) Sets whether the location is public or not (optional)
    /// - parameter locationType: (query) External custom type identifier (optional)
    /// - parameter audienceIds: (query) Comma separated list of audience IDs used to assign audiences to the retailer location (optional)
    /// - parameter audienceIdsToAdd: (query) Comma separated list of audience IDs to add to the retailer location (optional)
    /// - parameter audienceIdsToRemove: (query) Comma separated list of audience IDs to remove from the retailer location (optional)
    /// - parameter responseFormat: (query) The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
    /// - parameter tags: (query) Custom string field for doing full-text searches (optional)
    /// - returns: AnyPublisher<RetailerLocationResponse, Error> 
    open func updateRetailerLocations(version: Double, retailerLocationId: Int64, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, postalCode: String? = nil, country: String? = nil, businessPhone: String? = nil, businessPhoneExt: String? = nil, website: String? = nil, email: String? = nil, internalId: String? = nil, detailsHeader: String? = nil, detailsBody: String? = nil, hours: String? = nil, logo: Data? = nil, logoAssetId: Int64? = nil, picture1: Data? = nil, picture1AssetId: Int64? = nil, picture2: Data? = nil, picture2AssetId: Int64? = nil, categoryIds: String? = nil, filterIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil, building: String? = nil, googlePlaceId: String? = nil, yelpId: String? = nil, metaData: String? = nil, paymentProvider: String? = nil, active: Bool? = nil, publicLocation: Bool? = nil, locationType: String? = nil, audienceIds: String? = nil, audienceIdsToAdd: String? = nil, audienceIdsToRemove: String? = nil, responseFormat: UpdateRetailerLocationsResponseFormat? = nil, tags: String? = nil) -> AnyPublisher<RetailerLocationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/retailer/location/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let businessPhoneExt = businessPhoneExt { queryItems.append(URLQueryItem(name: "businessPhoneExt", value: businessPhoneExt)) } 
                if let website = website { queryItems.append(URLQueryItem(name: "website", value: website)) } 
                if let email = email { queryItems.append(URLQueryItem(name: "email", value: email)) } 
                if let internalId = internalId { queryItems.append(URLQueryItem(name: "internalId", value: internalId)) } 
                if let detailsHeader = detailsHeader { queryItems.append(URLQueryItem(name: "detailsHeader", value: detailsHeader)) } 
                if let detailsBody = detailsBody { queryItems.append(URLQueryItem(name: "detailsBody", value: detailsBody)) } 
                if let hours = hours { queryItems.append(URLQueryItem(name: "hours", value: hours)) } 
                if let logo = logo { queryItems.append(URLQueryItem(name: "logo", value: )) } 
                if let logoAssetId = logoAssetId { queryItems.append(URLQueryItem(name: "logoAssetId", value: "\(logoAssetId)")) } 
                if let picture1 = picture1 { queryItems.append(URLQueryItem(name: "picture1", value: )) } 
                if let picture1AssetId = picture1AssetId { queryItems.append(URLQueryItem(name: "picture1AssetId", value: "\(picture1AssetId)")) } 
                if let picture2 = picture2 { queryItems.append(URLQueryItem(name: "picture2", value: )) } 
                if let picture2AssetId = picture2AssetId { queryItems.append(URLQueryItem(name: "picture2AssetId", value: "\(picture2AssetId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let building = building { queryItems.append(URLQueryItem(name: "building", value: building)) } 
                if let googlePlaceId = googlePlaceId { queryItems.append(URLQueryItem(name: "googlePlaceId", value: googlePlaceId)) } 
                if let yelpId = yelpId { queryItems.append(URLQueryItem(name: "yelpId", value: yelpId)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let paymentProvider = paymentProvider { queryItems.append(URLQueryItem(name: "paymentProvider", value: paymentProvider)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let publicLocation = publicLocation { queryItems.append(URLQueryItem(name: "publicLocation", value: publicLocation ? "true" : "false")) } 
                if let locationType = locationType { queryItems.append(URLQueryItem(name: "locationType", value: locationType)) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let audienceIdsToAdd = audienceIdsToAdd { queryItems.append(URLQueryItem(name: "audienceIdsToAdd", value: audienceIdsToAdd)) } 
                if let audienceIdsToRemove = audienceIdsToRemove { queryItems.append(URLQueryItem(name: "audienceIdsToRemove", value: audienceIdsToRemove)) } 
                if let responseFormat = responseFormat { queryItems.append(URLQueryItem(name: "responseFormat", value: responseFormat.rawValue)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerLocationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerLocationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
