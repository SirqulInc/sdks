//
// FilterAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class FilterAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Filter
    /// - POST /api/{version}/filter/create
    /// - Create a filter
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (must have permissions to the target application) 
    /// - parameter name: (query) The name of the filter 
    /// - parameter appKey: (query) The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (optional)
    /// - parameter parentFilterId: (query) The ID of the parent filter, if not provided then the parent filter will be null (optional)
    /// - parameter description: (query) The description of the filter (optional)
    /// - parameter externalId: (query) A string identifier used by client applications to store external information (optional)
    /// - parameter externalType: (query) A string type used by client applications to store external information (optional)
    /// - parameter active: (query) Sets whether the filter is active or inactive (hidden from consumers) (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - returns: AnyPublisher<FilterTreeResponse, Error> 
    open func createFilter(version: Double, accountId: Int64, name: String, appKey: String? = nil, parentFilterId: Int64? = nil, description: String? = nil, externalId: String? = nil, externalType: String? = nil, active: Bool? = nil, metaData: String? = nil) -> AnyPublisher<FilterTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/filter/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let parentFilterId = parentFilterId { queryItems.append(URLQueryItem(name: "parentFilterId", value: "\(parentFilterId)")) } 
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let externalType = externalType { queryItems.append(URLQueryItem(name: "externalType", value: externalType)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FilterTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(FilterTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Filter
    /// - POST /api/{version}/filter/delete
    /// - Delete a filter.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (must have permissions to the filter&#39;s assigned application) 
    /// - parameter filterId: (query) The ID of the filter to delete 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteFilter(version: Double, accountId: Int64, filterId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/filter/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "filterId", value: "\(filterId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Filter
    /// - GET /api/{version}/filter/get
    /// - Get the details of a specific filter. Recursively include all child filters and their children.
    /// - parameter version: (path)  
    /// - parameter filterId: (query) the id of the filter to get 
    /// - returns: AnyPublisher<FilterTreeResponse, Error> 
    open func getFilter(version: Double, filterId: Int64) -> AnyPublisher<FilterTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/filter/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "filterId", value: "\(filterId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FilterTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(FilterTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter responseGroup
    ///
    public enum SearchFiltersResponseGroup: String, Codable, CaseIterable {
        case all = "ALL"
        case global = "GLOBAL"
        case mine = "MINE"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum SearchFiltersSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case name = "NAME"
        case display = "DISPLAY"
    }

    /// Search Filters
    /// - GET /api/{version}/filter/search
    /// - Search for filters.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (optional)
    /// - parameter keyword: (query) The string to search on (optional)
    /// - parameter appKey: (query) the appKey of the application to retrieve filters for (optional)
    /// - parameter responseGroup: (query) The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
    /// - parameter rootOnly: (query) Restrict the search to only those filters with no parent filter assigned. (optional)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to .display)
    /// - parameter descending: (query) The order to return the search results (optional, default to false)
    /// - parameter start: (query) The record to begin the return set on (optional, default to 0)
    /// - parameter limit: (query) The number of records to return (optional, default to 20)
    /// - parameter activeOnly: (query) Determines whether to return only active categories (optional, default to true)
    /// - returns: AnyPublisher<[FilterResponse], Error> 
    open func searchFilters(version: Double, accountId: Int64? = nil, keyword: String? = nil, appKey: String? = nil, responseGroup: SearchFiltersResponseGroup? = nil, rootOnly: Bool? = nil, sortField: SearchFiltersSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil) -> AnyPublisher<[FilterResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/filter/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let responseGroup = responseGroup { queryItems.append(URLQueryItem(name: "responseGroup", value: responseGroup.rawValue)) } 
                if let rootOnly = rootOnly { queryItems.append(URLQueryItem(name: "rootOnly", value: rootOnly ? "true" : "false")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[FilterResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([FilterResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Filter
    /// - POST /api/{version}/filter/update
    /// - Update a filter.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user 
    /// - parameter filterId: (query) The ID of the filter to edit 
    /// - parameter parentFilterId: (query) The ID of the parent filter, if not provided then the parent filter will be null (optional)
    /// - parameter name: (query) The name of the filter (optional)
    /// - parameter description: (query) The description of the filter (optional)
    /// - parameter externalId: (query) A string identifier used by client applications to store external information (optional)
    /// - parameter externalType: (query) A string type used by client applications to store external information (optional)
    /// - parameter active: (query) Sets whether the filter is active or inactive (hidden from consumers) (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - returns: AnyPublisher<FilterTreeResponse, Error> 
    open func updateFilter(version: Double, accountId: Int64, filterId: Int64, parentFilterId: Int64? = nil, name: String? = nil, description: String? = nil, externalId: String? = nil, externalType: String? = nil, active: Bool? = nil, metaData: String? = nil) -> AnyPublisher<FilterTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/filter/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "filterId", value: "\(filterId)"))
                if let parentFilterId = parentFilterId { queryItems.append(URLQueryItem(name: "parentFilterId", value: "\(parentFilterId)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let externalType = externalType { queryItems.append(URLQueryItem(name: "externalType", value: externalType)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<FilterTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(FilterTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
