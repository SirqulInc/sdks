//
// ContestAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ContestAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum AddOrUpdateAlbumContestVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /// Create or Update Contest
    /// - POST /consumer/album/contest
    /// - Creates or updates a contest.
    /// - parameter publicRead: (query) determines whether the contest&#39;s participants has read permissions 
    /// - parameter publicWrite: (query) determines whether the contest&#39;s participants has write permissions 
    /// - parameter publicDelete: (query) determines whether the contest&#39;s participants has delete permissions 
    /// - parameter publicAdd: (query) determines whether the contest&#39;s participants has add permissions 
    /// - parameter visibility: (query) the determines the album&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) 
    /// - parameter includeFriendGroup: (query) determines whether to include all friends as participants 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) This parameter is deprecated. the application key (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter contestType: (query) a custom field used for aggregation and searching (optional)
    /// - parameter albumContestId: (query) the album contest ID for updating (don&#39;t pass in if creating) (optional)
    /// - parameter title: (query) the title of the contest (optional)
    /// - parameter description: (query) the description of the contest (optional)
    /// - parameter albumId1: (query) the album ID for the first album (optional)
    /// - parameter removeAlbum1: (query) removes album1 from the contest (optional)
    /// - parameter albumId2: (query) the album ID for the second album (optional)
    /// - parameter removeAlbum2: (query) removes album2 from the contest (optional)
    /// - parameter startDate: (query) the start date of the contest (time-stamp in milliseconds) (optional)
    /// - parameter endDate: (query) the end date of the contest (time-stamp in milliseconds) (optional)
    /// - parameter locationDescription: (query) the location description of the contest taking place (optional)
    /// - parameter connectionIdsToAdd: (query) comma separated list of connection IDs (optional)
    /// - parameter connectionGroupIdsToAdd: (query) comma separated list of connection group IDs (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<AlbumContestResponse, Error> 
    open func addOrUpdateAlbumContest(publicRead: Bool, publicWrite: Bool, publicDelete: Bool, publicAdd: Bool, visibility: AddOrUpdateAlbumContestVisibility, includeFriendGroup: Bool, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, contestType: String? = nil, albumContestId: Int64? = nil, title: String? = nil, description: String? = nil, albumId1: Int64? = nil, removeAlbum1: Bool? = nil, albumId2: Int64? = nil, removeAlbum2: Bool? = nil, startDate: Int64? = nil, endDate: Int64? = nil, locationDescription: String? = nil, connectionIdsToAdd: String? = nil, connectionGroupIdsToAdd: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<AlbumContestResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/album/contest"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let contestType = contestType { queryItems.append(URLQueryItem(name: "contestType", value: contestType)) } 
                if let albumContestId = albumContestId { queryItems.append(URLQueryItem(name: "albumContestId", value: "\(albumContestId)")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let albumId1 = albumId1 { queryItems.append(URLQueryItem(name: "albumId1", value: "\(albumId1)")) } 
                if let removeAlbum1 = removeAlbum1 { queryItems.append(URLQueryItem(name: "removeAlbum1", value: removeAlbum1 ? "true" : "false")) } 
                if let albumId2 = albumId2 { queryItems.append(URLQueryItem(name: "albumId2", value: "\(albumId2)")) } 
                if let removeAlbum2 = removeAlbum2 { queryItems.append(URLQueryItem(name: "removeAlbum2", value: removeAlbum2 ? "true" : "false")) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                queryItems.append(URLQueryItem(name: "publicRead", value: publicRead ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "publicWrite", value: publicWrite ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "publicDelete", value: publicDelete ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "publicAdd", value: publicAdd ? "true" : "false"))
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue))
                if let connectionIdsToAdd = connectionIdsToAdd { queryItems.append(URLQueryItem(name: "connectionIdsToAdd", value: connectionIdsToAdd)) } 
                if let connectionGroupIdsToAdd = connectionGroupIdsToAdd { queryItems.append(URLQueryItem(name: "connectionGroupIdsToAdd", value: connectionGroupIdsToAdd)) } 
                queryItems.append(URLQueryItem(name: "includeFriendGroup", value: includeFriendGroup ? "true" : "false"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AlbumContestResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AlbumContestResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter approvalStatus
    ///
    public enum ApproveAlbumContestApprovalStatus: String, Codable, CaseIterable {
        case pending = "PENDING"
        case rejected = "REJECTED"
        case approved = "APPROVED"
        case featured = "FEATURED"
    }

    /// Approve Contest
    /// - POST /consumer/album/contest/approve
    /// - Sets the approval status of a contest.
    /// - parameter albumContestId: (query) The ID of the album contest 
    /// - parameter approvalStatus: (query) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} 
    /// - parameter deviceId: (query) A unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account ID of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func approveAlbumContest(albumContestId: Int64, approvalStatus: ApproveAlbumContestApprovalStatus, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/album/contest/approve"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "albumContestId", value: "\(albumContestId)"))
                queryItems.append(URLQueryItem(name: "approvalStatus", value: approvalStatus.rawValue))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Contest
    /// - POST /consumer/album/contest/remove
    /// - Deletes a contest.
    /// - parameter albumContestId: (query) the album contest ID 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteContest(albumContestId: Int64, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/album/contest/remove"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "albumContestId", value: "\(albumContestId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Contest
    /// - GET /consumer/album/contest/get
    /// - Gets the contest object including the likes and notes
    /// - parameter albumContestId: (query) the album contest ID 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<AlbumContestResponse, Error> 
    open func getAlbumContest(albumContestId: Int64, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<AlbumContestResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/album/contest/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "albumContestId", value: "\(albumContestId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AlbumContestResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AlbumContestResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Contests
    /// - GET /consumer/album/contest/search
    /// - Searches on contests.
    /// - parameter filter: (query) a comma separated list of Ownership 
    /// - parameter sortField: (query) the field to sort by. See AlbumContestApiMap 
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order 
    /// - parameter start: (query) the start index for pagination 
    /// - parameter limit: (query) the limit for pagination (there is a hard limit of 30) 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter appType: (query) the application type (optional)
    /// - parameter contestType: (query) filter contests with this contest type (optional)
    /// - parameter ownerId: (query) search on contests that have been created by this account (that the user has permissions to) (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) keyword search string (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter dateCreated: (query) filter on items that have been created before this date (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<AlbumContestListResponse, Error> 
    open func getAlbumContests(filter: String, sortField: String, descending: Bool, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, appKey: String? = nil, appType: String? = nil, contestType: String? = nil, ownerId: Int64? = nil, q: String? = nil, keyword: String? = nil, i: Int? = nil, l: Int? = nil, dateCreated: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<AlbumContestListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/album/contest/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let appType = appType { queryItems.append(URLQueryItem(name: "appType", value: appType)) } 
                if let contestType = contestType { queryItems.append(URLQueryItem(name: "contestType", value: contestType)) } 
                if let ownerId = ownerId { queryItems.append(URLQueryItem(name: "ownerId", value: "\(ownerId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "filter", value: filter))
                queryItems.append(URLQueryItem(name: "sortField", value: sortField))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let dateCreated = dateCreated { queryItems.append(URLQueryItem(name: "dateCreated", value: "\(dateCreated)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AlbumContestListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AlbumContestListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Vote on Contest
    /// - POST /consumer/album/contest/vote
    /// - Vote on a collection in a contest.
    /// - parameter albumContestId: (query) the album contest ID 
    /// - parameter albumId: (query) the ID of the album to vote on 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter contestType: (query) a custom field used for aggregation and searching (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<AlbumContestResponse, Error> 
    open func voteOnAlbumContest(albumContestId: Int64, albumId: Int64, deviceId: String? = nil, accountId: Int64? = nil, contestType: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<AlbumContestResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/album/contest/vote"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "albumContestId", value: "\(albumContestId)"))
                queryItems.append(URLQueryItem(name: "albumId", value: "\(albumId)"))
                if let contestType = contestType { queryItems.append(URLQueryItem(name: "contestType", value: contestType)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AlbumContestResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AlbumContestResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
