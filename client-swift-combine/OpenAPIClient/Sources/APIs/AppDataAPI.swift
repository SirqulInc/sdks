//
// AppDataAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AppDataAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Get App Data
    /// - GET /app/get
    /// - Get the application data structure.  The basic structure is a   node tree, with the root node being a AppResponse.  The response contains   the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.     Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application.
    /// - parameter start: (query) start the search results at a record. 
    /// - parameter limit: (query) limit the search results to some number. 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter gameType: (query) the game to retrieve the data for, use your application key. (optional)
    /// - parameter includeGameData: (query) if true then include the game data blob, otherwise don&#39;t include. (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) query string used to filter the search results when looking for community and saved levels. (optional)
    /// - parameter sortField: (query) how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS. (optional)
    /// - parameter descending: (query) order the search results descending or ascending when looking for community and saved levels. (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter gameObjectCount: (query) if true then include the game object count, otherwise don&#39;t include. (optional)
    /// - parameter filter: (query) restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED (optional)
    /// - parameter dateCreated: (query) restrict the search to items created less then date (optional)
    /// - parameter ownerId: (query) get levels owned by a particular account (optional)
    /// - parameter missionIds: (query) get missions by specified id, comman seperated list of long ids (optional)
    /// - parameter gameIds: (query) get games by specified id, comman seperated list of long ids (optional)
    /// - parameter packIds: (query) get packs by specified id, comman seperated list of long ids (optional)
    /// - parameter gameLevelIds: (query) get game levels by specified id, comman seperated list of long ids (optional)
    /// - parameter appVersion: (query) the application version, used to versin the game level data (optional)
    /// - parameter includeHigherVersionPacks: (query) default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
    /// - parameter includeHigherVersionLevels: (query) default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
    /// - parameter responseGroups: (query) use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list  (optional)
    /// - parameter purchaseType: (query) the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase  (optional)
    /// - returns: AnyPublisher<AppResponse, Error> 
    open func getAppData(start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, includeGameData: Bool? = nil, q: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, i: Int? = nil, l: Int? = nil, gameObjectCount: Bool? = nil, filter: String? = nil, dateCreated: Int64? = nil, ownerId: Int64? = nil, missionIds: String? = nil, gameIds: String? = nil, packIds: String? = nil, gameLevelIds: String? = nil, appVersion: String? = nil, includeHigherVersionPacks: Bool? = nil, includeHigherVersionLevels: Bool? = nil, responseGroups: String? = nil, purchaseType: String? = nil) -> AnyPublisher<AppResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/app/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let gameObjectCount = gameObjectCount { queryItems.append(URLQueryItem(name: "gameObjectCount", value: gameObjectCount ? "true" : "false")) } 
                if let filter = filter { queryItems.append(URLQueryItem(name: "filter", value: filter)) } 
                if let dateCreated = dateCreated { queryItems.append(URLQueryItem(name: "dateCreated", value: "\(dateCreated)")) } 
                if let ownerId = ownerId { queryItems.append(URLQueryItem(name: "ownerId", value: "\(ownerId)")) } 
                if let missionIds = missionIds { queryItems.append(URLQueryItem(name: "missionIds", value: missionIds)) } 
                if let gameIds = gameIds { queryItems.append(URLQueryItem(name: "gameIds", value: gameIds)) } 
                if let packIds = packIds { queryItems.append(URLQueryItem(name: "packIds", value: packIds)) } 
                if let gameLevelIds = gameLevelIds { queryItems.append(URLQueryItem(name: "gameLevelIds", value: gameLevelIds)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let includeHigherVersionPacks = includeHigherVersionPacks { queryItems.append(URLQueryItem(name: "includeHigherVersionPacks", value: includeHigherVersionPacks ? "true" : "false")) } 
                if let includeHigherVersionLevels = includeHigherVersionLevels { queryItems.append(URLQueryItem(name: "includeHigherVersionLevels", value: includeHigherVersionLevels ? "true" : "false")) } 
                if let responseGroups = responseGroups { queryItems.append(URLQueryItem(name: "responseGroups", value: responseGroups)) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AppResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AppResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create App Data
    /// - POST /app/post
    /// - Publish the application data structure.  Can be used to save levels   and scores.  It then returns the application data structure.  The basic   structure is a node tree, with the root node being a AppResponse.  The response   contains the user's profile, messages from the system, and a list of MissionResponse.    A mission can have any number of GameResponses but typically is a single   game type.  A game then has any number of PackResponses which help group   the game levels. Packs are then composed of any number of GameLevelResponses.      Using the various parameters can return the applications default mission   (built-in packs to play), the list of community levels published, the user's   saved levels, or explicity levels desired.  You can choose to include the   profile or not, or just return parts of the profile.  You can also filter   out game levels that have been published with a higher version of the application
    /// - parameter gameType: (query) the game to retrieve the data for, use your application key. 
    /// - parameter start: (query) start the search results at a record. 
    /// - parameter limit: (query) limit the search results to some number. 
    /// - parameter data: (query) The analytic data AnalyticListResponse 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required). (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - parameter includeGameData: (query) if true then include the game data blob, otherwise don&#39;t include. (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) query string used to filter the search results when looking for community and saved levels. (optional)
    /// - parameter sortField: (query) how to sort the results when looking for community and saved levels. possible values are: LEVEL_NAME, LEVEL_CREATED, LEVEL_UPDATED, LEVEL_LIKES, LEVEL_DISLIKES, LEVEL_NOTES, LEVEL_PLAYS. (optional)
    /// - parameter descending: (query) order the search results descending or ascending when looking for community and saved levels. (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter gameObjectCount: (query) if true then include the game object count, otherwise don&#39;t include. (optional)
    /// - parameter filter: (query) restrict the search to items with certain permissions, possible values are: MINE, FRIENDS, PUBLIC, ALL_PUBLIC, ALL, LIKED (optional)
    /// - parameter dateCreated: (query) restrict the search to items created less then date (optional)
    /// - parameter ownerId: (query) get levels owned by a particular account (optional)
    /// - parameter missionIds: (query) get missions by specified id, comman seperated list of long ids (optional)
    /// - parameter gameIds: (query) get games by specified id, comman seperated list of long ids (optional)
    /// - parameter packIds: (query) get packs by specified id, comman seperated list of long ids (optional)
    /// - parameter gameLevelIds: (query) get game levels by specified id, comman seperated list of long ids (optional)
    /// - parameter appVersion: (query) the application version, used to versin the game level data (optional)
    /// - parameter includeHigherVersionPacks: (query) default is false and will not include any packs that have levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
    /// - parameter includeHigherVersionLevels: (query) default is false and will not include any levels above the specified appVersion. If true then will return all levels regardless of version. (optional)
    /// - parameter responseGroups: (query) use response groups to include large parts of the structure. possible values are: * MISSION_DEFAULT (default) - include the default mission (built-in packs), excludes all other mission groups * MISSION_DEFAULT_LEVELS_SAVED - include saved levels, excludes all other mission groups * MISSION_DEFAULT_LEVELS_COMMUNITY - include community levels, excludes all other mission groups * MISSION_INVITED (default) - include challenges sent to user * PROFILE (default) - include entire profile * PROFILE_DATA - only include profile date (exclude friends) * PROFILE_FRIENDS - include friends list  (optional)
    /// - parameter purchaseType: (query) the will return the correct in app purchases for the device, possible values are: * SIRQUL (default) - purchasing from the sirqul store using tickets * IOS - purchasing from the itunes store for iPhone, iPod, iPod Touch * GOOGLE - purchasing from the google android store * AMAZON - purchasing from the amazon android store * MAC - purchasing from the itunes store for OSX * FREE - the item is free to purchase  (optional)
    /// - returns: AnyPublisher<AppResponse, Error> 
    open func postAppData(gameType: String, start: Int, limit: Int, data: String, deviceId: String? = nil, accountId: Int64? = nil, includeGameData: Bool? = nil, q: String? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, i: Int? = nil, l: Int? = nil, gameObjectCount: Bool? = nil, filter: String? = nil, dateCreated: Int64? = nil, ownerId: Int64? = nil, missionIds: String? = nil, gameIds: String? = nil, packIds: String? = nil, gameLevelIds: String? = nil, appVersion: String? = nil, includeHigherVersionPacks: Bool? = nil, includeHigherVersionLevels: Bool? = nil, responseGroups: String? = nil, purchaseType: String? = nil) -> AnyPublisher<AppResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/app/post"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "gameType", value: gameType))
                if let includeGameData = includeGameData { queryItems.append(URLQueryItem(name: "includeGameData", value: includeGameData ? "true" : "false")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let gameObjectCount = gameObjectCount { queryItems.append(URLQueryItem(name: "gameObjectCount", value: gameObjectCount ? "true" : "false")) } 
                if let filter = filter { queryItems.append(URLQueryItem(name: "filter", value: filter)) } 
                if let dateCreated = dateCreated { queryItems.append(URLQueryItem(name: "dateCreated", value: "\(dateCreated)")) } 
                if let ownerId = ownerId { queryItems.append(URLQueryItem(name: "ownerId", value: "\(ownerId)")) } 
                if let missionIds = missionIds { queryItems.append(URLQueryItem(name: "missionIds", value: missionIds)) } 
                if let gameIds = gameIds { queryItems.append(URLQueryItem(name: "gameIds", value: gameIds)) } 
                if let packIds = packIds { queryItems.append(URLQueryItem(name: "packIds", value: packIds)) } 
                if let gameLevelIds = gameLevelIds { queryItems.append(URLQueryItem(name: "gameLevelIds", value: gameLevelIds)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let includeHigherVersionPacks = includeHigherVersionPacks { queryItems.append(URLQueryItem(name: "includeHigherVersionPacks", value: includeHigherVersionPacks ? "true" : "false")) } 
                if let includeHigherVersionLevels = includeHigherVersionLevels { queryItems.append(URLQueryItem(name: "includeHigherVersionLevels", value: includeHigherVersionLevels ? "true" : "false")) } 
                if let responseGroups = responseGroups { queryItems.append(URLQueryItem(name: "responseGroups", value: responseGroups)) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                queryItems.append(URLQueryItem(name: "data", value: data))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AppResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AppResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Regenerate App Data
    /// - POST /app/regen
    /// - Regenerate the app data cache for apps
    /// - parameter accountId: (query) the account id of the user (optional)
    /// - parameter appKey: (query) process a specific application, if null process all apps with caches (optional)
    /// - parameter buildVersion: (query) create a specific version, if null use current version. Be careful if processing all (optional)
    /// - parameter apiVersion: (query) create a specific version, if null use current version. Be careful if processing all (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func regenAppData(accountId: Int64? = nil, appKey: String? = nil, buildVersion: String? = nil, apiVersion: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/app/regen"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let buildVersion = buildVersion { queryItems.append(URLQueryItem(name: "buildVersion", value: buildVersion)) } 
                if let apiVersion = apiVersion { queryItems.append(URLQueryItem(name: "apiVersion", value: apiVersion)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
