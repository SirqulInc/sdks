//
// AccountAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AccountAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Search Accounts by Location
    /// - GET /api/{version}/account/search
    /// - Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter q: (query) Deprecated - legacy query parameter (optional)
    /// - parameter keyword: (query) An optional keyword to search on, will be ignore if empty (NOT implemented yet) (optional)
    /// - parameter postalCode: (query) The postal code to search on, either postalCode or the user&#39;s exact location is required (optional)
    /// - parameter latitude: (query) The latitude of the user, either postalCode or the user&#39;s exact location is required (optional)
    /// - parameter longitude: (query) The longitude of the user, either postalCode or the user&#39;s exact location is required (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter range: (query) The range to search on (optional, default to 10)
    /// - parameter locationLastUpdated: (query) Searches for user&#39;s that has updated their location since this date (optional)
    /// - parameter gender: (query) The preferred gender (optional)
    /// - parameter minAge: (query) The preferred min age (optional)
    /// - parameter maxAge: (query) The preferred max age (optional)
    /// - parameter companionshipIndex: (query) The preferred companionship index (optional)
    /// - parameter i: (query) this is the start index of a query (optional)
    /// - parameter start: (query) Start of the pagination (optional, default to 0)
    /// - parameter l: (query) this is the limit index of a query (optional)
    /// - parameter limit: (query) Limit of the pagination (optional, default to 100)
    /// - parameter searchMode: (query) Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH) (optional)
    /// - parameter sortField: (query) Sorting field for results (default: DISTANCE) (optional)
    /// - parameter descending: (query) Whether to sort descending (default: false) (optional)
    /// - parameter roles: (query) Roles to filter on (optional)
    /// - parameter tags: (query) Tags to filter on (optional)
    /// - parameter experience: (query) The experience to filter on (optional)
    /// - parameter categoryIds: (query) The category ids to filter on (comma separated) (optional)
    /// - parameter audienceIds: (query) The audience ids to filter on (comma separated) (optional)
    /// - parameter audienceOperator: (query) Operator used to combine audience filters (default: AND) (optional, default to "AND")
    /// - parameter updateCurrentLocation: (query) Whether to use the given lat &amp; long to update the user&#39;s current location (optional, default to false)
    /// - parameter updatePreferredSettings: (query) Whether to use the given parameters to update the user&#39;s preferred settings (optional, default to false)
    /// - parameter showExactLocations: (query) Determines whether to always display user exact locations (optional, default to true)
    /// - parameter showConnectionToSearcher: (query) Return connection of the accounts in the result to the passed in account if there exists any (optional, default to false)
    /// - parameter flagCountMinimum: (query) Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (optional)
    /// - parameter verifiedUserOnly: (query) Returns only verified users (optional)
    /// - parameter contentAdminOnly: (query) Returns only content admin users (optional)
    /// - returns: AnyPublisher<UserLocationSearchResponse, Error> 
    open func accountLocationSearch(version: Double, deviceId: String? = nil, accountId: Int64? = nil, q: String? = nil, keyword: String? = nil, postalCode: String? = nil, latitude: Double? = nil, longitude: Double? = nil, appKey: String? = nil, range: Double? = nil, locationLastUpdated: Int64? = nil, gender: String? = nil, minAge: Int? = nil, maxAge: Int? = nil, companionshipIndex: Int? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil, searchMode: String? = nil, sortField: String? = nil, descending: Bool? = nil, roles: String? = nil, tags: String? = nil, experience: String? = nil, categoryIds: String? = nil, audienceIds: String? = nil, audienceOperator: String? = nil, updateCurrentLocation: Bool? = nil, updatePreferredSettings: Bool? = nil, showExactLocations: Bool? = nil, showConnectionToSearcher: Bool? = nil, flagCountMinimum: Int64? = nil, verifiedUserOnly: Bool? = nil, contentAdminOnly: Bool? = nil) -> AnyPublisher<UserLocationSearchResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let range = range { queryItems.append(URLQueryItem(name: "range", value: "\(range)")) } 
                if let locationLastUpdated = locationLastUpdated { queryItems.append(URLQueryItem(name: "locationLastUpdated", value: "\(locationLastUpdated)")) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let minAge = minAge { queryItems.append(URLQueryItem(name: "minAge", value: "\(minAge)")) } 
                if let maxAge = maxAge { queryItems.append(URLQueryItem(name: "maxAge", value: "\(maxAge)")) } 
                if let companionshipIndex = companionshipIndex { queryItems.append(URLQueryItem(name: "companionshipIndex", value: "\(companionshipIndex)")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let searchMode = searchMode { queryItems.append(URLQueryItem(name: "searchMode", value: searchMode)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let roles = roles { queryItems.append(URLQueryItem(name: "roles", value: roles)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let experience = experience { queryItems.append(URLQueryItem(name: "experience", value: experience)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let audienceOperator = audienceOperator { queryItems.append(URLQueryItem(name: "audienceOperator", value: audienceOperator)) } 
                if let updateCurrentLocation = updateCurrentLocation { queryItems.append(URLQueryItem(name: "updateCurrentLocation", value: updateCurrentLocation ? "true" : "false")) } 
                if let updatePreferredSettings = updatePreferredSettings { queryItems.append(URLQueryItem(name: "updatePreferredSettings", value: updatePreferredSettings ? "true" : "false")) } 
                if let showExactLocations = showExactLocations { queryItems.append(URLQueryItem(name: "showExactLocations", value: showExactLocations ? "true" : "false")) } 
                if let showConnectionToSearcher = showConnectionToSearcher { queryItems.append(URLQueryItem(name: "showConnectionToSearcher", value: showConnectionToSearcher ? "true" : "false")) } 
                if let flagCountMinimum = flagCountMinimum { queryItems.append(URLQueryItem(name: "flagCountMinimum", value: "\(flagCountMinimum)")) } 
                if let verifiedUserOnly = verifiedUserOnly { queryItems.append(URLQueryItem(name: "verifiedUserOnly", value: verifiedUserOnly ? "true" : "false")) } 
                if let contentAdminOnly = contentAdminOnly { queryItems.append(URLQueryItem(name: "contentAdminOnly", value: contentAdminOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserLocationSearchResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(UserLocationSearchResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Block Account
    /// - POST /api/{version}/account/block
    /// - Moves or removes an account into the user's blocked group.
    /// - parameter version: (path)  
    /// - parameter accountIdBeingBlocked: (query) The id of the account to be blocked/unblocked 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter blockFlagValue: (query) Determines whether the account is blocked or unblocked (optional, default to true)
    /// - parameter removeFromGroupsIfBlocked: (query) Determines whether the account is removed from all other groups if blocked (optional, default to false)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func blockAccount(version: Double, accountIdBeingBlocked: Int64, deviceId: String? = nil, accountId: Int64? = nil, blockFlagValue: Bool? = nil, removeFromGroupsIfBlocked: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/block"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "accountIdBeingBlocked", value: "\(accountIdBeingBlocked)"))
                if let blockFlagValue = blockFlagValue { queryItems.append(URLQueryItem(name: "blockFlagValue", value: blockFlagValue ? "true" : "false")) } 
                if let removeFromGroupsIfBlocked = removeFromGroupsIfBlocked { queryItems.append(URLQueryItem(name: "removeFromGroupsIfBlocked", value: removeFromGroupsIfBlocked ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Account
    /// - POST /api/{version}/account/create
    /// - Create a new account by role.
    /// - parameter version: (path)  
    /// - parameter username: (query) The access token to authenticate with (ex: username) 
    /// - parameter password: (query) The secret to authenticate with (ex: password) 
    /// - parameter name: (query) The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName (optional)
    /// - parameter prefixName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
    /// - parameter firstName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
    /// - parameter middleName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
    /// - parameter lastName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
    /// - parameter suffixName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
    /// - parameter title: (query) This field will be used to set the user&#39;s job title (optional)
    /// - parameter deviceId: (query) The unique id of the device making the request (optional)
    /// - parameter deviceIdType: (query) The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
    /// - parameter emailAddress: (query) The user&#39;s contact email address (NOT the username) (optional)
    /// - parameter assetId: (query) The asset id to set the user&#39;s profile image (optional)
    /// - parameter streetAddress: (query) The street address of the user&#39;s contact location (optional)
    /// - parameter zipcode: (query) The zipcode of the user&#39;s contact location (optional)
    /// - parameter gender: (query) The gender of the user (AudienceGender) (optional)
    /// - parameter birthday: (query) The birthday date of the user in UTC milliseconds (optional)
    /// - parameter homePhone: (query) The home phone number (optional)
    /// - parameter cellPhone: (query) The cellular phone number (optional)
    /// - parameter cellPhoneCarrier: (query) The cellular service provider (optional)
    /// - parameter businessPhone: (query) The business phone number (optional)
    /// - parameter role: (query) The account role (default: MEMBER) (optional)
    /// - parameter platforms: (query) Comma separated list of development platforms (optional)
    /// - parameter tags: (query) Search tags (optional)
    /// - parameter aboutUs: (query) About us information (optional)
    /// - parameter gameExperience: (query) Game experience of the user (optional)
    /// - parameter categoryIds: (query) A list of category ids that represent interests and associations (optional)
    /// - parameter hometown: (query) The user&#39;s hometown (optional)
    /// - parameter height: (query) The user&#39;s height (optional)
    /// - parameter heightIndex: (query) The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
    /// - parameter ethnicity: (query) The user&#39;s ethnicity (optional)
    /// - parameter bodyType: (query) The user&#39;s body type (optional)
    /// - parameter maritalStatus: (query) The user&#39;s marital status (optional)
    /// - parameter children: (query) The user&#39;s children status (optional)
    /// - parameter religion: (query) The user&#39;s religion (optional)
    /// - parameter education: (query) The user&#39;s education (optional)
    /// - parameter educationIndex: (query) The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
    /// - parameter smoke: (query) The user&#39;s smoke status (optional)
    /// - parameter drink: (query) The user&#39;s drink status (optional)
    /// - parameter companionship: (query) The user&#39;s companionship status (optional)
    /// - parameter companionshipIndex: (query) The user&#39;s companionship index (optional)
    /// - parameter preferredMinAge: (query) The preferred minimum age in the account location search (optional)
    /// - parameter preferredMaxAge: (query) The preferred maximum age in the account location search (optional)
    /// - parameter preferredMinHeight: (query) The preferred minimum height in the account location search (optional)
    /// - parameter preferredMaxHeight: (query) The preferred maximum height in the account location search (optional)
    /// - parameter preferredGender: (query) The preferred gender in the account location search (optional)
    /// - parameter preferredEducation: (query) The preferred education in the account location search (optional)
    /// - parameter preferredEducationIndex: (query) The preferred education in a numerical value that can be used for ordering/searching (optional)
    /// - parameter preferredBodyType: (query) The preferred body type in the account location search (optional)
    /// - parameter preferredEthnicity: (query) The preferred ethnicity in the account location search (optional)
    /// - parameter preferredLocation: (query) The preferred location in the account location search (optional)
    /// - parameter preferredLocationRange: (query) The preferred location range in the account location search (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - parameter acceptedTerms: (query) Accepted Terms (optional)
    /// - parameter inviteToken: (query) The inviteToken that the referrer used for this account to sign up (optional)
    /// - parameter referralAccountId: (query) The accountId of the referrer (used if there is no inviteToken) (optional)
    /// - parameter sendValidation: (query) Whether to send validation email (optional)
    /// - parameter gameType: (query) Deprecated: use appKey (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter appVersion: (query) The application version (optional)
    /// - parameter responseType: (query) Returns an AccountLoginResponse if \&quot;AccountLoginResponse\&quot; is passed in (optional)
    /// - parameter audienceIdsToAdd: (query) Comma separated list of audience ids to assign to the user (optional)
    /// - parameter appBlob: (query) Application blob data (optional)
    /// - parameter appEnablePush: (query) Enable push for the app (optional)
    /// - parameter appEnableSMS: (query) Enable SMS for the app (optional)
    /// - parameter appEnableEmail: (query) Enable email for the app (optional)
    /// - parameter locationVisibility: (query) Location visibility setting (optional)
    /// - parameter homeLatitude: (query) Home latitude (optional)
    /// - parameter homeLongitude: (query) Home longitude (optional)
    /// - parameter appNickname: (query) The nickname used in the application for this account (optional)
    /// - parameter personalAudienceId: (query) Personal audience id to associate with this account (optional)
    /// - returns: AnyPublisher<AccountLoginResponse, Error> 
    open func createAccount(version: Double, username: String, password: String, name: String? = nil, prefixName: String? = nil, firstName: String? = nil, middleName: String? = nil, lastName: String? = nil, suffixName: String? = nil, title: String? = nil, deviceId: String? = nil, deviceIdType: String? = nil, emailAddress: String? = nil, assetId: Int64? = nil, streetAddress: String? = nil, zipcode: String? = nil, gender: String? = nil, birthday: Int64? = nil, homePhone: String? = nil, cellPhone: String? = nil, cellPhoneCarrier: String? = nil, businessPhone: String? = nil, role: String? = nil, platforms: String? = nil, tags: String? = nil, aboutUs: String? = nil, gameExperience: String? = nil, categoryIds: String? = nil, hometown: String? = nil, height: String? = nil, heightIndex: Int? = nil, ethnicity: String? = nil, bodyType: String? = nil, maritalStatus: String? = nil, children: String? = nil, religion: String? = nil, education: String? = nil, educationIndex: Int? = nil, smoke: String? = nil, drink: String? = nil, companionship: String? = nil, companionshipIndex: Int? = nil, preferredMinAge: Int? = nil, preferredMaxAge: Int? = nil, preferredMinHeight: Int? = nil, preferredMaxHeight: Int? = nil, preferredGender: String? = nil, preferredEducation: String? = nil, preferredEducationIndex: Int? = nil, preferredBodyType: String? = nil, preferredEthnicity: String? = nil, preferredLocation: String? = nil, preferredLocationRange: Double? = nil, latitude: Double? = nil, longitude: Double? = nil, acceptedTerms: Bool? = nil, inviteToken: String? = nil, referralAccountId: Int64? = nil, sendValidation: Bool? = nil, gameType: String? = nil, appKey: String? = nil, appVersion: String? = nil, responseType: String? = nil, audienceIdsToAdd: String? = nil, appBlob: String? = nil, appEnablePush: Bool? = nil, appEnableSMS: Bool? = nil, appEnableEmail: Bool? = nil, locationVisibility: String? = nil, homeLatitude: Double? = nil, homeLongitude: Double? = nil, appNickname: String? = nil, personalAudienceId: Int64? = nil) -> AnyPublisher<AccountLoginResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let prefixName = prefixName { queryItems.append(URLQueryItem(name: "prefixName", value: prefixName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let middleName = middleName { queryItems.append(URLQueryItem(name: "middleName", value: middleName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let suffixName = suffixName { queryItems.append(URLQueryItem(name: "suffixName", value: suffixName)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let deviceIdType = deviceIdType { queryItems.append(URLQueryItem(name: "deviceIdType", value: deviceIdType)) } 
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let zipcode = zipcode { queryItems.append(URLQueryItem(name: "zipcode", value: zipcode)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let birthday = birthday { queryItems.append(URLQueryItem(name: "birthday", value: "\(birthday)")) } 
                if let homePhone = homePhone { queryItems.append(URLQueryItem(name: "homePhone", value: homePhone)) } 
                if let cellPhone = cellPhone { queryItems.append(URLQueryItem(name: "cellPhone", value: cellPhone)) } 
                if let cellPhoneCarrier = cellPhoneCarrier { queryItems.append(URLQueryItem(name: "cellPhoneCarrier", value: cellPhoneCarrier)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let platforms = platforms { queryItems.append(URLQueryItem(name: "platforms", value: platforms)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let aboutUs = aboutUs { queryItems.append(URLQueryItem(name: "aboutUs", value: aboutUs)) } 
                if let gameExperience = gameExperience { queryItems.append(URLQueryItem(name: "gameExperience", value: gameExperience)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let hometown = hometown { queryItems.append(URLQueryItem(name: "hometown", value: hometown)) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: height)) } 
                if let heightIndex = heightIndex { queryItems.append(URLQueryItem(name: "heightIndex", value: "\(heightIndex)")) } 
                if let ethnicity = ethnicity { queryItems.append(URLQueryItem(name: "ethnicity", value: ethnicity)) } 
                if let bodyType = bodyType { queryItems.append(URLQueryItem(name: "bodyType", value: bodyType)) } 
                if let maritalStatus = maritalStatus { queryItems.append(URLQueryItem(name: "maritalStatus", value: maritalStatus)) } 
                if let children = children { queryItems.append(URLQueryItem(name: "children", value: children)) } 
                if let religion = religion { queryItems.append(URLQueryItem(name: "religion", value: religion)) } 
                if let education = education { queryItems.append(URLQueryItem(name: "education", value: education)) } 
                if let educationIndex = educationIndex { queryItems.append(URLQueryItem(name: "educationIndex", value: "\(educationIndex)")) } 
                if let smoke = smoke { queryItems.append(URLQueryItem(name: "smoke", value: smoke)) } 
                if let drink = drink { queryItems.append(URLQueryItem(name: "drink", value: drink)) } 
                if let companionship = companionship { queryItems.append(URLQueryItem(name: "companionship", value: companionship)) } 
                if let companionshipIndex = companionshipIndex { queryItems.append(URLQueryItem(name: "companionshipIndex", value: "\(companionshipIndex)")) } 
                if let preferredMinAge = preferredMinAge { queryItems.append(URLQueryItem(name: "preferredMinAge", value: "\(preferredMinAge)")) } 
                if let preferredMaxAge = preferredMaxAge { queryItems.append(URLQueryItem(name: "preferredMaxAge", value: "\(preferredMaxAge)")) } 
                if let preferredMinHeight = preferredMinHeight { queryItems.append(URLQueryItem(name: "preferredMinHeight", value: "\(preferredMinHeight)")) } 
                if let preferredMaxHeight = preferredMaxHeight { queryItems.append(URLQueryItem(name: "preferredMaxHeight", value: "\(preferredMaxHeight)")) } 
                if let preferredGender = preferredGender { queryItems.append(URLQueryItem(name: "preferredGender", value: preferredGender)) } 
                if let preferredEducation = preferredEducation { queryItems.append(URLQueryItem(name: "preferredEducation", value: preferredEducation)) } 
                if let preferredEducationIndex = preferredEducationIndex { queryItems.append(URLQueryItem(name: "preferredEducationIndex", value: "\(preferredEducationIndex)")) } 
                if let preferredBodyType = preferredBodyType { queryItems.append(URLQueryItem(name: "preferredBodyType", value: preferredBodyType)) } 
                if let preferredEthnicity = preferredEthnicity { queryItems.append(URLQueryItem(name: "preferredEthnicity", value: preferredEthnicity)) } 
                if let preferredLocation = preferredLocation { queryItems.append(URLQueryItem(name: "preferredLocation", value: preferredLocation)) } 
                if let preferredLocationRange = preferredLocationRange { queryItems.append(URLQueryItem(name: "preferredLocationRange", value: "\(preferredLocationRange)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let acceptedTerms = acceptedTerms { queryItems.append(URLQueryItem(name: "acceptedTerms", value: acceptedTerms ? "true" : "false")) } 
                if let inviteToken = inviteToken { queryItems.append(URLQueryItem(name: "inviteToken", value: inviteToken)) } 
                if let referralAccountId = referralAccountId { queryItems.append(URLQueryItem(name: "referralAccountId", value: "\(referralAccountId)")) } 
                if let sendValidation = sendValidation { queryItems.append(URLQueryItem(name: "sendValidation", value: sendValidation ? "true" : "false")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let responseType = responseType { queryItems.append(URLQueryItem(name: "responseType", value: responseType)) } 
                if let audienceIdsToAdd = audienceIdsToAdd { queryItems.append(URLQueryItem(name: "audienceIdsToAdd", value: audienceIdsToAdd)) } 
                if let appBlob = appBlob { queryItems.append(URLQueryItem(name: "appBlob", value: appBlob)) } 
                if let appEnablePush = appEnablePush { queryItems.append(URLQueryItem(name: "appEnablePush", value: appEnablePush ? "true" : "false")) } 
                if let appEnableSMS = appEnableSMS { queryItems.append(URLQueryItem(name: "appEnableSMS", value: appEnableSMS ? "true" : "false")) } 
                if let appEnableEmail = appEnableEmail { queryItems.append(URLQueryItem(name: "appEnableEmail", value: appEnableEmail ? "true" : "false")) } 
                if let locationVisibility = locationVisibility { queryItems.append(URLQueryItem(name: "locationVisibility", value: locationVisibility)) } 
                if let homeLatitude = homeLatitude { queryItems.append(URLQueryItem(name: "homeLatitude", value: "\(homeLatitude)")) } 
                if let homeLongitude = homeLongitude { queryItems.append(URLQueryItem(name: "homeLongitude", value: "\(homeLongitude)")) } 
                if let appNickname = appNickname { queryItems.append(URLQueryItem(name: "appNickname", value: appNickname)) } 
                if let personalAudienceId = personalAudienceId { queryItems.append(URLQueryItem(name: "personalAudienceId", value: "\(personalAudienceId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AccountLoginResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AccountLoginResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Account
    /// - POST /api/{version}/account/profile/update
    /// - Edit the user's profile information
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionAccountId: (query) The account id used to edit another person&#39;s account (optional)
    /// - parameter role: (query) The account role to change to (optional)
    /// - parameter assetId: (query) The asset id to set the user&#39;s profile image (optional)
    /// - parameter name: (query) The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
    /// - parameter prefixName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
    /// - parameter firstName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
    /// - parameter middleName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
    /// - parameter lastName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
    /// - parameter suffixName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
    /// - parameter title: (query) This field will be used to set the user&#39;s job title (optional)
    /// - parameter gender: (query) The gender of the user AudienceGender (optional)
    /// - parameter age: (query) This is deperecated, use the birthday parameter (optional)
    /// - parameter birthday: (query) The birthday date of the user in UTC milliseconds (optional)
    /// - parameter homePhone: (query) The home phone number (optional)
    /// - parameter cellPhone: (query) The cellular phone number (optional)
    /// - parameter cellPhoneCarrier: (query) The cellular service provider (optional)
    /// - parameter businessPhone: (query) The business phone number (optional)
    /// - parameter emailAddress: (query) The user&#39;s contact email address (NOT the username) (optional)
    /// - parameter streetAddress: (query) The street address of the user&#39;s contact location (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the user&#39;s contact location (optional)
    /// - parameter state: (query) The state of the user&#39;s contact location (optional)
    /// - parameter zipcode: (query) The zipcode of the user&#39;s contact location (optional)
    /// - parameter country: (query) The country of the user&#39;s contact location (optional)
    /// - parameter makeProfileInfoPublic: (query) Allow anyone to view the user&#39;s personal profile (optional)
    /// - parameter makeGameInfoPublic: (query) Allow anyone to view the user&#39;s game/app info (optional)
    /// - parameter makeFriendsInfoPublic: (query) Allow anyone to view the user&#39;s friends list (optional)
    /// - parameter hometown: (query) The user&#39;s hometown (optional)
    /// - parameter height: (query) The user&#39;s height (optional)
    /// - parameter heightIndex: (query) The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
    /// - parameter ethnicity: (query) The user&#39;s ethnicity (optional)
    /// - parameter bodyType: (query) The user&#39;s body type (optional)
    /// - parameter maritalStatus: (query) The user&#39;s marital status (optional)
    /// - parameter children: (query) The user&#39;s children status (optional)
    /// - parameter religion: (query) The user&#39;s religion (optional)
    /// - parameter education: (query) The user&#39;s education (optional)
    /// - parameter educationIndex: (query) The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
    /// - parameter smoke: (query) The user&#39;s smoke status (optional)
    /// - parameter drink: (query) The user&#39;s drink status (optional)
    /// - parameter companionship: (query) The user&#39;s companionship status (optional)
    /// - parameter companionshipIndex: (query) The user&#39;s companionship index (optional)
    /// - parameter preferredMinAge: (query) The preferred minimum age in the account location search (optional)
    /// - parameter preferredMaxAge: (query) The preferred maximum age in the account location search (optional)
    /// - parameter preferredMinHeight: (query) The preferred minimum height in the account location search (optional)
    /// - parameter preferredMaxHeight: (query) The preferred maximum height in the account location search (optional)
    /// - parameter preferredGender: (query) The preferred gender in the account location search (optional)
    /// - parameter preferredEducation: (query) The preferred education in the account location search (optional)
    /// - parameter preferredEducationIndex: (query) The preferred education in a numerical value that can be used for ordering/searching (optional)
    /// - parameter preferredBodyType: (query) The preferred body type in the account location search (optional)
    /// - parameter preferredEthnicity: (query) The preferred ethnicity in the account location search (optional)
    /// - parameter preferredLocation: (query) The preferred education in the account location search (optional)
    /// - parameter preferredLocationRange: (query) The preferred location range in the account location search (optional)
    /// - parameter platforms: (query) Platforms (optional)
    /// - parameter tags: (query) Tags (optional)
    /// - parameter aboutUs: (query) About Us (optional)
    /// - parameter matchToken: (query) Match Token (optional)
    /// - parameter gameExperience: (query) Game Experience (optional)
    /// - parameter categories: (query) Deprecated use categoryIds (optional)
    /// - parameter categoryIds: (query) A list of category ids that represent interests and associations (optional)
    /// - parameter responseFilters: (query) A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE,PROFILE_CONTACT")
    /// - parameter showAsZipcode: (query) The user&#39;s preference if they want to be shown by zipcode on a map (optional)
    /// - parameter showExactLocation: (query) The user&#39;s preference if they want to be shown by their exact location on a map (optional)
    /// - parameter showOthersExactLocation: (query) The user&#39;s preference if they want to see others exact location on a map (optional)
    /// - parameter acceptedTerms: (query) Accepted Terms (optional)
    /// - parameter locationVisibility: (query) Location Visibility (optional)
    /// - parameter appBlob: (query) App Blob (optional)
    /// - parameter appEnablePush: (query) App Enable Push (optional)
    /// - parameter appEnableSMS: (query) App Enable SMS (optional)
    /// - parameter appEnableEmail: (query) App Enable Email (optional)
    /// - parameter gameType: (query) Game Type (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - parameter returnProfile: (query) Return Profile (optional)
    /// - parameter audienceIdsToAdd: (query) Audience Ids to add (optional)
    /// - parameter audienceIdsToRemove: (query) Audience Ids to remove (optional)
    /// - parameter referralAccountId: (query) The account id of the referrer (optional)
    /// - parameter appNickname: (query) App nickname (optional)
    /// - parameter personalAudienceId: (query) Personal Audience (optional)
    /// - parameter nonGuestUsername: (query) The user&#39;s username to update with if they currently have a guest username (optional)
    /// - returns: AnyPublisher<ProfileInfoResponse, Error> 
    open func editAccount(version: Double, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountId: Int64? = nil, role: String? = nil, assetId: Int64? = nil, name: String? = nil, prefixName: String? = nil, firstName: String? = nil, middleName: String? = nil, lastName: String? = nil, suffixName: String? = nil, title: String? = nil, gender: String? = nil, age: Int? = nil, birthday: Int64? = nil, homePhone: String? = nil, cellPhone: String? = nil, cellPhoneCarrier: String? = nil, businessPhone: String? = nil, emailAddress: String? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, zipcode: String? = nil, country: String? = nil, makeProfileInfoPublic: Bool? = nil, makeGameInfoPublic: Bool? = nil, makeFriendsInfoPublic: Bool? = nil, hometown: String? = nil, height: String? = nil, heightIndex: Int? = nil, ethnicity: String? = nil, bodyType: String? = nil, maritalStatus: String? = nil, children: String? = nil, religion: String? = nil, education: String? = nil, educationIndex: Int? = nil, smoke: String? = nil, drink: String? = nil, companionship: String? = nil, companionshipIndex: Int? = nil, preferredMinAge: Int? = nil, preferredMaxAge: Int? = nil, preferredMinHeight: Int? = nil, preferredMaxHeight: Int? = nil, preferredGender: String? = nil, preferredEducation: String? = nil, preferredEducationIndex: Int? = nil, preferredBodyType: String? = nil, preferredEthnicity: String? = nil, preferredLocation: String? = nil, preferredLocationRange: Double? = nil, platforms: String? = nil, tags: String? = nil, aboutUs: String? = nil, matchToken: String? = nil, gameExperience: String? = nil, categories: String? = nil, categoryIds: String? = nil, responseFilters: String? = nil, showAsZipcode: Bool? = nil, showExactLocation: Bool? = nil, showOthersExactLocation: Bool? = nil, acceptedTerms: Bool? = nil, locationVisibility: String? = nil, appBlob: String? = nil, appEnablePush: Bool? = nil, appEnableSMS: Bool? = nil, appEnableEmail: Bool? = nil, gameType: String? = nil, appKey: String? = nil, latitude: Double? = nil, longitude: Double? = nil, returnProfile: Bool? = nil, audienceIdsToAdd: String? = nil, audienceIdsToRemove: String? = nil, referralAccountId: Int64? = nil, appNickname: String? = nil, personalAudienceId: Int64? = nil, nonGuestUsername: String? = nil) -> AnyPublisher<ProfileInfoResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/profile/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let prefixName = prefixName { queryItems.append(URLQueryItem(name: "prefixName", value: prefixName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let middleName = middleName { queryItems.append(URLQueryItem(name: "middleName", value: middleName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let suffixName = suffixName { queryItems.append(URLQueryItem(name: "suffixName", value: suffixName)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let age = age { queryItems.append(URLQueryItem(name: "age", value: "\(age)")) } 
                if let birthday = birthday { queryItems.append(URLQueryItem(name: "birthday", value: "\(birthday)")) } 
                if let homePhone = homePhone { queryItems.append(URLQueryItem(name: "homePhone", value: homePhone)) } 
                if let cellPhone = cellPhone { queryItems.append(URLQueryItem(name: "cellPhone", value: cellPhone)) } 
                if let cellPhoneCarrier = cellPhoneCarrier { queryItems.append(URLQueryItem(name: "cellPhoneCarrier", value: cellPhoneCarrier)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let zipcode = zipcode { queryItems.append(URLQueryItem(name: "zipcode", value: zipcode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let makeProfileInfoPublic = makeProfileInfoPublic { queryItems.append(URLQueryItem(name: "makeProfileInfoPublic", value: makeProfileInfoPublic ? "true" : "false")) } 
                if let makeGameInfoPublic = makeGameInfoPublic { queryItems.append(URLQueryItem(name: "makeGameInfoPublic", value: makeGameInfoPublic ? "true" : "false")) } 
                if let makeFriendsInfoPublic = makeFriendsInfoPublic { queryItems.append(URLQueryItem(name: "makeFriendsInfoPublic", value: makeFriendsInfoPublic ? "true" : "false")) } 
                if let hometown = hometown { queryItems.append(URLQueryItem(name: "hometown", value: hometown)) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: height)) } 
                if let heightIndex = heightIndex { queryItems.append(URLQueryItem(name: "heightIndex", value: "\(heightIndex)")) } 
                if let ethnicity = ethnicity { queryItems.append(URLQueryItem(name: "ethnicity", value: ethnicity)) } 
                if let bodyType = bodyType { queryItems.append(URLQueryItem(name: "bodyType", value: bodyType)) } 
                if let maritalStatus = maritalStatus { queryItems.append(URLQueryItem(name: "maritalStatus", value: maritalStatus)) } 
                if let children = children { queryItems.append(URLQueryItem(name: "children", value: children)) } 
                if let religion = religion { queryItems.append(URLQueryItem(name: "religion", value: religion)) } 
                if let education = education { queryItems.append(URLQueryItem(name: "education", value: education)) } 
                if let educationIndex = educationIndex { queryItems.append(URLQueryItem(name: "educationIndex", value: "\(educationIndex)")) } 
                if let smoke = smoke { queryItems.append(URLQueryItem(name: "smoke", value: smoke)) } 
                if let drink = drink { queryItems.append(URLQueryItem(name: "drink", value: drink)) } 
                if let companionship = companionship { queryItems.append(URLQueryItem(name: "companionship", value: companionship)) } 
                if let companionshipIndex = companionshipIndex { queryItems.append(URLQueryItem(name: "companionshipIndex", value: "\(companionshipIndex)")) } 
                if let preferredMinAge = preferredMinAge { queryItems.append(URLQueryItem(name: "preferredMinAge", value: "\(preferredMinAge)")) } 
                if let preferredMaxAge = preferredMaxAge { queryItems.append(URLQueryItem(name: "preferredMaxAge", value: "\(preferredMaxAge)")) } 
                if let preferredMinHeight = preferredMinHeight { queryItems.append(URLQueryItem(name: "preferredMinHeight", value: "\(preferredMinHeight)")) } 
                if let preferredMaxHeight = preferredMaxHeight { queryItems.append(URLQueryItem(name: "preferredMaxHeight", value: "\(preferredMaxHeight)")) } 
                if let preferredGender = preferredGender { queryItems.append(URLQueryItem(name: "preferredGender", value: preferredGender)) } 
                if let preferredEducation = preferredEducation { queryItems.append(URLQueryItem(name: "preferredEducation", value: preferredEducation)) } 
                if let preferredEducationIndex = preferredEducationIndex { queryItems.append(URLQueryItem(name: "preferredEducationIndex", value: "\(preferredEducationIndex)")) } 
                if let preferredBodyType = preferredBodyType { queryItems.append(URLQueryItem(name: "preferredBodyType", value: preferredBodyType)) } 
                if let preferredEthnicity = preferredEthnicity { queryItems.append(URLQueryItem(name: "preferredEthnicity", value: preferredEthnicity)) } 
                if let preferredLocation = preferredLocation { queryItems.append(URLQueryItem(name: "preferredLocation", value: preferredLocation)) } 
                if let preferredLocationRange = preferredLocationRange { queryItems.append(URLQueryItem(name: "preferredLocationRange", value: "\(preferredLocationRange)")) } 
                if let platforms = platforms { queryItems.append(URLQueryItem(name: "platforms", value: platforms)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let aboutUs = aboutUs { queryItems.append(URLQueryItem(name: "aboutUs", value: aboutUs)) } 
                if let matchToken = matchToken { queryItems.append(URLQueryItem(name: "matchToken", value: matchToken)) } 
                if let gameExperience = gameExperience { queryItems.append(URLQueryItem(name: "gameExperience", value: gameExperience)) } 
                if let categories = categories { queryItems.append(URLQueryItem(name: "categories", value: categories)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let showAsZipcode = showAsZipcode { queryItems.append(URLQueryItem(name: "showAsZipcode", value: showAsZipcode ? "true" : "false")) } 
                if let showExactLocation = showExactLocation { queryItems.append(URLQueryItem(name: "showExactLocation", value: showExactLocation ? "true" : "false")) } 
                if let showOthersExactLocation = showOthersExactLocation { queryItems.append(URLQueryItem(name: "showOthersExactLocation", value: showOthersExactLocation ? "true" : "false")) } 
                if let acceptedTerms = acceptedTerms { queryItems.append(URLQueryItem(name: "acceptedTerms", value: acceptedTerms ? "true" : "false")) } 
                if let locationVisibility = locationVisibility { queryItems.append(URLQueryItem(name: "locationVisibility", value: locationVisibility)) } 
                if let appBlob = appBlob { queryItems.append(URLQueryItem(name: "appBlob", value: appBlob)) } 
                if let appEnablePush = appEnablePush { queryItems.append(URLQueryItem(name: "appEnablePush", value: appEnablePush ? "true" : "false")) } 
                if let appEnableSMS = appEnableSMS { queryItems.append(URLQueryItem(name: "appEnableSMS", value: appEnableSMS ? "true" : "false")) } 
                if let appEnableEmail = appEnableEmail { queryItems.append(URLQueryItem(name: "appEnableEmail", value: appEnableEmail ? "true" : "false")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let returnProfile = returnProfile { queryItems.append(URLQueryItem(name: "returnProfile", value: returnProfile ? "true" : "false")) } 
                if let audienceIdsToAdd = audienceIdsToAdd { queryItems.append(URLQueryItem(name: "audienceIdsToAdd", value: audienceIdsToAdd)) } 
                if let audienceIdsToRemove = audienceIdsToRemove { queryItems.append(URLQueryItem(name: "audienceIdsToRemove", value: audienceIdsToRemove)) } 
                if let referralAccountId = referralAccountId { queryItems.append(URLQueryItem(name: "referralAccountId", value: "\(referralAccountId)")) } 
                if let appNickname = appNickname { queryItems.append(URLQueryItem(name: "appNickname", value: appNickname)) } 
                if let personalAudienceId = personalAudienceId { queryItems.append(URLQueryItem(name: "personalAudienceId", value: "\(personalAudienceId)")) } 
                if let nonGuestUsername = nonGuestUsername { queryItems.append(URLQueryItem(name: "nonGuestUsername", value: nonGuestUsername)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileInfoResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileInfoResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Username and Email
    /// - POST /api/{version}/account/username/update
    /// - Update account's own username and/or emailAddress
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter emailAddress: (query) the user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
    /// - parameter username: (query) the user&#39;s username to update with if they currently have a guest username (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func editUsername(version: Double, deviceId: String? = nil, accountId: Int64? = nil, emailAddress: String? = nil, username: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/username/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let username = username { queryItems.append(URLQueryItem(name: "username", value: username)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Account
    /// - GET /api/{version}/account/profile/get
    /// - Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) Return Nulls (optional, default to false)
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionAccountEmail: (query) Connection Account Email (optional)
    /// - parameter connectionAccountId: (query) The account id used to view another person&#39;s account (optional, default to 0)
    /// - parameter responseFilters: (query) A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
    /// - parameter gameType: (query) Game Type (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter purchaseType: (query) Purchase Type (optional, default to "SIRQUL")
    /// - parameter updateViewedDate: (query) Determines whether to track if a person has viewed someone&#39;s profile (optional, default to false)
    /// - parameter latitude: (query) Latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) Longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func getAccount(version: Double, returnNulls: Bool? = nil, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountEmail: String? = nil, connectionAccountId: Int64? = nil, responseFilters: String? = nil, gameType: String? = nil, appKey: String? = nil, purchaseType: String? = nil, updateViewedDate: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/profile/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let returnNulls = returnNulls { queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountEmail = connectionAccountEmail { queryItems.append(URLQueryItem(name: "connectionAccountEmail", value: connectionAccountEmail)) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                if let updateViewedDate = updateViewedDate { queryItems.append(URLQueryItem(name: "updateViewedDate", value: updateViewedDate ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Profile Assets
    /// - GET /api/{version}/account/profile/assets
    /// - Get a list of assets a person has ever uploaded. Filters the list based on parameters.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) Determines whether to return null fields in the response (optional, default to false)
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter ownerId: (query) The account id of the person the user wants to view (optional)
    /// - parameter mediaTypes: (query) Comma separated list of MediaType (optional)
    /// - parameter mimeTypes: (query) Comma separated list of mime types (optional)
    /// - parameter sortField: (query) Determines what the returning list will be sorted by (see AssetApiMap) (optional, default to "CREATED")
    /// - parameter descending: (query) Determines whether to return the resulting list in descending or ascending order (optional, default to true)
    /// - parameter latitude: (query) Latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) Longitude used to update the user&#39;s current location (optional)
    /// - parameter i: (query) _i (optional)
    /// - parameter start: (query) Start of the pagination (optional, default to 0)
    /// - parameter l: (query) _l (optional)
    /// - parameter limit: (query) Limit of the pagination (optional, default to 0)
    /// - returns: AnyPublisher<AssetListResponse, Error> 
    open func getProfileAssets(version: Double, returnNulls: Bool? = nil, deviceId: String? = nil, accountId: Int64? = nil, ownerId: Int64? = nil, mediaTypes: String? = nil, mimeTypes: String? = nil, sortField: String? = nil, descending: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil) -> AnyPublisher<AssetListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/profile/assets"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let returnNulls = returnNulls { queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let ownerId = ownerId { queryItems.append(URLQueryItem(name: "ownerId", value: "\(ownerId)")) } 
                if let mediaTypes = mediaTypes { queryItems.append(URLQueryItem(name: "mediaTypes", value: mediaTypes)) } 
                if let mimeTypes = mimeTypes { queryItems.append(URLQueryItem(name: "mimeTypes", value: mimeTypes)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssetListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssetListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Accounts
    /// - GET /api/{version}/account/referral/list
    /// - Gets a user's account profile and their referral List.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter retrieveType: (query) one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it&#39;s parents, recursively - GET_ALL will get all of the above (optional)
    /// - parameter levelLimit: (query) level limit for children and ancestors of current account, starts from current account (optional)
    /// - parameter ancestorLevelLimit: (query) level limit for ancestors, will override levelLimit if this is set (optional)
    /// - parameter childrenLevelLimit: (query) level limit for children, will override levelLimit if this is set (optional)
    /// - parameter ancestorListStart: (query) pagination start for children list (optional)
    /// - parameter ancestorListLimit: (query) pagination limit for children list (optional)
    /// - parameter childrenListStart: (query) pagination start for children list (optional)
    /// - parameter childrenListLimit: (query) pagination limit for children list (optional)
    /// - parameter childrenChildren: (query) if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item (optional, default to true)
    /// - returns: AnyPublisher<Void, Error> 
    open func getReferralList(version: Double, accountId: Int64? = nil, appKey: String? = nil, retrieveType: String? = nil, levelLimit: Double? = nil, ancestorLevelLimit: Double? = nil, childrenLevelLimit: Double? = nil, ancestorListStart: Double? = nil, ancestorListLimit: Double? = nil, childrenListStart: Double? = nil, childrenListLimit: Double? = nil, childrenChildren: Bool? = nil) -> AnyPublisher<Void, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/referral/list"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let retrieveType = retrieveType { queryItems.append(URLQueryItem(name: "retrieveType", value: retrieveType)) } 
                if let levelLimit = levelLimit { queryItems.append(URLQueryItem(name: "levelLimit", value: "\(levelLimit)")) } 
                if let ancestorLevelLimit = ancestorLevelLimit { queryItems.append(URLQueryItem(name: "ancestorLevelLimit", value: "\(ancestorLevelLimit)")) } 
                if let childrenLevelLimit = childrenLevelLimit { queryItems.append(URLQueryItem(name: "childrenLevelLimit", value: "\(childrenLevelLimit)")) } 
                if let ancestorListStart = ancestorListStart { queryItems.append(URLQueryItem(name: "ancestorListStart", value: "\(ancestorListStart)")) } 
                if let ancestorListLimit = ancestorListLimit { queryItems.append(URLQueryItem(name: "ancestorListLimit", value: "\(ancestorListLimit)")) } 
                if let childrenListStart = childrenListStart { queryItems.append(URLQueryItem(name: "childrenListStart", value: "\(childrenListStart)")) } 
                if let childrenListLimit = childrenListLimit { queryItems.append(URLQueryItem(name: "childrenListLimit", value: "\(childrenListLimit)")) } 
                if let childrenChildren = childrenChildren { queryItems.append(URLQueryItem(name: "childrenChildren", value: childrenChildren ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<Void, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    return ()
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Account Settings
    /// - GET /api/{version}/account/settings/get
    /// - Get the account settings for a user
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<UserSettingsResponse, Error> 
    open func getSettings(version: Double, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<UserSettingsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/settings/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSettingsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(UserSettingsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Login as Account
    /// - POST /api/{version}/account/login/delegate
    /// - A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.
    /// - parameter version: (path)  
    /// - parameter accessToken: (query)  
    /// - parameter appKey: (query)  
    /// - parameter deviceId: (query)  (optional)
    /// - parameter accessTokenSecret: (query)  (optional)
    /// - parameter delegatedAccountId: (query)  (optional)
    /// - parameter delegatedUsername: (query)  (optional)
    /// - parameter networkUID: (query) The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE (optional, default to "USERNAME")
    /// - parameter ageRestriction: (query) Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
    /// - parameter responseFilters: (query) This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
    /// - parameter latitude: (query)  (optional)
    /// - parameter longitude: (query)  (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func loginDelegate(version: Double, accessToken: String, appKey: String, deviceId: String? = nil, accessTokenSecret: String? = nil, delegatedAccountId: Int64? = nil, delegatedUsername: String? = nil, networkUID: String? = nil, ageRestriction: Int? = nil, responseFilters: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/login/delegate"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                queryItems.append(URLQueryItem(name: "accessToken", value: accessToken))
                if let accessTokenSecret = accessTokenSecret { queryItems.append(URLQueryItem(name: "accessTokenSecret", value: accessTokenSecret)) } 
                if let delegatedAccountId = delegatedAccountId { queryItems.append(URLQueryItem(name: "delegatedAccountId", value: "\(delegatedAccountId)")) } 
                if let delegatedUsername = delegatedUsername { queryItems.append(URLQueryItem(name: "delegatedUsername", value: delegatedUsername)) } 
                if let networkUID = networkUID { queryItems.append(URLQueryItem(name: "networkUID", value: networkUID)) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let ageRestriction = ageRestriction { queryItems.append(URLQueryItem(name: "ageRestriction", value: "\(ageRestriction)")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Login Account
    /// - POST /api/{version}/account/login
    /// - General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}
    /// - parameter version: (path)  
    /// - parameter accessToken: (query) The access token to authenticate with (ex: username or fb token) 
    /// - parameter networkUID: (query) The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  
    /// - parameter appKey: (query) The application key 
    /// - parameter deviceId: (query) The unique id of the device making the request (optional)
    /// - parameter deviceIdType: (query) The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc (optional)
    /// - parameter accessTokenSecret: (query) The secret to authenticate with (ex: password) (optional)
    /// - parameter ageRestriction: (query) Checks user&#39;s birthday to see if they meet an age requirement. If the user is under age, an error message is returned. (optional, default to 0)
    /// - parameter responseFilters: (query) This determines how much of the profile should be returned, see ProfileFilters (optional, default to "PROFILE")
    /// - parameter latitude: (query) Used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) Used to update the user&#39;s current location (optional)
    /// - parameter emailMatch: (query) Option to check for email if username doesn&#39;t match, also support multiple accounts (optional, default to false)
    /// - parameter chosenAccountId: (query) Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request (optional, default to 0)
    /// - parameter thirdPartyCredentialId: (query) Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object (optional, default to 0)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func loginGeneral(version: Double, accessToken: String, networkUID: String, appKey: String, deviceId: String? = nil, deviceIdType: String? = nil, accessTokenSecret: String? = nil, ageRestriction: Int? = nil, responseFilters: String? = nil, latitude: Double? = nil, longitude: Double? = nil, emailMatch: Bool? = nil, chosenAccountId: Int64? = nil, thirdPartyCredentialId: Int64? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/login"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let deviceIdType = deviceIdType { queryItems.append(URLQueryItem(name: "deviceIdType", value: deviceIdType)) } 
                queryItems.append(URLQueryItem(name: "accessToken", value: accessToken))
                if let accessTokenSecret = accessTokenSecret { queryItems.append(URLQueryItem(name: "accessTokenSecret", value: accessTokenSecret)) } 
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let ageRestriction = ageRestriction { queryItems.append(URLQueryItem(name: "ageRestriction", value: "\(ageRestriction)")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let emailMatch = emailMatch { queryItems.append(URLQueryItem(name: "emailMatch", value: emailMatch ? "true" : "false")) } 
                if let chosenAccountId = chosenAccountId { queryItems.append(URLQueryItem(name: "chosenAccountId", value: "\(chosenAccountId)")) } 
                if let thirdPartyCredentialId = thirdPartyCredentialId { queryItems.append(URLQueryItem(name: "thirdPartyCredentialId", value: "\(thirdPartyCredentialId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Login Account (Username)
    /// - POST /api/{version}/account/get
    /// - Login to system with an account
    /// - parameter version: (path)  
    /// - parameter username: (query) the user&#39;s email address they used to sign-up 
    /// - parameter password: (query) the password 
    /// - parameter deviceId: (query) the device id (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - parameter app: (query) the app (optional)
    /// - parameter gameType: (query) This parameter is deprecated. This is deprecated, use appKey. (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter returnProfile: (query) the profile to return (optional)
    /// - parameter responseFilters: (query) a comma separated list of ProfileFilters for filtering the returned response data (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func loginUsername(version: Double, username: String, password: String, deviceId: String? = nil, latitude: Double? = nil, longitude: Double? = nil, app: String? = nil, gameType: String? = nil, appKey: String? = nil, returnProfile: Bool? = nil, responseFilters: String? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let app = app { queryItems.append(URLQueryItem(name: "app", value: app)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let returnProfile = returnProfile { queryItems.append(URLQueryItem(name: "returnProfile", value: returnProfile ? "true" : "false")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Logout Account
    /// - POST /api/{version}/account/logout
    /// - Cleans up the users data for logging out.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter deviceIdType: (query) Device Id Type (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func logout(version: Double, deviceId: String? = nil, deviceIdType: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/logout"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let deviceIdType = deviceIdType { queryItems.append(URLQueryItem(name: "deviceIdType", value: deviceIdType)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Merge Account
    /// - POST /api/{version}/account/merge
    /// - Merges the analytics, achievements, leaderboards of two accounts.
    /// - parameter version: (path)  
    /// - parameter mergeAccountId: (query) The id of the account to being merged 
    /// - parameter appKey: (query) The application key 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func mergeAccount(version: Double, mergeAccountId: Int64, appKey: String, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/merge"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "mergeAccountId", value: "\(mergeAccountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Password
    /// - POST /api/{version}/account/passwordchange
    /// - Update the account password.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account to update 
    /// - parameter oldPassword: (query) The current password, used to validate access 
    /// - parameter newPassword: (query) The new password to set, cannot be empty 
    /// - parameter confirmPassword: (query) The new password to confirm, must match newPassword 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func passwordChange(version: Double, accountId: Int64, oldPassword: String, newPassword: String, confirmPassword: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/passwordchange"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "oldPassword", value: oldPassword))
                queryItems.append(URLQueryItem(name: "newPassword", value: newPassword))
                queryItems.append(URLQueryItem(name: "confirmPassword", value: confirmPassword))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Reset Password
    /// - POST /api/{version}/account/passwordreset
    /// - Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.
    /// - parameter version: (path)  
    /// - parameter token: (query) The token associated with the account to update, good for 24 hours 
    /// - parameter password: (query) The new password to set, cannot be empty 
    /// - parameter confirm: (query) The new password to confirm, must match newPassword 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func passwordReset(version: Double, token: String, password: String, confirm: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/passwordreset"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "token", value: token))
                queryItems.append(URLQueryItem(name: "password", value: password))
                queryItems.append(URLQueryItem(name: "confirm", value: confirm))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Request Password Reset
    /// - POST /api/{version}/account/requestpasswordreset
    /// - Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.
    /// - parameter version: (path)  
    /// - parameter email: (query) The email/username of the account 
    /// - parameter from: (query) this is the sender email (optional, default to "Sirqul")
    /// - parameter domain: (query) this is the domain (like dev.sirqul.com) used to generate the password reset link (optional)
    /// - parameter subUrl: (query) this is the the subUrl (like resetpassword) used to generate a password reset link (optional)
    /// - parameter referer: (query) this is used to generate a password reset link (optional, default to "http://dev.sirqul.com/resetpassword")
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func requestPasswordReset(version: Double, email: String, from: String? = nil, domain: String? = nil, subUrl: String? = nil, referer: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/requestpasswordreset"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "email", value: email))
                if let from = from { queryItems.append(URLQueryItem(name: "from", value: from)) } 
                if let domain = domain { queryItems.append(URLQueryItem(name: "domain", value: domain)) } 
                if let subUrl = subUrl { queryItems.append(URLQueryItem(name: "subUrl", value: subUrl)) } 
                if let referer = referer { queryItems.append(URLQueryItem(name: "referer", value: referer)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Send Validation Request
    /// - POST /api/{version}/account/requestValidateAccount
    /// - Send an email to validate a user's account.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func requestValidateAccount(version: Double, accountId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/requestValidateAccount"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter gender
    ///
    public enum SearchAccountsGender: String, Codable, CaseIterable {
        case male = "MALE"
        case female = "FEMALE"
        case any = "ANY"
    }
    ///
    /// Enum for parameter gameExperience
    ///
    public enum SearchAccountsGameExperience: String, Codable, CaseIterable {
        case any = "ANY"
        case new = "NEW"
        case beginner = "BEGINNER"
        case intermediate = "INTERMEDIATE"
        case expert = "EXPERT"
    }

    /// Search Accounts
    /// - GET /api/{version}/account/profile/search
    /// - Search for account profiles.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The id of the account requesting 
    /// - parameter appKey: (query) The application key 
    /// - parameter keyword: (query) The keyword for for querying the account (optional)
    /// - parameter latitude: (query) the latitude (optional)
    /// - parameter longitude: (query) the longitude (optional)
    /// - parameter radius: (query) the radius (optional, default to 5)
    /// - parameter gender: (query) the user&#39;s gender (optional)
    /// - parameter gameExperience: (query) the user&#39;s Game Experience (optional)
    /// - parameter age: (query) the user&#39;s age (optional)
    /// - parameter categoryIds: (query) the user&#39;s Category Ids (optional)
    /// - parameter returnNulls: (query) Return Nulls (optional, default to true)
    /// - parameter responseFilters: (query) A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
    /// - parameter purchaseType: (query) A comma separated list of PurchaseType (optional, default to "SIRQUL")
    /// - parameter sortField: (query) The field to sort by (optional, default to "id")
    /// - parameter descending: (query) The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
    /// - parameter start: (query) The index into the record set to start with. (optional, default to 0)
    /// - parameter limit: (query) The total number of record to return. (optional, default to 20)
    /// - parameter activeOnly: (query) Determines whether to return only active results. Default is false. (optional, default to false)
    /// - returns: AnyPublisher<[ProfileResponse], Error> 
    open func searchAccounts(version: Double, accountId: Int64, appKey: String, keyword: String? = nil, latitude: Double? = nil, longitude: Double? = nil, radius: Double? = nil, gender: SearchAccountsGender? = nil, gameExperience: SearchAccountsGameExperience? = nil, age: Int? = nil, categoryIds: String? = nil, returnNulls: Bool? = nil, responseFilters: String? = nil, purchaseType: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil) -> AnyPublisher<[ProfileResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/profile/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let radius = radius { queryItems.append(URLQueryItem(name: "radius", value: "\(radius)")) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender.rawValue)) } 
                if let gameExperience = gameExperience { queryItems.append(URLQueryItem(name: "gameExperience", value: gameExperience.rawValue)) } 
                if let age = age { queryItems.append(URLQueryItem(name: "age", value: "\(age)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let returnNulls = returnNulls { queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ProfileResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ProfileResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Login Account (Encrypted Username)
    /// - POST /api/{version}/account/login/validate
    /// - ogin with encrypted user-name and password.
    /// - parameter version: (path)  
    /// - parameter username: (query) The user&#39;s encrypted email address they used to sign-up 
    /// - parameter password: (query) The encrypted password 
    /// - parameter gameType: (query) The application key 
    /// - parameter deviceId: (query) The device id (optional)
    /// - parameter charsetName: (query) Charset Name (optional, default to "UTF-8")
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - parameter returnProfile: (query) Return Profile (optional, default to false)
    /// - parameter responseFilters: (query) A comma separated list of ProfileFilters for filtering the returned response data (optional, default to "PROFILE")
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func secureLogin(version: Double, username: String, password: String, gameType: String, deviceId: String? = nil, charsetName: String? = nil, latitude: Double? = nil, longitude: Double? = nil, returnProfile: Bool? = nil, responseFilters: String? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/login/validate"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                queryItems.append(URLQueryItem(name: "gameType", value: gameType))
                if let charsetName = charsetName { queryItems.append(URLQueryItem(name: "charsetName", value: charsetName)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let returnProfile = returnProfile { queryItems.append(URLQueryItem(name: "returnProfile", value: returnProfile ? "true" : "false")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Account (Encrypted Username)
    /// - POST /api/{version}/account/create/validate
    /// - Create a new account by role (with encrypted user-name and password)
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id 
    /// - parameter username: (query) The encrypted email of the user, this is what will be used when they login 
    /// - parameter password: (query) The encrypted password of the user 
    /// - parameter name: (query) The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName  (optional)
    /// - parameter inviteToken: (query) the inviteToken that the referrer use for this account to sign up (optional)
    /// - parameter prefixName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the prefix of the user&#39;s name (optional)
    /// - parameter firstName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s first name (optional)
    /// - parameter middleName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s middle name (optional)
    /// - parameter lastName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the user&#39;s last name (optional)
    /// - parameter suffixName: (query) If the parameter &#39;name&#39; is empty or not present, this field will be used to set the suffix of the user&#39;s name (optional)
    /// - parameter title: (query) Title (optional)
    /// - parameter deviceIdType: (query) Device Id Type (optional)
    /// - parameter emailAddress: (query) The user&#39;s contact email address (NOT the username) which is also used for email validation (optional)
    /// - parameter assetId: (query) The asset id to set the user&#39;s profile image (optional)
    /// - parameter address: (query) the user&#39;s address (optional)
    /// - parameter zipcode: (query) The street zipcode of the user&#39;s contact location (optional)
    /// - parameter gender: (query) The gender of the user AudienceGender (optional)
    /// - parameter birthday: (query) The birthday date of the user in milliseconds (optional)
    /// - parameter homePhone: (query) the user&#39;s home phone number (optional)
    /// - parameter cellPhone: (query) the user&#39;s cell phone number (optional)
    /// - parameter cellPhoneCarrier: (query) the user&#39;s Cell Phone Carrier (optional)
    /// - parameter businessPhone: (query) the user&#39;s Business Phone Number (optional)
    /// - parameter role: (query) The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST (optional, default to "MEMBER")
    /// - parameter platforms: (query) Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK (optional)
    /// - parameter tags: (query) Search tags (optional)
    /// - parameter aboutUs: (query) About Us information (optional)
    /// - parameter gameExperience: (query) Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
    /// - parameter categoryIds: (query) A list of category ids that represent interests and associations (optional)
    /// - parameter hometown: (query) The user&#39;s hometown (optional)
    /// - parameter height: (query) The user&#39;s height (optional)
    /// - parameter heightIndex: (query) The user&#39;s height in a numerical value that can be used for ordering/searching (optional)
    /// - parameter ethnicity: (query) The user&#39;s ethnicity (optional)
    /// - parameter bodyType: (query) The user&#39;s body type (optional)
    /// - parameter maritalStatus: (query) The user&#39;s maritial status (optional)
    /// - parameter children: (query) The user&#39;s children status (optional)
    /// - parameter religion: (query) The user&#39;s religion (optional)
    /// - parameter education: (query) The user&#39;s education (optional)
    /// - parameter educationIndex: (query) The user&#39;s education in a numerical value that can be used for ordering/searching (optional)
    /// - parameter smoke: (query) The user&#39;s smoke status (optional)
    /// - parameter drink: (query) The user&#39;s drink status (optional)
    /// - parameter companionship: (query) The user&#39;s companionship status (optional)
    /// - parameter companionshipIndex: (query) The user&#39;s companionship index (optional)
    /// - parameter preferredMinAge: (query) The preferred minimum age in the account location search (optional)
    /// - parameter preferredMaxAge: (query) The preferred maximum age in the account location search (optional)
    /// - parameter preferredMinHeight: (query) The preferred minimum height in the account location search (optional)
    /// - parameter preferredMaxHeight: (query) The preferred maximum height in the account location search (optional)
    /// - parameter preferredGender: (query) The preferred gender in the account location search (optional)
    /// - parameter preferredEducation: (query) The preferred education in the account location search (optional)
    /// - parameter preferredEducationIndex: (query) The preferred education in a numerical value that can be used for ordering/searching (optional)
    /// - parameter preferredBodyType: (query) The preferred body type in the account location search (optional)
    /// - parameter preferredEthnicity: (query) The preferred ethnicity in the account location search (optional)
    /// - parameter preferredLocation: (query) The preferred education in the account location search (optional)
    /// - parameter preferredLocationRange: (query) The preferred location range in the account location search (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - parameter acceptedTerms: (query) Accepted Terms (optional, default to true)
    /// - parameter charsetName: (query) Charset Name (optional, default to "UTF-8")
    /// - parameter gameType: (query) Game Type (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter appVersion: (query) App Version (optional)
    /// - parameter responseType: (query) Response Type (optional)
    /// - returns: AnyPublisher<ProfileInfoResponse, Error> 
    open func secureSignup(version: Double, deviceId: String, username: String, password: String, name: String? = nil, inviteToken: String? = nil, prefixName: String? = nil, firstName: String? = nil, middleName: String? = nil, lastName: String? = nil, suffixName: String? = nil, title: String? = nil, deviceIdType: String? = nil, emailAddress: String? = nil, assetId: Int64? = nil, address: String? = nil, zipcode: String? = nil, gender: String? = nil, birthday: Int64? = nil, homePhone: String? = nil, cellPhone: String? = nil, cellPhoneCarrier: String? = nil, businessPhone: String? = nil, role: String? = nil, platforms: String? = nil, tags: String? = nil, aboutUs: String? = nil, gameExperience: String? = nil, categoryIds: String? = nil, hometown: String? = nil, height: String? = nil, heightIndex: Int? = nil, ethnicity: String? = nil, bodyType: String? = nil, maritalStatus: String? = nil, children: String? = nil, religion: String? = nil, education: String? = nil, educationIndex: Int? = nil, smoke: String? = nil, drink: String? = nil, companionship: String? = nil, companionshipIndex: Int? = nil, preferredMinAge: Int? = nil, preferredMaxAge: Int? = nil, preferredMinHeight: Int? = nil, preferredMaxHeight: Int? = nil, preferredGender: String? = nil, preferredEducation: String? = nil, preferredEducationIndex: Int? = nil, preferredBodyType: String? = nil, preferredEthnicity: String? = nil, preferredLocation: String? = nil, preferredLocationRange: Double? = nil, latitude: Double? = nil, longitude: Double? = nil, acceptedTerms: Bool? = nil, charsetName: String? = nil, gameType: String? = nil, appKey: String? = nil, appVersion: String? = nil, responseType: String? = nil) -> AnyPublisher<ProfileInfoResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/create/validate"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let inviteToken = inviteToken { queryItems.append(URLQueryItem(name: "inviteToken", value: inviteToken)) } 
                if let prefixName = prefixName { queryItems.append(URLQueryItem(name: "prefixName", value: prefixName)) } 
                if let firstName = firstName { queryItems.append(URLQueryItem(name: "firstName", value: firstName)) } 
                if let middleName = middleName { queryItems.append(URLQueryItem(name: "middleName", value: middleName)) } 
                if let lastName = lastName { queryItems.append(URLQueryItem(name: "lastName", value: lastName)) } 
                if let suffixName = suffixName { queryItems.append(URLQueryItem(name: "suffixName", value: suffixName)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                queryItems.append(URLQueryItem(name: "deviceId", value: deviceId))
                if let deviceIdType = deviceIdType { queryItems.append(URLQueryItem(name: "deviceIdType", value: deviceIdType)) } 
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let address = address { queryItems.append(URLQueryItem(name: "address", value: address)) } 
                if let zipcode = zipcode { queryItems.append(URLQueryItem(name: "zipcode", value: zipcode)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let birthday = birthday { queryItems.append(URLQueryItem(name: "birthday", value: "\(birthday)")) } 
                if let homePhone = homePhone { queryItems.append(URLQueryItem(name: "homePhone", value: homePhone)) } 
                if let cellPhone = cellPhone { queryItems.append(URLQueryItem(name: "cellPhone", value: cellPhone)) } 
                if let cellPhoneCarrier = cellPhoneCarrier { queryItems.append(URLQueryItem(name: "cellPhoneCarrier", value: cellPhoneCarrier)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let role = role { queryItems.append(URLQueryItem(name: "role", value: role)) } 
                if let platforms = platforms { queryItems.append(URLQueryItem(name: "platforms", value: platforms)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let aboutUs = aboutUs { queryItems.append(URLQueryItem(name: "aboutUs", value: aboutUs)) } 
                if let gameExperience = gameExperience { queryItems.append(URLQueryItem(name: "gameExperience", value: gameExperience)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let hometown = hometown { queryItems.append(URLQueryItem(name: "hometown", value: hometown)) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: height)) } 
                if let heightIndex = heightIndex { queryItems.append(URLQueryItem(name: "heightIndex", value: "\(heightIndex)")) } 
                if let ethnicity = ethnicity { queryItems.append(URLQueryItem(name: "ethnicity", value: ethnicity)) } 
                if let bodyType = bodyType { queryItems.append(URLQueryItem(name: "bodyType", value: bodyType)) } 
                if let maritalStatus = maritalStatus { queryItems.append(URLQueryItem(name: "maritalStatus", value: maritalStatus)) } 
                if let children = children { queryItems.append(URLQueryItem(name: "children", value: children)) } 
                if let religion = religion { queryItems.append(URLQueryItem(name: "religion", value: religion)) } 
                if let education = education { queryItems.append(URLQueryItem(name: "education", value: education)) } 
                if let educationIndex = educationIndex { queryItems.append(URLQueryItem(name: "educationIndex", value: "\(educationIndex)")) } 
                if let smoke = smoke { queryItems.append(URLQueryItem(name: "smoke", value: smoke)) } 
                if let drink = drink { queryItems.append(URLQueryItem(name: "drink", value: drink)) } 
                if let companionship = companionship { queryItems.append(URLQueryItem(name: "companionship", value: companionship)) } 
                if let companionshipIndex = companionshipIndex { queryItems.append(URLQueryItem(name: "companionshipIndex", value: "\(companionshipIndex)")) } 
                if let preferredMinAge = preferredMinAge { queryItems.append(URLQueryItem(name: "preferredMinAge", value: "\(preferredMinAge)")) } 
                if let preferredMaxAge = preferredMaxAge { queryItems.append(URLQueryItem(name: "preferredMaxAge", value: "\(preferredMaxAge)")) } 
                if let preferredMinHeight = preferredMinHeight { queryItems.append(URLQueryItem(name: "preferredMinHeight", value: "\(preferredMinHeight)")) } 
                if let preferredMaxHeight = preferredMaxHeight { queryItems.append(URLQueryItem(name: "preferredMaxHeight", value: "\(preferredMaxHeight)")) } 
                if let preferredGender = preferredGender { queryItems.append(URLQueryItem(name: "preferredGender", value: preferredGender)) } 
                if let preferredEducation = preferredEducation { queryItems.append(URLQueryItem(name: "preferredEducation", value: preferredEducation)) } 
                if let preferredEducationIndex = preferredEducationIndex { queryItems.append(URLQueryItem(name: "preferredEducationIndex", value: "\(preferredEducationIndex)")) } 
                if let preferredBodyType = preferredBodyType { queryItems.append(URLQueryItem(name: "preferredBodyType", value: preferredBodyType)) } 
                if let preferredEthnicity = preferredEthnicity { queryItems.append(URLQueryItem(name: "preferredEthnicity", value: preferredEthnicity)) } 
                if let preferredLocation = preferredLocation { queryItems.append(URLQueryItem(name: "preferredLocation", value: preferredLocation)) } 
                if let preferredLocationRange = preferredLocationRange { queryItems.append(URLQueryItem(name: "preferredLocationRange", value: "\(preferredLocationRange)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let acceptedTerms = acceptedTerms { queryItems.append(URLQueryItem(name: "acceptedTerms", value: acceptedTerms ? "true" : "false")) } 
                if let charsetName = charsetName { queryItems.append(URLQueryItem(name: "charsetName", value: charsetName)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let responseType = responseType { queryItems.append(URLQueryItem(name: "responseType", value: responseType)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileInfoResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileInfoResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Save Match Token
    /// - POST /api/{version}/consumer/profile/matchToken
    /// - Save user's match token to be used for profile match making
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter matchToken: (query) A string of numbers (optional)
    /// - parameter gameType: (query) Game Type (deprecated) (optional, default to "BOOPY")
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func setMatchToken(version: Double, deviceId: String? = nil, accountId: Int64? = nil, matchToken: String? = nil, gameType: String? = nil, appKey: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/consumer/profile/matchToken"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let matchToken = matchToken { queryItems.append(URLQueryItem(name: "matchToken", value: matchToken)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Account Active Status
    /// - POST /api/{version}/account/active/update
    /// - Activate or deactivate an account (requires appropriate permissions).
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) 
    /// - parameter connectionAccountId: (query) The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead) 
    /// - parameter active: (query) true will activate the user and false will deactivate 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) the application key that the user belongs to (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateActveStatus(version: Double, accountId: Int64, connectionAccountId: Int64, active: Bool, deviceId: String? = nil, appKey: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/active/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Location
    /// - POST /api/{version}/account/location/update
    /// - Update the account location
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - parameter clientTime: (query) The time of the update (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateLocation(version: Double, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil, clientTime: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/location/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let clientTime = clientTime { queryItems.append(URLQueryItem(name: "clientTime", value: "\(clientTime)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Account Settings
    /// - POST /api/{version}/account/settings/update
    /// - Update the account settings for a user
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter blockedNotifications: (query) The notifications to be blocked (optional)
    /// - parameter suggestionMethod: (query) How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS) (optional)
    /// - parameter suggestionCount: (query) How many suggestions to receive per time frame (optional)
    /// - parameter suggestionTimeFrame: (query) The time frame in seconds, 3600 would be a 1 hour time frame (optional)
    /// - parameter showOthersExactLocation: (query) Show Others Exact Location (optional)
    /// - parameter showAsZipcode: (query) Show As Zipcode (optional)
    /// - parameter showExactLocation: (query) Show Exact Location (optional)
    /// - parameter favoriteVisibility: (query) Show favorites (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<UserSettingsResponse, Error> 
    open func updateSettings(version: Double, deviceId: String? = nil, accountId: Int64? = nil, blockedNotifications: String? = nil, suggestionMethod: String? = nil, suggestionCount: Int? = nil, suggestionTimeFrame: Int? = nil, showOthersExactLocation: Bool? = nil, showAsZipcode: Bool? = nil, showExactLocation: Bool? = nil, favoriteVisibility: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<UserSettingsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/settings/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let blockedNotifications = blockedNotifications { queryItems.append(URLQueryItem(name: "blockedNotifications", value: blockedNotifications)) } 
                if let suggestionMethod = suggestionMethod { queryItems.append(URLQueryItem(name: "suggestionMethod", value: suggestionMethod)) } 
                if let suggestionCount = suggestionCount { queryItems.append(URLQueryItem(name: "suggestionCount", value: "\(suggestionCount)")) } 
                if let suggestionTimeFrame = suggestionTimeFrame { queryItems.append(URLQueryItem(name: "suggestionTimeFrame", value: "\(suggestionTimeFrame)")) } 
                if let showOthersExactLocation = showOthersExactLocation { queryItems.append(URLQueryItem(name: "showOthersExactLocation", value: showOthersExactLocation ? "true" : "false")) } 
                if let showAsZipcode = showAsZipcode { queryItems.append(URLQueryItem(name: "showAsZipcode", value: showAsZipcode ? "true" : "false")) } 
                if let showExactLocation = showExactLocation { queryItems.append(URLQueryItem(name: "showExactLocation", value: showExactLocation ? "true" : "false")) } 
                if let favoriteVisibility = favoriteVisibility { queryItems.append(URLQueryItem(name: "favoriteVisibility", value: favoriteVisibility)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<UserSettingsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(UserSettingsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Save Validation Status
    /// - POST /api/{version}/account/validateAccountSignup
    /// - Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.
    /// - parameter version: (path)  
    /// - parameter token: (query) The token associated with the account to update, good for 24 hours 
    /// - returns: AnyPublisher<AccountLoginResponse, Error> 
    open func validateAccountSignup(version: Double, token: String) -> AnyPublisher<AccountLoginResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/validateAccountSignup"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "token", value: token))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AccountLoginResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AccountLoginResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Validate Password Reset Token
    /// - POST /api/{version}/account/validatepasswordreset
    /// - Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.
    /// - parameter version: (path)  
    /// - parameter token: (query) The token associated with the account to update, good for 24 hours 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func validatePasswordReset(version: Double, token: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/account/validatepasswordreset"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "token", value: token))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
