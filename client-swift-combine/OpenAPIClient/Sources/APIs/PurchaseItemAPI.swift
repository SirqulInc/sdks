//
// PurchaseItemAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class PurchaseItemAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter purchaseType
    ///
    public enum CreatePurchaseItemPurchaseType: String, Codable, CaseIterable {
        case sirqul = "SIRQUL"
        case ios = "IOS"
        case google = "GOOGLE"
        case amazon = "AMAZON"
        case mac = "MAC"
        case wp8 = "WP8"
        case free = "FREE"
    }
    ///
    /// Enum for parameter serviceAction
    ///
    public enum CreatePurchaseItemServiceAction: String, Codable, CaseIterable {
        case dayPremium = "DAY_PREMIUM"
        case weekPremium = "WEEK_PREMIUM"
        case monthPremium = "MONTH_PREMIUM"
        case yearPremium = "YEAR_PREMIUM"
        case lifetimePremium = "LIFETIME_PREMIUM"
        case addTicket = "ADD_TICKET"
        case addGift = "ADD_GIFT"
        case addPoints = "ADD_POINTS"
    }

    /// Create Purchase
    /// - POST /api/{version}/purchase/create
    /// - Creates a purchase item for in app purchases
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The application key that the purchase can be used in 
    /// - parameter name: (query) The name of the purchase item 
    /// - parameter purchaseType: (query) The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter description: (query) The description of the purchase item (optional)
    /// - parameter tickets: (query) How much the purchase item is worth in tickets (optional)
    /// - parameter price: (query) How much the purchase item will cost in real money (optional)
    /// - parameter purchaseCode: (query) The unique identifier used by purchase providers to identify in-app-purchases (optional)
    /// - parameter secretKey: (query) A secret key from purchase providers that would be used for validation (optional)
    /// - parameter purchaseLimit: (query) How many times a user acquire the same purchase item (optional, default to 0)
    /// - parameter serviceAction: (query) Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
    /// - parameter coverAssetId: (query) The cover image of the purchase item (optional)
    /// - parameter promoAssetId: (query) An application specific asset that can be used to store/provide additional data (optional)
    /// - parameter giftable: (query) Determines whether the purchase item can be gifted to other users (optional)
    /// - parameter assetable: (query) Determines whether users can attach their own media/asset to the purchase item (optional)
    /// - parameter allocateTickets: (query) Flag to indicate owner should receive tickets for completed missions (optional, default to false)
    /// - parameter ticketType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter points: (query) The number of points to award for completing a mission (optional)
    /// - parameter offerLocationId: (query) The offer location that will get added to the user&#39;s wallet after purchase. (optional)
    /// - returns: AnyPublisher<PurchaseItemFullResponse, Error> 
    open func createPurchaseItem(version: Double, appKey: String, name: String, purchaseType: CreatePurchaseItemPurchaseType, deviceId: String? = nil, accountId: Int64? = nil, description: String? = nil, tickets: Int? = nil, price: Float? = nil, purchaseCode: String? = nil, secretKey: String? = nil, purchaseLimit: Int? = nil, serviceAction: CreatePurchaseItemServiceAction? = nil, coverAssetId: Int64? = nil, promoAssetId: Int64? = nil, giftable: Bool? = nil, assetable: Bool? = nil, allocateTickets: Bool? = nil, ticketType: String? = nil, points: Int64? = nil, offerLocationId: Int64? = nil) -> AnyPublisher<PurchaseItemFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/purchase/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let tickets = tickets { queryItems.append(URLQueryItem(name: "tickets", value: "\(tickets)")) } 
                if let price = price { queryItems.append(URLQueryItem(name: "price", value: "\(price)")) } 
                queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType.rawValue))
                if let purchaseCode = purchaseCode { queryItems.append(URLQueryItem(name: "purchaseCode", value: purchaseCode)) } 
                if let secretKey = secretKey { queryItems.append(URLQueryItem(name: "secretKey", value: secretKey)) } 
                if let purchaseLimit = purchaseLimit { queryItems.append(URLQueryItem(name: "purchaseLimit", value: "\(purchaseLimit)")) } 
                if let serviceAction = serviceAction { queryItems.append(URLQueryItem(name: "serviceAction", value: serviceAction.rawValue)) } 
                if let coverAssetId = coverAssetId { queryItems.append(URLQueryItem(name: "coverAssetId", value: "\(coverAssetId)")) } 
                if let promoAssetId = promoAssetId { queryItems.append(URLQueryItem(name: "promoAssetId", value: "\(promoAssetId)")) } 
                if let giftable = giftable { queryItems.append(URLQueryItem(name: "giftable", value: giftable ? "true" : "false")) } 
                if let assetable = assetable { queryItems.append(URLQueryItem(name: "assetable", value: assetable ? "true" : "false")) } 
                if let allocateTickets = allocateTickets { queryItems.append(URLQueryItem(name: "allocateTickets", value: allocateTickets ? "true" : "false")) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                if let points = points { queryItems.append(URLQueryItem(name: "points", value: "\(points)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PurchaseItemFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PurchaseItemFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Purchase
    /// - POST /api/{version}/purchase/delete
    /// - Marks the purchase item as deleted
    /// - parameter version: (path)  
    /// - parameter purchaseItemId: (query) The purchase item id 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deletePurchaseItem(version: Double, purchaseItemId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/purchase/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "purchaseItemId", value: "\(purchaseItemId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Purchase
    /// - GET /api/{version}/purchase/get
    /// - Get detailed information about a purchase item
    /// - parameter version: (path)  
    /// - parameter purchaseItemId: (query) The purchase item id 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<PurchaseItemFullResponse, Error> 
    open func getPurchaseItem(version: Double, purchaseItemId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<PurchaseItemFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/purchase/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "purchaseItemId", value: "\(purchaseItemId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PurchaseItemFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PurchaseItemFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchPurchaseItemsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case name = "NAME"
        case description = "DESCRIPTION"
        case tickets = "TICKETS"
        case price = "PRICE"
        case purchaseType = "PURCHASE_TYPE"
        case purchaseCode = "PURCHASE_CODE"
        case purchaseLimit = "PURCHASE_LIMIT"
        case serivceAction = "SERIVCE_ACTION"
        case giftable = "GIFTABLE"
        case assetable = "ASSETABLE"
        case applicationId = "APPLICATION_ID"
        case applicationName = "APPLICATION_NAME"
    }

    /// Search Purchases
    /// - GET /api/{version}/purchase/search
    /// - Search for purchasable items from the system
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) The application key to filter results by application (optional)
    /// - parameter filterByBillable: (query) Determines whether to filter results by the user&#39;s billable entity (optional, default to false)
    /// - parameter purchaseType: (query) A comma separated list of purchase providers to filter by. Possible values include: &lt;ul&gt; &lt;li&gt;SIRQUL - purchases from the Sirqul store using tickets&lt;/li&gt; &lt;li&gt;IOS - purchases from the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - purchases from the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - purchases from the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - purchases from the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - purchases from the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - purchases that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
    /// - parameter serviceAction: (query) A comma separated list of service actions to filter results by. Possible values include: &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - purchases that subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - purchases that subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - purchases that subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - purchases that allow users to add more tickets&lt;/li&gt; &lt;li&gt;ADD_GIFT - purchases that allow users to recieve gifts&lt;/li&gt; &lt;/ul&gt; (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (optional, default to .name)
    /// - parameter descending: (query) The order to return the search results (optional, default to false)
    /// - parameter start: (query) The record to begin the return set on (optional, default to 0)
    /// - parameter limit: (query) The number of records to return (optional, default to 20)
    /// - parameter activeOnly: (query) Return only active results (optional, default to false)
    /// - returns: AnyPublisher<[PurchaseItemResponse], Error> 
    open func searchPurchaseItems(version: Double, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, filterByBillable: Bool? = nil, purchaseType: String? = nil, serviceAction: String? = nil, keyword: String? = nil, sortField: SearchPurchaseItemsSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil) -> AnyPublisher<[PurchaseItemResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/purchase/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let filterByBillable = filterByBillable { queryItems.append(URLQueryItem(name: "filterByBillable", value: filterByBillable ? "true" : "false")) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType)) } 
                if let serviceAction = serviceAction { queryItems.append(URLQueryItem(name: "serviceAction", value: serviceAction)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[PurchaseItemResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([PurchaseItemResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter purchaseType
    ///
    public enum UpdatePurchaseItemPurchaseType: String, Codable, CaseIterable {
        case sirqul = "SIRQUL"
        case ios = "IOS"
        case google = "GOOGLE"
        case amazon = "AMAZON"
        case mac = "MAC"
        case wp8 = "WP8"
        case free = "FREE"
    }
    ///
    /// Enum for parameter serviceAction
    ///
    public enum UpdatePurchaseItemServiceAction: String, Codable, CaseIterable {
        case dayPremium = "DAY_PREMIUM"
        case weekPremium = "WEEK_PREMIUM"
        case monthPremium = "MONTH_PREMIUM"
        case yearPremium = "YEAR_PREMIUM"
        case lifetimePremium = "LIFETIME_PREMIUM"
        case addTicket = "ADD_TICKET"
        case addGift = "ADD_GIFT"
        case addPoints = "ADD_POINTS"
    }

    /// Update Purchase
    /// - POST /api/{version}/purchase/update
    /// - Updates a purchase item for in app purchases
    /// - parameter version: (path)  
    /// - parameter purchaseItemId: (query) The purchase item id 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter name: (query) The name of the purchase item (optional)
    /// - parameter description: (query) The description of the purchase item (optional)
    /// - parameter tickets: (query) How much the purchase item is worth in tickets (optional)
    /// - parameter price: (query) How much the purchase item will cost in real money (optional)
    /// - parameter purchaseType: (query) The purchase provider &lt;ul&gt; &lt;li&gt;SIRQUL - the Sirqul store to make purchases using tickets&lt;/li&gt; &lt;li&gt;IOS - the iTunes store for iPhone, iPod, iPod Touch&lt;/li&gt; &lt;li&gt;GOOGLE - the Google Play store&lt;/li&gt; &lt;li&gt;AMAZON - the Amazon Android store&lt;/li&gt; &lt;li&gt;MAC - the iTunes store for OSX&lt;/li&gt; &lt;li&gt;WP8 - the Windows Phone 8 store&lt;/li&gt; &lt;li&gt;FREE - used for purchase items that are free (can be used for development/testing purposes)&lt;/li&gt; &lt;/ul&gt; (optional)
    /// - parameter purchaseCode: (query) The unique identifier used by purchase providers to identify in-app-purchases (optional)
    /// - parameter secretKey: (query) A secret key from purchase providers that would be used for validation (optional)
    /// - parameter purchaseLimit: (query) How many times a user acquire the same purchase item (optional)
    /// - parameter serviceAction: (query) Determines whether the purchase item will enable certain features &lt;ul&gt; &lt;li&gt;DAY_PREMIUM - subscribes a user for a day of membership&lt;/li&gt; &lt;li&gt;WEEK_PREMIUM - subscribes a user for a week of membership&lt;/li&gt; &lt;li&gt;MONTH_PREMIUM - subscribes a user for a month of membership&lt;/li&gt; &lt;li&gt;ADD_TICKET - allows a user to add more tickets to their account&lt;/li&gt; &lt;li&gt;ADD_GIFT - allows a user to send/recieve the purchase item as a gift&lt;/li&gt; &lt;/ul&gt; (optional)
    /// - parameter coverAssetId: (query) The cover image of the purchase item (optional)
    /// - parameter promoAssetId: (query) An application specific asset that can be used to store/provide additional data (optional)
    /// - parameter giftable: (query) Determines whether the purchase item can be gifted to other users (optional)
    /// - parameter assetable: (query) Determines whether users can attach their own media/asset to the purchase item (optional)
    /// - parameter active: (query) Sets whether the purchase item is active or inactive (hidden from consumers) (optional)
    /// - parameter allocateTickets: (query) Flag to indicate owner should receive tickets for completed missions (optional, default to false)
    /// - parameter ticketType: (query) The type of ticket to reward, null means default type (optional)
    /// - parameter points: (query) The number of points to award for completing a mission (optional)
    /// - parameter offerLocationId: (query) The offer location that will get added to the user&#39;s wallet after purchase. (optional)
    /// - returns: AnyPublisher<PurchaseItemFullResponse, Error> 
    open func updatePurchaseItem(version: Double, purchaseItemId: Int64, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, description: String? = nil, tickets: Int? = nil, price: Float? = nil, purchaseType: UpdatePurchaseItemPurchaseType? = nil, purchaseCode: String? = nil, secretKey: String? = nil, purchaseLimit: Int? = nil, serviceAction: UpdatePurchaseItemServiceAction? = nil, coverAssetId: Int64? = nil, promoAssetId: Int64? = nil, giftable: Bool? = nil, assetable: Bool? = nil, active: Bool? = nil, allocateTickets: Bool? = nil, ticketType: String? = nil, points: Int64? = nil, offerLocationId: Int64? = nil) -> AnyPublisher<PurchaseItemFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/purchase/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "purchaseItemId", value: "\(purchaseItemId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let tickets = tickets { queryItems.append(URLQueryItem(name: "tickets", value: "\(tickets)")) } 
                if let price = price { queryItems.append(URLQueryItem(name: "price", value: "\(price)")) } 
                if let purchaseType = purchaseType { queryItems.append(URLQueryItem(name: "purchaseType", value: purchaseType.rawValue)) } 
                if let purchaseCode = purchaseCode { queryItems.append(URLQueryItem(name: "purchaseCode", value: purchaseCode)) } 
                if let secretKey = secretKey { queryItems.append(URLQueryItem(name: "secretKey", value: secretKey)) } 
                if let purchaseLimit = purchaseLimit { queryItems.append(URLQueryItem(name: "purchaseLimit", value: "\(purchaseLimit)")) } 
                if let serviceAction = serviceAction { queryItems.append(URLQueryItem(name: "serviceAction", value: serviceAction.rawValue)) } 
                if let coverAssetId = coverAssetId { queryItems.append(URLQueryItem(name: "coverAssetId", value: "\(coverAssetId)")) } 
                if let promoAssetId = promoAssetId { queryItems.append(URLQueryItem(name: "promoAssetId", value: "\(promoAssetId)")) } 
                if let giftable = giftable { queryItems.append(URLQueryItem(name: "giftable", value: giftable ? "true" : "false")) } 
                if let assetable = assetable { queryItems.append(URLQueryItem(name: "assetable", value: assetable ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let allocateTickets = allocateTickets { queryItems.append(URLQueryItem(name: "allocateTickets", value: allocateTickets ? "true" : "false")) } 
                if let ticketType = ticketType { queryItems.append(URLQueryItem(name: "ticketType", value: ticketType)) } 
                if let points = points { queryItems.append(URLQueryItem(name: "points", value: "\(points)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PurchaseItemFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PurchaseItemFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
