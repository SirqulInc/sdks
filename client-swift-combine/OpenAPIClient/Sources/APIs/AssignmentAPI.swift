//
// AssignmentAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AssignmentAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Search Assignment Assignees
    /// - GET /api/{version}/assignment/assignee/search
    /// - Search for avaiable users for creating or updating assignment.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id sending the request 
    /// - parameter keyword: (query) The keyword to filter the returned results (optional)
    /// - returns: AnyPublisher<[AccountMiniResponse], Error> 
    open func assigmentAssigneeAccountSearch(version: Double, accountId: Int64, keyword: String? = nil) -> AnyPublisher<[AccountMiniResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/assignee/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AccountMiniResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AccountMiniResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Assignment
    /// - POST /api/{version}/assignment/create
    /// - Create an assignment.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter name: (query) the name for the assignment 
    /// - parameter assigneeAccountId: (query) the account id to assign to 
    /// - parameter description: (query) the desciprtion for the assignment (optional)
    /// - parameter retailerLocationId: (query) the retailer location id (optional)
    /// - parameter tags: (query) the tags (optional)
    /// - parameter active: (query) determines whether the assignment is active or inactive (optional)
    /// - returns: AnyPublisher<AssignmentResponse, Error> 
    open func assignmentCreate(version: Double, accountId: Int64, name: String, assigneeAccountId: Int64, description: String? = nil, retailerLocationId: Int64? = nil, tags: String? = nil, active: Bool? = nil) -> AnyPublisher<AssignmentResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                queryItems.append(URLQueryItem(name: "assigneeAccountId", value: "\(assigneeAccountId)"))
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssignmentResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssignmentResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Assignment
    /// - POST /api/{version}/assignment/delete
    /// - Delete an assignment.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentId: (query) the assignment id 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func assignmentDelete(version: Double, accountId: Int64, assignmentId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentId", value: "\(assignmentId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Assignment
    /// - GET /api/{version}/assignment/get
    /// - Get the details of an assignment.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentId: (query) the assignment id 
    /// - returns: AnyPublisher<AssignmentResponse, Error> 
    open func assignmentGet(version: Double, accountId: Int64, assignmentId: Int64) -> AnyPublisher<AssignmentResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentId", value: "\(assignmentId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssignmentResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssignmentResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum AssignmentSearchSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case assigneeId = "ASSIGNEE_ID"
        case creatorId = "CREATOR_ID"
        case locationId = "LOCATION_ID"
        case locationName = "LOCATION_NAME"
        case currentStatus = "CURRENT_STATUS"
        case currentStatusType = "CURRENT_STATUS_TYPE"
        case statuses = "STATUSES"
    }
    ///
    /// Enum for parameter currentStatusType
    ///
    public enum AssignmentSearchCurrentStatusType: String, Codable, CaseIterable {
        case new = "NEW"
        case inProgress = "IN_PROGRESS"
        case subscribed = "SUBSCRIBED"
        case archived = "ARCHIVED"
    }

    /// Search Assignments
    /// - GET /api/{version}/assignment/search
    /// - Search for assignments by the given parameters.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account sending the request 
    /// - parameter sortField: (query) sort by table field 
    /// - parameter descending: (query) return results in descending order or not 
    /// - parameter activeOnly: (query) return active results only or not 
    /// - parameter start: (query) The record to begin the return set on 
    /// - parameter limit: (query) The number of records to return 
    /// - parameter creatorAccountId: (query) the creator of the assignment (optional)
    /// - parameter assigneeAccountIds: (query) filter results by assignee accounts. If not provided, all assignments that are assigned to accounts that are managed by the requested account will be returned. (optional)
    /// - parameter retailerLocationIds: (query) filter results by retailer locations (optional)
    /// - parameter currentStatusType: (query) filter results by assignment status (optional)
    /// - parameter keyword: (query) filter results by keyword search that matches the assignee, creator, or retailer location name (optional)
    /// - returns: AnyPublisher<[AssignmentResponse], Error> 
    open func assignmentSearch(version: Double, accountId: Int64, sortField: AssignmentSearchSortField, descending: Bool, activeOnly: Bool, start: Int, limit: Int, creatorAccountId: Int64? = nil, assigneeAccountIds: String? = nil, retailerLocationIds: String? = nil, currentStatusType: AssignmentSearchCurrentStatusType? = nil, keyword: String? = nil) -> AnyPublisher<[AssignmentResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let creatorAccountId = creatorAccountId { queryItems.append(URLQueryItem(name: "creatorAccountId", value: "\(creatorAccountId)")) } 
                if let assigneeAccountIds = assigneeAccountIds { queryItems.append(URLQueryItem(name: "assigneeAccountIds", value: assigneeAccountIds)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let currentStatusType = currentStatusType { queryItems.append(URLQueryItem(name: "currentStatusType", value: currentStatusType.rawValue)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AssignmentResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AssignmentResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter toDo
    ///
    public enum AssignmentStatusCreateToDo: String, Codable, CaseIterable {
        case siteVisit = "SITE_VISIT"
        case phone = "PHONE"
        case recontact = "RECONTACT"
        case renewal = "RENEWAL"
        case credit = "CREDIT"
    }
    ///
    /// Enum for parameter connection
    ///
    public enum AssignmentStatusCreateConnection: String, Codable, CaseIterable {
        case initial = "INITIAL"
        case followUp = "FOLLOW_UP"
        case declined = "DECLINED"
    }
    ///
    /// Enum for parameter method
    ///
    public enum AssignmentStatusCreateMethod: String, Codable, CaseIterable {
        case phone = "PHONE"
        case siteVisit = "SITE_VISIT"
        case email = "EMAIL"
    }
    ///
    /// Enum for parameter status
    ///
    public enum AssignmentStatusCreateStatus: String, Codable, CaseIterable {
        case archived = "ARCHIVED"
        case subscribed = "SUBSCRIBED"
        case unsubscribed = "UNSUBSCRIBED"
        case contacted = "CONTACTED"
        case declined = "DECLINED"
        case notContacted = "NOT_CONTACTED"
    }
    ///
    /// Enum for parameter closure
    ///
    public enum AssignmentStatusCreateClosure: String, Codable, CaseIterable {
        case phone = "PHONE"
        case siteVisit = "SITE_VISIT"
        case phoneSite = "PHONE_SITE"
        case web = "WEB"
    }

    /// Create Assignment Status
    /// - POST /api/{version}/assignment/status/create
    /// - Create an assignment status.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentId: (query) the assignment id 
    /// - parameter scheduledNotificationId: (query) the scheduled notification id for reminders (optional)
    /// - parameter toDo: (query) the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
    /// - parameter connection: (query) the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
    /// - parameter method: (query) the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
    /// - parameter status: (query) the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
    /// - parameter closure: (query) the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
    /// - parameter message: (query) the message from the assignee (optional)
    /// - parameter followUp: (query) the date to follow up by (optional)
    /// - parameter active: (query) determines whether the assignment status is active or inactive (optional)
    /// - returns: AnyPublisher<AssignmentStatusResponse, Error> 
    open func assignmentStatusCreate(version: Double, accountId: Int64, assignmentId: Int64, scheduledNotificationId: Int64? = nil, toDo: AssignmentStatusCreateToDo? = nil, connection: AssignmentStatusCreateConnection? = nil, method: AssignmentStatusCreateMethod? = nil, status: AssignmentStatusCreateStatus? = nil, closure: AssignmentStatusCreateClosure? = nil, message: String? = nil, followUp: Int64? = nil, active: Bool? = nil) -> AnyPublisher<AssignmentStatusResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/status/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentId", value: "\(assignmentId)"))
                if let scheduledNotificationId = scheduledNotificationId { queryItems.append(URLQueryItem(name: "scheduledNotificationId", value: "\(scheduledNotificationId)")) } 
                if let toDo = toDo { queryItems.append(URLQueryItem(name: "toDo", value: toDo.rawValue)) } 
                if let connection = connection { queryItems.append(URLQueryItem(name: "connection", value: connection.rawValue)) } 
                if let method = method { queryItems.append(URLQueryItem(name: "method", value: method.rawValue)) } 
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: status.rawValue)) } 
                if let closure = closure { queryItems.append(URLQueryItem(name: "closure", value: closure.rawValue)) } 
                if let message = message { queryItems.append(URLQueryItem(name: "message", value: message)) } 
                if let followUp = followUp { queryItems.append(URLQueryItem(name: "followUp", value: "\(followUp)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssignmentStatusResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssignmentStatusResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Deletes Assignment Status
    /// - POST /api/{version}/assignment/status/delete
    /// - Deletes an assignment status.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentStatusId: (query) the assignment status id 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func assignmentStatusDelete(version: Double, accountId: Int64, assignmentStatusId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/status/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentStatusId", value: "\(assignmentStatusId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Assignment Status
    /// - GET /api/{version}/assignment/status/get
    /// - Get an assignment status.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentStatusId: (query) the assignment status id 
    /// - returns: AnyPublisher<AssignmentStatusResponse, Error> 
    open func assignmentStatusGet(version: Double, accountId: Int64, assignmentStatusId: Int64) -> AnyPublisher<AssignmentStatusResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/status/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentStatusId", value: "\(assignmentStatusId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssignmentStatusResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssignmentStatusResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum AssignmentStatusSearchSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case assigneeId = "ASSIGNEE_ID"
        case creatorId = "CREATOR_ID"
        case locationId = "LOCATION_ID"
        case locationName = "LOCATION_NAME"
        case currentStatus = "CURRENT_STATUS"
        case currentStatusType = "CURRENT_STATUS_TYPE"
        case todo = "TODO"
        case connection = "CONNECTION"
        case method = "METHOD"
        case status = "STATUS"
        case closure = "CLOSURE"
        case message = "MESSAGE"
        case followUp = "FOLLOW_UP"
    }
    ///
    /// Enum for parameter statusType
    ///
    public enum AssignmentStatusSearchStatusType: String, Codable, CaseIterable {
        case archived = "ARCHIVED"
        case subscribed = "SUBSCRIBED"
        case unsubscribed = "UNSUBSCRIBED"
        case contacted = "CONTACTED"
        case declined = "DECLINED"
        case notContacted = "NOT_CONTACTED"
    }

    /// Search Assignment Statuses
    /// - GET /api/{version}/assignment/status/search
    /// - Search on assignment statuses.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter sortField: (query) the field to sort by. Possible values include: ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, CURRENT_STATUS, TODO, CONNECTION, METHOD, STATUS, CLOSURE, MESSAGE, FOLLOW_UP 
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order 
    /// - parameter activeOnly: (query) determines whether to only return active results 
    /// - parameter start: (query) the start index for pagination 
    /// - parameter limit: (query) the limit for pagination 
    /// - parameter assignmentId: (query) the assignment id (optional)
    /// - parameter creatorAccountId: (query) filter results by the account who created the status (optional)
    /// - parameter assigneeAccountId: (query) filter results by the assignee account (optional)
    /// - parameter retailerLocationId: (query) filter results by by retailer location (optional)
    /// - parameter statusType: (query) filter results by the status type (optional)
    /// - parameter keyword: (query) filter results by keyword search (optional)
    /// - returns: AnyPublisher<[AssignmentStatusResponse], Error> 
    open func assignmentStatusSearch(version: Double, accountId: Int64, sortField: AssignmentStatusSearchSortField, descending: Bool, activeOnly: Bool, start: Int, limit: Int, assignmentId: Int64? = nil, creatorAccountId: Int64? = nil, assigneeAccountId: Int64? = nil, retailerLocationId: Int64? = nil, statusType: AssignmentStatusSearchStatusType? = nil, keyword: String? = nil) -> AnyPublisher<[AssignmentStatusResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/status/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let assignmentId = assignmentId { queryItems.append(URLQueryItem(name: "assignmentId", value: "\(assignmentId)")) } 
                if let creatorAccountId = creatorAccountId { queryItems.append(URLQueryItem(name: "creatorAccountId", value: "\(creatorAccountId)")) } 
                if let assigneeAccountId = assigneeAccountId { queryItems.append(URLQueryItem(name: "assigneeAccountId", value: "\(assigneeAccountId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let statusType = statusType { queryItems.append(URLQueryItem(name: "statusType", value: statusType.rawValue)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AssignmentStatusResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AssignmentStatusResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter toDo
    ///
    public enum AssignmentStatusUpdateToDo: String, Codable, CaseIterable {
        case siteVisit = "SITE_VISIT"
        case phone = "PHONE"
        case recontact = "RECONTACT"
        case renewal = "RENEWAL"
        case credit = "CREDIT"
    }
    ///
    /// Enum for parameter connection
    ///
    public enum AssignmentStatusUpdateConnection: String, Codable, CaseIterable {
        case initial = "INITIAL"
        case followUp = "FOLLOW_UP"
        case declined = "DECLINED"
    }
    ///
    /// Enum for parameter method
    ///
    public enum AssignmentStatusUpdateMethod: String, Codable, CaseIterable {
        case phone = "PHONE"
        case siteVisit = "SITE_VISIT"
        case email = "EMAIL"
    }
    ///
    /// Enum for parameter status
    ///
    public enum AssignmentStatusUpdateStatus: String, Codable, CaseIterable {
        case archived = "ARCHIVED"
        case subscribed = "SUBSCRIBED"
        case unsubscribed = "UNSUBSCRIBED"
        case contacted = "CONTACTED"
        case declined = "DECLINED"
        case notContacted = "NOT_CONTACTED"
    }
    ///
    /// Enum for parameter closure
    ///
    public enum AssignmentStatusUpdateClosure: String, Codable, CaseIterable {
        case phone = "PHONE"
        case siteVisit = "SITE_VISIT"
        case phoneSite = "PHONE_SITE"
        case web = "WEB"
    }

    /// Update Assignment Status
    /// - POST /api/{version}/assignment/status/update
    /// - Updates an assignment status.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentStatusId: (query) the assignment status id 
    /// - parameter scheduledNotificationId: (query) the scheduled notification id for reminders (optional)
    /// - parameter toDo: (query) the type of to do. Possible values include: SITE_VISIT, PHONE, RECONTACT, RENEWAL, CREDIT (optional)
    /// - parameter connection: (query) the connection type. Possible values include: INITIAL, FOLLOW_UP, DECLINED (optional)
    /// - parameter method: (query) the communication method type. Possible values include: PHONE, SITE_VISIT, EMAIL (optional)
    /// - parameter status: (query) the status type. Possible values include: ARCHIVED, SUBSCRIBED, UNSUBSCRIBED, CONTACTED, DECLINED, NOT_CONTACTED (optional)
    /// - parameter closure: (query) the closure type. Possible values include: PHONE, SITE_VISIT, PHONE_SITE, WEB (optional)
    /// - parameter message: (query) the message from the assignee (optional)
    /// - parameter followUp: (query) the date to follow up by (optional)
    /// - parameter active: (query) determines whether the assignment status is active or inactive (optional)
    /// - returns: AnyPublisher<AssignmentStatusResponse, Error> 
    open func assignmentStatusUpdate(version: Double, accountId: Int64, assignmentStatusId: Int64, scheduledNotificationId: Int64? = nil, toDo: AssignmentStatusUpdateToDo? = nil, connection: AssignmentStatusUpdateConnection? = nil, method: AssignmentStatusUpdateMethod? = nil, status: AssignmentStatusUpdateStatus? = nil, closure: AssignmentStatusUpdateClosure? = nil, message: String? = nil, followUp: Int64? = nil, active: Bool? = nil) -> AnyPublisher<AssignmentStatusResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/status/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentStatusId", value: "\(assignmentStatusId)"))
                if let scheduledNotificationId = scheduledNotificationId { queryItems.append(URLQueryItem(name: "scheduledNotificationId", value: "\(scheduledNotificationId)")) } 
                if let toDo = toDo { queryItems.append(URLQueryItem(name: "toDo", value: toDo.rawValue)) } 
                if let connection = connection { queryItems.append(URLQueryItem(name: "connection", value: connection.rawValue)) } 
                if let method = method { queryItems.append(URLQueryItem(name: "method", value: method.rawValue)) } 
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: status.rawValue)) } 
                if let closure = closure { queryItems.append(URLQueryItem(name: "closure", value: closure.rawValue)) } 
                if let message = message { queryItems.append(URLQueryItem(name: "message", value: message)) } 
                if let followUp = followUp { queryItems.append(URLQueryItem(name: "followUp", value: "\(followUp)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssignmentStatusResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssignmentStatusResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Assignment
    /// - POST /api/{version}/assignment/update
    /// - Updates an assignment.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the user account id 
    /// - parameter assignmentId: (query) the assignment id 
    /// - parameter name: (query) the name of the assignment (optional)
    /// - parameter description: (query) the description of the assignment (optional)
    /// - parameter assigneeAccountId: (query) the account id to assign to (optional)
    /// - parameter retailerLocationId: (query) the retailer location id (optional)
    /// - parameter tags: (query) the tags (optional)
    /// - parameter active: (query) determines whether the assignment is active or inactive (optional)
    /// - returns: AnyPublisher<AssignmentResponse, Error> 
    open func assignmentUpdate(version: Double, accountId: Int64, assignmentId: Int64, name: String? = nil, description: String? = nil, assigneeAccountId: Int64? = nil, retailerLocationId: Int64? = nil, tags: String? = nil, active: Bool? = nil) -> AnyPublisher<AssignmentResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/assignment/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "assignmentId", value: "\(assignmentId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let assigneeAccountId = assigneeAccountId { queryItems.append(URLQueryItem(name: "assigneeAccountId", value: "\(assigneeAccountId)")) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AssignmentResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AssignmentResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
