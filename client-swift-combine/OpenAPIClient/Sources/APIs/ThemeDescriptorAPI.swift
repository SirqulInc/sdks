//
// ThemeDescriptorAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ThemeDescriptorAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum AddOrUpdateThemeDescriptorVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /// Create/Update Theme
    /// - POST /consumer/theme
    /// - Creates or updates a theme descriptor that can be used to give applications a customized look and feel. The theme can be created by consumers and shared to other users, allowing them to use and/or collaborate on making the theme.
    /// - parameter publicRead: (query) determines whether the theme&#39;s participants have read permissions 
    /// - parameter publicWrite: (query) determines whether the theme&#39;s participants have write permissions 
    /// - parameter publicDelete: (query) determines whether the theme&#39;s participants have delete permissions 
    /// - parameter publicAdd: (query)  
    /// - parameter visibility: (query) the determines the theme&#39;s participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) 
    /// - parameter includeFriendGroup: (query) flag to determine whether to share to the user&#39;s \&quot;friends\&quot; group 
    /// - parameter completeWithDefaultValues: (query) determines whether to use default values to complete the theme 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) the application key (optional)
    /// - parameter themeDescriptorId: (query) the theme descriptor id used to update an existing theme, leave empty for creating a new theme (optional)
    /// - parameter title: (query) the title of the theme (optional)
    /// - parameter description: (query) the description of the theme (optional)
    /// - parameter connectionIdsToAdd: (query) a comma separated list of connection IDs to share to users (optional)
    /// - parameter connectionGroupIdsToAdd: (query) a comma separated list of connection group IDs to share to groups (optional)
    /// - parameter appVersion: (query) the application version the theme was created for (optional)
    /// - parameter colorValueJson: (query) a json array used to replace colors within the application. Example: &#x60;&#x60;&#x60;json [   {     \&quot;name\&quot;: \&quot;sceneAtlas\&quot;,     \&quot;valueString\&quot;: \&quot;100,100,100,255\&quot;   },   {     \&quot;name\&quot;: \&quot;bg\&quot;,     \&quot;valueString\&quot;: \&quot;100,100,100,255\&quot;   } ] &#x60;&#x60;&#x60;  (optional)
    /// - parameter stringReplacerJson: (query) a json array used to replace strings within the application. Example: &#x60;&#x60;&#x60;json [   {     \&quot;name\&quot;: \&quot;coins\&quot;,     \&quot;valueString\&quot;: \&quot;Gems\&quot;   },   {     \&quot;name\&quot;: \&quot;lives\&quot;,     \&quot;valueString\&quot;: \&quot;lives\&quot;   } ] &#x60;&#x60;&#x60;  (optional)
    /// - parameter customJsonObjects: (query) a json object used by the scene atlas to position sprites. Example: &#x60;&#x60;&#x60;json {   \&quot;pShootingOffset\&quot;: [     {       \&quot;name\&quot;: \&quot;x\&quot;,       \&quot;valueString\&quot;: \&quot;2.2\&quot;     },     {       \&quot;name\&quot;: \&quot;y\&quot;,       \&quot;valueString\&quot;: \&quot;-0.3\&quot;     }   ],   \&quot;e1ShootingOffset\&quot;: [     {       \&quot;name\&quot;: \&quot;x\&quot;,       \&quot;valueString\&quot;: \&quot;0.25\&quot;     },     {       \&quot;name\&quot;: \&quot;y\&quot;,       \&quot;valueString\&quot;: \&quot;0.5\&quot;     }   ] } &#x60;&#x60;&#x60;  (optional)
    /// - parameter iconImage: (query) a MultipartFile containing the image used as the theme icon (optional)
    /// - parameter sceneAtlasImage: (query) a MultipartFile containing the scene atlas (optional)
    /// - parameter bgImage: (query) a MultipartFile containing the background image (optional)
    /// - parameter bgSound: (query) a MultipartFile containing the background sound file (preferably in MP3 format) (optional)
    /// - parameter musicSelection: (query) used to select a default sound file that already exists in the application (optional)
    /// - parameter locationDescription: (query) the description of the user&#39;s current location (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<ThemeDescriptorResponse, Error> 
    open func addOrUpdateThemeDescriptor(publicRead: Bool, publicWrite: Bool, publicDelete: Bool, publicAdd: Bool, visibility: AddOrUpdateThemeDescriptorVisibility, includeFriendGroup: Bool, completeWithDefaultValues: Bool, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, themeDescriptorId: Int64? = nil, title: String? = nil, description: String? = nil, connectionIdsToAdd: String? = nil, connectionGroupIdsToAdd: String? = nil, appVersion: String? = nil, colorValueJson: String? = nil, stringReplacerJson: String? = nil, customJsonObjects: String? = nil, iconImage: Data? = nil, sceneAtlasImage: Data? = nil, bgImage: Data? = nil, bgSound: Data? = nil, musicSelection: String? = nil, locationDescription: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ThemeDescriptorResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/theme"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let themeDescriptorId = themeDescriptorId { queryItems.append(URLQueryItem(name: "themeDescriptorId", value: "\(themeDescriptorId)")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                queryItems.append(URLQueryItem(name: "publicRead", value: publicRead ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "publicWrite", value: publicWrite ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "publicDelete", value: publicDelete ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "publicAdd", value: publicAdd ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue))
                if let connectionIdsToAdd = connectionIdsToAdd { queryItems.append(URLQueryItem(name: "connectionIdsToAdd", value: connectionIdsToAdd)) } 
                if let connectionGroupIdsToAdd = connectionGroupIdsToAdd { queryItems.append(URLQueryItem(name: "connectionGroupIdsToAdd", value: connectionGroupIdsToAdd)) } 
                queryItems.append(URLQueryItem(name: "includeFriendGroup", value: includeFriendGroup ? "true" : "false"))
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let colorValueJson = colorValueJson { queryItems.append(URLQueryItem(name: "colorValueJson", value: colorValueJson)) } 
                if let stringReplacerJson = stringReplacerJson { queryItems.append(URLQueryItem(name: "stringReplacerJson", value: stringReplacerJson)) } 
                if let customJsonObjects = customJsonObjects { queryItems.append(URLQueryItem(name: "customJsonObjects", value: customJsonObjects)) } 
                if let iconImage = iconImage { queryItems.append(URLQueryItem(name: "iconImage", value: )) } 
                if let sceneAtlasImage = sceneAtlasImage { queryItems.append(URLQueryItem(name: "sceneAtlasImage", value: )) } 
                if let bgImage = bgImage { queryItems.append(URLQueryItem(name: "bgImage", value: )) } 
                if let bgSound = bgSound { queryItems.append(URLQueryItem(name: "bgSound", value: )) } 
                if let musicSelection = musicSelection { queryItems.append(URLQueryItem(name: "musicSelection", value: musicSelection)) } 
                queryItems.append(URLQueryItem(name: "completeWithDefaultValues", value: completeWithDefaultValues ? "true" : "false"))
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ThemeDescriptorResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ThemeDescriptorResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Theme
    /// - GET /consumer/theme/get
    /// - Gets a theme.
    /// - parameter themeDescriptorId: (query) the theme id 
    /// - parameter deviceId: (query) a unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account ID of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) the application key (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<PurchaseItemListResponse, Error> 
    open func getThemeDescriptor(themeDescriptorId: Int64, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<PurchaseItemListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/theme/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                queryItems.append(URLQueryItem(name: "themeDescriptorId", value: "\(themeDescriptorId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PurchaseItemListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PurchaseItemListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Themes
    /// - GET /consumer/theme/search
    /// - Searches for themes.
    /// - parameter filter: (query) a comma separated list of Ownership 
    /// - parameter sortField: (query) the field to sort by. See ThemeDescriptorApiMap 
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order 
    /// - parameter start: (query) the start parameter for pagination 
    /// - parameter limit: (query) the limit parameter for pagination 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) the unique title of an application given from the admin tool (optional)
    /// - parameter contestType: (query) contest type (optional)
    /// - parameter ownerId: (query) search on contests that an account has access to (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) a keyword to search on (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter dateCreated: (query) filter on items that have been created before this date (optional)
    /// - parameter appVersion: (query) application version of the theme to filter by (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<PurchaseItemListResponse, Error> 
    open func getThemeDescriptors(filter: String, sortField: String, descending: Bool, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, contestType: String? = nil, ownerId: Int64? = nil, q: String? = nil, keyword: String? = nil, i: Int? = nil, l: Int? = nil, dateCreated: Int64? = nil, appVersion: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<PurchaseItemListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/theme/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let contestType = contestType { queryItems.append(URLQueryItem(name: "contestType", value: contestType)) } 
                if let ownerId = ownerId { queryItems.append(URLQueryItem(name: "ownerId", value: "\(ownerId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "filter", value: filter))
                queryItems.append(URLQueryItem(name: "sortField", value: sortField))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                if let dateCreated = dateCreated { queryItems.append(URLQueryItem(name: "dateCreated", value: "\(dateCreated)")) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PurchaseItemListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PurchaseItemListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Theme
    /// - POST /consumer/theme/remove
    /// - Removes a theme.
    /// - parameter themeDescriptorId: (query) the theme id to remove 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter gameType: (query) the unique title of an application given from the admin tool (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func removeThemeDescriptor(themeDescriptorId: Int64, deviceId: String? = nil, accountId: Int64? = nil, gameType: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/consumer/theme/remove"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                queryItems.append(URLQueryItem(name: "themeDescriptorId", value: "\(themeDescriptorId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
