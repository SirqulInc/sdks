//
// NoteAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class NoteAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Batch Note Operation
    /// - POST /note/batch
    /// - Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 
    /// - parameter notableId: (query) The id of the notable object the batch operation will affect 
    /// - parameter notableType: (query) The notable object type (for example ALBUM, ASSET, OFFER, etc.) 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter batchOperation: (query) The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional. (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func batchOperation(notableId: Int64, notableType: String, deviceId: String? = nil, accountId: Int64? = nil, batchOperation: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/note/batch"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "notableId", value: "\(notableId)"))
                queryItems.append(URLQueryItem(name: "notableType", value: notableType))
                if let batchOperation = batchOperation { queryItems.append(URLQueryItem(name: "batchOperation", value: batchOperation)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Note
    /// - POST /note/create
    /// - This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.
    /// - parameter comment: (query) The message the user wishes to leave a comment on 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter notableType: (query) The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
    /// - parameter notableId: (query) The id of the notable object (optional)
    /// - parameter noteType: (query) The custom string defined by the client (used for differentiating various note types) (optional)
    /// - parameter assetIds: (query) A comma separated list of asset IDs to add with the note (optional)
    /// - parameter tags: (query) search tags (optional)
    /// - parameter permissionableType: (query) This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
    /// - parameter permissionableId: (query) The id of the permissionable object (for sending group notifications) (optional)
    /// - parameter appKey: (query) The application key used to identify the application (optional)
    /// - parameter locationDescription: (query) The description of the location (optional)
    /// - parameter latitude: (query) The current location of the user (optional)
    /// - parameter longitude: (query) The current location of the user (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter receiverAccountIds: (query) Comma separated list of additional account IDs that will receive the note notifications (optional)
    /// - parameter returnFullResponse: (query) whether to return the full response or not (optional)
    /// - parameter initializeAsset: (query) Check true if need to initialize an asset and assign to current note (optional)
    /// - parameter assetReturnNulls: (query) Return null fields for asset response when creating an asset (optional)
    /// - parameter assetAlbumId: (query) the album the asset will be added to (optional) (optional)
    /// - parameter assetCollectionId: (query) the collection ID that the asset is associated with (optional)
    /// - parameter assetAddToDefaultAlbum: (query) the default album to add the asset to (optional)
    /// - parameter assetAddToMediaLibrary: (query) the media library to add the asset to (optional)
    /// - parameter assetVersionCode: (query) the version code of the asset (optional)
    /// - parameter assetVersionName: (query) the version name of the asset (optional)
    /// - parameter assetMetaData: (query) the meta data of the asset (optional)
    /// - parameter assetCaption: (query) the caption of the asset (optional)
    /// - parameter assetMedia: (query) the media of the asset (optional)
    /// - parameter assetMediaUrl: (query) the media URL of the asset (optional)
    /// - parameter assetMediaString: (query) the media string of the asset (optional)
    /// - parameter assetMediaStringFileName: (query) the media string file name of the asset (optional)
    /// - parameter assetMediaStringContentType: (query) the media string content type of the asset (optional)
    /// - parameter assetAttachedMedia: (query) the attached media of the asset (optional)
    /// - parameter assetAttachedMediaUrl: (query) the attached media URL of the asset (optional)
    /// - parameter assetAttachedMediaString: (query) the attached media string of the asset (optional)
    /// - parameter assetAttachedMediaStringFileName: (query) the attached media string file name of the asset (optional)
    /// - parameter assetAttachedMediaStringContentType: (query) the attached media string content type of the asset (optional)
    /// - parameter assetLocationDescription: (query) the location description for the asset (optional)
    /// - parameter assetApp: (query) the application for the asset (optional)
    /// - parameter assetSearchTags: (query) the search tags used for the asset (optional)
    /// - parameter assetLatitude: (query) the latitude of the asset (optional)
    /// - parameter assetLongitude: (query) the longitude of the asset (optional)
    /// - returns: AnyPublisher<NoteResponse, Error> 
    open func createNote(comment: String, deviceId: String? = nil, accountId: Int64? = nil, notableType: String? = nil, notableId: Int64? = nil, noteType: String? = nil, assetIds: String? = nil, tags: String? = nil, permissionableType: String? = nil, permissionableId: Int64? = nil, appKey: String? = nil, locationDescription: String? = nil, latitude: Double? = nil, longitude: Double? = nil, metaData: String? = nil, receiverAccountIds: String? = nil, returnFullResponse: Bool? = nil, initializeAsset: Bool? = nil, assetReturnNulls: Bool? = nil, assetAlbumId: Int64? = nil, assetCollectionId: Int64? = nil, assetAddToDefaultAlbum: String? = nil, assetAddToMediaLibrary: Bool? = nil, assetVersionCode: Int? = nil, assetVersionName: String? = nil, assetMetaData: String? = nil, assetCaption: String? = nil, assetMedia: Data? = nil, assetMediaUrl: String? = nil, assetMediaString: String? = nil, assetMediaStringFileName: String? = nil, assetMediaStringContentType: String? = nil, assetAttachedMedia: Data? = nil, assetAttachedMediaUrl: String? = nil, assetAttachedMediaString: String? = nil, assetAttachedMediaStringFileName: String? = nil, assetAttachedMediaStringContentType: String? = nil, assetLocationDescription: String? = nil, assetApp: String? = nil, assetSearchTags: String? = nil, assetLatitude: Double? = nil, assetLongitude: Double? = nil) -> AnyPublisher<NoteResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/note/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let notableType = notableType { queryItems.append(URLQueryItem(name: "notableType", value: notableType)) } 
                if let notableId = notableId { queryItems.append(URLQueryItem(name: "notableId", value: "\(notableId)")) } 
                queryItems.append(URLQueryItem(name: "comment", value: comment))
                if let noteType = noteType { queryItems.append(URLQueryItem(name: "noteType", value: noteType)) } 
                if let assetIds = assetIds { queryItems.append(URLQueryItem(name: "assetIds", value: assetIds)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let permissionableType = permissionableType { queryItems.append(URLQueryItem(name: "permissionableType", value: permissionableType)) } 
                if let permissionableId = permissionableId { queryItems.append(URLQueryItem(name: "permissionableId", value: "\(permissionableId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let receiverAccountIds = receiverAccountIds { queryItems.append(URLQueryItem(name: "receiverAccountIds", value: receiverAccountIds)) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                if let initializeAsset = initializeAsset { queryItems.append(URLQueryItem(name: "initializeAsset", value: initializeAsset ? "true" : "false")) } 
                if let assetReturnNulls = assetReturnNulls { queryItems.append(URLQueryItem(name: "assetReturnNulls", value: assetReturnNulls ? "true" : "false")) } 
                if let assetAlbumId = assetAlbumId { queryItems.append(URLQueryItem(name: "assetAlbumId", value: "\(assetAlbumId)")) } 
                if let assetCollectionId = assetCollectionId { queryItems.append(URLQueryItem(name: "assetCollectionId", value: "\(assetCollectionId)")) } 
                if let assetAddToDefaultAlbum = assetAddToDefaultAlbum { queryItems.append(URLQueryItem(name: "assetAddToDefaultAlbum", value: assetAddToDefaultAlbum)) } 
                if let assetAddToMediaLibrary = assetAddToMediaLibrary { queryItems.append(URLQueryItem(name: "assetAddToMediaLibrary", value: assetAddToMediaLibrary ? "true" : "false")) } 
                if let assetVersionCode = assetVersionCode { queryItems.append(URLQueryItem(name: "assetVersionCode", value: "\(assetVersionCode)")) } 
                if let assetVersionName = assetVersionName { queryItems.append(URLQueryItem(name: "assetVersionName", value: assetVersionName)) } 
                if let assetMetaData = assetMetaData { queryItems.append(URLQueryItem(name: "assetMetaData", value: assetMetaData)) } 
                if let assetCaption = assetCaption { queryItems.append(URLQueryItem(name: "assetCaption", value: assetCaption)) } 
                if let assetMedia = assetMedia { queryItems.append(URLQueryItem(name: "assetMedia", value: )) } 
                if let assetMediaUrl = assetMediaUrl { queryItems.append(URLQueryItem(name: "assetMediaUrl", value: assetMediaUrl)) } 
                if let assetMediaString = assetMediaString { queryItems.append(URLQueryItem(name: "assetMediaString", value: assetMediaString)) } 
                if let assetMediaStringFileName = assetMediaStringFileName { queryItems.append(URLQueryItem(name: "assetMediaStringFileName", value: assetMediaStringFileName)) } 
                if let assetMediaStringContentType = assetMediaStringContentType { queryItems.append(URLQueryItem(name: "assetMediaStringContentType", value: assetMediaStringContentType)) } 
                if let assetAttachedMedia = assetAttachedMedia { queryItems.append(URLQueryItem(name: "assetAttachedMedia", value: )) } 
                if let assetAttachedMediaUrl = assetAttachedMediaUrl { queryItems.append(URLQueryItem(name: "assetAttachedMediaUrl", value: assetAttachedMediaUrl)) } 
                if let assetAttachedMediaString = assetAttachedMediaString { queryItems.append(URLQueryItem(name: "assetAttachedMediaString", value: assetAttachedMediaString)) } 
                if let assetAttachedMediaStringFileName = assetAttachedMediaStringFileName { queryItems.append(URLQueryItem(name: "assetAttachedMediaStringFileName", value: assetAttachedMediaStringFileName)) } 
                if let assetAttachedMediaStringContentType = assetAttachedMediaStringContentType { queryItems.append(URLQueryItem(name: "assetAttachedMediaStringContentType", value: assetAttachedMediaStringContentType)) } 
                if let assetLocationDescription = assetLocationDescription { queryItems.append(URLQueryItem(name: "assetLocationDescription", value: assetLocationDescription)) } 
                if let assetApp = assetApp { queryItems.append(URLQueryItem(name: "assetApp", value: assetApp)) } 
                if let assetSearchTags = assetSearchTags { queryItems.append(URLQueryItem(name: "assetSearchTags", value: assetSearchTags)) } 
                if let assetLatitude = assetLatitude { queryItems.append(URLQueryItem(name: "assetLatitude", value: "\(assetLatitude)")) } 
                if let assetLongitude = assetLongitude { queryItems.append(URLQueryItem(name: "assetLongitude", value: "\(assetLongitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NoteResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NoteResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Note
    /// - POST /note/delete
    /// - Sets a comment (note) as deleted.
    /// - parameter noteId: (query) The ID of the note to delete 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter latitude: (query) The current location of the user (optional)
    /// - parameter longitude: (query) The current location of the user (optional)
    /// - parameter appKey: (query) The application key used to identify the application (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteNote(noteId: Int64, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil, appKey: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/note/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "noteId", value: "\(noteId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Note
    /// - POST /note/get
    /// - Get for a note based on its Id.
    /// - parameter noteId: (query) the id of the note to get 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter returnFullResponse: (query) Determines whether to return the NoteFullResponse for the item (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func getNote(noteId: Int64, deviceId: String? = nil, accountId: Int64? = nil, returnFullResponse: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/note/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                queryItems.append(URLQueryItem(name: "noteId", value: "\(noteId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchNotesSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case ownerDisplay = "OWNER_DISPLAY"
        case notableType = "NOTABLE_TYPE"
        case noteTag = "NOTE_TAG"
        case noteCount = "NOTE_COUNT"
        case likes = "LIKES"
        case dislikes = "DISLIKES"
    }

    /// Search Notes
    /// - POST /note/search
    /// - Search for notes on a notable object.
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter notableType: (query) The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR} (optional)
    /// - parameter notableId: (query) The id of the notable object (optional)
    /// - parameter noteTypes: (query) Comma separated list of noteType strings to filter results with (optional)
    /// - parameter appKey: (query) The application key used to identify the application (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter flagCountMinimum: (query) return items that has flagCount &gt;&#x3D; flagCountMinimum if this is set, return all items, even ones with flagCount &gt;&#x3D; flagThreshold (optional)
    /// - parameter flagsExceedThreshold: (query) return items that has flagCount &gt;&#x3D; flagThreshold, which are hidden by default (optional)
    /// - parameter includeInactive: (query) include inactive in the result (optional)
    /// - parameter sortField: (query) The column to sort the search on (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter returnFullResponse: (query) Determines whether to return the NoteFullResponse for each search item (optional)
    /// - parameter updatedSince: (query) return items that have been updated since this date (time-stamp in milliseconds) (optional)
    /// - parameter updatedBefore: (query) return items that have been updated before this date (time-stamp in milliseconds) (optional)
    /// - parameter start: (query) The record to begin the return set on (optional)
    /// - parameter limit: (query) The number of records to return (optional)
    /// - returns: AnyPublisher<[NoteResponse], Error> 
    open func searchNotes(deviceId: String? = nil, accountId: Int64? = nil, notableType: String? = nil, notableId: Int64? = nil, noteTypes: String? = nil, appKey: String? = nil, keyword: String? = nil, flagCountMinimum: Int64? = nil, flagsExceedThreshold: Bool? = nil, includeInactive: Bool? = nil, sortField: SearchNotesSortField? = nil, descending: Bool? = nil, returnFullResponse: Bool? = nil, updatedSince: Int64? = nil, updatedBefore: Int64? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[NoteResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/note/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let notableType = notableType { queryItems.append(URLQueryItem(name: "notableType", value: notableType)) } 
                if let notableId = notableId { queryItems.append(URLQueryItem(name: "notableId", value: "\(notableId)")) } 
                if let noteTypes = noteTypes { queryItems.append(URLQueryItem(name: "noteTypes", value: noteTypes)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let flagCountMinimum = flagCountMinimum { queryItems.append(URLQueryItem(name: "flagCountMinimum", value: "\(flagCountMinimum)")) } 
                if let flagsExceedThreshold = flagsExceedThreshold { queryItems.append(URLQueryItem(name: "flagsExceedThreshold", value: flagsExceedThreshold ? "true" : "false")) } 
                if let includeInactive = includeInactive { queryItems.append(URLQueryItem(name: "includeInactive", value: includeInactive ? "true" : "false")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                if let updatedSince = updatedSince { queryItems.append(URLQueryItem(name: "updatedSince", value: "\(updatedSince)")) } 
                if let updatedBefore = updatedBefore { queryItems.append(URLQueryItem(name: "updatedBefore", value: "\(updatedBefore)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[NoteResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([NoteResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Note
    /// - POST /note/update
    /// - Update an existing comment (note). Only the creator of the note have permission to update.
    /// - parameter noteId: (query) The id of the note, used when editing a comment 
    /// - parameter deviceId: (query) The unique device identifier that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter accountId: (query) The unique accountId that made the request (either deviceId or accountId must be used) (optional)
    /// - parameter comment: (query) The message the user wishes to leave a comment on (optional)
    /// - parameter noteType: (query) The custom string defined by the client (used for differentiating on various note types) (optional)
    /// - parameter assetIds: (query) A comma separated list of asset IDs to add with the note (optional)
    /// - parameter tags: (query) search tags (optional)
    /// - parameter permissionableType: (query) This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \&quot;album\&quot;), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR} (optional)
    /// - parameter permissionableId: (query) The id of the permissionable object (for sending group notifications) (optional)
    /// - parameter appKey: (query) The application key used to identify the application (optional)
    /// - parameter locationDescription: (query) The description of the location (optional)
    /// - parameter latitude: (query) The current location of the user (optional)
    /// - parameter longitude: (query) The current location of the user (optional)
    /// - parameter metaData: (query) meta data to update with the note (optional)
    /// - parameter returnFullResponse: (query) whether to return the full response or not (optional)
    /// - parameter active: (query) Sets the active flag for the note (optional)
    /// - parameter updateAsset: (query) main flag for updating asset in note, must set to true if you want to update the note&#39;s asset (optional)
    /// - parameter assetReturnNulls: (query) Return null fields for asset response when updating an asset (optional)
    /// - parameter assetAlbumId: (query) the album the asset will be added to (optional) (optional)
    /// - parameter assetCollectionId: (query) the collection ID that the asset is associated with (optional)
    /// - parameter assetAddToDefaultAlbum: (query) the default album to add the asset to (optional)
    /// - parameter assetAddToMediaLibrary: (query) the media library to add the asset to (optional)
    /// - parameter assetVersionCode: (query) the version code of the asset (optional)
    /// - parameter assetVersionName: (query) the version name of the asset (optional)
    /// - parameter assetMetaData: (query) the meta data of the asset (optional)
    /// - parameter assetCaption: (query) the caption of the asset (optional)
    /// - parameter assetMedia: (query) the media of the asset (optional)
    /// - parameter assetMediaUrl: (query) the media URL of the asset (optional)
    /// - parameter assetMediaString: (query) the media string of the asset (optional)
    /// - parameter assetMediaStringFileName: (query) the media string file name of the asset (optional)
    /// - parameter assetMediaStringContentType: (query) the media string content type of the asset (optional)
    /// - parameter assetAttachedMedia: (query) the attached media of the asset (optional)
    /// - parameter assetAttachedMediaUrl: (query) the attached media URL of the asset (optional)
    /// - parameter assetAttachedMediaString: (query) the attached media string of the asset (optional)
    /// - parameter assetAttachedMediaStringFileName: (query) the attached media string file name of the asset (optional)
    /// - parameter assetAttachedMediaStringContentType: (query) the attached media string content type of the asset (optional)
    /// - parameter assetLocationDescription: (query) the location description for the asset (optional)
    /// - parameter assetApp: (query) the application for the asset (optional)
    /// - parameter assetSearchTags: (query) the search tags used for the asset (optional)
    /// - parameter assetLatitude: (query) the latitude of the asset (optional)
    /// - parameter assetLongitude: (query) the longitude of the asset (optional)
    /// - returns: AnyPublisher<NoteResponse, Error> 
    open func updateNote(noteId: Int64, deviceId: String? = nil, accountId: Int64? = nil, comment: String? = nil, noteType: String? = nil, assetIds: String? = nil, tags: String? = nil, permissionableType: String? = nil, permissionableId: Int64? = nil, appKey: String? = nil, locationDescription: String? = nil, latitude: Double? = nil, longitude: Double? = nil, metaData: String? = nil, returnFullResponse: Bool? = nil, active: Bool? = nil, updateAsset: Bool? = nil, assetReturnNulls: Bool? = nil, assetAlbumId: Int64? = nil, assetCollectionId: Int64? = nil, assetAddToDefaultAlbum: String? = nil, assetAddToMediaLibrary: Bool? = nil, assetVersionCode: Int? = nil, assetVersionName: String? = nil, assetMetaData: String? = nil, assetCaption: String? = nil, assetMedia: Data? = nil, assetMediaUrl: String? = nil, assetMediaString: String? = nil, assetMediaStringFileName: String? = nil, assetMediaStringContentType: String? = nil, assetAttachedMedia: Data? = nil, assetAttachedMediaUrl: String? = nil, assetAttachedMediaString: String? = nil, assetAttachedMediaStringFileName: String? = nil, assetAttachedMediaStringContentType: String? = nil, assetLocationDescription: String? = nil, assetApp: String? = nil, assetSearchTags: String? = nil, assetLatitude: Double? = nil, assetLongitude: Double? = nil) -> AnyPublisher<NoteResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/note/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "noteId", value: "\(noteId)"))
                if let comment = comment { queryItems.append(URLQueryItem(name: "comment", value: comment)) } 
                if let noteType = noteType { queryItems.append(URLQueryItem(name: "noteType", value: noteType)) } 
                if let assetIds = assetIds { queryItems.append(URLQueryItem(name: "assetIds", value: assetIds)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                if let permissionableType = permissionableType { queryItems.append(URLQueryItem(name: "permissionableType", value: permissionableType)) } 
                if let permissionableId = permissionableId { queryItems.append(URLQueryItem(name: "permissionableId", value: "\(permissionableId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let updateAsset = updateAsset { queryItems.append(URLQueryItem(name: "updateAsset", value: updateAsset ? "true" : "false")) } 
                if let assetReturnNulls = assetReturnNulls { queryItems.append(URLQueryItem(name: "assetReturnNulls", value: assetReturnNulls ? "true" : "false")) } 
                if let assetAlbumId = assetAlbumId { queryItems.append(URLQueryItem(name: "assetAlbumId", value: "\(assetAlbumId)")) } 
                if let assetCollectionId = assetCollectionId { queryItems.append(URLQueryItem(name: "assetCollectionId", value: "\(assetCollectionId)")) } 
                if let assetAddToDefaultAlbum = assetAddToDefaultAlbum { queryItems.append(URLQueryItem(name: "assetAddToDefaultAlbum", value: assetAddToDefaultAlbum)) } 
                if let assetAddToMediaLibrary = assetAddToMediaLibrary { queryItems.append(URLQueryItem(name: "assetAddToMediaLibrary", value: assetAddToMediaLibrary ? "true" : "false")) } 
                if let assetVersionCode = assetVersionCode { queryItems.append(URLQueryItem(name: "assetVersionCode", value: "\(assetVersionCode)")) } 
                if let assetVersionName = assetVersionName { queryItems.append(URLQueryItem(name: "assetVersionName", value: assetVersionName)) } 
                if let assetMetaData = assetMetaData { queryItems.append(URLQueryItem(name: "assetMetaData", value: assetMetaData)) } 
                if let assetCaption = assetCaption { queryItems.append(URLQueryItem(name: "assetCaption", value: assetCaption)) } 
                if let assetMedia = assetMedia { queryItems.append(URLQueryItem(name: "assetMedia", value: )) } 
                if let assetMediaUrl = assetMediaUrl { queryItems.append(URLQueryItem(name: "assetMediaUrl", value: assetMediaUrl)) } 
                if let assetMediaString = assetMediaString { queryItems.append(URLQueryItem(name: "assetMediaString", value: assetMediaString)) } 
                if let assetMediaStringFileName = assetMediaStringFileName { queryItems.append(URLQueryItem(name: "assetMediaStringFileName", value: assetMediaStringFileName)) } 
                if let assetMediaStringContentType = assetMediaStringContentType { queryItems.append(URLQueryItem(name: "assetMediaStringContentType", value: assetMediaStringContentType)) } 
                if let assetAttachedMedia = assetAttachedMedia { queryItems.append(URLQueryItem(name: "assetAttachedMedia", value: )) } 
                if let assetAttachedMediaUrl = assetAttachedMediaUrl { queryItems.append(URLQueryItem(name: "assetAttachedMediaUrl", value: assetAttachedMediaUrl)) } 
                if let assetAttachedMediaString = assetAttachedMediaString { queryItems.append(URLQueryItem(name: "assetAttachedMediaString", value: assetAttachedMediaString)) } 
                if let assetAttachedMediaStringFileName = assetAttachedMediaStringFileName { queryItems.append(URLQueryItem(name: "assetAttachedMediaStringFileName", value: assetAttachedMediaStringFileName)) } 
                if let assetAttachedMediaStringContentType = assetAttachedMediaStringContentType { queryItems.append(URLQueryItem(name: "assetAttachedMediaStringContentType", value: assetAttachedMediaStringContentType)) } 
                if let assetLocationDescription = assetLocationDescription { queryItems.append(URLQueryItem(name: "assetLocationDescription", value: assetLocationDescription)) } 
                if let assetApp = assetApp { queryItems.append(URLQueryItem(name: "assetApp", value: assetApp)) } 
                if let assetSearchTags = assetSearchTags { queryItems.append(URLQueryItem(name: "assetSearchTags", value: assetSearchTags)) } 
                if let assetLatitude = assetLatitude { queryItems.append(URLQueryItem(name: "assetLatitude", value: "\(assetLatitude)")) } 
                if let assetLongitude = assetLongitude { queryItems.append(URLQueryItem(name: "assetLongitude", value: "\(assetLongitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NoteResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NoteResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
