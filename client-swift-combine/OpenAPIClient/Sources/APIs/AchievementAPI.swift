//
// AchievementAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AchievementAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Searches an Achievement Tier
    /// - POST /api/{version}/achievement/tier/search
    /// - Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter keyword: (query) the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier) (optional)
    /// - parameter achievementType: (query) filter results by achievementType (these are exact case sensitive matches) (optional)
    /// - parameter rankType: (query) filter results by the rankType (these are the exact case sensitive matches) (optional)
    /// - parameter sortField: (query) the field to sort by. See {@link AchievementApiMap} (optional)
    /// - parameter descending: (query) determines whether the sort list is in descending or ascending order (of the achievement) (optional)
    /// - parameter descendingGoal: (query) determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement) (optional)
    /// - parameter start: (query) The start of the index for pagination (optional)
    /// - parameter limit: (query) the limit for pagination (has a hard limit of 1000) (optional)
    /// - returns: AnyPublisher<AchievementTierResponse, Error> 
    open func apiVersionAchievementTierSearchPost(version: Double, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, keyword: String? = nil, achievementType: Int64? = nil, rankType: String? = nil, sortField: String? = nil, descending: Bool? = nil, descendingGoal: Bool? = nil, start: Int64? = nil, limit: Int64? = nil) -> AnyPublisher<AchievementTierResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/tier/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let achievementType = achievementType { queryItems.append(URLQueryItem(name: "achievementType", value: "\(achievementType)")) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let descendingGoal = descendingGoal { queryItems.append(URLQueryItem(name: "descendingGoal", value: descendingGoal ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementTierResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementTierResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Achievement
    /// - POST /api/{version}/achievement/create
    /// - Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) the application key the achievement is for 
    /// - parameter title: (query) the title of the achievement (255 character limit) 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter analyticsTag: (query) the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
    /// - parameter description: (query) the description of the achievement (optional)
    /// - parameter rankType: (query) the rank type for updating leader boards (optional)
    /// - parameter rankIncrement: (query) determines how much the rank count is incremented (optional)
    /// - parameter minIncrement: (query) restrict scores to be above or equal to this minimum value (optional)
    /// - parameter maxIncrement: (query) restrict scores to be below or equal to this maximum value (optional)
    /// - parameter validate: (query) determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
    /// - parameter active: (query) achievement is active or inactive (optional)
    /// - parameter triggerDefinition: (query) if provided will define what triggers to run after a tier is completed (optional)
    /// - returns: AnyPublisher<AchievementResponse, Error> 
    open func createAchievement(version: Double, appKey: String, title: String, deviceId: String? = nil, accountId: Int64? = nil, analyticsTag: String? = nil, description: String? = nil, rankType: String? = nil, rankIncrement: Int? = nil, minIncrement: Int? = nil, maxIncrement: Int? = nil, validate: Bool? = nil, active: Bool? = nil, triggerDefinition: String? = nil) -> AnyPublisher<AchievementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let analyticsTag = analyticsTag { queryItems.append(URLQueryItem(name: "analyticsTag", value: analyticsTag)) } 
                queryItems.append(URLQueryItem(name: "title", value: title))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let rankIncrement = rankIncrement { queryItems.append(URLQueryItem(name: "rankIncrement", value: "\(rankIncrement)")) } 
                if let minIncrement = minIncrement { queryItems.append(URLQueryItem(name: "minIncrement", value: "\(minIncrement)")) } 
                if let maxIncrement = maxIncrement { queryItems.append(URLQueryItem(name: "maxIncrement", value: "\(maxIncrement)")) } 
                if let validate = validate { queryItems.append(URLQueryItem(name: "validate", value: validate ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let triggerDefinition = triggerDefinition { queryItems.append(URLQueryItem(name: "triggerDefinition", value: triggerDefinition)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Achievement Tier
    /// - POST /api/{version}/achievement/tier/create
    /// - Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter achievementId: (query) the achievement id for adding a new tier 
    /// - parameter scoreAllInstances: (query) score all instances 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter icon: (query) achievement tier icon image file (optional)
    /// - parameter iconAssetId: (query) the icon assetId, if icon is provided, icon will overrule (optional)
    /// - parameter title: (query) the title of the achievement tier (optional)
    /// - parameter description: (query) the description of the achievement tier (optional)
    /// - parameter goalCount: (query) the count requirement for completing the achievement tier (optional)
    /// - parameter missionId: (query) The ID of the mission to associate with the achievement (optional)
    /// - parameter gameId: (query) The ID of the game to associate with the achievement (optional)
    /// - parameter packId: (query) The ID of the pack to associate with the achievement (optional)
    /// - parameter gameLevelId: (query) The ID of the game level to associate with the achievement (optional)
    /// - parameter gameObjectId: (query) The ID of the game object to associate with the achievement (optional)
    /// - returns: AnyPublisher<AchievementTierResponse, Error> 
    open func createAchievementTier(version: Double, achievementId: Int64, scoreAllInstances: Bool, deviceId: String? = nil, accountId: Int64? = nil, icon: Data? = nil, iconAssetId: Int64? = nil, title: String? = nil, description: String? = nil, goalCount: Int64? = nil, missionId: Int64? = nil, gameId: Int64? = nil, packId: Int64? = nil, gameLevelId: Int64? = nil, gameObjectId: Int? = nil) -> AnyPublisher<AchievementTierResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/tier/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "achievementId", value: "\(achievementId)"))
                if let icon = icon { queryItems.append(URLQueryItem(name: "icon", value: )) } 
                if let iconAssetId = iconAssetId { queryItems.append(URLQueryItem(name: "iconAssetId", value: "\(iconAssetId)")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let goalCount = goalCount { queryItems.append(URLQueryItem(name: "goalCount", value: "\(goalCount)")) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let gameId = gameId { queryItems.append(URLQueryItem(name: "gameId", value: "\(gameId)")) } 
                if let packId = packId { queryItems.append(URLQueryItem(name: "packId", value: "\(packId)")) } 
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                if let gameObjectId = gameObjectId { queryItems.append(URLQueryItem(name: "gameObjectId", value: "\(gameObjectId)")) } 
                queryItems.append(URLQueryItem(name: "scoreAllInstances", value: scoreAllInstances ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementTierResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementTierResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Achievement
    /// - POST /api/{version}/achievement/delete
    /// - Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.
    /// - parameter version: (path)  
    /// - parameter achievementId: (query) The ID of the achievement 
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteAchievement(version: Double, achievementId: Int64, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "achievementId", value: "\(achievementId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Achievement Tier
    /// - POST /api/{version}/achievement/tier/delete
    /// - Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.
    /// - parameter version: (path)  
    /// - parameter achievementTierId: (query) the achievement id for deletion 
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required). (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteAchievementTier(version: Double, achievementTierId: Int64, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/tier/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "achievementTierId", value: "\(achievementTierId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Achievement
    /// - GET /api/{version}/achievement/get
    /// - Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter achievementId: (query) The ID of the achievement 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter achievementType: (query) achievementType (optional)
    /// - returns: AnyPublisher<AchievementTierResponse, Error> 
    open func getAchievement(version: Double, achievementId: Int64, deviceId: String? = nil, accountId: Int64? = nil, achievementType: String? = nil) -> AnyPublisher<AchievementTierResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "achievementId", value: "\(achievementId)"))
                if let achievementType = achievementType { queryItems.append(URLQueryItem(name: "achievementType", value: achievementType)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementTierResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementTierResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Gets an achievement tier
    /// - POST /api/{version}/achievement/tier/get
    /// - Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) 
    /// - parameter achievementTierId: (query) the achievement tier id that is being retrieved 
    /// - returns: AnyPublisher<AchievementTierResponse, Error> 
    open func getAchievementTier(version: Double, accountId: Int64, achievementTierId: Int64) -> AnyPublisher<AchievementTierResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/tier/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "achievementTierId", value: "\(achievementTierId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementTierResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementTierResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Achievement Progress
    /// - GET /api/{version}/achievement/progress/get
    /// - Gets a list of user achievements.
    /// - parameter version: (path)  
    /// - parameter returnNulls: (query) determines whether to return null fields in the response 
    /// - parameter appKey: (query) the application key for filtering results by application 
    /// - parameter includeUndiscovered: (query) determines whether to return achievements that the user has not discovered yet 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionAccountEmail: (query) the email of the account to view achievements (optional)
    /// - parameter connectionAccountId: (query) the id of the account to view achievements (optional)
    /// - parameter rankType: (query) filter results by achievement rankType (optional)
    /// - parameter achievementType: (query) filter results by achievement type (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<[AchievementProgressResponse], Error> 
    open func getUserAchievements(version: Double, returnNulls: Bool, appKey: String, includeUndiscovered: Bool, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountEmail: String? = nil, connectionAccountId: Int64? = nil, rankType: String? = nil, achievementType: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<[AchievementProgressResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/progress/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "returnNulls", value: returnNulls ? "true" : "false"))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountEmail = connectionAccountEmail { queryItems.append(URLQueryItem(name: "connectionAccountEmail", value: connectionAccountEmail)) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let achievementType = achievementType { queryItems.append(URLQueryItem(name: "achievementType", value: achievementType)) } 
                queryItems.append(URLQueryItem(name: "includeUndiscovered", value: includeUndiscovered ? "true" : "false"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AchievementProgressResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AchievementProgressResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// List Achievement Tags
    /// - GET /api/{version}/achievement/tag/list
    /// - List achievement tags by application
    /// - parameter version: (path)  
    /// - parameter appKey: (query) filter results by application key (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func listAchievementTags(version: Double, appKey: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/tag/list"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum ListAchievementsSortField: String, Codable, CaseIterable {
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case title = "TITLE"
        case description = "DESCRIPTION"
        case rankType = "RANK_TYPE"
        case applicationId = "APPLICATION_ID"
        case applicationName = "APPLICATION_NAME"
        case billableId = "BILLABLE_ID"
    }

    /// List Achievements
    /// - GET /api/{version}/achievement/list
    /// - List achievements by billable.
    /// - parameter version: (path)  
    /// - parameter sortField: (query) the field to sort by. See AchievementApiMap 
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order 
    /// - parameter start: (query) the start index for pagination 
    /// - parameter limit: (query) the limit for pagination (has a hard limit of 1000) 
    /// - parameter activeOnly: (query) Filter results to only return active achievements 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter keyword: (query) the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
    /// - parameter achievementType: (query) filter results by the achievementType (these are exact case sensitive matches) (optional)
    /// - parameter rankType: (query) filter results by the rankType (these are exact case sensitive matches) (optional)
    /// - returns: AnyPublisher<[AchievementShortResponse], Error> 
    open func listAchievements(version: Double, sortField: ListAchievementsSortField, descending: Bool, start: Int, limit: Int, activeOnly: Bool, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, keyword: String? = nil, achievementType: String? = nil, rankType: String? = nil) -> AnyPublisher<[AchievementShortResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/list"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let achievementType = achievementType { queryItems.append(URLQueryItem(name: "achievementType", value: achievementType)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AchievementShortResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AchievementShortResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchAchievementsSortField: String, Codable, CaseIterable {
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case title = "TITLE"
        case description = "DESCRIPTION"
        case rankType = "RANK_TYPE"
        case applicationId = "APPLICATION_ID"
        case applicationName = "APPLICATION_NAME"
        case billableId = "BILLABLE_ID"
    }

    /// Search Achievements
    /// - GET /api/{version}/achievement/search
    /// - Searches achievements by application for consumers.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) the application key 
    /// - parameter sortField: (query) the field to sort by. See AchievementApiMap 
    /// - parameter descending: (query) determines whether the sorted list is in descending or ascending order 
    /// - parameter includeTiers: (query) return tiers, only applicable for version &gt;3.18 
    /// - parameter includeInactiveTiers: (query) return inactive tiers, only applicable when includeTiers is true, only applicable for version &gt;3.18 
    /// - parameter start: (query) the start index for pagination 
    /// - parameter limit: (query) the limit for pagination (has a hard limit of 1000) 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter keyword: (query) the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement) (optional)
    /// - parameter achievementType: (query) filter results by the achievementType (these are exact case sensitive matches) (optional)
    /// - parameter rankType: (query) filter results by the rankType (these are exact case sensitive matches) (optional)
    /// - returns: AnyPublisher<[AchievementShortResponse], Error> 
    open func searchAchievements(version: Double, appKey: String, sortField: SearchAchievementsSortField, descending: Bool, includeTiers: Bool, includeInactiveTiers: Bool, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, keyword: String? = nil, achievementType: String? = nil, rankType: String? = nil) -> AnyPublisher<[AchievementShortResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let achievementType = achievementType { queryItems.append(URLQueryItem(name: "achievementType", value: achievementType)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includeTiers", value: includeTiers ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "includeInactiveTiers", value: includeInactiveTiers ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AchievementShortResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AchievementShortResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Achievement
    /// - POST /api/{version}/achievement/update
    /// - Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter achievementId: (query) the achievement ID for updating an existing achievement (optional)
    /// - parameter analyticsTag: (query) the analytics tag that will trigger when a user&#39;s achievement count gets updated (optional)
    /// - parameter title: (query) the title of the achievement (255 character limit) (optional)
    /// - parameter description: (query) the description of the achievement (optional)
    /// - parameter rankType: (query) the rank type for updating leader boards (optional)
    /// - parameter rankIncrement: (query) determines how much the rank count is incremented (optional)
    /// - parameter minIncrement: (query) restrict scores to be above or equal to this minimum value (optional)
    /// - parameter nullMinIncrement: (query) enable to ignore usage of minIncrement (optional)
    /// - parameter maxIncrement: (query) restrict scores to be below or equal to this maximum value (optional)
    /// - parameter nullMaxIncrement: (query) enable to ignore usage of maxIncrement (optional)
    /// - parameter validate: (query) determines whether the customId on analytics are used to validate a user&#39;s achievement progress. (optional)
    /// - parameter active: (query) if it&#39;s active or inactive (optional)
    /// - parameter triggerDefinition: (query) if provided will define what triggers to run after a tier is completed (optional)
    /// - returns: AnyPublisher<AchievementResponse, Error> 
    open func updateAchievement(version: Double, deviceId: String? = nil, accountId: Int64? = nil, achievementId: Int64? = nil, analyticsTag: String? = nil, title: String? = nil, description: String? = nil, rankType: String? = nil, rankIncrement: Int? = nil, minIncrement: Int? = nil, nullMinIncrement: Bool? = nil, maxIncrement: Int? = nil, nullMaxIncrement: Bool? = nil, validate: Bool? = nil, active: Bool? = nil, triggerDefinition: String? = nil) -> AnyPublisher<AchievementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let achievementId = achievementId { queryItems.append(URLQueryItem(name: "achievementId", value: "\(achievementId)")) } 
                if let analyticsTag = analyticsTag { queryItems.append(URLQueryItem(name: "analyticsTag", value: analyticsTag)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let rankIncrement = rankIncrement { queryItems.append(URLQueryItem(name: "rankIncrement", value: "\(rankIncrement)")) } 
                if let minIncrement = minIncrement { queryItems.append(URLQueryItem(name: "minIncrement", value: "\(minIncrement)")) } 
                if let nullMinIncrement = nullMinIncrement { queryItems.append(URLQueryItem(name: "nullMinIncrement", value: nullMinIncrement ? "true" : "false")) } 
                if let maxIncrement = maxIncrement { queryItems.append(URLQueryItem(name: "maxIncrement", value: "\(maxIncrement)")) } 
                if let nullMaxIncrement = nullMaxIncrement { queryItems.append(URLQueryItem(name: "nullMaxIncrement", value: nullMaxIncrement ? "true" : "false")) } 
                if let validate = validate { queryItems.append(URLQueryItem(name: "validate", value: validate ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let triggerDefinition = triggerDefinition { queryItems.append(URLQueryItem(name: "triggerDefinition", value: triggerDefinition)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Achievement Tier
    /// - POST /api/{version}/achievement/tier/update
    /// - Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.
    /// - parameter version: (path)  
    /// - parameter achievementTierId: (query) the achievement tier id for updating 
    /// - parameter deviceId: (query) a unique id given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter icon: (query) achievement tier icon image file (optional)
    /// - parameter iconAssetId: (query) the icon assetId, if icon is provided, icon will overrule (optional)
    /// - parameter title: (query) the title of the achievement tier (optional)
    /// - parameter description: (query) the description of the achievement tier (optional)
    /// - parameter goalCount: (query) the count requirement for completing the achievement tier (optional)
    /// - parameter missionId: (query) The ID of the mission to associate with the achievement (optional)
    /// - parameter gameId: (query) The ID of the game to associate with the achievement (optional)
    /// - parameter packId: (query) The ID of the pack to associate with the achievement (optional)
    /// - parameter gameLevelId: (query) The ID of the game level to associate with the achievement (optional)
    /// - parameter gameObjectId: (query) The ID of the game object to associate with the achievement (optional)
    /// - parameter scoreAllInstances: (query) score all instances (optional)
    /// - returns: AnyPublisher<AchievementTierResponse, Error> 
    open func updateAchievementTier(version: Double, achievementTierId: Int64, deviceId: String? = nil, accountId: Int64? = nil, icon: Data? = nil, iconAssetId: Int64? = nil, title: String? = nil, description: String? = nil, goalCount: Int64? = nil, missionId: Int64? = nil, gameId: Int64? = nil, packId: Int64? = nil, gameLevelId: Int64? = nil, gameObjectId: Int64? = nil, scoreAllInstances: Bool? = nil) -> AnyPublisher<AchievementTierResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/tier/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "achievementTierId", value: "\(achievementTierId)"))
                if let icon = icon { queryItems.append(URLQueryItem(name: "icon", value: )) } 
                if let iconAssetId = iconAssetId { queryItems.append(URLQueryItem(name: "iconAssetId", value: "\(iconAssetId)")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let goalCount = goalCount { queryItems.append(URLQueryItem(name: "goalCount", value: "\(goalCount)")) } 
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let gameId = gameId { queryItems.append(URLQueryItem(name: "gameId", value: "\(gameId)")) } 
                if let packId = packId { queryItems.append(URLQueryItem(name: "packId", value: "\(packId)")) } 
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                if let gameObjectId = gameObjectId { queryItems.append(URLQueryItem(name: "gameObjectId", value: "\(gameObjectId)")) } 
                if let scoreAllInstances = scoreAllInstances { queryItems.append(URLQueryItem(name: "scoreAllInstances", value: scoreAllInstances ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AchievementTierResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AchievementTierResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Achievement Progress
    /// - POST /api/{version}/achievement/progress/update
    /// - Update user achievement progress.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter achievementId: (query) the achievement id (achievementId or tag required) (optional)
    /// - parameter tag: (query) the analytic tag to identify an achievement (achievementId or tag required) (optional)
    /// - parameter customId: (query) a custom identifier used for validation (optional)
    /// - parameter increment: (query) the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement&#39;s rankIncrement value) (optional)
    /// - parameter startDate: (query) a custom start date that the client can set (not yet used in server logic) (optional)
    /// - parameter endDate: (query) a custom end date that the client can set (not yet used in server logic) (optional)
    /// - parameter returnProgress: (query) determines whether to return the achievement progress response (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateUserAchievement(version: Double, accountId: Int64, achievementId: Int64? = nil, tag: String? = nil, customId: Int64? = nil, increment: Int64? = nil, startDate: Int64? = nil, endDate: Int64? = nil, returnProgress: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/achievement/progress/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let achievementId = achievementId { queryItems.append(URLQueryItem(name: "achievementId", value: "\(achievementId)")) } 
                if let tag = tag { queryItems.append(URLQueryItem(name: "tag", value: tag)) } 
                if let customId = customId { queryItems.append(URLQueryItem(name: "customId", value: "\(customId)")) } 
                if let increment = increment { queryItems.append(URLQueryItem(name: "increment", value: "\(increment)")) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let returnProgress = returnProgress { queryItems.append(URLQueryItem(name: "returnProgress", value: returnProgress ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
