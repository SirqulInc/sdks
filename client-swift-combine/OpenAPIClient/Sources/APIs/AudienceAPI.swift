//
// AudienceAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AudienceAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Audience
    /// - POST /audience/create
    /// - Create a user defined audience.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter name: (query) The name of the audience 
    /// - parameter description: (query) The description of the audience (optional)
    /// - parameter searchTags: (query) The search tags (optional)
    /// - parameter gender: (query) The gender; possible values are: MALE, FEMALE, ANY (optional)
    /// - parameter ageGroups: (query) The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
    /// - parameter categoryIds: (query) The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
    /// - parameter applicationIds: (query) The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
    /// - parameter gameExperienceLevel: (query) The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
    /// - parameter devices: (query) (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
    /// - parameter deviceIds: (query) The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
    /// - parameter deviceVersions: (query) The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
    /// - parameter locations: (query) The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
    /// - parameter radius: (query) The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
    /// - parameter startTimeOffset: (query) Seconds from the start time of an event (optional)
    /// - parameter endTimeOffset: (query) Seconds from the end time of an event (optional)
    /// - parameter sendSuggestion: (query) If true, then notify matching users when they are inside the radius (optional, default to true)
    /// - parameter associateDescription: (query) The description of the associated object (optional)
    /// - parameter associateType: (query) The type of the object to center the audience geofence (optional)
    /// - parameter associateId: (query) The ID of the object to center the audience geofence (optional)
    /// - parameter groupingId: (query) Optional grouping id for the audience (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter visibility: (query) Visibility of the audience (optional)
    /// - parameter audienceType: (query) Type of audience (optional)
    /// - parameter useOrder: (query) Use order for cohort (optional)
    /// - parameter cohortRegionsData: (query) Cohort data for \&quot;cohort\&quot; audience type (optional)
    /// - parameter appKey: (query) Filter results by application key (optional)
    /// - parameter trilaterationTypes: (query) Trilateration types (optional)
    /// - parameter uniqueName: (query) If true, makes sure the audience name is unique (optional)
    /// - returns: AnyPublisher<AudienceResponse, Error> 
    open func createAudience(accountId: Int64, name: String, description: String? = nil, searchTags: String? = nil, gender: String? = nil, ageGroups: String? = nil, categoryIds: String? = nil, applicationIds: String? = nil, gameExperienceLevel: String? = nil, devices: String? = nil, deviceIds: String? = nil, deviceVersions: String? = nil, locations: String? = nil, radius: String? = nil, startTimeOffset: Int? = nil, endTimeOffset: Int? = nil, sendSuggestion: Bool? = nil, associateDescription: String? = nil, associateType: String? = nil, associateId: Int64? = nil, groupingId: String? = nil, metaData: String? = nil, visibility: String? = nil, audienceType: String? = nil, useOrder: Bool? = nil, cohortRegionsData: String? = nil, appKey: String? = nil, trilaterationTypes: String? = nil, uniqueName: Bool? = nil) -> AnyPublisher<AudienceResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let ageGroups = ageGroups { queryItems.append(URLQueryItem(name: "ageGroups", value: ageGroups)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let applicationIds = applicationIds { queryItems.append(URLQueryItem(name: "applicationIds", value: applicationIds)) } 
                if let gameExperienceLevel = gameExperienceLevel { queryItems.append(URLQueryItem(name: "gameExperienceLevel", value: gameExperienceLevel)) } 
                if let devices = devices { queryItems.append(URLQueryItem(name: "devices", value: devices)) } 
                if let deviceIds = deviceIds { queryItems.append(URLQueryItem(name: "deviceIds", value: deviceIds)) } 
                if let deviceVersions = deviceVersions { queryItems.append(URLQueryItem(name: "deviceVersions", value: deviceVersions)) } 
                if let locations = locations { queryItems.append(URLQueryItem(name: "locations", value: locations)) } 
                if let radius = radius { queryItems.append(URLQueryItem(name: "radius", value: radius)) } 
                if let startTimeOffset = startTimeOffset { queryItems.append(URLQueryItem(name: "startTimeOffset", value: "\(startTimeOffset)")) } 
                if let endTimeOffset = endTimeOffset { queryItems.append(URLQueryItem(name: "endTimeOffset", value: "\(endTimeOffset)")) } 
                if let sendSuggestion = sendSuggestion { queryItems.append(URLQueryItem(name: "sendSuggestion", value: sendSuggestion ? "true" : "false")) } 
                if let associateDescription = associateDescription { queryItems.append(URLQueryItem(name: "associateDescription", value: associateDescription)) } 
                if let associateType = associateType { queryItems.append(URLQueryItem(name: "associateType", value: associateType)) } 
                if let associateId = associateId { queryItems.append(URLQueryItem(name: "associateId", value: "\(associateId)")) } 
                if let groupingId = groupingId { queryItems.append(URLQueryItem(name: "groupingId", value: groupingId)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility)) } 
                if let audienceType = audienceType { queryItems.append(URLQueryItem(name: "audienceType", value: audienceType)) } 
                if let useOrder = useOrder { queryItems.append(URLQueryItem(name: "useOrder", value: useOrder ? "true" : "false")) } 
                if let cohortRegionsData = cohortRegionsData { queryItems.append(URLQueryItem(name: "cohortRegionsData", value: cohortRegionsData)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let trilaterationTypes = trilaterationTypes { queryItems.append(URLQueryItem(name: "trilaterationTypes", value: trilaterationTypes)) } 
                if let uniqueName = uniqueName { queryItems.append(URLQueryItem(name: "uniqueName", value: uniqueName ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AudienceResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AudienceResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Audience
    /// - POST /audience/delete
    /// - Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter audienceId: (query) The id of the audience to delete. 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteAudience(accountId: Int64, audienceId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "audienceId", value: "\(audienceId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Age Groups
    /// - GET /audience/ageGroups
    /// - Gets the list of available age groups that can be selected by consumers and retailers targeting offers.
    /// - returns: AnyPublisher<[AgeGroupResponse], Error> 
    open func getAgeGroups() -> AnyPublisher<[AgeGroupResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/ageGroups"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AgeGroupResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AgeGroupResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Audience
    /// - GET /audience/get
    /// - Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter audienceId: (query) The id of the audience to return. 
    /// - parameter appKey: (query) The application key (optional). If provided, results may be scoped to this application. (optional)
    /// - parameter returnAccountCount: (query) (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
    /// - parameter returnAlbumCount: (query) (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
    /// - parameter albumTypesForCount: (query) (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
    /// - returns: AnyPublisher<AudienceResponse, Error> 
    open func getAudience(accountId: Int64, audienceId: Int64, appKey: String? = nil, returnAccountCount: Bool? = nil, returnAlbumCount: Bool? = nil, albumTypesForCount: String? = nil) -> AnyPublisher<AudienceResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "audienceId", value: "\(audienceId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let returnAccountCount = returnAccountCount { queryItems.append(URLQueryItem(name: "returnAccountCount", value: returnAccountCount ? "true" : "false")) } 
                if let returnAlbumCount = returnAlbumCount { queryItems.append(URLQueryItem(name: "returnAlbumCount", value: returnAlbumCount ? "true" : "false")) } 
                if let albumTypesForCount = albumTypesForCount { queryItems.append(URLQueryItem(name: "albumTypesForCount", value: albumTypesForCount)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AudienceResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AudienceResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum GetAudienceListSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case name = "NAME"
        case description = "DESCRIPTION"
        case sendSuggestion = "SEND_SUGGESTION"
        case ownerId = "OWNER_ID"
        case ownerDisplay = "OWNER_DISPLAY"
        case gender = "GENDER"
    }

    /// Search Audiences
    /// - GET /audience/search
    /// - Get the list audiences owned by the account
    /// - parameter accountId: (query) The logged in user. (optional)
    /// - parameter albumIds: (query) Comma separated list of album IDs to filter results with (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter keywordFields: (query) Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (optional, default to "SEARCH_TAGS,NAME,DESCRIPTION")
    /// - parameter sortField: (query) The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (optional, default to .name)
    /// - parameter descending: (query) The order to return the results. Default is false, which will return the results in ascending order. (optional, default to false)
    /// - parameter start: (query) The index into the record set to start with. (optional, default to 0)
    /// - parameter limit: (query) The total number of record to return (there is a hard limit of 100). (optional, default to 20)
    /// - parameter sendSuggestion: (query) Filter results based on whether or not the audience is set to send suggestions (optional)
    /// - parameter activeOnly: (query) Determines whether to return only active results. Default is false. (optional)
    /// - parameter groupByGroupingId: (query) Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (optional)
    /// - parameter appKey: (query) Filter results by application key (optional)
    /// - parameter returnGlobal: (query) If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (optional)
    /// - parameter exactKeyword: (query) If true, match keyword exactly (optional)
    /// - parameter audienceType: (query) (Deprecated) Filter results by audience type (optional)
    /// - parameter audienceTypes: (query) comma separated string with the different audience types you want to filter for (optional)
    /// - parameter returnAccountCount: (query) (boolean) set to true to include the accountCount associated with current audience of the current app (optional, default to false)
    /// - parameter returnAlbumCount: (query) (boolean) set to true to include the albumCount associated with current audience of the current app (optional, default to false)
    /// - parameter albumTypesForCount: (query) (String) comma separated list, return an array with each item is the count of each album type. If not provided, \&quot;all_types\&quot; count is returned. (optional)
    /// - returns: AnyPublisher<[SearchResponse], Error> 
    open func getAudienceList(accountId: Int64? = nil, albumIds: String? = nil, keyword: String? = nil, keywordFields: String? = nil, sortField: GetAudienceListSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, sendSuggestion: Bool? = nil, activeOnly: Bool? = nil, groupByGroupingId: Bool? = nil, appKey: String? = nil, returnGlobal: Bool? = nil, exactKeyword: Bool? = nil, audienceType: String? = nil, audienceTypes: String? = nil, returnAccountCount: Bool? = nil, returnAlbumCount: Bool? = nil, albumTypesForCount: String? = nil) -> AnyPublisher<[SearchResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let albumIds = albumIds { queryItems.append(URLQueryItem(name: "albumIds", value: albumIds)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let keywordFields = keywordFields { queryItems.append(URLQueryItem(name: "keywordFields", value: keywordFields)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let sendSuggestion = sendSuggestion { queryItems.append(URLQueryItem(name: "sendSuggestion", value: sendSuggestion ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let groupByGroupingId = groupByGroupingId { queryItems.append(URLQueryItem(name: "groupByGroupingId", value: groupByGroupingId ? "true" : "false")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let returnGlobal = returnGlobal { queryItems.append(URLQueryItem(name: "returnGlobal", value: returnGlobal ? "true" : "false")) } 
                if let exactKeyword = exactKeyword { queryItems.append(URLQueryItem(name: "exactKeyword", value: exactKeyword ? "true" : "false")) } 
                if let audienceType = audienceType { queryItems.append(URLQueryItem(name: "audienceType", value: audienceType)) } 
                if let audienceTypes = audienceTypes { queryItems.append(URLQueryItem(name: "audienceTypes", value: audienceTypes)) } 
                if let returnAccountCount = returnAccountCount { queryItems.append(URLQueryItem(name: "returnAccountCount", value: returnAccountCount ? "true" : "false")) } 
                if let returnAlbumCount = returnAlbumCount { queryItems.append(URLQueryItem(name: "returnAlbumCount", value: returnAlbumCount ? "true" : "false")) } 
                if let albumTypesForCount = albumTypesForCount { queryItems.append(URLQueryItem(name: "albumTypesForCount", value: albumTypesForCount)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[SearchResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([SearchResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Devices
    /// - GET /audience/devices
    /// - Gets the list of available devices that can be selected by consumers and retailers.
    /// - parameter includeInactive: (query) If true return inactive record as well. default is false. 
    /// - returns: AnyPublisher<[AudienceDeviceResponse], Error> 
    open func getDevices(includeInactive: Bool) -> AnyPublisher<[AudienceDeviceResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/devices"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "includeInactive", value: includeInactive ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AudienceDeviceResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AudienceDeviceResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Experiences
    /// - GET /audience/experiences
    /// - Gets the list of available experiences that can be selected by consumers and retailers.
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func getExperiences() -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/experiences"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get GroupedAudiences
    /// - GET /audience/grouped/get
    /// - Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter audienceGroupingId: (query) The audience grouping id to return. 
    /// - returns: AnyPublisher<AudienceResponse, Error> 
    open func getGroupedAudiences(accountId: Int64, audienceGroupingId: String) -> AnyPublisher<AudienceResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/grouped/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "audienceGroupingId", value: audienceGroupingId))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AudienceResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AudienceResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// List Suggestions by Audience
    /// - POST /audience/suggestion/list
    /// - List either Missions or Offers that the user matches the assigned audience.
    /// - parameter accountId: (query) The account to match offers for. 
    /// - parameter limit: (query) the limit of the index 
    /// - parameter suggestionType: (query) the type of suggestion 
    /// - returns: AnyPublisher<OfferListResponse, Error> 
    open func listByAccount(accountId: Int64, limit: Int, suggestionType: String) -> AnyPublisher<OfferListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/suggestion/list"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "suggestionType", value: suggestionType))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// List Offers by Audience
    /// - GET /audience/suggestion/offersByAudience
    /// - Get a list of offer locations based on audience information provided.
    /// - parameter limit: (query) this is the limit of the index 
    /// - parameter gender: (query) this is the gender to list offers by (optional)
    /// - parameter age: (query) this is the age to list offers by (optional)
    /// - parameter categoryIds: (query) this is the category IDs to list offers by (optional)
    /// - parameter latitude: (query) this is the latitude to list offers by (optional)
    /// - parameter longitude: (query) this is the longitude to list offers by (optional)
    /// - returns: AnyPublisher<OfferListResponse, Error> 
    open func listByAudience(limit: Int, gender: String? = nil, age: Int? = nil, categoryIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<OfferListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/suggestion/offersByAudience"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let age = age { queryItems.append(URLQueryItem(name: "age", value: "\(age)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// List Sent Suggestions 
    /// - GET /audience/suggestion/latest
    /// - Return list of recent trigger suggestions that have been sent to the user.
    /// - parameter accountId: (query) The account to match offers for. 
    /// - parameter timeframe: (query) The timeframe in seconds of the latest suggestions 
    /// - parameter suggestionType: (query) The type of trigger suggestions to return 
    /// - returns: AnyPublisher<OfferListResponse, Error> 
    open func listLastestByAccount(accountId: Int64, timeframe: Int, suggestionType: String) -> AnyPublisher<OfferListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/suggestion/latest"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "timeframe", value: "\(timeframe)"))
                queryItems.append(URLQueryItem(name: "suggestionType", value: suggestionType))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Send Suggestions
    /// - POST /audience/suggestion/send
    /// - Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.
    /// - parameter accountId: (query) The account to match offers for. 
    /// - parameter latitude: (query) the latitude 
    /// - parameter longitude: (query) the longitude 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func sendByAccount(accountId: Int64, latitude: Double, longitude: Double) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/suggestion/send"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)"))
                queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Audience
    /// - POST /audience/update
    /// - Update a user defined audience.
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter audienceId: (query) The id of the audience to update. 
    /// - parameter name: (query) The name of the audience (optional)
    /// - parameter description: (query) The description of the audience (optional)
    /// - parameter searchTags: (query) The search tags (optional)
    /// - parameter gender: (query) The gender; possible values are: MALE, FEMALE, ANY (optional)
    /// - parameter ageGroups: (query) The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (optional)
    /// - parameter categoryIds: (query) The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (optional)
    /// - parameter applicationIds: (query) The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (optional)
    /// - parameter gameExperienceLevel: (query) The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (optional)
    /// - parameter devices: (query) (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (optional)
    /// - parameter deviceIds: (query) The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (optional)
    /// - parameter deviceVersions: (query) The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (optional)
    /// - parameter locations: (query) The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (optional)
    /// - parameter radius: (query) The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (optional)
    /// - parameter active: (query) if audience is active (optional)
    /// - parameter sendSuggestion: (query) If true, then notify matching users when they are inside the radius (optional)
    /// - parameter startTimeOffset: (query) Seconds from the start time of an event (optional)
    /// - parameter endTimeOffset: (query) Seconds from the end time of an event (optional)
    /// - parameter associateDescription: (query) the associate description (optional)
    /// - parameter associateType: (query) The type of the object to center the audience geofence (optional)
    /// - parameter associateId: (query) The ID of the object to center the audience geofence (optional)
    /// - parameter groupingId: (query) Optional grouping id for the audience (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter visibility: (query) Visibility of the audience (optional)
    /// - parameter audienceType: (query) Type of audience (optional)
    /// - parameter useOrder: (query) Use order for cohort (optional)
    /// - parameter cohortRegionsData: (query) Cohort data for \&quot;cohort\&quot; audience type (optional)
    /// - parameter appKey: (query) Filter results by application key (optional)
    /// - parameter trilaterationTypes: (query) Trilateration types (optional)
    /// - parameter uniqueName: (query) If true, makes sure the audience name is unique (optional)
    /// - returns: AnyPublisher<AudienceResponse, Error> 
    open func updateAudience(accountId: Int64, audienceId: Int64, name: String? = nil, description: String? = nil, searchTags: String? = nil, gender: String? = nil, ageGroups: String? = nil, categoryIds: String? = nil, applicationIds: String? = nil, gameExperienceLevel: String? = nil, devices: String? = nil, deviceIds: String? = nil, deviceVersions: String? = nil, locations: String? = nil, radius: String? = nil, active: Bool? = nil, sendSuggestion: Bool? = nil, startTimeOffset: Int? = nil, endTimeOffset: Int? = nil, associateDescription: String? = nil, associateType: String? = nil, associateId: Int64? = nil, groupingId: String? = nil, metaData: String? = nil, visibility: String? = nil, audienceType: String? = nil, useOrder: Bool? = nil, cohortRegionsData: String? = nil, appKey: String? = nil, trilaterationTypes: String? = nil, uniqueName: Bool? = nil) -> AnyPublisher<AudienceResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/audience/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "audienceId", value: "\(audienceId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let ageGroups = ageGroups { queryItems.append(URLQueryItem(name: "ageGroups", value: ageGroups)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let applicationIds = applicationIds { queryItems.append(URLQueryItem(name: "applicationIds", value: applicationIds)) } 
                if let gameExperienceLevel = gameExperienceLevel { queryItems.append(URLQueryItem(name: "gameExperienceLevel", value: gameExperienceLevel)) } 
                if let devices = devices { queryItems.append(URLQueryItem(name: "devices", value: devices)) } 
                if let deviceIds = deviceIds { queryItems.append(URLQueryItem(name: "deviceIds", value: deviceIds)) } 
                if let deviceVersions = deviceVersions { queryItems.append(URLQueryItem(name: "deviceVersions", value: deviceVersions)) } 
                if let locations = locations { queryItems.append(URLQueryItem(name: "locations", value: locations)) } 
                if let radius = radius { queryItems.append(URLQueryItem(name: "radius", value: radius)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let sendSuggestion = sendSuggestion { queryItems.append(URLQueryItem(name: "sendSuggestion", value: sendSuggestion ? "true" : "false")) } 
                if let startTimeOffset = startTimeOffset { queryItems.append(URLQueryItem(name: "startTimeOffset", value: "\(startTimeOffset)")) } 
                if let endTimeOffset = endTimeOffset { queryItems.append(URLQueryItem(name: "endTimeOffset", value: "\(endTimeOffset)")) } 
                if let associateDescription = associateDescription { queryItems.append(URLQueryItem(name: "associateDescription", value: associateDescription)) } 
                if let associateType = associateType { queryItems.append(URLQueryItem(name: "associateType", value: associateType)) } 
                if let associateId = associateId { queryItems.append(URLQueryItem(name: "associateId", value: "\(associateId)")) } 
                if let groupingId = groupingId { queryItems.append(URLQueryItem(name: "groupingId", value: groupingId)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility)) } 
                if let audienceType = audienceType { queryItems.append(URLQueryItem(name: "audienceType", value: audienceType)) } 
                if let useOrder = useOrder { queryItems.append(URLQueryItem(name: "useOrder", value: useOrder ? "true" : "false")) } 
                if let cohortRegionsData = cohortRegionsData { queryItems.append(URLQueryItem(name: "cohortRegionsData", value: cohortRegionsData)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let trilaterationTypes = trilaterationTypes { queryItems.append(URLQueryItem(name: "trilaterationTypes", value: trilaterationTypes)) } 
                if let uniqueName = uniqueName { queryItems.append(URLQueryItem(name: "uniqueName", value: uniqueName ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AudienceResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AudienceResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
