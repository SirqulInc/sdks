//
// WalletAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class WalletAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Wallet Offers
    /// - POST /wallet/create
    /// - Adds offers to the wallet
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter offerId: (query) The id of the offer being added (offerId or offeLocationId required) (optional)
    /// - parameter offerLocationId: (query) The id of the offer location being added (offerId or offeLocationId required) (optional)
    /// - parameter offerCart: (query) A JSON list of offers to purchase. &#x60;&#x60;&#x60;json [   {     \&quot;offerId\&quot;: 123,     \&quot;offerLocationId\&quot;: 234,     \&quot;quantity\&quot;: 2   },   {     \&quot;offerId\&quot;: 456,     \&quot;offerLocationId\&quot;: 567,     \&quot;quantity\&quot;: 1   } ] &#x60;&#x60;&#x60;  (optional)
    /// - parameter promoCode: (query) The promoCode (optional)
    /// - parameter currencyType: (query) Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
    /// - parameter usePoints: (query) Sets the currencyType to POINTS (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter appKey: (query) The application requesting the purchase, required when currencyType is TICKETS (optional)
    /// - parameter status: (query) Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
    /// - returns: AnyPublisher<[OfferTransactionResponse], Error> 
    open func createOfferTransaction(deviceId: String? = nil, accountId: Int64? = nil, offerId: Int64? = nil, offerLocationId: Int64? = nil, offerCart: String? = nil, promoCode: String? = nil, currencyType: String? = nil, usePoints: Bool? = nil, metaData: String? = nil, appKey: String? = nil, status: Int? = nil) -> AnyPublisher<[OfferTransactionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/wallet/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let offerCart = offerCart { queryItems.append(URLQueryItem(name: "offerCart", value: offerCart)) } 
                if let promoCode = promoCode { queryItems.append(URLQueryItem(name: "promoCode", value: promoCode)) } 
                if let currencyType = currencyType { queryItems.append(URLQueryItem(name: "currencyType", value: currencyType)) } 
                if let usePoints = usePoints { queryItems.append(URLQueryItem(name: "usePoints", value: usePoints ? "true" : "false")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let status = status { queryItems.append(URLQueryItem(name: "status", value: "\(status)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferTransactionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferTransactionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Wallet Offer
    /// - POST /wallet/delete
    /// - Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
    /// - parameter transactionId: (query) The offer transaction id to remove 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteOfferTransaction(transactionId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/wallet/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "transactionId", value: "\(transactionId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Wallet Offer
    /// - GET /wallet/get
    /// - parameter transactionId: (query) The offer transaction id to get details of 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter includeMission: (query) If true then include mission data, false to not include (optional, default to false)
    /// - parameter latitude: (query) The latitude location of the user (optional)
    /// - parameter longitude: (query) The latitude location of the user (optional)
    /// - parameter returnFullResponse: (query) Determines whether to return a detailed version of the response (optional, default to true)
    /// - returns: AnyPublisher<OfferTransactionResponse, Error> 
    open func getOfferTransaction(transactionId: Int64, deviceId: String? = nil, accountId: Int64? = nil, includeMission: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil, returnFullResponse: Bool? = nil) -> AnyPublisher<OfferTransactionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/wallet/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "transactionId", value: "\(transactionId)"))
                if let includeMission = includeMission { queryItems.append(URLQueryItem(name: "includeMission", value: includeMission ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferTransactionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferTransactionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Preview Wallet Offers
    /// - POST /wallet/preview
    /// - Preview the final cost of a transaction without charging the user
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter offerId: (query) The id of the offer being added (offerId or offeLocationId required) (optional)
    /// - parameter offerLocationId: (query) The id of the offer location being added (offerId or offeLocationId required) (optional)
    /// - parameter offerCart: (query) A JSON list of offers to purchase. (optional)
    /// - parameter promoCode: (query) The promoCode (optional)
    /// - parameter currencyType: (query) Determines the method of purchasing offer. CASH &#x3D; use card on file, POINTS &#x3D; use points, TICKETS &#x3D; use tickets (optional, default to "CASH")
    /// - parameter usePoints: (query) Sets the currencyType to POINTS (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter appKey: (query) The application requesting the purchase, required when currencyType is TICKETS (optional)
    /// - returns: AnyPublisher<[OfferTransactionResponse], Error> 
    open func previewOfferTransaction(deviceId: String? = nil, accountId: Int64? = nil, offerId: Int64? = nil, offerLocationId: Int64? = nil, offerCart: String? = nil, promoCode: String? = nil, currencyType: String? = nil, usePoints: Bool? = nil, metaData: String? = nil, appKey: String? = nil) -> AnyPublisher<[OfferTransactionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/wallet/preview"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let offerCart = offerCart { queryItems.append(URLQueryItem(name: "offerCart", value: offerCart)) } 
                if let promoCode = promoCode { queryItems.append(URLQueryItem(name: "promoCode", value: promoCode)) } 
                if let currencyType = currencyType { queryItems.append(URLQueryItem(name: "currencyType", value: currencyType)) } 
                if let usePoints = usePoints { queryItems.append(URLQueryItem(name: "usePoints", value: usePoints ? "true" : "false")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferTransactionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferTransactionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter offerType
    ///
    public enum SearchOfferTransactionsOfferType: String, Codable, CaseIterable {
        case voucher = "VOUCHER"
        case coupon = "COUPON"
        case product = "PRODUCT"
        case media = "MEDIA"
        case event = "EVENT"
        case device = "DEVICE"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum SearchOfferTransactionsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case activated = "ACTIVATED"
        case expires = "EXPIRES"
        case title = "TITLE"
        case subtitle = "SUBTITLE"
        case details = "DETAILS"
        case offerType = "OFFER_TYPE"
        case specialOfferType = "SPECIAL_OFFER_TYPE"
        case offerVisibility = "OFFER_VISIBILITY"
        case redeemableStart = "REDEEMABLE_START"
        case redeemableEnd = "REDEEMABLE_END"
        case customerId = "CUSTOMER_ID"
        case customerDisplay = "CUSTOMER_DISPLAY"
        case retailerId = "RETAILER_ID"
        case retailerName = "RETAILER_NAME"
        case retailerLocationId = "RETAILER_LOCATION_ID"
        case retailerLocationName = "RETAILER_LOCATION_NAME"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
    }

    /// Search Wallet Offers
    /// - GET /wallet/search
    /// - Search on active offers currently in the user's wallet, or past offers the user has already redeemed.
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter keyword: (query) The keyword to search for (optional)
    /// - parameter retailerId: (query) Filter results for this retailer (optional)
    /// - parameter retailerIds: (query) Filter results for a list of retailers (optional)
    /// - parameter retailerLocationId: (query) Filter results for this retailer location (optional)
    /// - parameter retailerLocationIds: (query) Filter results for a list of retailer locations (optional)
    /// - parameter excludeRetailerLocationIds: (query) Filter results to exclude retailer locations (optional)
    /// - parameter offerId: (query) Filter results for this offer (optional)
    /// - parameter offerIds: (query) Filter results for a list of offer (optional)
    /// - parameter offerLocationId: (query) Filter results for this offer location (optional)
    /// - parameter offerLocationIds: (query) Filter results for a list of offer locations (optional)
    /// - parameter offerType: (query) Filter results to return a specific offer type (optional)
    /// - parameter offerTypes: (query) Filter results to return specific offer types (optional)
    /// - parameter specialOfferType: (query) Filter results to return a specific special offer type (optional)
    /// - parameter specialOfferTypes: (query) Filter results to return specific special offer types (optional)
    /// - parameter categoryIds: (query) Category Ids (optional)
    /// - parameter filterIds: (query) Filter Ids (optional)
    /// - parameter offerAudienceIds: (query) Offer Audience Ids (optional)
    /// - parameter sortField: (query) Determines what to sort the results by (optional, default to .created)
    /// - parameter descending: (query) Determines whether the results are in descending order (optional, default to true)
    /// - parameter start: (query) The start index for pagination (optional, default to 0)
    /// - parameter limit: (query) The limit for pagination (optional, default to 20)
    /// - parameter latitude: (query) The latitude location of the user (optional)
    /// - parameter longitude: (query) The latitude location of the user (optional)
    /// - parameter redeemableStartDate: (query) Filter results by the offer redeemable date (optional)
    /// - parameter redeemableEndDate: (query) Filter results by the offer redeemable date (optional)
    /// - parameter filterByParentOffer: (query) Apply params to offer&#39;s parent (optional, default to false)
    /// - parameter startedSince: (query) Filter results by the offer start date (optional)
    /// - parameter startedBefore: (query) Filter results by the offer start date (optional)
    /// - parameter endedSince: (query) Filter results by the offer end date (optional)
    /// - parameter endedBefore: (query) Filter results by the offer end date (optional)
    /// - parameter redeemed: (query) If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1) (optional, default to false)
    /// - parameter statuses: (query) Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership) (optional)
    /// - parameter reservationsOnly: (query) Returns only reservation transactions if true (optional, default to false)
    /// - parameter activeOnly: (query) Active Only (optional, default to false)
    /// - parameter returnFullResponse: (query) Determines whether to return a detailed version of the response (optional, default to false)
    /// - parameter recurringStartedSince: (query) Filter results by the recurring billing start date (optional)
    /// - parameter recurringStartedBefore: (query) Filter results by the recurring billing start date (optional)
    /// - parameter recurringExpirationSince: (query) Filter results by the recurring billing expiration date (optional)
    /// - parameter recurringExpirationBefore: (query) Filter results by the recurring billing expiration date (optional)
    /// - returns: AnyPublisher<[OfferTransactionResponse], Error> 
    open func searchOfferTransactions(deviceId: String? = nil, accountId: Int64? = nil, keyword: String? = nil, retailerId: Int64? = nil, retailerIds: String? = nil, retailerLocationId: Int64? = nil, retailerLocationIds: String? = nil, excludeRetailerLocationIds: String? = nil, offerId: Int64? = nil, offerIds: String? = nil, offerLocationId: Int64? = nil, offerLocationIds: String? = nil, offerType: SearchOfferTransactionsOfferType? = nil, offerTypes: String? = nil, specialOfferType: String? = nil, specialOfferTypes: String? = nil, categoryIds: String? = nil, filterIds: String? = nil, offerAudienceIds: String? = nil, sortField: SearchOfferTransactionsSortField? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, latitude: Double? = nil, longitude: Double? = nil, redeemableStartDate: Int64? = nil, redeemableEndDate: Int64? = nil, filterByParentOffer: Bool? = nil, startedSince: Int64? = nil, startedBefore: Int64? = nil, endedSince: Int64? = nil, endedBefore: Int64? = nil, redeemed: Bool? = nil, statuses: String? = nil, reservationsOnly: Bool? = nil, activeOnly: Bool? = nil, returnFullResponse: Bool? = nil, recurringStartedSince: Int64? = nil, recurringStartedBefore: Int64? = nil, recurringExpirationSince: Int64? = nil, recurringExpirationBefore: Int64? = nil) -> AnyPublisher<[OfferTransactionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/wallet/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                if let retailerIds = retailerIds { queryItems.append(URLQueryItem(name: "retailerIds", value: retailerIds)) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let excludeRetailerLocationIds = excludeRetailerLocationIds { queryItems.append(URLQueryItem(name: "excludeRetailerLocationIds", value: excludeRetailerLocationIds)) } 
                if let offerId = offerId { queryItems.append(URLQueryItem(name: "offerId", value: "\(offerId)")) } 
                if let offerIds = offerIds { queryItems.append(URLQueryItem(name: "offerIds", value: offerIds)) } 
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let offerLocationIds = offerLocationIds { queryItems.append(URLQueryItem(name: "offerLocationIds", value: offerLocationIds)) } 
                if let offerType = offerType { queryItems.append(URLQueryItem(name: "offerType", value: offerType.rawValue)) } 
                if let offerTypes = offerTypes { queryItems.append(URLQueryItem(name: "offerTypes", value: offerTypes)) } 
                if let specialOfferType = specialOfferType { queryItems.append(URLQueryItem(name: "specialOfferType", value: specialOfferType)) } 
                if let specialOfferTypes = specialOfferTypes { queryItems.append(URLQueryItem(name: "specialOfferTypes", value: specialOfferTypes)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let offerAudienceIds = offerAudienceIds { queryItems.append(URLQueryItem(name: "offerAudienceIds", value: offerAudienceIds)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let redeemableStartDate = redeemableStartDate { queryItems.append(URLQueryItem(name: "redeemableStartDate", value: "\(redeemableStartDate)")) } 
                if let redeemableEndDate = redeemableEndDate { queryItems.append(URLQueryItem(name: "redeemableEndDate", value: "\(redeemableEndDate)")) } 
                if let filterByParentOffer = filterByParentOffer { queryItems.append(URLQueryItem(name: "filterByParentOffer", value: filterByParentOffer ? "true" : "false")) } 
                if let startedSince = startedSince { queryItems.append(URLQueryItem(name: "startedSince", value: "\(startedSince)")) } 
                if let startedBefore = startedBefore { queryItems.append(URLQueryItem(name: "startedBefore", value: "\(startedBefore)")) } 
                if let endedSince = endedSince { queryItems.append(URLQueryItem(name: "endedSince", value: "\(endedSince)")) } 
                if let endedBefore = endedBefore { queryItems.append(URLQueryItem(name: "endedBefore", value: "\(endedBefore)")) } 
                if let redeemed = redeemed { queryItems.append(URLQueryItem(name: "redeemed", value: redeemed ? "true" : "false")) } 
                if let statuses = statuses { queryItems.append(URLQueryItem(name: "statuses", value: statuses)) } 
                if let reservationsOnly = reservationsOnly { queryItems.append(URLQueryItem(name: "reservationsOnly", value: reservationsOnly ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                if let recurringStartedSince = recurringStartedSince { queryItems.append(URLQueryItem(name: "recurringStartedSince", value: "\(recurringStartedSince)")) } 
                if let recurringStartedBefore = recurringStartedBefore { queryItems.append(URLQueryItem(name: "recurringStartedBefore", value: "\(recurringStartedBefore)")) } 
                if let recurringExpirationSince = recurringExpirationSince { queryItems.append(URLQueryItem(name: "recurringExpirationSince", value: "\(recurringExpirationSince)")) } 
                if let recurringExpirationBefore = recurringExpirationBefore { queryItems.append(URLQueryItem(name: "recurringExpirationBefore", value: "\(recurringExpirationBefore)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OfferTransactionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OfferTransactionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Wallet Offer
    /// - POST /wallet/update
    /// - Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.
    /// - parameter transactionId: (query) The offer transaction id to remove 
    /// - parameter status: (query) The status value to change to (0 or 1) 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter offerLocationId: (query) Offer Location Id (optional)
    /// - parameter currencyType: (query) Currency Type (optional, default to "CASH")
    /// - parameter usePoints: (query) Use Points (optional)
    /// - parameter appKey: (query) App Key (optional)
    /// - parameter latitude: (query) The latitude location of the user (optional)
    /// - parameter longitude: (query) The latitude location of the user (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter returnFullResponse: (query) Determines whether to return a detailed version of the response (optional, default to false)
    /// - parameter exceptionMembershipOfferIds: (query) Exception Offers, transaction audiences of these offers won&#39;t be removed out of the account when up (optional)
    /// - returns: AnyPublisher<OfferTransactionResponse, Error> 
    open func updateOfferTransaction(transactionId: Int64, status: Int, deviceId: String? = nil, accountId: Int64? = nil, offerLocationId: Int64? = nil, currencyType: String? = nil, usePoints: Bool? = nil, appKey: String? = nil, latitude: Double? = nil, longitude: Double? = nil, metaData: String? = nil, returnFullResponse: Bool? = nil, exceptionMembershipOfferIds: String? = nil) -> AnyPublisher<OfferTransactionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/wallet/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "transactionId", value: "\(transactionId)"))
                if let offerLocationId = offerLocationId { queryItems.append(URLQueryItem(name: "offerLocationId", value: "\(offerLocationId)")) } 
                if let currencyType = currencyType { queryItems.append(URLQueryItem(name: "currencyType", value: currencyType)) } 
                if let usePoints = usePoints { queryItems.append(URLQueryItem(name: "usePoints", value: usePoints ? "true" : "false")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "status", value: "\(status)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let returnFullResponse = returnFullResponse { queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false")) } 
                if let exceptionMembershipOfferIds = exceptionMembershipOfferIds { queryItems.append(URLQueryItem(name: "exceptionMembershipOfferIds", value: exceptionMembershipOfferIds)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OfferTransactionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OfferTransactionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
