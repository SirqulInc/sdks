//
// NotificationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class NotificationAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Notification Template
    /// - POST /api/{version}/notification/template/create
    /// - Create a notification template. Developers will only be able to create notification templates for their own applications.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account ID of the user. 
    /// - parameter conduit: (query) Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. 
    /// - parameter title: (query) title of the notification template 
    /// - parameter body: (query) body of the notification template 
    /// - parameter appKey: (query) Filter results by application. (optional)
    /// - parameter event: (query) Filter results by event. (optional)
    /// - parameter tags: (query) tags associated with the note template (optional)
    /// - returns: AnyPublisher<NotificationTemplateResponse, Error> 
    open func createNotificationTemplate(version: Double, accountId: Int64, conduit: String, title: String, body: String, appKey: String? = nil, event: String? = nil, tags: String? = nil) -> AnyPublisher<NotificationTemplateResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/template/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let event = event { queryItems.append(URLQueryItem(name: "event", value: event)) } 
                queryItems.append(URLQueryItem(name: "conduit", value: conduit))
                queryItems.append(URLQueryItem(name: "title", value: title))
                queryItems.append(URLQueryItem(name: "body", value: body))
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTemplateResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationTemplateResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create or update blocked notification settings
    /// - POST /api/{version}/notification/blocked/batch
    /// - Create or update blocked notification settings
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The application key 
    /// - parameter data: (query) batch data payload (application specific) 
    /// - parameter accountId: (query) the account id of the user (optional)
    /// - returns: AnyPublisher<BlockedNotificationResponse, Error> 
    open func createOrUpdateBlockedNotifications(version: Double, appKey: String, data: String, accountId: Int64? = nil) -> AnyPublisher<BlockedNotificationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/blocked/batch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "data", value: data))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<BlockedNotificationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(BlockedNotificationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Notification Template
    /// - POST /api/{version}/notification/template/delete
    /// - Deletes a notification template. Developers will only be able to delete notification templates for their own applications.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the account id of the user 
    /// - parameter notificationTemplateId: (query) the id of the notification template to delete 
    /// - returns: AnyPublisher<NotificationTemplateResponse, Error> 
    open func deleteNotificationTemplate(version: Double, accountId: Int64, notificationTemplateId: Int64) -> AnyPublisher<NotificationTemplateResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/template/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "notificationTemplateId", value: "\(notificationTemplateId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTemplateResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationTemplateResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Notification Template
    /// - GET /api/{version}/notification/template/get
    /// - Get the details of a notification template. Developers will only be able to see notification templates for their own applications.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the account 
    /// - parameter notificationTemplateId: (query) the id of the notification template to get 
    /// - returns: AnyPublisher<NotificationTemplateResponse, Error> 
    open func getNotificationTemplate(version: Double, accountId: Int64, notificationTemplateId: Int64) -> AnyPublisher<NotificationTemplateResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/template/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "notificationTemplateId", value: "\(notificationTemplateId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTemplateResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationTemplateResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Notifications
    /// - GET /api/{version}/notification/search
    /// - Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionAccountId: (query) the account id used to view another person&#39;s notifications (optional)
    /// - parameter appKey: (query) the application key to filter messages by application (optional)
    /// - parameter eventType: (query) comma separated list of EVENTS. Filters search results to only include these events. Don&#39;t include this parameter or pass in an empty string to return all event types. (optional)
    /// - parameter contentIds: (query) comma separated list of content ids to search notifications on (optional)
    /// - parameter contentTypes: (query) comma separated list of content types to search notifications on (optional)
    /// - parameter parentIds: (query) comma separated list of parent ids to search notifications on (optional)
    /// - parameter parentTypes: (query) comma separated list of parent types to search notifications on (optional)
    /// - parameter actionCategory: (query) Action category used to filter notifications (optional)
    /// - parameter conduits: (query) comma separated list of conduits to search notifications on (optional)
    /// - parameter keyword: (query) search notifications via keyword (optional)
    /// - parameter returnReadMessages: (query) if set to true, will return notifications that have been marked as read (optional)
    /// - parameter markAsRead: (query) if set to true, the returned notifications will be marked as \\\&quot;read\\\&quot; after the response has been sent (optional)
    /// - parameter fromDate: (query) filter notifications from this date (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - parameter returnSent: (query) whether to include notifications sent by the requester in the response (optional)
    /// - parameter ignoreFlagged: (query) whether to ignore flagged notifications (optional)
    /// - parameter start: (query) start of the pagination (optional)
    /// - parameter limit: (query) limit of the pagination (optional)
    /// - returns: AnyPublisher<NotificationMessageListResponse, Error> 
    open func getNotifications(version: Double, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountId: Int64? = nil, appKey: String? = nil, eventType: String? = nil, contentIds: String? = nil, contentTypes: String? = nil, parentIds: String? = nil, parentTypes: String? = nil, actionCategory: String? = nil, conduits: String? = nil, keyword: String? = nil, returnReadMessages: Bool? = nil, markAsRead: Bool? = nil, fromDate: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil, returnSent: Bool? = nil, ignoreFlagged: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<NotificationMessageListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let eventType = eventType { queryItems.append(URLQueryItem(name: "eventType", value: eventType)) } 
                if let contentIds = contentIds { queryItems.append(URLQueryItem(name: "contentIds", value: contentIds)) } 
                if let contentTypes = contentTypes { queryItems.append(URLQueryItem(name: "contentTypes", value: contentTypes)) } 
                if let parentIds = parentIds { queryItems.append(URLQueryItem(name: "parentIds", value: parentIds)) } 
                if let parentTypes = parentTypes { queryItems.append(URLQueryItem(name: "parentTypes", value: parentTypes)) } 
                if let actionCategory = actionCategory { queryItems.append(URLQueryItem(name: "actionCategory", value: actionCategory)) } 
                if let conduits = conduits { queryItems.append(URLQueryItem(name: "conduits", value: conduits)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let returnReadMessages = returnReadMessages { queryItems.append(URLQueryItem(name: "returnReadMessages", value: returnReadMessages ? "true" : "false")) } 
                if let markAsRead = markAsRead { queryItems.append(URLQueryItem(name: "markAsRead", value: markAsRead ? "true" : "false")) } 
                if let fromDate = fromDate { queryItems.append(URLQueryItem(name: "fromDate", value: "\(fromDate)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let returnSent = returnSent { queryItems.append(URLQueryItem(name: "returnSent", value: returnSent ? "true" : "false")) } 
                if let ignoreFlagged = ignoreFlagged { queryItems.append(URLQueryItem(name: "ignoreFlagged", value: ignoreFlagged ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationMessageListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationMessageListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter pushType
    ///
    public enum RegisterNotificationTokenPushType: String, Codable, CaseIterable {
        case apns = "APNS"
        case gcm = "GCM"
        case baidu = "BAIDU"
        case xgpush = "XGPUSH"
        case jpush = "JPUSH"
    }

    /// Register Notification Token
    /// - POST /api/{version}/notification/token
    /// - Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.
    /// - parameter version: (path)  
    /// - parameter token: (query) A token that is generated by the device to sign requests for the notification service providers 
    /// - parameter pushType: (query) The type of push notification. Possible values include: APNS, GCM 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter environment: (query) Determines if the token is a DEVELOPMENT or PRODUCTION token (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter gameType: (query) This parameter is deprecated (use appKey instead) (optional)
    /// - parameter active: (query) Sets whether the token is active or not (non-active tokens are not used) (optional)
    /// - parameter latitude: (query) Latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) Longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func registerNotificationToken(version: Double, token: String, pushType: RegisterNotificationTokenPushType, deviceId: String? = nil, accountId: Int64? = nil, environment: String? = nil, appKey: String? = nil, gameType: String? = nil, active: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/token"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "token", value: token))
                queryItems.append(URLQueryItem(name: "pushType", value: pushType.rawValue))
                if let environment = environment { queryItems.append(URLQueryItem(name: "environment", value: environment)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search on the user's blocked notification settings
    /// - GET /api/{version}/notification/blocked/search
    /// - Search on the user's blocked notification settings
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The application key 
    /// - parameter accountId: (query) the account id of the user (optional)
    /// - parameter searchTags: (query) search tags to filter results (optional)
    /// - parameter events: (query) events to filter by (comma separated) (optional)
    /// - parameter conduits: (query) conduits to filter by (comma separated) (optional)
    /// - parameter customTypes: (query) custom types to filter by (comma separated) (optional)
    /// - parameter contentTypes: (query) content types to filter by (comma separated) (optional)
    /// - parameter contentIds: (query) content ids to filter by (comma separated) (optional)
    /// - parameter sortField: (query) sort field for results (optional)
    /// - parameter descending: (query) whether to sort descending (optional)
    /// - parameter start: (query) start of the pagination (optional)
    /// - parameter limit: (query) limit of the pagination (optional)
    /// - returns: AnyPublisher<BlockedNotificationResponse, Error> 
    open func searchBlockedNotifications(version: Double, appKey: String, accountId: Int64? = nil, searchTags: String? = nil, events: String? = nil, conduits: String? = nil, customTypes: String? = nil, contentTypes: String? = nil, contentIds: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<BlockedNotificationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/blocked/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let events = events { queryItems.append(URLQueryItem(name: "events", value: events)) } 
                if let conduits = conduits { queryItems.append(URLQueryItem(name: "conduits", value: conduits)) } 
                if let customTypes = customTypes { queryItems.append(URLQueryItem(name: "customTypes", value: customTypes)) } 
                if let contentTypes = contentTypes { queryItems.append(URLQueryItem(name: "contentTypes", value: contentTypes)) } 
                if let contentIds = contentIds { queryItems.append(URLQueryItem(name: "contentIds", value: contentIds)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<BlockedNotificationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(BlockedNotificationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Notification Templates
    /// - GET /api/{version}/notification/template/search
    /// - Search for notification templates on owned applications.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account ID of the user. 
    /// - parameter sortField: (query) Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name (&#39;global&#39; templates will not have an application and will be returned last if &#39;descending&#39; is set to false. 
    /// - parameter descending: (query) Specified whether the results are returned in descending or ascending order. 
    /// - parameter start: (query) The start of the pagination. 
    /// - parameter limit: (query) The limit of the pagination. 
    /// - parameter appKey: (query) Filter results by application. (optional)
    /// - parameter event: (query) Filter results by event. (optional)
    /// - parameter conduit: (query) Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
    /// - parameter globalOnly: (query) Returns only templates that have been reserved for system use on all applications (only for admin accounts). (optional)
    /// - parameter reservedOnly: (query) Returns only templates that use reserved events. (optional)
    /// - parameter keyword: (query) Filter results by keyword on the title, tags. (optional)
    /// - returns: AnyPublisher<NotificationTemplateResponse, Error> 
    open func searchNotificationTemplate(version: Double, accountId: Int64, sortField: String, descending: Bool, start: Int, limit: Int, appKey: String? = nil, event: String? = nil, conduit: String? = nil, globalOnly: Bool? = nil, reservedOnly: Bool? = nil, keyword: String? = nil) -> AnyPublisher<NotificationTemplateResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/template/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let event = event { queryItems.append(URLQueryItem(name: "event", value: event)) } 
                if let conduit = conduit { queryItems.append(URLQueryItem(name: "conduit", value: conduit)) } 
                if let globalOnly = globalOnly { queryItems.append(URLQueryItem(name: "globalOnly", value: globalOnly ? "true" : "false")) } 
                if let reservedOnly = reservedOnly { queryItems.append(URLQueryItem(name: "reservedOnly", value: reservedOnly ? "true" : "false")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTemplateResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationTemplateResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchRecipientsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case hasSms = "HAS_SMS"
        case hasEmail = "HAS_EMAIL"
        case hasApns = "HAS_APNS"
        case hasGcm = "HAS_GCM"
        case applicationId = "APPLICATION_ID"
        case applicationName = "APPLICATION_NAME"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountType = "ACCOUNT_TYPE"
    }

    /// Search for Recipients
    /// - GET /api/{version}/notification/recipient/search
    /// - Search for application users to send notifications.
    /// - parameter version: (path)  
    /// - parameter sortField: (query) The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME} 
    /// - parameter deviceId: (query) the unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
    /// - parameter conduit: (query) the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
    /// - parameter keyword: (query) search by keyword on user&#39;s display name and email (optional)
    /// - parameter audienceId: (query) This parameter is deprecated. filter results by audience (optional)
    /// - parameter audienceIds: (query) filter results by audiences (comma separated list of audience ids) (optional)
    /// - parameter connectionGroupIds: (query) filter results by connection groups (comma separated list of connection group ids) (optional)
    /// - parameter recipientAccountIds: (query) filter results by accounts (comma separated list of account ids) (optional)
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
    /// - parameter start: (query) start of the pagination (optional)
    /// - parameter limit: (query) limit of the pagination (hard limit of 1000) (optional)
    /// - returns: AnyPublisher<[NotificationRecipientResponse], Error> 
    open func searchRecipients(version: Double, sortField: SearchRecipientsSortField, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, conduit: String? = nil, keyword: String? = nil, audienceId: Int64? = nil, audienceIds: String? = nil, connectionGroupIds: String? = nil, recipientAccountIds: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[NotificationRecipientResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/recipient/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let conduit = conduit { queryItems.append(URLQueryItem(name: "conduit", value: conduit)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let audienceId = audienceId { queryItems.append(URLQueryItem(name: "audienceId", value: "\(audienceId)")) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let connectionGroupIds = connectionGroupIds { queryItems.append(URLQueryItem(name: "connectionGroupIds", value: connectionGroupIds)) } 
                if let recipientAccountIds = recipientAccountIds { queryItems.append(URLQueryItem(name: "recipientAccountIds", value: recipientAccountIds)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[NotificationRecipientResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([NotificationRecipientResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search for Recipients (Counts/Grouped)
    /// - GET /api/{version}/notification/recipient/search/count
    /// - Search for application users to send notifications (count/grouped variant).
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter appKey: (query) filters results by application. If this is empty, will return all recipients for all applications that the user has access to. (optional)
    /// - parameter conduit: (query) the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
    /// - parameter keyword: (query) search by keyword on user&#39;s display name and email (optional)
    /// - parameter audienceId: (query) This parameter is deprecated. filter results by audience (optional)
    /// - parameter audienceIds: (query) filter results by audiences (comma separated list of audience ids) (optional)
    /// - parameter connectionGroupIds: (query) filter results by connection groups (comma separated list of connection group ids) (optional)
    /// - parameter sortField: (query) The field to sort by (see API docs for allowed values). (optional)
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
    /// - parameter start: (query) start of the pagination (optional)
    /// - parameter limit: (query) limit of the pagination (optional)
    /// - returns: AnyPublisher<NotificationRecipientResponseListResponse, Error> 
    open func searchRecipientsCount(version: Double, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, conduit: String? = nil, keyword: String? = nil, audienceId: Int64? = nil, audienceIds: String? = nil, connectionGroupIds: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<NotificationRecipientResponseListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/recipient/search/count"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let conduit = conduit { queryItems.append(URLQueryItem(name: "conduit", value: conduit)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let audienceId = audienceId { queryItems.append(URLQueryItem(name: "audienceId", value: "\(audienceId)")) } 
                if let audienceIds = audienceIds { queryItems.append(URLQueryItem(name: "audienceIds", value: audienceIds)) } 
                if let connectionGroupIds = connectionGroupIds { queryItems.append(URLQueryItem(name: "connectionGroupIds", value: connectionGroupIds)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationRecipientResponseListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationRecipientResponseListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Send Batch Notifications
    /// - POST /api/{version}/notification/batch
    /// - Send notifications to all users of an application. Only someone with permissions to the application can do this.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the application owner/manager 
    /// - parameter appKey: (query) The application key for updating an existing application 
    /// - parameter customMessage: (query) Message string that will be displayed in on the notification 
    /// - parameter conduit: (query) The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
    /// - parameter contentId: (query) Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter contentName: (query) Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter contentType: (query) Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter parentId: (query) Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter parentType: (query) Default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func sendBatchNotifications(version: Double, accountId: Int64, appKey: String, customMessage: String, conduit: String? = nil, contentId: Int64? = nil, contentName: String? = nil, contentType: String? = nil, parentId: Int64? = nil, parentType: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/batch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let conduit = conduit { queryItems.append(URLQueryItem(name: "conduit", value: conduit)) } 
                queryItems.append(URLQueryItem(name: "customMessage", value: customMessage))
                if let contentId = contentId { queryItems.append(URLQueryItem(name: "contentId", value: "\(contentId)")) } 
                if let contentName = contentName { queryItems.append(URLQueryItem(name: "contentName", value: contentName)) } 
                if let contentType = contentType { queryItems.append(URLQueryItem(name: "contentType", value: contentType)) } 
                if let parentId = parentId { queryItems.append(URLQueryItem(name: "parentId", value: "\(parentId)")) } 
                if let parentType = parentType { queryItems.append(URLQueryItem(name: "parentType", value: parentType)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Send Custom Notifications
    /// - POST /api/{version}/notification/custom
    /// - Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) the unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter receiverAccountIds: (query) comma separated list of account IDs that will receive the notification (optional)
    /// - parameter includeFriendGroup: (query) determines whether to send to all of the user&#39;s friends, this flag must be true or receiverAccountIds must not be empty (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - parameter gameType: (query) This parameter is deprecated. (optional)
    /// - parameter conduit: (query) the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (optional)
    /// - parameter contentId: (query) default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter contentName: (query) default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter contentType: (query) default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter parentId: (query) default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter parentType: (query) default notification pay-load field (usage is dependent on the app and the type of event) (optional)
    /// - parameter actionCategory: (query)  (optional)
    /// - parameter subject: (query) the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event) (optional)
    /// - parameter customMessage: (query) message string that will be displayed in on the notification (optional)
    /// - parameter friendOnlyAPNS: (query) only sends APNS to people who are friends of the user (still saves the notification message for feed polling) (optional)
    /// - parameter latitude: (query) latitude used to update the user&#39;s current location (optional)
    /// - parameter longitude: (query) longitude used to update the user&#39;s current location (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func sendCustomNotifications(version: Double, deviceId: String? = nil, accountId: Int64? = nil, receiverAccountIds: String? = nil, includeFriendGroup: Bool? = nil, appKey: String? = nil, gameType: String? = nil, conduit: String? = nil, contentId: Int64? = nil, contentName: String? = nil, contentType: String? = nil, parentId: Int64? = nil, parentType: String? = nil, actionCategory: String? = nil, subject: String? = nil, customMessage: String? = nil, friendOnlyAPNS: Bool? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/custom"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let receiverAccountIds = receiverAccountIds { queryItems.append(URLQueryItem(name: "receiverAccountIds", value: receiverAccountIds)) } 
                if let includeFriendGroup = includeFriendGroup { queryItems.append(URLQueryItem(name: "includeFriendGroup", value: includeFriendGroup ? "true" : "false")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let gameType = gameType { queryItems.append(URLQueryItem(name: "gameType", value: gameType)) } 
                if let conduit = conduit { queryItems.append(URLQueryItem(name: "conduit", value: conduit)) } 
                if let contentId = contentId { queryItems.append(URLQueryItem(name: "contentId", value: "\(contentId)")) } 
                if let contentName = contentName { queryItems.append(URLQueryItem(name: "contentName", value: contentName)) } 
                if let contentType = contentType { queryItems.append(URLQueryItem(name: "contentType", value: contentType)) } 
                if let parentId = parentId { queryItems.append(URLQueryItem(name: "parentId", value: "\(parentId)")) } 
                if let parentType = parentType { queryItems.append(URLQueryItem(name: "parentType", value: parentType)) } 
                if let actionCategory = actionCategory { queryItems.append(URLQueryItem(name: "actionCategory", value: actionCategory)) } 
                if let subject = subject { queryItems.append(URLQueryItem(name: "subject", value: subject)) } 
                if let customMessage = customMessage { queryItems.append(URLQueryItem(name: "customMessage", value: customMessage)) } 
                if let friendOnlyAPNS = friendOnlyAPNS { queryItems.append(URLQueryItem(name: "friendOnlyAPNS", value: friendOnlyAPNS ? "true" : "false")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Notification Template
    /// - POST /api/{version}/notification/template/update
    /// - Update a notification template. Developers will only be able to update notification templates for their own applications.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account ID of the user. 
    /// - parameter notificationTemplateId: (query) The notification template ID to update. 
    /// - parameter title: (query) The title of the message (this would become the subject title for emails). There is a 191 character limit. (optional)
    /// - parameter body: (query) The body of the message. (optional)
    /// - parameter tags: (query) The search tags on the template used during search queries. (optional)
    /// - returns: AnyPublisher<NotificationTemplateResponse, Error> 
    open func updateNotificationTemplate(version: Double, accountId: Int64, notificationTemplateId: Int64, title: String? = nil, body: String? = nil, tags: String? = nil) -> AnyPublisher<NotificationTemplateResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/notification/template/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "notificationTemplateId", value: "\(notificationTemplateId)"))
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let body = body { queryItems.append(URLQueryItem(name: "body", value: body)) } 
                if let tags = tags { queryItems.append(URLQueryItem(name: "tags", value: tags)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<NotificationTemplateResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(NotificationTemplateResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
