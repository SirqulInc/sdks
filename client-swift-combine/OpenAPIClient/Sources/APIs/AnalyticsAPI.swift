//
// AnalyticsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AnalyticsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Get User Activity
    /// - GET /api/{version}/analytics/useractivity
    /// - Get an activity feed by user.
    /// - parameter version: (path)  
    /// - parameter start: (query) The start of the pagination 
    /// - parameter limit: (query) The limit of the pagination 
    /// - parameter accountId: (query) the account id of the user 
    /// - returns: AnyPublisher<[UserActivityResponse], Error> 
    open func activities(version: Double, start: Int, limit: Int, accountId: Int64) -> AnyPublisher<[UserActivityResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/analytics/useractivity"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[UserActivityResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([UserActivityResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter groupByRoot
    ///
    public enum AggregatedFilteredUsageGroupByRoot: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter groupBy
    ///
    public enum AggregatedFilteredUsageGroupBy: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter distinctCount
    ///
    public enum AggregatedFilteredUsageDistinctCount: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum AggregatedFilteredUsageSortField: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter responseFormat
    ///
    public enum AggregatedFilteredUsageResponseFormat: String, Codable, CaseIterable {
        case html = "HTML"
        case xml = "XML"
        case json = "JSON"
        case csv = "CSV"
    }

    /// Get Aggregated Filtered Usage
    /// - GET /api/{version}/analytics/aggregatedFilteredUsage
    /// - Query analytics to get data used for nested graphs and charts
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter applicationId: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) The application key used to filter results by application (optional)
    /// - parameter startDate: (query) Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
    /// - parameter endDate: (query) Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
    /// - parameter deviceType: (query) The device type to filter results by (performs a LIKE search) (optional)
    /// - parameter device: (query) The device to filter results by (performs a LIKE search) (optional)
    /// - parameter deviceOS: (query) The device OS to filter results by (performs a LIKE search) (optional)
    /// - parameter gender: (query) The gender to filter results by {MALE, FEMALE} (optional)
    /// - parameter ageGroup: (query) Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
    /// - parameter country: (query) The country to filter results by (performs a wild-card search) (optional)
    /// - parameter state: (query) The state to filter results by (performs a wild-card search) (optional)
    /// - parameter city: (query) The city to filter results by (performs a wild-card search) (optional)
    /// - parameter zip: (query) The zip to filter results by (performs a wild-card search) (optional)
    /// - parameter model: (query) The model to filter results by (performs a wild-card search) (optional)
    /// - parameter tag: (query) The tag to filter results by (performs a wild-card search) (optional)
    /// - parameter userAccountId: (query) The account id to filter results for a particular user (optional)
    /// - parameter userAccountDisplay: (query) The user display to filter results by (performs a wild-card search) (optional)
    /// - parameter userAccountUsername: (query) The username to filter results by (performs a wild-card search) (optional)
    /// - parameter groupByRoot: (query) Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
    /// - parameter groupBy: (query) Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID} (optional)
    /// - parameter distinctCount: (query) Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT} (optional)
    /// - parameter sortField: (query) Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
    /// - parameter descending: (query) Determines whether to return results in descending order (optional)
    /// - parameter hideUnknown: (query) Determines whether to return data that has empty or unknown values (optional)
    /// - parameter responseFormat: (query) Determines whether to return a JOSN or XML representation of the graph results (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter limit: (query) Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<ChartData, Error> 
    open func aggregatedFilteredUsage(version: Double, deviceId: String? = nil, accountId: Int64? = nil, applicationId: Int64? = nil, appKey: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, deviceType: String? = nil, device: String? = nil, deviceOS: String? = nil, gender: String? = nil, ageGroup: String? = nil, country: String? = nil, state: String? = nil, city: String? = nil, zip: String? = nil, model: String? = nil, tag: String? = nil, userAccountId: Int64? = nil, userAccountDisplay: String? = nil, userAccountUsername: String? = nil, groupByRoot: AggregatedFilteredUsageGroupByRoot? = nil, groupBy: AggregatedFilteredUsageGroupBy? = nil, distinctCount: AggregatedFilteredUsageDistinctCount? = nil, sortField: AggregatedFilteredUsageSortField? = nil, descending: Bool? = nil, hideUnknown: Bool? = nil, responseFormat: AggregatedFilteredUsageResponseFormat? = nil, l: Int? = nil, limit: Int? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ChartData, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/analytics/aggregatedFilteredUsage"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let applicationId = applicationId { queryItems.append(URLQueryItem(name: "applicationId", value: "\(applicationId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let deviceType = deviceType { queryItems.append(URLQueryItem(name: "deviceType", value: deviceType)) } 
                if let device = device { queryItems.append(URLQueryItem(name: "device", value: device)) } 
                if let deviceOS = deviceOS { queryItems.append(URLQueryItem(name: "deviceOS", value: deviceOS)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let ageGroup = ageGroup { queryItems.append(URLQueryItem(name: "ageGroup", value: ageGroup)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let zip = zip { queryItems.append(URLQueryItem(name: "zip", value: zip)) } 
                if let model = model { queryItems.append(URLQueryItem(name: "model", value: model)) } 
                if let tag = tag { queryItems.append(URLQueryItem(name: "tag", value: tag)) } 
                if let userAccountId = userAccountId { queryItems.append(URLQueryItem(name: "userAccountId", value: "\(userAccountId)")) } 
                if let userAccountDisplay = userAccountDisplay { queryItems.append(URLQueryItem(name: "userAccountDisplay", value: userAccountDisplay)) } 
                if let userAccountUsername = userAccountUsername { queryItems.append(URLQueryItem(name: "userAccountUsername", value: userAccountUsername)) } 
                if let groupByRoot = groupByRoot { queryItems.append(URLQueryItem(name: "groupByRoot", value: groupByRoot.rawValue)) } 
                if let groupBy = groupBy { queryItems.append(URLQueryItem(name: "groupBy", value: groupBy.rawValue)) } 
                if let distinctCount = distinctCount { queryItems.append(URLQueryItem(name: "distinctCount", value: distinctCount.rawValue)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let hideUnknown = hideUnknown { queryItems.append(URLQueryItem(name: "hideUnknown", value: hideUnknown ? "true" : "false")) } 
                if let responseFormat = responseFormat { queryItems.append(URLQueryItem(name: "responseFormat", value: responseFormat.rawValue)) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ChartData, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ChartData.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter groupBy
    ///
    public enum FilteredUsageGroupBy: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter distinctCount
    ///
    public enum FilteredUsageDistinctCount: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter sumColumn
    ///
    public enum FilteredUsageSumColumn: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum FilteredUsageSortField: String, Codable, CaseIterable {
        case tagCount = "TAG_COUNT"
        case tag = "TAG"
        case token = "TOKEN"
        case model = "MODEL"
        case deviceType = "DEVICE_TYPE"
        case device = "DEVICE"
        case deviceOs = "DEVICE_OS"
        case deviceId = "DEVICE_ID"
        case ipAddress = "IP_ADDRESS"
        case state = "STATE"
        case city = "CITY"
        case zip = "ZIP"
        case country = "COUNTRY"
        case created = "CREATED"
        case updated = "UPDATED"
        case lastUpdated = "LAST_UPDATED"
        case clientTime = "CLIENT_TIME"
        case active = "ACTIVE"
        case customId = "CUSTOM_ID"
        case customType = "CUSTOM_TYPE"
        case customValue = "CUSTOM_VALUE"
        case customValue2 = "CUSTOM_VALUE2"
        case customLong = "CUSTOM_LONG"
        case customLong2 = "CUSTOM_LONG2"
        case customMessage = "CUSTOM_MESSAGE"
        case customMessage2 = "CUSTOM_MESSAGE2"
        case accountId = "ACCOUNT_ID"
        case accountUsername = "ACCOUNT_USERNAME"
        case accountDisplay = "ACCOUNT_DISPLAY"
        case accountCreated = "ACCOUNT_CREATED"
        case accountGender = "ACCOUNT_GENDER"
        case accountAgeGroup = "ACCOUNT_AGE_GROUP"
        case applicationId = "APPLICATION_ID"
        case applicationKey = "APPLICATION_KEY"
        case applicationName = "APPLICATION_NAME"
    }
    ///
    /// Enum for parameter responseFormat
    ///
    public enum FilteredUsageResponseFormat: String, Codable, CaseIterable {
        case html = "HTML"
        case xml = "XML"
        case json = "JSON"
        case csv = "CSV"
    }

    /// Get Filtered Usage
    /// - GET /api/{version}/analytics/filteredUsage
    /// - Query analytics to get data used for graphs and charts
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter applicationId: (query) This parameter is deprecated. (optional)
    /// - parameter appKey: (query) The application key used to filter results by application (optional)
    /// - parameter startDate: (query) Used to search for results after or equal to this date (UNIX time-stamp in milliseconds) (optional)
    /// - parameter endDate: (query) Used to search for results before or equal to this date (UNIX time-stamp in milliseconds) (optional)
    /// - parameter deviceType: (query) The device type to filter results by (performs a LIKE search) (optional)
    /// - parameter device: (query) The device to filter results by (performs a LIKE search) (optional)
    /// - parameter deviceOS: (query) The device OS to filter results by (performs a LIKE search) (optional)
    /// - parameter gender: (query) The gender to filter results by {MALE, FEMALE} (optional)
    /// - parameter ageGroup: (query) Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS} (optional)
    /// - parameter country: (query) The country to filter results by (performs a wild-card search) (optional)
    /// - parameter state: (query) The state to filter results by (performs a wild-card search) (optional)
    /// - parameter city: (query) The city to filter results by (performs a wild-card search) (optional)
    /// - parameter zip: (query) The zip to filter results by (performs a wild-card search) (optional)
    /// - parameter model: (query) The model to filter results by (performs a wild-card search) (optional)
    /// - parameter tag: (query) The tag to filter results by (performs a wild-card search) (optional)
    /// - parameter userAccountId: (query) The account id to filter results for a particular user (optional)
    /// - parameter userAccountDisplay: (query) The user display to filter results by (performs a wild-card search) (optional)
    /// - parameter userAccountUsername: (query) The username to filter results by (performs a wild-card search) (optional)
    /// - parameter customId: (query) The ID for the custom table column (optional)
    /// - parameter customType: (query) The type defined for the custom table column (optional)
    /// - parameter customValue: (query) The value for the custom table column (optional)
    /// - parameter customValue2: (query) The value for another custom table column (optional)
    /// - parameter customLong: (query) The value that supports Longs for custom table column (optional)
    /// - parameter customLong2: (query) The value that supports Longs for custom table column (optional)
    /// - parameter customMessage: (query) The message for the custom table column (optional)
    /// - parameter customMessage2: (query) The message for the custom table column (optional)
    /// - parameter groupBy: (query) Determines how to group results. For example, passing in &#39;CREATED&#39; will return results by date. Passing in &#39;ACCOUNT&#39; will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
    /// - parameter distinctCount: (query) Performs a unique query on the specified column. For example, passing in &#39;ACCOUNT&#39; will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID} (optional)
    /// - parameter sumColumn: (query) sum of the column values (optional)
    /// - parameter sortField: (query) Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT} (optional)
    /// - parameter descending: (query) Determines whether to return results in descending order (optional)
    /// - parameter hideUnknown: (query) Determines whether to return data that has empty or unknown values (optional)
    /// - parameter responseFormat: (query) Determines whether to return a JOSN or XML representation of the graph results (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - parameter limit: (query) Used to limit results to get a cleaner graph. The results that gets filtered out will be combined (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - returns: AnyPublisher<ChartData, Error> 
    open func filteredUsage(version: Double, deviceId: String? = nil, accountId: Int64? = nil, applicationId: Int64? = nil, appKey: String? = nil, startDate: Int64? = nil, endDate: Int64? = nil, deviceType: String? = nil, device: String? = nil, deviceOS: String? = nil, gender: String? = nil, ageGroup: String? = nil, country: String? = nil, state: String? = nil, city: String? = nil, zip: String? = nil, model: String? = nil, tag: String? = nil, userAccountId: Int64? = nil, userAccountDisplay: String? = nil, userAccountUsername: String? = nil, customId: Int64? = nil, customType: String? = nil, customValue: Double? = nil, customValue2: Double? = nil, customLong: Int64? = nil, customLong2: Int64? = nil, customMessage: String? = nil, customMessage2: String? = nil, groupBy: FilteredUsageGroupBy? = nil, distinctCount: FilteredUsageDistinctCount? = nil, sumColumn: FilteredUsageSumColumn? = nil, sortField: FilteredUsageSortField? = nil, descending: Bool? = nil, hideUnknown: Bool? = nil, responseFormat: FilteredUsageResponseFormat? = nil, l: Int? = nil, limit: Int? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<ChartData, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/analytics/filteredUsage"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let applicationId = applicationId { queryItems.append(URLQueryItem(name: "applicationId", value: "\(applicationId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let startDate = startDate { queryItems.append(URLQueryItem(name: "startDate", value: "\(startDate)")) } 
                if let endDate = endDate { queryItems.append(URLQueryItem(name: "endDate", value: "\(endDate)")) } 
                if let deviceType = deviceType { queryItems.append(URLQueryItem(name: "deviceType", value: deviceType)) } 
                if let device = device { queryItems.append(URLQueryItem(name: "device", value: device)) } 
                if let deviceOS = deviceOS { queryItems.append(URLQueryItem(name: "deviceOS", value: deviceOS)) } 
                if let gender = gender { queryItems.append(URLQueryItem(name: "gender", value: gender)) } 
                if let ageGroup = ageGroup { queryItems.append(URLQueryItem(name: "ageGroup", value: ageGroup)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let zip = zip { queryItems.append(URLQueryItem(name: "zip", value: zip)) } 
                if let model = model { queryItems.append(URLQueryItem(name: "model", value: model)) } 
                if let tag = tag { queryItems.append(URLQueryItem(name: "tag", value: tag)) } 
                if let userAccountId = userAccountId { queryItems.append(URLQueryItem(name: "userAccountId", value: "\(userAccountId)")) } 
                if let userAccountDisplay = userAccountDisplay { queryItems.append(URLQueryItem(name: "userAccountDisplay", value: userAccountDisplay)) } 
                if let userAccountUsername = userAccountUsername { queryItems.append(URLQueryItem(name: "userAccountUsername", value: userAccountUsername)) } 
                if let customId = customId { queryItems.append(URLQueryItem(name: "customId", value: "\(customId)")) } 
                if let customType = customType { queryItems.append(URLQueryItem(name: "customType", value: customType)) } 
                if let customValue = customValue { queryItems.append(URLQueryItem(name: "customValue", value: "\(customValue)")) } 
                if let customValue2 = customValue2 { queryItems.append(URLQueryItem(name: "customValue2", value: "\(customValue2)")) } 
                if let customLong = customLong { queryItems.append(URLQueryItem(name: "customLong", value: "\(customLong)")) } 
                if let customLong2 = customLong2 { queryItems.append(URLQueryItem(name: "customLong2", value: "\(customLong2)")) } 
                if let customMessage = customMessage { queryItems.append(URLQueryItem(name: "customMessage", value: customMessage)) } 
                if let customMessage2 = customMessage2 { queryItems.append(URLQueryItem(name: "customMessage2", value: customMessage2)) } 
                if let groupBy = groupBy { queryItems.append(URLQueryItem(name: "groupBy", value: groupBy.rawValue)) } 
                if let distinctCount = distinctCount { queryItems.append(URLQueryItem(name: "distinctCount", value: distinctCount.rawValue)) } 
                if let sumColumn = sumColumn { queryItems.append(URLQueryItem(name: "sumColumn", value: sumColumn.rawValue)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let hideUnknown = hideUnknown { queryItems.append(URLQueryItem(name: "hideUnknown", value: hideUnknown ? "true" : "false")) } 
                if let responseFormat = responseFormat { queryItems.append(URLQueryItem(name: "responseFormat", value: responseFormat.rawValue)) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ChartData, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ChartData.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Usage Record
    /// - POST /api/{version}/analytics/usage
    /// - Record an analytic record for a known state within the application.
    /// - parameter version: (path)  
    /// - parameter tag: (query) The tag to apply: the name of the action or thing being logged. 
    /// - parameter deviceId: (query) The client deviceID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter applicationId: (query) This parameter is deprecated. This is deprecated, use appKey. (optional)
    /// - parameter appKey: (query) The application key unique to each application. (optional)
    /// - parameter appVersion: (query) The current build version of the application (optional)
    /// - parameter device: (query) The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (optional)
    /// - parameter deviceType: (query) The type of device (Handheld or Desktop) (optional)
    /// - parameter deviceOS: (query) The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc) (optional)
    /// - parameter model: (query) The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
    /// - parameter latitude: (query) The current position of the user (optional)
    /// - parameter longitude: (query) The current position of the user (optional)
    /// - parameter customId: (query) A customId used to associate the usage record with some other record in the system (optional)
    /// - parameter customType: (query) The type of record the customId is recorded for (optional)
    /// - parameter achievementIncrement: (query) This parameter is deprecated. This is deprecated, use \&quot;customValue\&quot;. Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement (optional)
    /// - parameter city: (query) The current city of the user (optional)
    /// - parameter state: (query) The current state of the user (optional)
    /// - parameter country: (query) The current country of the user (optional)
    /// - parameter zip: (query) The current zip of the user (optional)
    /// - parameter locationDescription: (query) The general description of the user&#39;s location (optional)
    /// - parameter clientTime: (query) Timestamp sent from device (optional)
    /// - parameter errorMessage: (query) This parameter is deprecated. (optional)
    /// - parameter ip: (query) the ip address of the client device (optional)
    /// - parameter userAgent: (query) this is a description of the client (might contain the device&#39;s OS, browser version etc - its a common term) (optional)
    /// - parameter backgroundEvent: (query) This is deprecated. (optional)
    /// - parameter customMessage: (query) a custom message for the usage record (optional)
    /// - parameter customMessage2: (query) a custom message for the usage record (optional)
    /// - parameter customValue: (query) a custom value for the usage record (optional)
    /// - parameter customValue2: (query) a custom value for the usage record (optional)
    /// - parameter customLong: (query) a custom long value for the usage record (optional)
    /// - parameter customLong2: (query) a custom long value for the usage record (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func usage(version: Double, tag: String, deviceId: String? = nil, accountId: Int64? = nil, applicationId: Int64? = nil, appKey: String? = nil, appVersion: String? = nil, device: String? = nil, deviceType: String? = nil, deviceOS: String? = nil, model: String? = nil, latitude: Double? = nil, longitude: Double? = nil, customId: Int64? = nil, customType: String? = nil, achievementIncrement: Int64? = nil, city: String? = nil, state: String? = nil, country: String? = nil, zip: String? = nil, locationDescription: String? = nil, clientTime: Int64? = nil, errorMessage: String? = nil, ip: String? = nil, userAgent: String? = nil, backgroundEvent: Bool? = nil, customMessage: String? = nil, customMessage2: String? = nil, customValue: Double? = nil, customValue2: Double? = nil, customLong: Int64? = nil, customLong2: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/analytics/usage"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "tag", value: tag))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let applicationId = applicationId { queryItems.append(URLQueryItem(name: "applicationId", value: "\(applicationId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                if let device = device { queryItems.append(URLQueryItem(name: "device", value: device)) } 
                if let deviceType = deviceType { queryItems.append(URLQueryItem(name: "deviceType", value: deviceType)) } 
                if let deviceOS = deviceOS { queryItems.append(URLQueryItem(name: "deviceOS", value: deviceOS)) } 
                if let model = model { queryItems.append(URLQueryItem(name: "model", value: model)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let customId = customId { queryItems.append(URLQueryItem(name: "customId", value: "\(customId)")) } 
                if let customType = customType { queryItems.append(URLQueryItem(name: "customType", value: customType)) } 
                if let achievementIncrement = achievementIncrement { queryItems.append(URLQueryItem(name: "achievementIncrement", value: "\(achievementIncrement)")) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let zip = zip { queryItems.append(URLQueryItem(name: "zip", value: zip)) } 
                if let locationDescription = locationDescription { queryItems.append(URLQueryItem(name: "locationDescription", value: locationDescription)) } 
                if let clientTime = clientTime { queryItems.append(URLQueryItem(name: "clientTime", value: "\(clientTime)")) } 
                if let errorMessage = errorMessage { queryItems.append(URLQueryItem(name: "errorMessage", value: errorMessage)) } 
                if let ip = ip { queryItems.append(URLQueryItem(name: "ip", value: ip)) } 
                if let userAgent = userAgent { queryItems.append(URLQueryItem(name: "userAgent", value: userAgent)) } 
                if let backgroundEvent = backgroundEvent { queryItems.append(URLQueryItem(name: "backgroundEvent", value: backgroundEvent ? "true" : "false")) } 
                if let customMessage = customMessage { queryItems.append(URLQueryItem(name: "customMessage", value: customMessage)) } 
                if let customMessage2 = customMessage2 { queryItems.append(URLQueryItem(name: "customMessage2", value: customMessage2)) } 
                if let customValue = customValue { queryItems.append(URLQueryItem(name: "customValue", value: "\(customValue)")) } 
                if let customValue2 = customValue2 { queryItems.append(URLQueryItem(name: "customValue2", value: "\(customValue2)")) } 
                if let customLong = customLong { queryItems.append(URLQueryItem(name: "customLong", value: "\(customLong)")) } 
                if let customLong2 = customLong2 { queryItems.append(URLQueryItem(name: "customLong2", value: "\(customLong2)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Multiple Usage Records
    /// - POST /api/{version}/analytics/usage/batch
    /// - Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The application key unique to each application. 
    /// - parameter device: (query) The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) 
    /// - parameter data: (query) The analytic data AnalyticListResponse 
    /// - parameter deviceId: (query) The unique id of the device making the request (optional)
    /// - parameter accountId: (query) The account ID of the logged in user making the request (optional)
    /// - parameter appVersion: (query) The current build version of the application (optional)
    /// - parameter deviceType: (query) The type of device (Handheld or Desktop) (optional)
    /// - parameter deviceOS: (query) The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.) (optional)
    /// - parameter model: (query) The model of the device (iPhone5,1 , Nexus One, etc.) (optional)
    /// - parameter updateRanking: (query) Will create a leaderboard if one does not exist for the \&quot;tag\&quot; yet (optional)
    /// - parameter returnSummaryResponse: (query) Returns a summary response of the achievements that have been completed due to the analytics (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func usageBatch(version: Double, appKey: String, device: String, data: String, deviceId: String? = nil, accountId: Int64? = nil, appVersion: String? = nil, deviceType: String? = nil, deviceOS: String? = nil, model: String? = nil, updateRanking: Bool? = nil, returnSummaryResponse: Bool? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/analytics/usage/batch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let appVersion = appVersion { queryItems.append(URLQueryItem(name: "appVersion", value: appVersion)) } 
                queryItems.append(URLQueryItem(name: "device", value: device))
                if let deviceType = deviceType { queryItems.append(URLQueryItem(name: "deviceType", value: deviceType)) } 
                if let deviceOS = deviceOS { queryItems.append(URLQueryItem(name: "deviceOS", value: deviceOS)) } 
                if let model = model { queryItems.append(URLQueryItem(name: "model", value: model)) } 
                queryItems.append(URLQueryItem(name: "data", value: data))
                if let updateRanking = updateRanking { queryItems.append(URLQueryItem(name: "updateRanking", value: updateRanking ? "true" : "false")) } 
                if let returnSummaryResponse = returnSummaryResponse { queryItems.append(URLQueryItem(name: "returnSummaryResponse", value: returnSummaryResponse ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
