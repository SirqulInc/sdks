//
// ScoreAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ScoreAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Score
    /// - POST /api/{version}/score/create
    /// - Create a score.  The response object will contain a series of   coded messages detailing what items were completed, the score registered,   and any tickets allocated.  Scoring a  level could complete the pack it   is in, completing that pack could complete the game, which  in turn could   complete the mission.  This completion chain is indicated to the client   via  a list of {@link MessageResponse}.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) The game application key to save the score for. 
    /// - parameter points: (query) The score 
    /// - parameter missionId: (query) The missionId to score for, ignore if not playing mission. (optional)
    /// - parameter gameId: (query) The gameId to score for, ignore if not playing mission. (optional)
    /// - parameter packId: (query) The packId to score for, send -2 if playing community levels. (optional)
    /// - parameter gameLevelId: (query) The gameLevelId to score for. (optional)
    /// - parameter gameObjectId: (query) The gameObjectId to score for, ignore if level based scoring. (optional)
    /// - parameter timeTaken: (query) The time taken to complete task (optional)
    /// - parameter highest: (query)  (optional)
    /// - returns: AnyPublisher<ScoreResponse, Error> 
    open func createScore(version: Double, accountId: Int64, appKey: String, points: Int, missionId: Int64? = nil, gameId: Int64? = nil, packId: Int64? = nil, gameLevelId: Int64? = nil, gameObjectId: Int64? = nil, timeTaken: Int? = nil, highest: Bool? = nil) -> AnyPublisher<ScoreResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/score/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let gameId = gameId { queryItems.append(URLQueryItem(name: "gameId", value: "\(gameId)")) } 
                if let packId = packId { queryItems.append(URLQueryItem(name: "packId", value: "\(packId)")) } 
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                if let gameObjectId = gameObjectId { queryItems.append(URLQueryItem(name: "gameObjectId", value: "\(gameObjectId)")) } 
                queryItems.append(URLQueryItem(name: "points", value: "\(points)"))
                if let timeTaken = timeTaken { queryItems.append(URLQueryItem(name: "timeTaken", value: "\(timeTaken)")) } 
                if let highest = highest { queryItems.append(URLQueryItem(name: "highest", value: highest ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScoreResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ScoreResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Score
    /// - GET /api/{version}/score/get
    /// - Get the high score for an item.  Pass in the full path IDs for the score.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) The game application key to get the level for. 
    /// - parameter missionId: (query) The missionId to score for, null if not playing mission. (optional)
    /// - parameter gameId: (query) The gameId to score for, null if not playing mission. (optional)
    /// - parameter packId: (query) The packId to score for, null if playing community levels. (optional)
    /// - parameter gameLevelId: (query) The gameLevelId to score for. (optional)
    /// - parameter gameObjectId: (query) The gameObjectId to score for, null if level based scoring. (optional)
    /// - parameter scoreObjectType: (query) The object type to filter scores by (TicketObjectType) (optional)
    /// - parameter scoreStatus: (query) The status of the score to filter (ScoreStatus) (optional)
    /// - returns: AnyPublisher<ScoreResponse, Error> 
    open func getScore(version: Double, accountId: Int64, appKey: String, missionId: Int64? = nil, gameId: Int64? = nil, packId: Int64? = nil, gameLevelId: Int64? = nil, gameObjectId: Int64? = nil, scoreObjectType: String? = nil, scoreStatus: String? = nil) -> AnyPublisher<ScoreResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/score/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let gameId = gameId { queryItems.append(URLQueryItem(name: "gameId", value: "\(gameId)")) } 
                if let packId = packId { queryItems.append(URLQueryItem(name: "packId", value: "\(packId)")) } 
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                if let gameObjectId = gameObjectId { queryItems.append(URLQueryItem(name: "gameObjectId", value: "\(gameObjectId)")) } 
                if let scoreObjectType = scoreObjectType { queryItems.append(URLQueryItem(name: "scoreObjectType", value: scoreObjectType)) } 
                if let scoreStatus = scoreStatus { queryItems.append(URLQueryItem(name: "scoreStatus", value: scoreStatus)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ScoreResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ScoreResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Score
    /// - GET /api/{version}/score/search
    /// - Search the scores for an item.  Pass in the full path IDs for the scores.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter appKey: (query) The game application key to get the level for. 
    /// - parameter missionId: (query) The missionId to score for, null if not playing mission. (optional)
    /// - parameter gameId: (query) The gameId to score for, null if not playing mission. (optional)
    /// - parameter packId: (query) The packId to score for, null if playing community levels. (optional)
    /// - parameter gameLevelId: (query) The gameLevelId to score for. (optional)
    /// - parameter gameObjectId: (query) The gameObjectId to score for, null if level based scoring. (optional)
    /// - returns: AnyPublisher<[ScoreResponse], Error> 
    open func searchScores(version: Double, accountId: Int64, appKey: String, missionId: Int64? = nil, gameId: Int64? = nil, packId: Int64? = nil, gameLevelId: Int64? = nil, gameObjectId: Int64? = nil) -> AnyPublisher<[ScoreResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/score/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let missionId = missionId { queryItems.append(URLQueryItem(name: "missionId", value: "\(missionId)")) } 
                if let gameId = gameId { queryItems.append(URLQueryItem(name: "gameId", value: "\(gameId)")) } 
                if let packId = packId { queryItems.append(URLQueryItem(name: "packId", value: "\(packId)")) } 
                if let gameLevelId = gameLevelId { queryItems.append(URLQueryItem(name: "gameLevelId", value: "\(gameLevelId)")) } 
                if let gameObjectId = gameObjectId { queryItems.append(URLQueryItem(name: "gameObjectId", value: "\(gameObjectId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ScoreResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ScoreResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
