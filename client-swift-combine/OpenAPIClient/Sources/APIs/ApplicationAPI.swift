//
// ApplicationAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ApplicationAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter scoringType
    ///
    public enum CreateApplicationScoringType: String, Codable, CaseIterable {
        case gameLevel = "GAME_LEVEL"
        case gameObject = "GAME_OBJECT"
    }
    ///
    /// Enum for parameter placementSize
    ///
    public enum CreateApplicationPlacementSize: String, Codable, CaseIterable {
        case config = "CONFIG"
        case banner = "BANNER"
        case leaderboard = "LEADERBOARD"
        case skyscraper = "SKYSCRAPER"
        case video = "VIDEO"
        case zip = "ZIP"
        case interstitial = "INTERSTITIAL"
        case custom1 = "CUSTOM1"
        case custom2 = "CUSTOM2"
        case custom3 = "CUSTOM3"
        case custom4 = "CUSTOM4"
        case custom5 = "CUSTOM5"
        case custom6 = "CUSTOM6"
        case custom7 = "CUSTOM7"
        case custom8 = "CUSTOM8"
        case custom9 = "CUSTOM9"
        case custom10 = "CUSTOM10"
    }
    ///
    /// Enum for parameter trilatProcessingType
    ///
    public enum CreateApplicationTrilatProcessingType: String, Codable, CaseIterable {
        case _default = "DEFAULT"
        case fingerprint = "FINGERPRINT"
        case fingerprintV2 = "FINGERPRINT_V2"
    }

    /// Create Application
    /// - POST /api/{version}/application/create
    /// - Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.
    /// - parameter version: (path)  
    /// - parameter appName: (query) The name of the application 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter about: (query) The description of the application (optional)
    /// - parameter bundleId: (query) The application bundle identifier (format - com.company.appName) (optional)
    /// - parameter appIconAssetId: (query) The application icon asset id (optional)
    /// - parameter appLogoAssetId: (query) The application logo asset id (optional)
    /// - parameter facebookAppId: (query) The Facebook application id (optional)
    /// - parameter facebookAppSecret: (query) The Facebook application secret (optional)
    /// - parameter googleApiKey: (query) This is the either the &#39;server key&#39; or &#39;browser key&#39; generated from google to enable Google Cloud Messaging (optional)
    /// - parameter updateEULADate: (query) Determines whether to update the EULA date (optional)
    /// - parameter eulaVersion: (query) The EULA version (optional)
    /// - parameter landingPageUrl: (query) The landing page URL (optional)
    /// - parameter showInActivities: (query) Determines whether to show the application in the activity feed (optional)
    /// - parameter activityDescription: (query) The description of the application in the activity feed (optional)
    /// - parameter inviteWelcomeText: (query) The text to display on the invite page (optional)
    /// - parameter invitePageUrl: (query) The url to the application invite page (optional)
    /// - parameter urlScheme: (query) The protocal the app uses to load the app via a browser (optional)
    /// - parameter platforms: (query) A json object with a list of supported platforms.  &#x60;&#x60;&#x60;json {   \&quot;platforms\&quot;: [     {       \&quot;deviceId\&quot;: 1,       \&quot;minimum\&quot;: 230,       \&quot;maximum\&quot;: 421,       \&quot;downloadUrl\&quot;: \&quot;http://app.store.com/download\&quot;,       \&quot;description\&quot;: \&quot;description and version info\&quot;     }   ] } &#x60;&#x60;&#x60;  (optional)
    /// - parameter downloadUrls: (query) Json formatted downloadUrls.  &#x60;&#x60;&#x60;json {   \&quot;ios\&quot;: \&quot;the-url-to-app-store\&quot;,    \&quot;android\&quot;: \&quot;the-url-to-google-play\&quot; } &#x60;&#x60;&#x60;   (optional)
    /// - parameter categoryIds: (query) List of categories to apply (optional)
    /// - parameter scoringType: (query) The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT (optional, default to .gameLevel)
    /// - parameter hintCost: (query) The cost of hints (optional, default to 11)
    /// - parameter maxScore: (query) The maximum score that will be possible (optional, default to 125)
    /// - parameter ticketsPerPoint: (query) The point-to-ticket conversion ratio (optional, default to 0.037)
    /// - parameter hasGameData: (query) Determines whether the application uses services to save custom game objects (optional, default to true)
    /// - parameter publicNotifications: (query) Public Notifications (optional)
    /// - parameter useMatchingAlgorithm: (query) Use Matching Algorithm (optional)
    /// - parameter globalTickets: (query) Determines whether earned tickets are applied across all applications (optional, default to false)
    /// - parameter buildVersion: (query) The current build version of the application (optional, default to 1)
    /// - parameter apiVersion: (query) The current API version the application uses (optional)
    /// - parameter placementName: (query) The name of the placement (optional)
    /// - parameter placementDescription: (query) The description of the placement (optional)
    /// - parameter placementSize: (query) The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created) (optional)
    /// - parameter placementHeight: (query) The height of a custom ad size (optional)
    /// - parameter placementWidth: (query) The width of a custom ad size (optional)
    /// - parameter placementRefreshInterval: (query) The refresh interval in seconds (optional)
    /// - parameter createObjectStore: (query) Generate a custom object store to use (optional, default to true)
    /// - parameter publicContentApproval: (query) Determine whether or not public content requires admin approval before it becomes public (optional, default to false)
    /// - parameter productionMode: (query) Determines whether the application uses production or sandbox services (optional, default to false)
    /// - parameter minimumSessionLength: (query) Minimum Session Length (optional)
    /// - parameter sessionGapLength: (query) Session Gap Length (optional)
    /// - parameter localAdsEnabled: (query) Local Ads Enabled (optional, default to false)
    /// - parameter sqootApiKey: (query) Sqoot Api Key (optional)
    /// - parameter trilatProcessingType: (query) Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT (optional, default to .fingerprint)
    /// - parameter maxSampleSize: (query) Determines what the maximum sample size during trilateration (optional)
    /// - parameter minRSSI: (query) Determines what the minimum acceptable RSSI value (optional)
    /// - parameter modules: (query) List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL (optional, default to "ALL")
    /// - parameter authorizedCount: (query) How many servers the license will support (optional, default to 1)
    /// - parameter authorizedServers: (query) The list of ip addresses of servers the license will support, leave null for any server (optional)
    /// - parameter defaultTimezone: (query) Sets the default timezone for the app (used for leaderboards and other time specific content) (optional)
    /// - parameter smtpPass: (query) SMTP Pass (optional)
    /// - parameter metaData: (query) The application meta data. Defined by the client (optional)
    /// - parameter placementMetaData: (query) The ad placement meta data. Defined by the client (optional)
    /// - parameter ipsFloor: (query) Create floor tables for Ips (optional, default to false)
    /// - parameter enableAPNSBadge: (query) Enables setting the APNS badge value in the payload (optional, default to true)
    /// - parameter includeInReport: (query) Enables using the application in session reports (optional, default to true)
    /// - parameter defaultAppFilterId: (query) Sets the default filter to use (if none is passed in) for certain search APIs including Album Search. (optional)
    /// - parameter enableWelcomeEmail: (query) Enables whether the default welcome email will be sent for new app users (optional)
    /// - parameter appleAppId: (query) The Apple Application ID (optional)
    /// - parameter appleTeamId: (query) The Apple Team ID (optional)
    /// - parameter appleAuthKeyId: (query) The Apple Auth Key ID (optional)
    /// - parameter appleAuthKey: (query) The Apple Auth Signin Key (p8) File (optional)
    /// - parameter appleIssuerId: (query) The Apple Issuer ID (optional)
    /// - parameter appStoreKeyId: (query) The Apple App Store Key ID (optional)
    /// - parameter appStoreKey: (query) The Apple App Store Key (p8) File (optional)
    /// - parameter googlePrivateKeyFile: (query) This is the private key file for your Google service account. (optional)
    /// - parameter authorizeNetApiKey: (query) Authorize Net Api Key (optional)
    /// - parameter authorizeNetTransactionKey: (query) Authorize Net Transaction Key (optional)
    /// - parameter emailSender: (query) Email Sender (optional)
    /// - parameter smtpUser: (query) SMTP User (optional)
    /// - parameter smtpHost: (query) SMTP Host (optional)
    /// - parameter vatomBusinessId: (query) Vatom Business Id (optional)
    /// - parameter vatomRestClientId: (query) Vatom REST Client Id (optional)
    /// - parameter vatomRestSecretKey: (query) Vatom Secret Key (optional)
    /// - parameter twilioAccountSID: (query) Twilio Account SID (optional)
    /// - parameter twilioAuthToken: (query) Twilio Auth Token (optional)
    /// - parameter twilioSenderPhoneNumber: (query) Twilio Sender Phone Number (optional)
    /// - parameter openAISecretKey: (query) OpenAI Secret API Key (optional)
    /// - returns: AnyPublisher<ApplicationResponse, Error> 
    open func createApplication(version: Double, appName: String, deviceId: String? = nil, accountId: Int64? = nil, about: String? = nil, bundleId: String? = nil, appIconAssetId: Int64? = nil, appLogoAssetId: Int64? = nil, facebookAppId: String? = nil, facebookAppSecret: String? = nil, googleApiKey: String? = nil, updateEULADate: Bool? = nil, eulaVersion: String? = nil, landingPageUrl: String? = nil, showInActivities: Bool? = nil, activityDescription: String? = nil, inviteWelcomeText: String? = nil, invitePageUrl: String? = nil, urlScheme: String? = nil, platforms: String? = nil, downloadUrls: String? = nil, categoryIds: String? = nil, scoringType: CreateApplicationScoringType? = nil, hintCost: Int? = nil, maxScore: Int? = nil, ticketsPerPoint: Float? = nil, hasGameData: Bool? = nil, publicNotifications: Bool? = nil, useMatchingAlgorithm: Bool? = nil, globalTickets: Bool? = nil, buildVersion: Float? = nil, apiVersion: Float? = nil, placementName: String? = nil, placementDescription: String? = nil, placementSize: CreateApplicationPlacementSize? = nil, placementHeight: Int? = nil, placementWidth: Int? = nil, placementRefreshInterval: Int? = nil, createObjectStore: Bool? = nil, publicContentApproval: Bool? = nil, productionMode: Bool? = nil, minimumSessionLength: Int? = nil, sessionGapLength: Int? = nil, localAdsEnabled: Bool? = nil, sqootApiKey: String? = nil, trilatProcessingType: CreateApplicationTrilatProcessingType? = nil, maxSampleSize: Int? = nil, minRSSI: Double? = nil, modules: String? = nil, authorizedCount: Int? = nil, authorizedServers: String? = nil, defaultTimezone: String? = nil, smtpPass: String? = nil, metaData: String? = nil, placementMetaData: String? = nil, ipsFloor: Bool? = nil, enableAPNSBadge: Bool? = nil, includeInReport: Bool? = nil, defaultAppFilterId: Int64? = nil, enableWelcomeEmail: Bool? = nil, appleAppId: String? = nil, appleTeamId: String? = nil, appleAuthKeyId: String? = nil, appleAuthKey: Data? = nil, appleIssuerId: String? = nil, appStoreKeyId: String? = nil, appStoreKey: Data? = nil, googlePrivateKeyFile: Data? = nil, authorizeNetApiKey: String? = nil, authorizeNetTransactionKey: String? = nil, emailSender: String? = nil, smtpUser: String? = nil, smtpHost: String? = nil, vatomBusinessId: String? = nil, vatomRestClientId: String? = nil, vatomRestSecretKey: String? = nil, twilioAccountSID: String? = nil, twilioAuthToken: String? = nil, twilioSenderPhoneNumber: String? = nil, openAISecretKey: String? = nil) -> AnyPublisher<ApplicationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appName", value: appName))
                if let about = about { queryItems.append(URLQueryItem(name: "about", value: about)) } 
                if let bundleId = bundleId { queryItems.append(URLQueryItem(name: "bundleId", value: bundleId)) } 
                if let appIconAssetId = appIconAssetId { queryItems.append(URLQueryItem(name: "appIconAssetId", value: "\(appIconAssetId)")) } 
                if let appLogoAssetId = appLogoAssetId { queryItems.append(URLQueryItem(name: "appLogoAssetId", value: "\(appLogoAssetId)")) } 
                if let facebookAppId = facebookAppId { queryItems.append(URLQueryItem(name: "facebookAppId", value: facebookAppId)) } 
                if let facebookAppSecret = facebookAppSecret { queryItems.append(URLQueryItem(name: "facebookAppSecret", value: facebookAppSecret)) } 
                if let googleApiKey = googleApiKey { queryItems.append(URLQueryItem(name: "googleApiKey", value: googleApiKey)) } 
                if let updateEULADate = updateEULADate { queryItems.append(URLQueryItem(name: "updateEULADate", value: updateEULADate ? "true" : "false")) } 
                if let eulaVersion = eulaVersion { queryItems.append(URLQueryItem(name: "eulaVersion", value: eulaVersion)) } 
                if let landingPageUrl = landingPageUrl { queryItems.append(URLQueryItem(name: "landingPageUrl", value: landingPageUrl)) } 
                if let showInActivities = showInActivities { queryItems.append(URLQueryItem(name: "showInActivities", value: showInActivities ? "true" : "false")) } 
                if let activityDescription = activityDescription { queryItems.append(URLQueryItem(name: "activityDescription", value: activityDescription)) } 
                if let inviteWelcomeText = inviteWelcomeText { queryItems.append(URLQueryItem(name: "inviteWelcomeText", value: inviteWelcomeText)) } 
                if let invitePageUrl = invitePageUrl { queryItems.append(URLQueryItem(name: "invitePageUrl", value: invitePageUrl)) } 
                if let urlScheme = urlScheme { queryItems.append(URLQueryItem(name: "urlScheme", value: urlScheme)) } 
                if let platforms = platforms { queryItems.append(URLQueryItem(name: "platforms", value: platforms)) } 
                if let downloadUrls = downloadUrls { queryItems.append(URLQueryItem(name: "downloadUrls", value: downloadUrls)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let scoringType = scoringType { queryItems.append(URLQueryItem(name: "scoringType", value: scoringType.rawValue)) } 
                if let hintCost = hintCost { queryItems.append(URLQueryItem(name: "hintCost", value: "\(hintCost)")) } 
                if let maxScore = maxScore { queryItems.append(URLQueryItem(name: "maxScore", value: "\(maxScore)")) } 
                if let ticketsPerPoint = ticketsPerPoint { queryItems.append(URLQueryItem(name: "ticketsPerPoint", value: "\(ticketsPerPoint)")) } 
                if let hasGameData = hasGameData { queryItems.append(URLQueryItem(name: "hasGameData", value: hasGameData ? "true" : "false")) } 
                if let publicNotifications = publicNotifications { queryItems.append(URLQueryItem(name: "publicNotifications", value: publicNotifications ? "true" : "false")) } 
                if let useMatchingAlgorithm = useMatchingAlgorithm { queryItems.append(URLQueryItem(name: "useMatchingAlgorithm", value: useMatchingAlgorithm ? "true" : "false")) } 
                if let globalTickets = globalTickets { queryItems.append(URLQueryItem(name: "globalTickets", value: globalTickets ? "true" : "false")) } 
                if let buildVersion = buildVersion { queryItems.append(URLQueryItem(name: "buildVersion", value: "\(buildVersion)")) } 
                if let apiVersion = apiVersion { queryItems.append(URLQueryItem(name: "apiVersion", value: "\(apiVersion)")) } 
                if let placementName = placementName { queryItems.append(URLQueryItem(name: "placementName", value: placementName)) } 
                if let placementDescription = placementDescription { queryItems.append(URLQueryItem(name: "placementDescription", value: placementDescription)) } 
                if let placementSize = placementSize { queryItems.append(URLQueryItem(name: "placementSize", value: placementSize.rawValue)) } 
                if let placementHeight = placementHeight { queryItems.append(URLQueryItem(name: "placementHeight", value: "\(placementHeight)")) } 
                if let placementWidth = placementWidth { queryItems.append(URLQueryItem(name: "placementWidth", value: "\(placementWidth)")) } 
                if let placementRefreshInterval = placementRefreshInterval { queryItems.append(URLQueryItem(name: "placementRefreshInterval", value: "\(placementRefreshInterval)")) } 
                if let createObjectStore = createObjectStore { queryItems.append(URLQueryItem(name: "createObjectStore", value: createObjectStore ? "true" : "false")) } 
                if let publicContentApproval = publicContentApproval { queryItems.append(URLQueryItem(name: "publicContentApproval", value: publicContentApproval ? "true" : "false")) } 
                if let productionMode = productionMode { queryItems.append(URLQueryItem(name: "productionMode", value: productionMode ? "true" : "false")) } 
                if let minimumSessionLength = minimumSessionLength { queryItems.append(URLQueryItem(name: "minimumSessionLength", value: "\(minimumSessionLength)")) } 
                if let sessionGapLength = sessionGapLength { queryItems.append(URLQueryItem(name: "sessionGapLength", value: "\(sessionGapLength)")) } 
                if let localAdsEnabled = localAdsEnabled { queryItems.append(URLQueryItem(name: "localAdsEnabled", value: localAdsEnabled ? "true" : "false")) } 
                if let sqootApiKey = sqootApiKey { queryItems.append(URLQueryItem(name: "sqootApiKey", value: sqootApiKey)) } 
                if let trilatProcessingType = trilatProcessingType { queryItems.append(URLQueryItem(name: "trilatProcessingType", value: trilatProcessingType.rawValue)) } 
                if let maxSampleSize = maxSampleSize { queryItems.append(URLQueryItem(name: "maxSampleSize", value: "\(maxSampleSize)")) } 
                if let minRSSI = minRSSI { queryItems.append(URLQueryItem(name: "minRSSI", value: "\(minRSSI)")) } 
                if let modules = modules { queryItems.append(URLQueryItem(name: "modules", value: modules)) } 
                if let authorizedCount = authorizedCount { queryItems.append(URLQueryItem(name: "authorizedCount", value: "\(authorizedCount)")) } 
                if let authorizedServers = authorizedServers { queryItems.append(URLQueryItem(name: "authorizedServers", value: authorizedServers)) } 
                if let defaultTimezone = defaultTimezone { queryItems.append(URLQueryItem(name: "defaultTimezone", value: defaultTimezone)) } 
                if let smtpPass = smtpPass { queryItems.append(URLQueryItem(name: "smtpPass", value: smtpPass)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let placementMetaData = placementMetaData { queryItems.append(URLQueryItem(name: "placementMetaData", value: placementMetaData)) } 
                if let ipsFloor = ipsFloor { queryItems.append(URLQueryItem(name: "ipsFloor", value: ipsFloor ? "true" : "false")) } 
                if let enableAPNSBadge = enableAPNSBadge { queryItems.append(URLQueryItem(name: "enableAPNSBadge", value: enableAPNSBadge ? "true" : "false")) } 
                if let includeInReport = includeInReport { queryItems.append(URLQueryItem(name: "includeInReport", value: includeInReport ? "true" : "false")) } 
                if let defaultAppFilterId = defaultAppFilterId { queryItems.append(URLQueryItem(name: "defaultAppFilterId", value: "\(defaultAppFilterId)")) } 
                if let enableWelcomeEmail = enableWelcomeEmail { queryItems.append(URLQueryItem(name: "enableWelcomeEmail", value: enableWelcomeEmail ? "true" : "false")) } 
                if let appleAppId = appleAppId { queryItems.append(URLQueryItem(name: "appleAppId", value: appleAppId)) } 
                if let appleTeamId = appleTeamId { queryItems.append(URLQueryItem(name: "appleTeamId", value: appleTeamId)) } 
                if let appleAuthKeyId = appleAuthKeyId { queryItems.append(URLQueryItem(name: "appleAuthKeyId", value: appleAuthKeyId)) } 
                if let appleAuthKey = appleAuthKey { queryItems.append(URLQueryItem(name: "appleAuthKey", value: )) } 
                if let appleIssuerId = appleIssuerId { queryItems.append(URLQueryItem(name: "appleIssuerId", value: appleIssuerId)) } 
                if let appStoreKeyId = appStoreKeyId { queryItems.append(URLQueryItem(name: "appStoreKeyId", value: appStoreKeyId)) } 
                if let appStoreKey = appStoreKey { queryItems.append(URLQueryItem(name: "appStoreKey", value: )) } 
                if let googlePrivateKeyFile = googlePrivateKeyFile { queryItems.append(URLQueryItem(name: "googlePrivateKeyFile", value: )) } 
                if let authorizeNetApiKey = authorizeNetApiKey { queryItems.append(URLQueryItem(name: "authorizeNetApiKey", value: authorizeNetApiKey)) } 
                if let authorizeNetTransactionKey = authorizeNetTransactionKey { queryItems.append(URLQueryItem(name: "authorizeNetTransactionKey", value: authorizeNetTransactionKey)) } 
                if let emailSender = emailSender { queryItems.append(URLQueryItem(name: "emailSender", value: emailSender)) } 
                if let smtpUser = smtpUser { queryItems.append(URLQueryItem(name: "smtpUser", value: smtpUser)) } 
                if let smtpHost = smtpHost { queryItems.append(URLQueryItem(name: "smtpHost", value: smtpHost)) } 
                if let vatomBusinessId = vatomBusinessId { queryItems.append(URLQueryItem(name: "vatomBusinessId", value: vatomBusinessId)) } 
                if let vatomRestClientId = vatomRestClientId { queryItems.append(URLQueryItem(name: "vatomRestClientId", value: vatomRestClientId)) } 
                if let vatomRestSecretKey = vatomRestSecretKey { queryItems.append(URLQueryItem(name: "vatomRestSecretKey", value: vatomRestSecretKey)) } 
                if let twilioAccountSID = twilioAccountSID { queryItems.append(URLQueryItem(name: "twilioAccountSID", value: twilioAccountSID)) } 
                if let twilioAuthToken = twilioAuthToken { queryItems.append(URLQueryItem(name: "twilioAuthToken", value: twilioAuthToken)) } 
                if let twilioSenderPhoneNumber = twilioSenderPhoneNumber { queryItems.append(URLQueryItem(name: "twilioSenderPhoneNumber", value: twilioSenderPhoneNumber)) } 
                if let openAISecretKey = openAISecretKey { queryItems.append(URLQueryItem(name: "openAISecretKey", value: openAISecretKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ApplicationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ApplicationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter size
    ///
    public enum CreateApplicationPlacementSize: String, Codable, CaseIterable {
        case config = "CONFIG"
        case banner = "BANNER"
        case leaderboard = "LEADERBOARD"
        case skyscraper = "SKYSCRAPER"
        case video = "VIDEO"
        case zip = "ZIP"
        case interstitial = "INTERSTITIAL"
        case custom1 = "CUSTOM1"
        case custom2 = "CUSTOM2"
        case custom3 = "CUSTOM3"
        case custom4 = "CUSTOM4"
        case custom5 = "CUSTOM5"
        case custom6 = "CUSTOM6"
        case custom7 = "CUSTOM7"
        case custom8 = "CUSTOM8"
        case custom9 = "CUSTOM9"
        case custom10 = "CUSTOM10"
    }

    /// Create Ad Placement
    /// - POST /api/{version}/application/placement/create
    /// - Creates a new ad placement for an application.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The appKey of the application the ad placement is for 
    /// - parameter size: (query) The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter name: (query) The name of the placement (optional)
    /// - parameter description: (query) The description of the placement (optional)
    /// - parameter height: (query) The height of a custom ad size (optional)
    /// - parameter width: (query) The width of a custom ad size (optional)
    /// - parameter refreshInterval: (query) The refresh interval in seconds (optional)
    /// - parameter defaultImageId: (query) Default Image Id (optional)
    /// - parameter active: (query) Active (optional)
    /// - returns: AnyPublisher<PlacementResponse, Error> 
    open func createApplicationPlacement(version: Double, appKey: String, size: CreateApplicationPlacementSize, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, description: String? = nil, height: Int? = nil, width: Int? = nil, refreshInterval: Int? = nil, defaultImageId: Int64? = nil, active: Bool? = nil) -> AnyPublisher<PlacementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/placement/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                queryItems.append(URLQueryItem(name: "size", value: size.rawValue))
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: "\(height)")) } 
                if let width = width { queryItems.append(URLQueryItem(name: "width", value: "\(width)")) } 
                if let refreshInterval = refreshInterval { queryItems.append(URLQueryItem(name: "refreshInterval", value: "\(refreshInterval)")) } 
                if let defaultImageId = defaultImageId { queryItems.append(URLQueryItem(name: "defaultImageId", value: "\(defaultImageId)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlacementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PlacementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Application
    /// - POST /api/{version}/application/delete
    /// - Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account used to perform the delete, must have rights to edit the application. (optional)
    /// - parameter appKey: (query) The key of the application to be deleted (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteApplication(version: Double, accountId: Int64? = nil, appKey: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Ad Placement
    /// - POST /api/{version}/application/placement/delete
    /// - Deletes an ad placement for an application.
    /// - parameter version: (path)  
    /// - parameter placementId: (query) The id of the placement to delete, the user must have rights to the application the ad placement is for 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<PlacementResponse, Error> 
    open func deleteApplicationPlacement(version: Double, placementId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<PlacementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/placement/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "placementId", value: "\(placementId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlacementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PlacementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Application
    /// - GET /api/{version}/application/get
    /// - Get a specific application by appKey
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The key of the application (optional)
    /// - parameter applicationId: (query) Application Id (optional)
    /// - returns: AnyPublisher<ApplicationResponse, Error> 
    open func getApplication(version: Double, appKey: String? = nil, applicationId: Int64? = nil) -> AnyPublisher<ApplicationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let applicationId = applicationId { queryItems.append(URLQueryItem(name: "applicationId", value: "\(applicationId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ApplicationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ApplicationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Ad Placement
    /// - GET /api/{version}/application/placement/get
    /// - Get details of an ad placement
    /// - parameter version: (path)  
    /// - parameter placementId: (query) The id of the placement 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<PlacementResponse, Error> 
    open func getApplicationPlacement(version: Double, placementId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<PlacementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/placement/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "placementId", value: "\(placementId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlacementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PlacementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get API versions
    /// - GET /api/{version}/application/versions
    /// - Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8
    /// - parameter version: (path)  
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func getApplicationVersions(version: Double) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/versions"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                let components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Application Users
    /// - GET /api/{version}/application/users
    /// - Get a list of users per application
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The application key 
    /// - parameter q: (query) Q (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter since: (query) Return accounts that have been active after this date (UNIX time-stamp in milliseconds) (optional)
    /// - parameter i: (query) the start of the index (optional)
    /// - parameter start: (query) The start of the pagination (optional, default to 0)
    /// - parameter l: (query) the limit of the index (optional)
    /// - parameter limit: (query) The limit of the pagination (optional, default to 20)
    /// - returns: AnyPublisher<AccountListResponse, Error> 
    open func getUniqueUsersByApp(version: Double, appKey: String, q: String? = nil, keyword: String? = nil, since: Int64? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil) -> AnyPublisher<AccountListResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/users"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let since = since { queryItems.append(URLQueryItem(name: "since", value: "\(since)")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AccountListResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AccountListResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum ListApplicationsSortField: String, Codable, CaseIterable {
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case hasAdvertisements = "HAS_ADVERTISEMENTS"
        case publicNotifications = "PUBLIC_NOTIFICATIONS"
        case placements = "PLACEMENTS"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
        case title = "TITLE"
        case name = "NAME"
        case about = "ABOUT"
        case description = "DESCRIPTION"
        case applicationId = "APPLICATION_ID"
        case appType = "APP_TYPE"
        case gameType = "GAME_TYPE"
        case bundleId = "BUNDLE_ID"
        case scoringType = "SCORING_TYPE"
        case landingPageUrl = "LANDING_PAGE_URL"
        case eulaVersion = "EULA_VERSION"
        case buildVersion = "BUILD_VERSION"
        case apiVersion = "API_VERSION"
    }

    /// List Applications
    /// - GET /api/{version}/application/list
    /// - List active applications matching the criteria (as a consumer)
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the application owner/manager (optional)
    /// - parameter q: (query) Q (optional)
    /// - parameter keyword: (query) The keyword used to search for title, about, and description fields (optional)
    /// - parameter platforms: (query) Deprecated, use deviceIds and deviceVersions (optional)
    /// - parameter deviceIds: (query) The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values) (optional)
    /// - parameter deviceVersions: (query) The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum.  (optional)
    /// - parameter categoryIds: (query) The list of category ids to filter the list by (optional)
    /// - parameter sortField: (query) The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE (optional, default to .updated)
    /// - parameter hasAds: (query) Filter results on whether the application supports ads or not. Ignore this parameter to return all results. (optional)
    /// - parameter publicNotifications: (query) Filter results on whether the application is available for public trigger notifications (optional)
    /// - parameter filterBillable: (query) Determines whether to only return applications that the user has access to (optional)
    /// - parameter filterContentAdmin: (query) Determines whether to only return applications that the user is a content admin of (optional)
    /// - parameter descending: (query) The order to return the search results (optional, default to true)
    /// - parameter i: (query) the start of the index (optional)
    /// - parameter start: (query) The start of the pagination (optional, default to 0)
    /// - parameter l: (query) The limit of the index (optional)
    /// - parameter limit: (query) The limit of the pagination (optional, default to 20)
    /// - parameter applicationIds: (query) The list of application ids, comma separated. If provided will ignore all other params. (optional)
    /// - parameter hasObjectStore: (query) Only include applications with a object store (default is false) (optional, default to false)
    /// - parameter activeOnly: (query) Return only active results (optional, default to true)
    /// - returns: AnyPublisher<[ApplicationShortResponse], Error> 
    open func listApplications(version: Double, accountId: Int64? = nil, q: String? = nil, keyword: String? = nil, platforms: String? = nil, deviceIds: String? = nil, deviceVersions: String? = nil, categoryIds: String? = nil, sortField: ListApplicationsSortField? = nil, hasAds: Bool? = nil, publicNotifications: Bool? = nil, filterBillable: Bool? = nil, filterContentAdmin: Bool? = nil, descending: Bool? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil, applicationIds: String? = nil, hasObjectStore: Bool? = nil, activeOnly: Bool? = nil) -> AnyPublisher<[ApplicationShortResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/list"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let platforms = platforms { queryItems.append(URLQueryItem(name: "platforms", value: platforms)) } 
                if let deviceIds = deviceIds { queryItems.append(URLQueryItem(name: "deviceIds", value: deviceIds)) } 
                if let deviceVersions = deviceVersions { queryItems.append(URLQueryItem(name: "deviceVersions", value: deviceVersions)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let hasAds = hasAds { queryItems.append(URLQueryItem(name: "hasAds", value: hasAds ? "true" : "false")) } 
                if let publicNotifications = publicNotifications { queryItems.append(URLQueryItem(name: "publicNotifications", value: publicNotifications ? "true" : "false")) } 
                if let filterBillable = filterBillable { queryItems.append(URLQueryItem(name: "filterBillable", value: filterBillable ? "true" : "false")) } 
                if let filterContentAdmin = filterContentAdmin { queryItems.append(URLQueryItem(name: "filterContentAdmin", value: filterContentAdmin ? "true" : "false")) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let applicationIds = applicationIds { queryItems.append(URLQueryItem(name: "applicationIds", value: applicationIds)) } 
                if let hasObjectStore = hasObjectStore { queryItems.append(URLQueryItem(name: "hasObjectStore", value: hasObjectStore ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ApplicationShortResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ApplicationShortResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search for Ad Placements
    /// - GET /api/{version}/application/placement/search
    /// - Searches placements for an application.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The key of the application 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter start: (query) The start of the pagination (optional, default to 0)
    /// - parameter limit: (query) The limit of the pagination (optional, default to 100)
    /// - returns: AnyPublisher<[PlacementResponse], Error> 
    open func searchApplicationPlacement(version: Double, appKey: String, deviceId: String? = nil, accountId: Int64? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[PlacementResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/placement/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[PlacementResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([PlacementResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search for Application Settings
    /// - GET /api/{version}/application/settings/search
    /// - Returns a list of applications that the user has logged into before, and returns specific settings for that application and user
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter connectionAccountId: (query) The account id used to view another person&#39;s account (optional)
    /// - parameter keyword: (query) The string to search applications on (optional)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE (optional, default to "APPLICATION_TITLE")
    /// - parameter descending: (query) The order to return the search results (optional, default to false)
    /// - parameter start: (query) The start index for pagination (optional, default to 0)
    /// - parameter limit: (query) The limit per result set for pagination (optional, default to 20)
    /// - returns: AnyPublisher<ApplicationSettingsResponse, Error> 
    open func searchApplicationSettings(version: Double, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountId: Int64? = nil, keyword: String? = nil, sortField: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<ApplicationSettingsResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/settings/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ApplicationSettingsResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ApplicationSettingsResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchApplicationsSortField: String, Codable, CaseIterable {
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case hasAdvertisements = "HAS_ADVERTISEMENTS"
        case publicNotifications = "PUBLIC_NOTIFICATIONS"
        case placements = "PLACEMENTS"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
        case title = "TITLE"
        case name = "NAME"
        case about = "ABOUT"
        case description = "DESCRIPTION"
        case applicationId = "APPLICATION_ID"
        case appType = "APP_TYPE"
        case gameType = "GAME_TYPE"
        case bundleId = "BUNDLE_ID"
        case scoringType = "SCORING_TYPE"
        case landingPageUrl = "LANDING_PAGE_URL"
        case eulaVersion = "EULA_VERSION"
        case buildVersion = "BUILD_VERSION"
        case apiVersion = "API_VERSION"
    }

    /// Search Applications
    /// - GET /api/{version}/application/search
    /// - Search for applications matching the criteria that the logged in user has access to
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The location of the device (optional)
    /// - parameter longitude: (query) The location of the device (optional)
    /// - parameter q: (query) Q (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter qSearchFields: (query) The columns to applied the keyword search to (optional, default to "NAME,ABOUT,BILLABLE_ENTITY_NAME")
    /// - parameter sortField: (query) The column to sort the search on (optional, default to .applicationId)
    /// - parameter descending: (query) The order to return the search results (optional, default to false)
    /// - parameter i: (query) the start of the index (optional)
    /// - parameter start: (query) The start of the pagination (optional, default to 0)
    /// - parameter l: (query) the limit of the index (optional)
    /// - parameter limit: (query) The limit of the pagination (optional, default to 100)
    /// - parameter hasAds: (query) Filter results on whether the application supports ads or not. Ignore this parameter to return all results. (optional)
    /// - parameter publicNotifications: (query) Filter results on whether the application is available for public trigger notifications (optional)
    /// - parameter activeOnly: (query) Return only active results (optional, default to false)
    /// - returns: AnyPublisher<[ApplicationResponse], Error> 
    open func searchApplications(version: Double, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil, q: String? = nil, keyword: String? = nil, qSearchFields: String? = nil, sortField: SearchApplicationsSortField? = nil, descending: Bool? = nil, i: Int? = nil, start: Int? = nil, l: Int? = nil, limit: Int? = nil, hasAds: Bool? = nil, publicNotifications: Bool? = nil, activeOnly: Bool? = nil) -> AnyPublisher<[ApplicationResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let qSearchFields = qSearchFields { queryItems.append(URLQueryItem(name: "qSearchFields", value: qSearchFields)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let hasAds = hasAds { queryItems.append(URLQueryItem(name: "hasAds", value: hasAds ? "true" : "false")) } 
                if let publicNotifications = publicNotifications { queryItems.append(URLQueryItem(name: "publicNotifications", value: publicNotifications ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ApplicationResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ApplicationResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter scoringType
    ///
    public enum UpdateApplicationScoringType: String, Codable, CaseIterable {
        case gameLevel = "GAME_LEVEL"
        case gameObject = "GAME_OBJECT"
    }
    ///
    /// Enum for parameter placementSize
    ///
    public enum UpdateApplicationPlacementSize: String, Codable, CaseIterable {
        case config = "CONFIG"
        case banner = "BANNER"
        case leaderboard = "LEADERBOARD"
        case skyscraper = "SKYSCRAPER"
        case video = "VIDEO"
        case zip = "ZIP"
        case interstitial = "INTERSTITIAL"
        case custom1 = "CUSTOM1"
        case custom2 = "CUSTOM2"
        case custom3 = "CUSTOM3"
        case custom4 = "CUSTOM4"
        case custom5 = "CUSTOM5"
        case custom6 = "CUSTOM6"
        case custom7 = "CUSTOM7"
        case custom8 = "CUSTOM8"
        case custom9 = "CUSTOM9"
        case custom10 = "CUSTOM10"
    }
    ///
    /// Enum for parameter trilatProcessingType
    ///
    public enum UpdateApplicationTrilatProcessingType: String, Codable, CaseIterable {
        case _default = "DEFAULT"
        case fingerprint = "FINGERPRINT"
        case fingerprintV2 = "FINGERPRINT_V2"
    }

    /// Update Application
    /// - POST /api/{version}/application/update
    /// - Update an application record
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The application key for updating an existing application 
    /// - parameter appName: (query) The name of the application 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter about: (query) The description of the application (optional)
    /// - parameter bundleId: (query) The application bundle identifier (format - com.company.appName) (optional)
    /// - parameter appIconAssetId: (query) The application icon asset id (optional)
    /// - parameter appLogoAssetId: (query) The application logo asset id (optional)
    /// - parameter facebookAppId: (query) The Facebook application id (optional)
    /// - parameter facebookAppSecret: (query) The Facebook application secret (optional)
    /// - parameter googleApiKey: (query) This is the either the &#39;server key&#39; or &#39;browser key&#39; generated from google to enable Google Cloud Messaging (optional)
    /// - parameter updateEULADate: (query) Determines whether to update the EULA date (optional)
    /// - parameter eulaVersion: (query) The EULA version (optional)
    /// - parameter landingPageUrl: (query) The landing page URL (optional)
    /// - parameter showInActivities: (query) Determines whether to show the application in the activity feed (optional)
    /// - parameter activityDescription: (query) The description of the application in the activity feed (optional)
    /// - parameter inviteWelcomeText: (query) The text to display on the invite page (optional)
    /// - parameter invitePageUrl: (query) The url to the application invite page (optional)
    /// - parameter urlScheme: (query) The protocal the app uses to load the app via a browser (optional)
    /// - parameter platforms: (query) A json object with a list of supported platforms.  &#x60;&#x60;&#x60;json {   \&quot;platforms\&quot;: [     {       \&quot;deviceId\&quot;: 1,       \&quot;minimum\&quot;: 230,       \&quot;maximum\&quot;: 421,       \&quot;downloadUrl\&quot;: \&quot;http://app.store.com/download\&quot;,       \&quot;description\&quot;: \&quot;description and version info\&quot;     }   ] } &#x60;&#x60;&#x60;  (optional)
    /// - parameter downloadUrls: (query) Json formatted downloadUrls.  &#x60;&#x60;&#x60;json {   \&quot;ios\&quot;: \&quot;the-url-to-app-store\&quot;,    \&quot;android\&quot;: \&quot;the-url-to-google-play\&quot; } &#x60;&#x60;&#x60;   (optional)
    /// - parameter categoryIds: (query) List of categories to apply (optional)
    /// - parameter scoringType: (query) The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT (optional, default to .gameLevel)
    /// - parameter hintCost: (query) The cost of hints (optional, default to 11)
    /// - parameter maxScore: (query) The maximum score that will be possible (optional, default to 125)
    /// - parameter ticketsPerPoint: (query) The point-to-ticket conversion ratio (optional, default to 0.037)
    /// - parameter hasGameData: (query) Determines whether the application uses services to save custom game objects (optional, default to true)
    /// - parameter publicNotifications: (query) Public Notifications (optional)
    /// - parameter useMatchingAlgorithm: (query) Use Matching Algorithm (optional)
    /// - parameter globalTickets: (query) Determines whether earned tickets are applied across all applications (optional, default to false)
    /// - parameter buildVersion: (query) The current build version of the application (optional, default to 1)
    /// - parameter apiVersion: (query) The current API version the application uses (optional)
    /// - parameter placementName: (query) The name of the placement (optional)
    /// - parameter placementDescription: (query) The description of the placement (optional)
    /// - parameter placementSize: (query) The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created) (optional)
    /// - parameter placementHeight: (query) The height of a custom ad size (optional)
    /// - parameter placementWidth: (query) The width of a custom ad size (optional)
    /// - parameter placementRefreshInterval: (query) The refresh interval in seconds (optional)
    /// - parameter createObjectStore: (query) Generate a custom object store to use (optional, default to true)
    /// - parameter publicContentApproval: (query) Determine whether or not public content requires admin approval before it becomes public (optional, default to false)
    /// - parameter productionMode: (query) Determines whether the application uses production or sandbox services (optional, default to false)
    /// - parameter minimumSessionLength: (query) Minimum Session Length (optional)
    /// - parameter sessionGapLength: (query) Session Gap Length (optional)
    /// - parameter localAdsEnabled: (query) Local Ads Enabled (optional, default to false)
    /// - parameter sqootApiKey: (query) Sqoot Api Key (optional)
    /// - parameter trilatProcessingType: (query) Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT (optional, default to .fingerprint)
    /// - parameter maxSampleSize: (query) Determines what the maximum sample size during trilateration (optional)
    /// - parameter minRSSI: (query) Determines what the minimum acceptable RSSI value (optional)
    /// - parameter modules: (query) List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL (optional, default to "ALL")
    /// - parameter authorizedCount: (query) How many servers the license will support (optional, default to 1)
    /// - parameter authorizedServers: (query) The list of ip addresses of servers the license will support, leave null for any server (optional)
    /// - parameter defaultTimezone: (query) Sets the default timezone for the app (used for leaderboards and other time specific content) (optional)
    /// - parameter smtpPass: (query) SMTP Pass (optional)
    /// - parameter metaData: (query) The application meta data. Defined by the client (optional)
    /// - parameter placementMetaData: (query) The ad placement meta data. Defined by the client (optional)
    /// - parameter ipsFloor: (query) Create floor tables for Ips (optional, default to false)
    /// - parameter enableAPNSBadge: (query) Enables setting the APNS badge value in the payload (optional, default to true)
    /// - parameter includeInReport: (query) Enables using the application in session reports (optional, default to true)
    /// - parameter defaultAppFilterId: (query) Sets the default filter to use (if none is passed in) for certain search APIs including Album Search. (optional)
    /// - parameter enableWelcomeEmail: (query) Enables whether the default welcome email will be sent for new app users (optional)
    /// - parameter appleAppId: (query) The Apple Application ID (optional)
    /// - parameter appleTeamId: (query) The Apple Team ID (optional)
    /// - parameter appleAuthKeyId: (query) The Apple Auth Key ID (optional)
    /// - parameter appleAuthKey: (query) The Apple Auth Signin Key (p8) File (optional)
    /// - parameter appleIssuerId: (query) The Apple Issuer ID (optional)
    /// - parameter appStoreKeyId: (query) The Apple App Store Key ID (optional)
    /// - parameter appStoreKey: (query) The Apple App Store Key (p8) File (optional)
    /// - parameter googlePrivateKeyFile: (query) This is the private key file for your Google service account. (optional)
    /// - parameter authorizeNetApiKey: (query) Authorize Net Api Key (optional)
    /// - parameter authorizeNetTransactionKey: (query) Authorize Net Transaction Key (optional)
    /// - parameter emailSender: (query) Email Sender (optional)
    /// - parameter smtpUser: (query) SMTP User (optional)
    /// - parameter smtpHost: (query) SMTP Host (optional)
    /// - parameter vatomBusinessId: (query) Vatom Business Id (optional)
    /// - parameter vatomRestClientId: (query) Vatom REST Client Id (optional)
    /// - parameter vatomRestSecretKey: (query) Vatom Secret Key (optional)
    /// - parameter twilioAccountSID: (query) Twilio Account SID (optional)
    /// - parameter twilioAuthToken: (query) Twilio Auth Token (optional)
    /// - parameter twilioSenderPhoneNumber: (query) Twilio Sender Phone Number (optional)
    /// - parameter openAISecretKey: (query) OpenAI Secret API Key (optional)
    /// - returns: AnyPublisher<ApplicationResponse, Error> 
    open func updateApplication(version: Double, appKey: String, appName: String, deviceId: String? = nil, accountId: Int64? = nil, about: String? = nil, bundleId: String? = nil, appIconAssetId: Int64? = nil, appLogoAssetId: Int64? = nil, facebookAppId: String? = nil, facebookAppSecret: String? = nil, googleApiKey: String? = nil, updateEULADate: Bool? = nil, eulaVersion: String? = nil, landingPageUrl: String? = nil, showInActivities: Bool? = nil, activityDescription: String? = nil, inviteWelcomeText: String? = nil, invitePageUrl: String? = nil, urlScheme: String? = nil, platforms: String? = nil, downloadUrls: String? = nil, categoryIds: String? = nil, scoringType: UpdateApplicationScoringType? = nil, hintCost: Int? = nil, maxScore: Int? = nil, ticketsPerPoint: Float? = nil, hasGameData: Bool? = nil, publicNotifications: Bool? = nil, useMatchingAlgorithm: Bool? = nil, globalTickets: Bool? = nil, buildVersion: Float? = nil, apiVersion: Float? = nil, placementName: String? = nil, placementDescription: String? = nil, placementSize: UpdateApplicationPlacementSize? = nil, placementHeight: Int? = nil, placementWidth: Int? = nil, placementRefreshInterval: Int? = nil, createObjectStore: Bool? = nil, publicContentApproval: Bool? = nil, productionMode: Bool? = nil, minimumSessionLength: Int? = nil, sessionGapLength: Int? = nil, localAdsEnabled: Bool? = nil, sqootApiKey: String? = nil, trilatProcessingType: UpdateApplicationTrilatProcessingType? = nil, maxSampleSize: Int? = nil, minRSSI: Double? = nil, modules: String? = nil, authorizedCount: Int? = nil, authorizedServers: String? = nil, defaultTimezone: String? = nil, smtpPass: String? = nil, metaData: String? = nil, placementMetaData: String? = nil, ipsFloor: Bool? = nil, enableAPNSBadge: Bool? = nil, includeInReport: Bool? = nil, defaultAppFilterId: Int64? = nil, enableWelcomeEmail: Bool? = nil, appleAppId: String? = nil, appleTeamId: String? = nil, appleAuthKeyId: String? = nil, appleAuthKey: Data? = nil, appleIssuerId: String? = nil, appStoreKeyId: String? = nil, appStoreKey: Data? = nil, googlePrivateKeyFile: Data? = nil, authorizeNetApiKey: String? = nil, authorizeNetTransactionKey: String? = nil, emailSender: String? = nil, smtpUser: String? = nil, smtpHost: String? = nil, vatomBusinessId: String? = nil, vatomRestClientId: String? = nil, vatomRestSecretKey: String? = nil, twilioAccountSID: String? = nil, twilioAuthToken: String? = nil, twilioSenderPhoneNumber: String? = nil, openAISecretKey: String? = nil) -> AnyPublisher<ApplicationResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "appName", value: appName))
                if let about = about { queryItems.append(URLQueryItem(name: "about", value: about)) } 
                if let bundleId = bundleId { queryItems.append(URLQueryItem(name: "bundleId", value: bundleId)) } 
                if let appIconAssetId = appIconAssetId { queryItems.append(URLQueryItem(name: "appIconAssetId", value: "\(appIconAssetId)")) } 
                if let appLogoAssetId = appLogoAssetId { queryItems.append(URLQueryItem(name: "appLogoAssetId", value: "\(appLogoAssetId)")) } 
                if let facebookAppId = facebookAppId { queryItems.append(URLQueryItem(name: "facebookAppId", value: facebookAppId)) } 
                if let facebookAppSecret = facebookAppSecret { queryItems.append(URLQueryItem(name: "facebookAppSecret", value: facebookAppSecret)) } 
                if let googleApiKey = googleApiKey { queryItems.append(URLQueryItem(name: "googleApiKey", value: googleApiKey)) } 
                if let updateEULADate = updateEULADate { queryItems.append(URLQueryItem(name: "updateEULADate", value: updateEULADate ? "true" : "false")) } 
                if let eulaVersion = eulaVersion { queryItems.append(URLQueryItem(name: "eulaVersion", value: eulaVersion)) } 
                if let landingPageUrl = landingPageUrl { queryItems.append(URLQueryItem(name: "landingPageUrl", value: landingPageUrl)) } 
                if let showInActivities = showInActivities { queryItems.append(URLQueryItem(name: "showInActivities", value: showInActivities ? "true" : "false")) } 
                if let activityDescription = activityDescription { queryItems.append(URLQueryItem(name: "activityDescription", value: activityDescription)) } 
                if let inviteWelcomeText = inviteWelcomeText { queryItems.append(URLQueryItem(name: "inviteWelcomeText", value: inviteWelcomeText)) } 
                if let invitePageUrl = invitePageUrl { queryItems.append(URLQueryItem(name: "invitePageUrl", value: invitePageUrl)) } 
                if let urlScheme = urlScheme { queryItems.append(URLQueryItem(name: "urlScheme", value: urlScheme)) } 
                if let platforms = platforms { queryItems.append(URLQueryItem(name: "platforms", value: platforms)) } 
                if let downloadUrls = downloadUrls { queryItems.append(URLQueryItem(name: "downloadUrls", value: downloadUrls)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let scoringType = scoringType { queryItems.append(URLQueryItem(name: "scoringType", value: scoringType.rawValue)) } 
                if let hintCost = hintCost { queryItems.append(URLQueryItem(name: "hintCost", value: "\(hintCost)")) } 
                if let maxScore = maxScore { queryItems.append(URLQueryItem(name: "maxScore", value: "\(maxScore)")) } 
                if let ticketsPerPoint = ticketsPerPoint { queryItems.append(URLQueryItem(name: "ticketsPerPoint", value: "\(ticketsPerPoint)")) } 
                if let hasGameData = hasGameData { queryItems.append(URLQueryItem(name: "hasGameData", value: hasGameData ? "true" : "false")) } 
                if let publicNotifications = publicNotifications { queryItems.append(URLQueryItem(name: "publicNotifications", value: publicNotifications ? "true" : "false")) } 
                if let useMatchingAlgorithm = useMatchingAlgorithm { queryItems.append(URLQueryItem(name: "useMatchingAlgorithm", value: useMatchingAlgorithm ? "true" : "false")) } 
                if let globalTickets = globalTickets { queryItems.append(URLQueryItem(name: "globalTickets", value: globalTickets ? "true" : "false")) } 
                if let buildVersion = buildVersion { queryItems.append(URLQueryItem(name: "buildVersion", value: "\(buildVersion)")) } 
                if let apiVersion = apiVersion { queryItems.append(URLQueryItem(name: "apiVersion", value: "\(apiVersion)")) } 
                if let placementName = placementName { queryItems.append(URLQueryItem(name: "placementName", value: placementName)) } 
                if let placementDescription = placementDescription { queryItems.append(URLQueryItem(name: "placementDescription", value: placementDescription)) } 
                if let placementSize = placementSize { queryItems.append(URLQueryItem(name: "placementSize", value: placementSize.rawValue)) } 
                if let placementHeight = placementHeight { queryItems.append(URLQueryItem(name: "placementHeight", value: "\(placementHeight)")) } 
                if let placementWidth = placementWidth { queryItems.append(URLQueryItem(name: "placementWidth", value: "\(placementWidth)")) } 
                if let placementRefreshInterval = placementRefreshInterval { queryItems.append(URLQueryItem(name: "placementRefreshInterval", value: "\(placementRefreshInterval)")) } 
                if let createObjectStore = createObjectStore { queryItems.append(URLQueryItem(name: "createObjectStore", value: createObjectStore ? "true" : "false")) } 
                if let publicContentApproval = publicContentApproval { queryItems.append(URLQueryItem(name: "publicContentApproval", value: publicContentApproval ? "true" : "false")) } 
                if let productionMode = productionMode { queryItems.append(URLQueryItem(name: "productionMode", value: productionMode ? "true" : "false")) } 
                if let minimumSessionLength = minimumSessionLength { queryItems.append(URLQueryItem(name: "minimumSessionLength", value: "\(minimumSessionLength)")) } 
                if let sessionGapLength = sessionGapLength { queryItems.append(URLQueryItem(name: "sessionGapLength", value: "\(sessionGapLength)")) } 
                if let localAdsEnabled = localAdsEnabled { queryItems.append(URLQueryItem(name: "localAdsEnabled", value: localAdsEnabled ? "true" : "false")) } 
                if let sqootApiKey = sqootApiKey { queryItems.append(URLQueryItem(name: "sqootApiKey", value: sqootApiKey)) } 
                if let trilatProcessingType = trilatProcessingType { queryItems.append(URLQueryItem(name: "trilatProcessingType", value: trilatProcessingType.rawValue)) } 
                if let maxSampleSize = maxSampleSize { queryItems.append(URLQueryItem(name: "maxSampleSize", value: "\(maxSampleSize)")) } 
                if let minRSSI = minRSSI { queryItems.append(URLQueryItem(name: "minRSSI", value: "\(minRSSI)")) } 
                if let modules = modules { queryItems.append(URLQueryItem(name: "modules", value: modules)) } 
                if let authorizedCount = authorizedCount { queryItems.append(URLQueryItem(name: "authorizedCount", value: "\(authorizedCount)")) } 
                if let authorizedServers = authorizedServers { queryItems.append(URLQueryItem(name: "authorizedServers", value: authorizedServers)) } 
                if let defaultTimezone = defaultTimezone { queryItems.append(URLQueryItem(name: "defaultTimezone", value: defaultTimezone)) } 
                if let smtpPass = smtpPass { queryItems.append(URLQueryItem(name: "smtpPass", value: smtpPass)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let placementMetaData = placementMetaData { queryItems.append(URLQueryItem(name: "placementMetaData", value: placementMetaData)) } 
                if let ipsFloor = ipsFloor { queryItems.append(URLQueryItem(name: "ipsFloor", value: ipsFloor ? "true" : "false")) } 
                if let enableAPNSBadge = enableAPNSBadge { queryItems.append(URLQueryItem(name: "enableAPNSBadge", value: enableAPNSBadge ? "true" : "false")) } 
                if let includeInReport = includeInReport { queryItems.append(URLQueryItem(name: "includeInReport", value: includeInReport ? "true" : "false")) } 
                if let defaultAppFilterId = defaultAppFilterId { queryItems.append(URLQueryItem(name: "defaultAppFilterId", value: "\(defaultAppFilterId)")) } 
                if let enableWelcomeEmail = enableWelcomeEmail { queryItems.append(URLQueryItem(name: "enableWelcomeEmail", value: enableWelcomeEmail ? "true" : "false")) } 
                if let appleAppId = appleAppId { queryItems.append(URLQueryItem(name: "appleAppId", value: appleAppId)) } 
                if let appleTeamId = appleTeamId { queryItems.append(URLQueryItem(name: "appleTeamId", value: appleTeamId)) } 
                if let appleAuthKeyId = appleAuthKeyId { queryItems.append(URLQueryItem(name: "appleAuthKeyId", value: appleAuthKeyId)) } 
                if let appleAuthKey = appleAuthKey { queryItems.append(URLQueryItem(name: "appleAuthKey", value: )) } 
                if let appleIssuerId = appleIssuerId { queryItems.append(URLQueryItem(name: "appleIssuerId", value: appleIssuerId)) } 
                if let appStoreKeyId = appStoreKeyId { queryItems.append(URLQueryItem(name: "appStoreKeyId", value: appStoreKeyId)) } 
                if let appStoreKey = appStoreKey { queryItems.append(URLQueryItem(name: "appStoreKey", value: )) } 
                if let googlePrivateKeyFile = googlePrivateKeyFile { queryItems.append(URLQueryItem(name: "googlePrivateKeyFile", value: )) } 
                if let authorizeNetApiKey = authorizeNetApiKey { queryItems.append(URLQueryItem(name: "authorizeNetApiKey", value: authorizeNetApiKey)) } 
                if let authorizeNetTransactionKey = authorizeNetTransactionKey { queryItems.append(URLQueryItem(name: "authorizeNetTransactionKey", value: authorizeNetTransactionKey)) } 
                if let emailSender = emailSender { queryItems.append(URLQueryItem(name: "emailSender", value: emailSender)) } 
                if let smtpUser = smtpUser { queryItems.append(URLQueryItem(name: "smtpUser", value: smtpUser)) } 
                if let smtpHost = smtpHost { queryItems.append(URLQueryItem(name: "smtpHost", value: smtpHost)) } 
                if let vatomBusinessId = vatomBusinessId { queryItems.append(URLQueryItem(name: "vatomBusinessId", value: vatomBusinessId)) } 
                if let vatomRestClientId = vatomRestClientId { queryItems.append(URLQueryItem(name: "vatomRestClientId", value: vatomRestClientId)) } 
                if let vatomRestSecretKey = vatomRestSecretKey { queryItems.append(URLQueryItem(name: "vatomRestSecretKey", value: vatomRestSecretKey)) } 
                if let twilioAccountSID = twilioAccountSID { queryItems.append(URLQueryItem(name: "twilioAccountSID", value: twilioAccountSID)) } 
                if let twilioAuthToken = twilioAuthToken { queryItems.append(URLQueryItem(name: "twilioAuthToken", value: twilioAuthToken)) } 
                if let twilioSenderPhoneNumber = twilioSenderPhoneNumber { queryItems.append(URLQueryItem(name: "twilioSenderPhoneNumber", value: twilioSenderPhoneNumber)) } 
                if let openAISecretKey = openAISecretKey { queryItems.append(URLQueryItem(name: "openAISecretKey", value: openAISecretKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ApplicationResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ApplicationResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Change Appliation Status
    /// - POST /api/{version}/application/active
    /// - Set the application's active flag to true/false. This effectively activates or deactivates the application.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account used to perform the delete, must have rights to edit the application. 
    /// - parameter appKey: (query) The key of the application to be deleted 
    /// - parameter active: (query) If true then set to active, false otherwise 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func updateApplicationActive(version: Double, accountId: Int64, appKey: String, active: Bool) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/active"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter size
    ///
    public enum UpdateApplicationPlacementSize: String, Codable, CaseIterable {
        case config = "CONFIG"
        case banner = "BANNER"
        case leaderboard = "LEADERBOARD"
        case skyscraper = "SKYSCRAPER"
        case video = "VIDEO"
        case zip = "ZIP"
        case interstitial = "INTERSTITIAL"
        case custom1 = "CUSTOM1"
        case custom2 = "CUSTOM2"
        case custom3 = "CUSTOM3"
        case custom4 = "CUSTOM4"
        case custom5 = "CUSTOM5"
        case custom6 = "CUSTOM6"
        case custom7 = "CUSTOM7"
        case custom8 = "CUSTOM8"
        case custom9 = "CUSTOM9"
        case custom10 = "CUSTOM10"
    }

    /// Update Ad Placement
    /// - POST /api/{version}/application/placement/update
    /// - Updates an ad placement for an application.
    /// - parameter version: (path)  
    /// - parameter placementId: (query) The id of the placement to update, the user must have rights to the application the ad placement is for 
    /// - parameter deviceId: (query) The unique id of the device making the request (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter name: (query) The name of the placement (optional)
    /// - parameter description: (query) The description of the placement (optional)
    /// - parameter size: (query) The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (optional)
    /// - parameter height: (query) The height of a custom ad size (optional)
    /// - parameter width: (query) The width of a custom ad size (optional)
    /// - parameter refreshInterval: (query) The refresh interval in seconds (optional)
    /// - parameter defaultImageId: (query) Default Image Id (optional)
    /// - parameter active: (query) Active (optional)
    /// - returns: AnyPublisher<PlacementResponse, Error> 
    open func updateApplicationPlacement(version: Double, placementId: Int64, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, description: String? = nil, size: UpdateApplicationPlacementSize? = nil, height: Int? = nil, width: Int? = nil, refreshInterval: Int? = nil, defaultImageId: Int64? = nil, active: Bool? = nil) -> AnyPublisher<PlacementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/placement/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "placementId", value: "\(placementId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let size = size { queryItems.append(URLQueryItem(name: "size", value: size.rawValue)) } 
                if let height = height { queryItems.append(URLQueryItem(name: "height", value: "\(height)")) } 
                if let width = width { queryItems.append(URLQueryItem(name: "width", value: "\(width)")) } 
                if let refreshInterval = refreshInterval { queryItems.append(URLQueryItem(name: "refreshInterval", value: "\(refreshInterval)")) } 
                if let defaultImageId = defaultImageId { queryItems.append(URLQueryItem(name: "defaultImageId", value: "\(defaultImageId)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<PlacementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(PlacementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Application Certificate
    /// - POST /api/{version}/application/certificate/create
    /// - Uploads a certificate for an application that the user has access to.
    /// - parameter version: (path)  
    /// - parameter appKey: (query) The key of the application 
    /// - parameter deviceId: (query) Device Id (optional)
    /// - parameter accountId: (query) The account used to perform the delete, must have rights to edit the application. (optional)
    /// - parameter certificate: (query) Certificate (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func uploadApplicationCertificate(version: Double, appKey: String, deviceId: String? = nil, accountId: Int64? = nil, certificate: Data? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/application/certificate/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let certificate = certificate { queryItems.append(URLQueryItem(name: "certificate", value: )) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
