//
// LeaderboardAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class LeaderboardAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    /// - POST /leaderboard/create
    /// - Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    /// - parameter accountId: (query) The account id of the user creating the leaderboard. (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter rankType: (query) a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (optional)
    /// - parameter leaderboardMode: (query) the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword (optional)
    /// - parameter iconMedia: (query) a MultipartFile containing the icon image of the leaderboard (this will only be used if \&quot;iconAssetId\&quot; is empty) (optional)
    /// - parameter iconAssetId: (query) The asset ID to set the leaderboard icon (optional)
    /// - parameter bannerMedia: (query) a MultipartFile containing the icon banner of the leaderboard (this will only be used if \&quot;bannerAssetId\&quot; is empty) (optional)
    /// - parameter bannerAssetId: (query) The asset ID to set the leaderboard banner (optional)
    /// - parameter limitation: (query) limit number of rankings for each leaderboard (optional)
    /// - parameter sortField: (query) determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST (optional)
    /// - parameter title: (query) leaderboard&#39;s title (optional)
    /// - parameter description: (query) leaderboard&#39;s description (optional)
    /// - parameter metaData: (query) custom meta data for the leaderboard (optional)
    /// - returns: AnyPublisher<LeaderboardResponse, Error> 
    open func createLeaderboard(accountId: Int64? = nil, appKey: String? = nil, rankType: String? = nil, leaderboardMode: String? = nil, iconMedia: Data? = nil, iconAssetId: Int64? = nil, bannerMedia: Data? = nil, bannerAssetId: Int64? = nil, limitation: Int? = nil, sortField: String? = nil, title: String? = nil, description: String? = nil, metaData: String? = nil) -> AnyPublisher<LeaderboardResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/leaderboard/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let leaderboardMode = leaderboardMode { queryItems.append(URLQueryItem(name: "leaderboardMode", value: leaderboardMode)) } 
                if let iconMedia = iconMedia { queryItems.append(URLQueryItem(name: "iconMedia", value: )) } 
                if let iconAssetId = iconAssetId { queryItems.append(URLQueryItem(name: "iconAssetId", value: "\(iconAssetId)")) } 
                if let bannerMedia = bannerMedia { queryItems.append(URLQueryItem(name: "bannerMedia", value: )) } 
                if let bannerAssetId = bannerAssetId { queryItems.append(URLQueryItem(name: "bannerAssetId", value: "\(bannerAssetId)")) } 
                if let limitation = limitation { queryItems.append(URLQueryItem(name: "limitation", value: "\(limitation)")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LeaderboardResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(LeaderboardResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete the Leader Board
    /// - POST /leaderboard/delete
    /// - Removes a leader board id.
    /// - parameter leaderboardId: (query) The leaderboard id to delete. 
    /// - parameter accountId: (query) The account id of the user making the request. (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteLeaderboard(leaderboardId: Int64, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/leaderboard/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "leaderboardId", value: "\(leaderboardId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Read a leaderboard by id and retrieve the matching ranking list
    /// - GET /leaderboard/get
    /// - Read a leaderboard by id and retrieve the matching ranking list
    /// - parameter leaderboardId: (query) The leaderboard id. 
    /// - parameter accountId: (query) A valid account. (optional)
    /// - parameter includeFullRankingList: (query) set to true if need to return the leaderboard&#39;s full ranking list (optional)
    /// - returns: AnyPublisher<LeaderboardResponse, Error> 
    open func getLeaderboard(leaderboardId: Int64, accountId: Int64? = nil, includeFullRankingList: Bool? = nil) -> AnyPublisher<LeaderboardResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/leaderboard/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "leaderboardId", value: "\(leaderboardId)"))
                if let includeFullRankingList = includeFullRankingList { queryItems.append(URLQueryItem(name: "includeFullRankingList", value: includeFullRankingList ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LeaderboardResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(LeaderboardResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search leaderboard and retrieve the matching ranking list
    /// - GET /leaderboard/search
    /// - Search leaderboard and retrieve the matching ranking list
    /// - parameter accountId: (query) The account id of the user requesting the search. (optional)
    /// - parameter appKey: (query) The application key. (optional)
    /// - parameter globalOnly: (query) only include global leaderboards (this overrides the appKey filter) (optional)
    /// - parameter keyword: (query) keyword to search by title (optional)
    /// - parameter leaderboardIds: (query) comma separated list of leaderboard ids to filter results with (optional)
    /// - parameter rankTypes: (query) comma separated list of rankType to filter results with (optional)
    /// - parameter sortField: (query) sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE) (optional)
    /// - parameter descending: (query) Determines whether the sorted list is in descending or ascending order (optional)
    /// - parameter includeInactive: (query) include inactive in the result (optional)
    /// - parameter includeAppResponse: (query) determines whether to include the application response for each leaderboard (optional)
    /// - parameter start: (query) Start the result set at some index. (optional)
    /// - parameter limit: (query) Limit the result to some number. (optional)
    /// - returns: AnyPublisher<LeaderboardResponse, Error> 
    open func searchLeaderboards(accountId: Int64? = nil, appKey: String? = nil, globalOnly: Bool? = nil, keyword: String? = nil, leaderboardIds: String? = nil, rankTypes: String? = nil, sortField: String? = nil, descending: Bool? = nil, includeInactive: Bool? = nil, includeAppResponse: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<LeaderboardResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/leaderboard/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let globalOnly = globalOnly { queryItems.append(URLQueryItem(name: "globalOnly", value: globalOnly ? "true" : "false")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let leaderboardIds = leaderboardIds { queryItems.append(URLQueryItem(name: "leaderboardIds", value: leaderboardIds)) } 
                if let rankTypes = rankTypes { queryItems.append(URLQueryItem(name: "rankTypes", value: rankTypes)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let includeInactive = includeInactive { queryItems.append(URLQueryItem(name: "includeInactive", value: includeInactive ? "true" : "false")) } 
                if let includeAppResponse = includeAppResponse { queryItems.append(URLQueryItem(name: "includeAppResponse", value: includeAppResponse ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LeaderboardResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(LeaderboardResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    /// - POST /leaderboard/update
    /// - Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation
    /// - parameter leaderboardId: (query) The leaderboard id to update. 
    /// - parameter accountId: (query) The account id of the user updating the leaderboard. (optional)
    /// - parameter appKey: (query) The application key (optional)
    /// - parameter rankType: (query) a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. (optional)
    /// - parameter leaderboardMode: (query) the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (optional)
    /// - parameter sortField: (query) determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST (optional)
    /// - parameter iconMedia: (query) a MultipartFile containing the icon image of the leaderboard (this will only be used if \&quot;iconAssetId\&quot; is empty) (optional)
    /// - parameter iconAssetId: (query) The asset ID to set the leaderboard icon (optional)
    /// - parameter bannerMedia: (query) a MultipartFile containing the icon banner of the leaderboard (this will only be used if \&quot;bannerAssetId\&quot; is empty) (optional)
    /// - parameter bannerAssetId: (query) The asset ID to set the leaderboard banner (optional)
    /// - parameter limitation: (query) limit number of rankings for each leaderboard (optional)
    /// - parameter active: (query) Whether the leaderboard is active (optional)
    /// - parameter title: (query) leaderboard&#39;s title (optional)
    /// - parameter description: (query) leaderboard&#39;s description (optional)
    /// - parameter metaData: (query) custom meta data for the leaderboard (optional)
    /// - returns: AnyPublisher<LeaderboardResponse, Error> 
    open func updateLeaderboard(leaderboardId: Int64, accountId: Int64? = nil, appKey: String? = nil, rankType: String? = nil, leaderboardMode: String? = nil, sortField: String? = nil, iconMedia: Data? = nil, iconAssetId: Int64? = nil, bannerMedia: Data? = nil, bannerAssetId: Int64? = nil, limitation: Int? = nil, active: Bool? = nil, title: String? = nil, description: String? = nil, metaData: String? = nil) -> AnyPublisher<LeaderboardResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/leaderboard/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "leaderboardId", value: "\(leaderboardId)"))
                if let rankType = rankType { queryItems.append(URLQueryItem(name: "rankType", value: rankType)) } 
                if let leaderboardMode = leaderboardMode { queryItems.append(URLQueryItem(name: "leaderboardMode", value: leaderboardMode)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let iconMedia = iconMedia { queryItems.append(URLQueryItem(name: "iconMedia", value: )) } 
                if let iconAssetId = iconAssetId { queryItems.append(URLQueryItem(name: "iconAssetId", value: "\(iconAssetId)")) } 
                if let bannerMedia = bannerMedia { queryItems.append(URLQueryItem(name: "bannerMedia", value: )) } 
                if let bannerAssetId = bannerAssetId { queryItems.append(URLQueryItem(name: "bannerAssetId", value: "\(bannerAssetId)")) } 
                if let limitation = limitation { queryItems.append(URLQueryItem(name: "limitation", value: "\(limitation)")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<LeaderboardResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(LeaderboardResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
