//
// PurchaseOrderAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class PurchaseOrderAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter currencyType
    ///
    public enum CreateOrderCurrencyType: String, Codable, CaseIterable {
        case void = "VOID"
        case cash = "CASH"
        case points = "POINTS"
        case tickets = "TICKETS"
        case refund = "REFUND"
        case credit = "CREDIT"
        case reload = "RELOAD"
    }

    /// Create Order
    /// - POST /order/create
    /// - Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created
    /// - parameter appKey: (query) The application requesting the purchase 
    /// - parameter cart: (query) &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60;  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter description: (query) A description of the purchase (optional)
    /// - parameter currencyType: (query) Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to .cash)
    /// - parameter paymentMethodId: (query) Use a specific payment method (CASH), if not provided use default (optional)
    /// - parameter externalOrderId: (query) Store identifier from external system (optional)
    /// - parameter externalPaymentId: (query) Store identifier from external system (optional)
    /// - parameter remoteRefType: (query) Remote Reference type (optional)
    /// - parameter externalDate: (query) External Date (optional)
    /// - parameter promoCode: (query) The Promo Code (optional)
    /// - returns: AnyPublisher<OrderResponse, Error> 
    open func createOrder(appKey: String, cart: String, deviceId: String? = nil, accountId: Int64? = nil, description: String? = nil, currencyType: CreateOrderCurrencyType? = nil, paymentMethodId: Int64? = nil, externalOrderId: String? = nil, externalPaymentId: String? = nil, remoteRefType: String? = nil, externalDate: Int64? = nil, promoCode: String? = nil) -> AnyPublisher<OrderResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/order/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let currencyType = currencyType { queryItems.append(URLQueryItem(name: "currencyType", value: currencyType.rawValue)) } 
                queryItems.append(URLQueryItem(name: "cart", value: cart))
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                if let externalOrderId = externalOrderId { queryItems.append(URLQueryItem(name: "externalOrderId", value: externalOrderId)) } 
                if let externalPaymentId = externalPaymentId { queryItems.append(URLQueryItem(name: "externalPaymentId", value: externalPaymentId)) } 
                if let remoteRefType = remoteRefType { queryItems.append(URLQueryItem(name: "remoteRefType", value: remoteRefType)) } 
                if let externalDate = externalDate { queryItems.append(URLQueryItem(name: "externalDate", value: "\(externalDate)")) } 
                if let promoCode = promoCode { queryItems.append(URLQueryItem(name: "promoCode", value: promoCode)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrderResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrderResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Order
    /// - POST /order/delete
    /// - Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.
    /// - parameter orderId: (query) Order Id 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteOrder(orderId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/order/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "orderId", value: "\(orderId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Order
    /// - GET /order/get
    /// - Get an order record
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter orderId: (query) The order id to get details of, either orderId or externalOrderId must be provided (optional)
    /// - parameter externalOrderId: (query) The external order id to get details of, either orderId or externalOrderId must be provided (optional)
    /// - returns: AnyPublisher<OrderResponse, Error> 
    open func getOrder(deviceId: String? = nil, accountId: Int64? = nil, orderId: Int64? = nil, externalOrderId: String? = nil) -> AnyPublisher<OrderResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/order/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let orderId = orderId { queryItems.append(URLQueryItem(name: "orderId", value: "\(orderId)")) } 
                if let externalOrderId = externalOrderId { queryItems.append(URLQueryItem(name: "externalOrderId", value: externalOrderId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrderResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrderResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter currencyType
    ///
    public enum PreviewOrderCurrencyType: String, Codable, CaseIterable {
        case void = "VOID"
        case cash = "CASH"
        case points = "POINTS"
        case tickets = "TICKETS"
        case refund = "REFUND"
        case credit = "CREDIT"
        case reload = "RELOAD"
    }

    /// Preview Order
    /// - POST /order/preview
    /// - Previews a purchase to see the total cost before making it.
    /// - parameter appKey: (query) The application requesting the purchase 
    /// - parameter cart: (query) A JSON list of items to purchase 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter description: (query) A description of the purchase (optional)
    /// - parameter currencyType: (query) Determines the method of purchasing offer. &#x60;&#x60;&#x60;json {   \&quot;VOID\&quot;: \&quot;used for when there is no payment involved (ie. for updating the status of a purchase order)\&quot;,   \&quot;CASH\&quot;: \&quot;use card on file\&quot;,   \&quot;POINTS\&quot;: \&quot;use account balance\&quot;,   \&quot;TICKETS\&quot;: \&quot;use tickets\&quot;,   \&quot;REFUND\&quot;: \&quot;not allowed for a create, requires a paymentTransactionId\&quot;,   \&quot;CREDIT\&quot;: \&quot;add to the account balance\&quot;,   \&quot;RELOAD\&quot;: \&quot;charge a credit card then add to the account balance\&quot; } &#x60;&#x60;&#x60;  (optional, default to .cash)
    /// - parameter paymentMethodId: (query) Use a specific payment method (CASH), if not provided use default (optional)
    /// - parameter externalOrderId: (query) Store identifier from external system (optional)
    /// - parameter externalPaymentId: (query) Store identifier from external system (optional)
    /// - parameter remoteRefType: (query) Remote Reference type (optional)
    /// - parameter externalDate: (query) External Date (optional)
    /// - parameter promoCode: (query) The Promo Code (optional)
    /// - returns: AnyPublisher<OrderResponse, Error> 
    open func previewOrder(appKey: String, cart: String, deviceId: String? = nil, accountId: Int64? = nil, description: String? = nil, currencyType: PreviewOrderCurrencyType? = nil, paymentMethodId: Int64? = nil, externalOrderId: String? = nil, externalPaymentId: String? = nil, remoteRefType: String? = nil, externalDate: Int64? = nil, promoCode: String? = nil) -> AnyPublisher<OrderResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/order/preview"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let currencyType = currencyType { queryItems.append(URLQueryItem(name: "currencyType", value: currencyType.rawValue)) } 
                queryItems.append(URLQueryItem(name: "cart", value: cart))
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                if let externalOrderId = externalOrderId { queryItems.append(URLQueryItem(name: "externalOrderId", value: externalOrderId)) } 
                if let externalPaymentId = externalPaymentId { queryItems.append(URLQueryItem(name: "externalPaymentId", value: externalPaymentId)) } 
                if let remoteRefType = remoteRefType { queryItems.append(URLQueryItem(name: "remoteRefType", value: remoteRefType)) } 
                if let externalDate = externalDate { queryItems.append(URLQueryItem(name: "externalDate", value: "\(externalDate)")) } 
                if let promoCode = promoCode { queryItems.append(URLQueryItem(name: "promoCode", value: promoCode)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrderResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrderResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Orders
    /// - GET /order/search
    /// - Search on active orders by customer
    /// - parameter appKey: (query) The application requesting the purchase 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter start: (query) The start index for pagination (optional, default to 0)
    /// - parameter limit: (query) The limit for pagination (optional, default to 20)
    /// - parameter descending: (query) Determines whether to return the resulting list in descending or ascending order (optional, default to true)
    /// - parameter activeOnly: (query) Only return active orders (optional, default to false)
    /// - parameter ignoreCustomerFilter: (query) Determines whether to ignore the customer filter (requires an Admin/Exec account) (optional, default to false)
    /// - parameter orderItemTypes: (query) Filter results by orderItemTypes (optional)
    /// - parameter orderItemIds: (query) Filter results by orderItemIds (optional)
    /// - parameter orderCustomTypes: (query) Filter results by orderCustomTypes (optional)
    /// - parameter orderCustomIds: (query) Filter results by orderCustomIds (optional)
    /// - parameter sortField: (query) Determines what to sort the results by (optional, default to "ID")
    /// - parameter offerTypes: (query) Filter results by offer type (optional)
    /// - parameter specialOfferTypes: (query) Filter results by special offer type (optional)
    /// - parameter categoryIds: (query) Filter results by category Ids (optional)
    /// - parameter filterIds: (query) Filter results by filter Ids (optional)
    /// - parameter offerAudienceIds: (query) Filter results by offer audience Ids (optional)
    /// - parameter transactionAudienceIds: (query) Filter results by transaction audience Ids (optional)
    /// - parameter offerIds: (query) Filter results by offer Ids (optional)
    /// - parameter offerLocationIds: (query) Filter results by offer location Ids (optional)
    /// - parameter retailerIds: (query) Filter results by retailer Ids (optional)
    /// - parameter retailerLocationIds: (query) Filter results by retailer location Ids (optional)
    /// - parameter statuses: (query) Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled) (optional)
    /// - parameter keyword: (query) The keyword to search for (optional)
    /// - parameter redeemableStartDate: (query) Filter results by the offer redeemable date (optional)
    /// - parameter redeemableEndDate: (query) Filter results by the offer redeemable date (optional)
    /// - parameter startedSince: (query) Filter results by the offer start date (optional)
    /// - parameter startedBefore: (query) Filter results by the offer start date (optional)
    /// - parameter endedSince: (query) Filter results by the offer end date (optional)
    /// - parameter endedBefore: (query) Filter results by the offer end date (optional)
    /// - returns: AnyPublisher<[OrderResponse], Error> 
    open func searchOrders(appKey: String, deviceId: String? = nil, accountId: Int64? = nil, start: Int? = nil, limit: Int? = nil, descending: Bool? = nil, activeOnly: Bool? = nil, ignoreCustomerFilter: Bool? = nil, orderItemTypes: String? = nil, orderItemIds: String? = nil, orderCustomTypes: String? = nil, orderCustomIds: String? = nil, sortField: String? = nil, offerTypes: String? = nil, specialOfferTypes: String? = nil, categoryIds: String? = nil, filterIds: String? = nil, offerAudienceIds: String? = nil, transactionAudienceIds: String? = nil, offerIds: String? = nil, offerLocationIds: String? = nil, retailerIds: String? = nil, retailerLocationIds: String? = nil, statuses: String? = nil, keyword: String? = nil, redeemableStartDate: Int64? = nil, redeemableEndDate: Int64? = nil, startedSince: Int64? = nil, startedBefore: Int64? = nil, endedSince: Int64? = nil, endedBefore: Int64? = nil) -> AnyPublisher<[OrderResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/order/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let ignoreCustomerFilter = ignoreCustomerFilter { queryItems.append(URLQueryItem(name: "ignoreCustomerFilter", value: ignoreCustomerFilter ? "true" : "false")) } 
                if let orderItemTypes = orderItemTypes { queryItems.append(URLQueryItem(name: "orderItemTypes", value: orderItemTypes)) } 
                if let orderItemIds = orderItemIds { queryItems.append(URLQueryItem(name: "orderItemIds", value: orderItemIds)) } 
                if let orderCustomTypes = orderCustomTypes { queryItems.append(URLQueryItem(name: "orderCustomTypes", value: orderCustomTypes)) } 
                if let orderCustomIds = orderCustomIds { queryItems.append(URLQueryItem(name: "orderCustomIds", value: orderCustomIds)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField)) } 
                if let offerTypes = offerTypes { queryItems.append(URLQueryItem(name: "offerTypes", value: offerTypes)) } 
                if let specialOfferTypes = specialOfferTypes { queryItems.append(URLQueryItem(name: "specialOfferTypes", value: specialOfferTypes)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let offerAudienceIds = offerAudienceIds { queryItems.append(URLQueryItem(name: "offerAudienceIds", value: offerAudienceIds)) } 
                if let transactionAudienceIds = transactionAudienceIds { queryItems.append(URLQueryItem(name: "transactionAudienceIds", value: transactionAudienceIds)) } 
                if let offerIds = offerIds { queryItems.append(URLQueryItem(name: "offerIds", value: offerIds)) } 
                if let offerLocationIds = offerLocationIds { queryItems.append(URLQueryItem(name: "offerLocationIds", value: offerLocationIds)) } 
                if let retailerIds = retailerIds { queryItems.append(URLQueryItem(name: "retailerIds", value: retailerIds)) } 
                if let retailerLocationIds = retailerLocationIds { queryItems.append(URLQueryItem(name: "retailerLocationIds", value: retailerLocationIds)) } 
                if let statuses = statuses { queryItems.append(URLQueryItem(name: "statuses", value: statuses)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let redeemableStartDate = redeemableStartDate { queryItems.append(URLQueryItem(name: "redeemableStartDate", value: "\(redeemableStartDate)")) } 
                if let redeemableEndDate = redeemableEndDate { queryItems.append(URLQueryItem(name: "redeemableEndDate", value: "\(redeemableEndDate)")) } 
                if let startedSince = startedSince { queryItems.append(URLQueryItem(name: "startedSince", value: "\(startedSince)")) } 
                if let startedBefore = startedBefore { queryItems.append(URLQueryItem(name: "startedBefore", value: "\(startedBefore)")) } 
                if let endedSince = endedSince { queryItems.append(URLQueryItem(name: "endedSince", value: "\(endedSince)")) } 
                if let endedBefore = endedBefore { queryItems.append(URLQueryItem(name: "endedBefore", value: "\(endedBefore)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[OrderResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([OrderResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter currencyType
    ///
    public enum UpdateOrderCurrencyType: String, Codable, CaseIterable {
        case void = "VOID"
        case cash = "CASH"
        case points = "POINTS"
        case tickets = "TICKETS"
        case refund = "REFUND"
        case credit = "CREDIT"
        case reload = "RELOAD"
    }

    /// Update Order
    /// - POST /order/update
    /// - Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.
    /// - parameter orderId: (query) The order to add the purchase to, leave null for new order. 
    /// - parameter appKey: (query) The application requesting the purchase 
    /// - parameter cart: (query) &#x60;&#x60;&#x60;json [   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 234, \&quot;orderCustomType\&quot;: \&quot;OfferLocation\&quot;, \&quot;orderCustomId\&quot;: 123, \&quot;retailerLocationId\&quot;: 1234, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;OFFER\&quot;, \&quot;orderItemId\&quot;: 235, \&quot;quantity\&quot;: 2 },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 10.50, \&quot;orderCustomType\&quot;: \&quot;ServiceFee\&quot; },   { \&quot;orderItemType\&quot;: \&quot;CUSTOM\&quot;, \&quot;amount\&quot;: 25.10, \&quot;quantity\&quot;: 2, \&quot;orderCustomType\&quot;: \&quot;Hat\&quot;, \&quot;orderCustomId\&quot;: 123 } ] &#x60;&#x60;&#x60;  
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter paymentTransactionId: (query) The payment transaction to apply the refund to (optional)
    /// - parameter description: (query) A description of the purchase (optional)
    /// - parameter currencyType: (query) Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance   (optional, default to .cash)
    /// - parameter paymentMethodId: (query) Use a specific payment method (CASH), if not provided use default (optional)
    /// - parameter externalPaymentId: (query) Store identifier from external system (optional)
    /// - parameter externalDate: (query) External Date (optional)
    /// - returns: AnyPublisher<OrderResponse, Error> 
    open func updateOrder(orderId: Int64, appKey: String, cart: String, deviceId: String? = nil, accountId: Int64? = nil, paymentTransactionId: Int64? = nil, description: String? = nil, currencyType: UpdateOrderCurrencyType? = nil, paymentMethodId: Int64? = nil, externalPaymentId: String? = nil, externalDate: Int64? = nil) -> AnyPublisher<OrderResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/order/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "orderId", value: "\(orderId)"))
                if let paymentTransactionId = paymentTransactionId { queryItems.append(URLQueryItem(name: "paymentTransactionId", value: "\(paymentTransactionId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let currencyType = currencyType { queryItems.append(URLQueryItem(name: "currencyType", value: currencyType.rawValue)) } 
                queryItems.append(URLQueryItem(name: "cart", value: cart))
                if let paymentMethodId = paymentMethodId { queryItems.append(URLQueryItem(name: "paymentMethodId", value: "\(paymentMethodId)")) } 
                if let externalPaymentId = externalPaymentId { queryItems.append(URLQueryItem(name: "externalPaymentId", value: externalPaymentId)) } 
                if let externalDate = externalDate { queryItems.append(URLQueryItem(name: "externalDate", value: "\(externalDate)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<OrderResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(OrderResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
