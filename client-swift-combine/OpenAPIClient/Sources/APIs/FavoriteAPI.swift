//
// FavoriteAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class FavoriteAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Favorite
    /// - POST /api/{version}/favorite/create
    /// - Adds an offer, offer location, retailer location, or category to your favorites.
    /// - parameter version: (path)  
    /// - parameter favoritableId: (query) The ID of the object to favorite {offerId, offerLocationId, retailerLocationId, categoryId} 
    /// - parameter favoritableType: (query) The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY, ALBUM} 
    /// - parameter deviceId: (query) The unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account ID of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<WrappedResponse, Error> 
    open func addFavorite(version: Double, favoritableId: Int64, favoritableType: String, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<WrappedResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/favorite/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "favoritableId", value: "\(favoritableId)"))
                queryItems.append(URLQueryItem(name: "favoritableType", value: favoritableType))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WrappedResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(WrappedResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Favorite
    /// - POST /api/{version}/favorite/delete
    /// - Removes a favorited item from the user's favorites list.
    /// - parameter version: (path)  
    /// - parameter deviceId: (query) The unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account ID of the user (deviceId or accountId required) (optional)
    /// - parameter favoriteId: (query) The ID of the favorite reference record (only optional if favoritableId &amp; favoritableType is pass in instead) (optional)
    /// - parameter favoritableId: (query) The ID of the object to un-favorite {offerId, offerLocationId, retailerLocationId, categoryId} (this is required if favoriteId is NOT passed in) (optional)
    /// - parameter favoritableType: (query) The type of the object to un-favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} (this is required if favoriteId is NOT passed in) (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteFavorite(version: Double, deviceId: String? = nil, accountId: Int64? = nil, favoriteId: Int64? = nil, favoritableId: Int64? = nil, favoritableType: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/favorite/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let favoriteId = favoriteId { queryItems.append(URLQueryItem(name: "favoriteId", value: "\(favoriteId)")) } 
                if let favoritableId = favoritableId { queryItems.append(URLQueryItem(name: "favoritableId", value: "\(favoritableId)")) } 
                if let favoritableType = favoritableType { queryItems.append(URLQueryItem(name: "favoritableType", value: favoritableType)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Favorite
    /// - GET /api/{version}/favorite/get
    /// - Retrieves a single favorited item.
    /// - parameter version: (path)  
    /// - parameter favoriteId: (query) The ID of the favorite reference record 
    /// - parameter deviceId: (query) The unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account ID of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<WrappedResponse, Error> 
    open func getFavorite(version: Double, favoriteId: Int64, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<WrappedResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/favorite/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "favoriteId", value: "\(favoriteId)"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<WrappedResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(WrappedResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchFavoritesSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case display = "DISPLAY"
    }

    /// Search Favorites
    /// - GET /api/{version}/favorite/search
    /// - Searches on the user's favorites.
    /// - parameter version: (path)  
    /// - parameter favoritableType: (query) The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} 
    /// - parameter sortField: (query) Determines what to sort the results by {CREATED, UPDATED, DISPLAY} 
    /// - parameter descending: (query) Determines whether the results are in descending order 
    /// - parameter start: (query) The start index for pagination 
    /// - parameter limit: (query) The limit for pagination (there is a hard limit of 1000) 
    /// - parameter activeOnly: (query) Determines whether to only return active favorites 
    /// - parameter returnFullResponse: (query) Determines whether to return a detailed version of the response list 
    /// - parameter deviceId: (query) The unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account ID of the user (deviceId or accountId required) (optional)
    /// - parameter connectionAccountId: (query) The ID of an account the user would like to view favorites for (optional)
    /// - parameter secondaryType: (query)  (optional)
    /// - parameter keyword: (query) The keyword to search for (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - returns: AnyPublisher<SearchResponse, Error> 
    open func searchFavorites(version: Double, favoritableType: String, sortField: SearchFavoritesSortField, descending: Bool, start: Int, limit: Int, activeOnly: Bool, returnFullResponse: Bool, deviceId: String? = nil, accountId: Int64? = nil, connectionAccountId: Int64? = nil, secondaryType: String? = nil, keyword: String? = nil, latitude: Double? = nil, longitude: Double? = nil) -> AnyPublisher<SearchResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/favorite/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let connectionAccountId = connectionAccountId { queryItems.append(URLQueryItem(name: "connectionAccountId", value: "\(connectionAccountId)")) } 
                queryItems.append(URLQueryItem(name: "favoritableType", value: favoritableType))
                if let secondaryType = secondaryType { queryItems.append(URLQueryItem(name: "secondaryType", value: secondaryType)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "returnFullResponse", value: returnFullResponse ? "true" : "false"))
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SearchResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SearchResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Who has Favorited
    /// - GET /api/{version}/favorite/whois
    /// - Searches for everyone that has favorited an item
    /// - parameter version: (path)  
    /// - parameter favoritableId: (query) The ID of the favoritableType to search on 
    /// - parameter favoritableType: (query) The type of the object to favorite {OFFER, OFFER_LOCATION, RETAILER_LOCATION, CATEGORY} 
    /// - parameter start: (query) The start index for pagination 
    /// - parameter limit: (query) The limit for pagination 
    /// - parameter deviceId: (query) The unique ID given by the device (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account ID of the user (deviceId or accountId required) (optional)
    /// - parameter latitude: (query) The current latitude of the user (optional)
    /// - parameter longitude: (query) The current longitude of the user (optional)
    /// - parameter keyword: (query) The keyword to limit that account list (optional)
    /// - returns: AnyPublisher<[AccountResponse], Error> 
    open func whoHasFavorited(version: Double, favoritableId: Int64, favoritableType: String, start: Int, limit: Int, deviceId: String? = nil, accountId: Int64? = nil, latitude: Double? = nil, longitude: Double? = nil, keyword: String? = nil) -> AnyPublisher<[AccountResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/favorite/whois"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                queryItems.append(URLQueryItem(name: "favoritableId", value: "\(favoritableId)"))
                queryItems.append(URLQueryItem(name: "favoritableType", value: favoritableType))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[AccountResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([AccountResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
