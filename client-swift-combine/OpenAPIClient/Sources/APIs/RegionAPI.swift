//
// RegionAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RegionAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum CreateRegionVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /// Create Region
    /// - POST /api/{version}/region/create
    /// - Create a region.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The id of the account sending the request 
    /// - parameter regionClass: (query) RegionClass of this region 
    /// - parameter shortName: (query) Short name of the region. This is optimized for search 
    /// - parameter fullName: (query) Full name of the region (optional)
    /// - parameter parentIds: (query) Comma separated region ids that are parents of this region (optional)
    /// - parameter childrenIds: (query) Comma separated region ids that are children of this region (optional)
    /// - parameter postalCodeIds: (query) Comma separated postal code ids the region will include (optional)
    /// - parameter locations: (query) Sets of name,lat,long used to create new postal codes assigned to the region (optional)
    /// - parameter retailerLocationId: (query) the id of the retailer location that the region is being created for (optional)
    /// - parameter visibility: (query) The Visibility of the region (optional)
    /// - parameter categoryIds: (query) the categories that the region is assigned to (optional)
    /// - parameter filterIds: (query) the filters that the region is assigned to (optional)
    /// - parameter start: (query)  (optional)
    /// - parameter end: (query)  (optional)
    /// - parameter polygon: (query) the polygon generated for the region (optional)
    /// - parameter metaData: (query) the meta data associated with the region (optional)
    /// - parameter latitude: (query) the latitude of the region (optional)
    /// - parameter longitude: (query) the longitude of the region (optional)
    /// - parameter versionCode: (query) the version code (optional)
    /// - parameter root: (query) If this is a root region or not. If true means this region has no parent regions (optional)
    /// - parameter active: (query) Active or inactive status of the region (optional)
    /// - returns: AnyPublisher<RegionResponse, Error> 
    open func createRegion(version: Double, accountId: Int64, regionClass: String, shortName: String, fullName: String? = nil, parentIds: String? = nil, childrenIds: String? = nil, postalCodeIds: String? = nil, locations: String? = nil, retailerLocationId: Int64? = nil, visibility: CreateRegionVisibility? = nil, categoryIds: String? = nil, filterIds: String? = nil, start: Int64? = nil, end: Int64? = nil, polygon: String? = nil, metaData: String? = nil, latitude: Double? = nil, longitude: Double? = nil, versionCode: Int? = nil, root: Bool? = nil, active: Bool? = nil) -> AnyPublisher<RegionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/region/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "regionClass", value: regionClass))
                queryItems.append(URLQueryItem(name: "shortName", value: shortName))
                if let fullName = fullName { queryItems.append(URLQueryItem(name: "fullName", value: fullName)) } 
                if let parentIds = parentIds { queryItems.append(URLQueryItem(name: "parentIds", value: parentIds)) } 
                if let childrenIds = childrenIds { queryItems.append(URLQueryItem(name: "childrenIds", value: childrenIds)) } 
                if let postalCodeIds = postalCodeIds { queryItems.append(URLQueryItem(name: "postalCodeIds", value: postalCodeIds)) } 
                if let locations = locations { queryItems.append(URLQueryItem(name: "locations", value: locations)) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let end = end { queryItems.append(URLQueryItem(name: "end", value: "\(end)")) } 
                if let polygon = polygon { queryItems.append(URLQueryItem(name: "polygon", value: polygon)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let versionCode = versionCode { queryItems.append(URLQueryItem(name: "versionCode", value: "\(versionCode)")) } 
                if let root = root { queryItems.append(URLQueryItem(name: "root", value: root ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RegionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RegionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Region
    /// - POST /api/{version}/region/delete
    /// - Delete a region.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the account logged in 
    /// - parameter regionId: (query) the id of the region 
    /// - returns: AnyPublisher<RegionResponse, Error> 
    open func deleteRegion(version: Double, accountId: Int64, regionId: Int64) -> AnyPublisher<RegionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/region/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "regionId", value: "\(regionId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RegionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RegionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Region
    /// - GET /api/{version}/region/get
    /// - Get a region.
    /// - parameter version: (path)  
    /// - parameter regionId: (query) the id of the region to get 
    /// - parameter accountId: (query) the id of the logged in user (optional)
    /// - returns: AnyPublisher<RegionResponse, Error> 
    open func getRegion(version: Double, regionId: Int64, accountId: Int64? = nil) -> AnyPublisher<RegionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/region/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "regionId", value: "\(regionId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RegionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RegionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter regionClass
    ///
    public enum SearchRegionsRegionClass: String, Codable, CaseIterable {
        case national = "NATIONAL"
        case state = "STATE"
        case county = "COUNTY"
        case metroArea = "METRO_AREA"
        case city = "CITY"
        case neighborhood = "NEIGHBORHOOD"
        case territory = "TERRITORY"
        case custom = "CUSTOM"
        case zone = "ZONE"
    }
    ///
    /// Enum for parameter visibility
    ///
    public enum SearchRegionsVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }
    ///
    /// Enum for parameter searchMode
    ///
    public enum SearchRegionsSearchMode: String, Codable, CaseIterable {
        case rds = "RDS"
        case lucene = "LUCENE"
        case cloudindex = "CLOUDINDEX"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum SearchRegionsSortField: String, Codable, CaseIterable {
        case id = "ID"
        case updated = "UPDATED"
        case name = "NAME"
        case distance = "DISTANCE"
    }

    /// Search Regions
    /// - GET /api/{version}/region/search
    /// - Get the list of regions.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the owner account id of the region to be created (optional)
    /// - parameter query: (query) This parameter is deprecated. deprecated - use \&quot;keyword\&quot; (optional)
    /// - parameter keyword: (query) the keyword to filter results on (optional)
    /// - parameter latitude: (query) the latitude of the user (optional)
    /// - parameter longitude: (query) the longitude of the user (optional)
    /// - parameter range: (query) the search radius (optional)
    /// - parameter regionClass: (query)  (optional)
    /// - parameter visibility: (query)  (optional)
    /// - parameter searchMode: (query) the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server (optional)
    /// - parameter sortField: (query) the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided. (optional)
    /// - parameter descending: (query) determines if the results get ordered in descending order (optional)
    /// - parameter includeParent: (query) include the parent region or not (optional)
    /// - parameter includeChildren: (query) include the chidren regions or not (optional)
    /// - parameter includePostalCodes: (query) include the postal codes associated with the region or not (optional)
    /// - parameter categoryIds: (query) search on the categories associated with the region (optional)
    /// - parameter filterIds: (query) search on the filters associated with the region (optional)
    /// - parameter versionCode: (query) filter by a specific version code (optional)
    /// - parameter activeOnly: (query) filter to show only active results (optional)
    /// - parameter showDeleted: (query) If showDeleted is true and activeOnly is false, will return regions that have been deleted (optional)
    /// - parameter lastUpdatedSince: (query) only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\) (optional)
    /// - parameter start: (query) the start index for pagination (optional)
    /// - parameter limit: (query) the limit for pagination (optional)
    /// - returns: AnyPublisher<[RegionResponse], Error> 
    open func searchRegions(version: Double, accountId: Int64? = nil, query: String? = nil, keyword: String? = nil, latitude: Double? = nil, longitude: Double? = nil, range: Double? = nil, regionClass: SearchRegionsRegionClass? = nil, visibility: SearchRegionsVisibility? = nil, searchMode: SearchRegionsSearchMode? = nil, sortField: SearchRegionsSortField? = nil, descending: Bool? = nil, includeParent: Bool? = nil, includeChildren: Bool? = nil, includePostalCodes: Bool? = nil, categoryIds: String? = nil, filterIds: String? = nil, versionCode: Int? = nil, activeOnly: Bool? = nil, showDeleted: Bool? = nil, lastUpdatedSince: Int64? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[RegionResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/region/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let query = query { queryItems.append(URLQueryItem(name: "query", value: query)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let range = range { queryItems.append(URLQueryItem(name: "range", value: "\(range)")) } 
                if let regionClass = regionClass { queryItems.append(URLQueryItem(name: "regionClass", value: regionClass.rawValue)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let searchMode = searchMode { queryItems.append(URLQueryItem(name: "searchMode", value: searchMode.rawValue)) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let includeParent = includeParent { queryItems.append(URLQueryItem(name: "includeParent", value: includeParent ? "true" : "false")) } 
                if let includeChildren = includeChildren { queryItems.append(URLQueryItem(name: "includeChildren", value: includeChildren ? "true" : "false")) } 
                if let includePostalCodes = includePostalCodes { queryItems.append(URLQueryItem(name: "includePostalCodes", value: includePostalCodes ? "true" : "false")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let versionCode = versionCode { queryItems.append(URLQueryItem(name: "versionCode", value: "\(versionCode)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let showDeleted = showDeleted { queryItems.append(URLQueryItem(name: "showDeleted", value: showDeleted ? "true" : "false")) } 
                if let lastUpdatedSince = lastUpdatedSince { queryItems.append(URLQueryItem(name: "lastUpdatedSince", value: "\(lastUpdatedSince)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RegionResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RegionResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum UpdateRegionVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }

    /// Update Region
    /// - POST /api/{version}/region/update
    /// - Update a region.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The id of the account sending the request 
    /// - parameter regionId: (query) The id of the region to be updated 
    /// - parameter regionClass: (query) RegionClass of this region (optional)
    /// - parameter shortName: (query) Short name of the region. This is optimized for search (optional)
    /// - parameter fullName: (query) Full name of the region (optional)
    /// - parameter parentIds: (query) Comma separated region ids that are parents of this region (optional)
    /// - parameter childrenIds: (query) Comma separated region ids that are children of this region (optional)
    /// - parameter postalCodeIds: (query) Comma separated postal code ids the region will include (optional)
    /// - parameter locations: (query) Sets of name,lat,long used to create new postal codes assigned to the region (optional)
    /// - parameter retailerLocationId: (query) the retailer location ID that the region is associated with (optional)
    /// - parameter visibility: (query) The Visibility of the region (optional)
    /// - parameter categoryIds: (query) the categories that the region is assigned to (optional)
    /// - parameter filterIds: (query) the filters that the region is assigned to (optional)
    /// - parameter start: (query)  (optional)
    /// - parameter end: (query)  (optional)
    /// - parameter polygon: (query) the polygon of the region (optional)
    /// - parameter metaData: (query) the meta data of the region (optional)
    /// - parameter latitude: (query) the latitude of the region (optional)
    /// - parameter longitude: (query) the longitude of the region (optional)
    /// - parameter versionCode: (query) the version code (optional)
    /// - parameter root: (query) If this is a root region or not. If true means this region has no parent regions (optional)
    /// - parameter active: (query) Active or inactive status of the region (optional)
    /// - parameter clearLists: (query) If true clear the children and postal code lists before add new ones, otherwise just append. (optional)
    /// - returns: AnyPublisher<RegionResponse, Error> 
    open func updateRegion(version: Double, accountId: Int64, regionId: Int64, regionClass: String? = nil, shortName: String? = nil, fullName: String? = nil, parentIds: String? = nil, childrenIds: String? = nil, postalCodeIds: String? = nil, locations: String? = nil, retailerLocationId: Int64? = nil, visibility: UpdateRegionVisibility? = nil, categoryIds: String? = nil, filterIds: String? = nil, start: Int64? = nil, end: Int64? = nil, polygon: String? = nil, metaData: String? = nil, latitude: Double? = nil, longitude: Double? = nil, versionCode: Int? = nil, root: Bool? = nil, active: Bool? = nil, clearLists: Bool? = nil) -> AnyPublisher<RegionResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/region/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "regionId", value: "\(regionId)"))
                if let regionClass = regionClass { queryItems.append(URLQueryItem(name: "regionClass", value: regionClass)) } 
                if let shortName = shortName { queryItems.append(URLQueryItem(name: "shortName", value: shortName)) } 
                if let fullName = fullName { queryItems.append(URLQueryItem(name: "fullName", value: fullName)) } 
                if let parentIds = parentIds { queryItems.append(URLQueryItem(name: "parentIds", value: parentIds)) } 
                if let childrenIds = childrenIds { queryItems.append(URLQueryItem(name: "childrenIds", value: childrenIds)) } 
                if let postalCodeIds = postalCodeIds { queryItems.append(URLQueryItem(name: "postalCodeIds", value: postalCodeIds)) } 
                if let locations = locations { queryItems.append(URLQueryItem(name: "locations", value: locations)) } 
                if let retailerLocationId = retailerLocationId { queryItems.append(URLQueryItem(name: "retailerLocationId", value: "\(retailerLocationId)")) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let end = end { queryItems.append(URLQueryItem(name: "end", value: "\(end)")) } 
                if let polygon = polygon { queryItems.append(URLQueryItem(name: "polygon", value: polygon)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let versionCode = versionCode { queryItems.append(URLQueryItem(name: "versionCode", value: "\(versionCode)")) } 
                if let root = root { queryItems.append(URLQueryItem(name: "root", value: root ? "true" : "false")) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let clearLists = clearLists { queryItems.append(URLQueryItem(name: "clearLists", value: clearLists ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RegionResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RegionResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
