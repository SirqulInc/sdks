//
// CategoryAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class CategoryAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum CategoryDistanceSearchSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case name = "NAME"
        case display = "DISPLAY"
    }
    ///
    /// Enum for parameter responseGroup
    ///
    public enum CategoryDistanceSearchResponseGroup: String, Codable, CaseIterable {
        case all = "ALL"
        case global = "GLOBAL"
        case mine = "MINE"
    }

    /// Search Categories by Distance
    /// - GET /api/{version}/category/distancesearch
    /// - Search for categories by distance.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (optional)
    /// - parameter keyword: (query) The keyword string to search on (optional)
    /// - parameter appKey: (query) the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
    /// - parameter categoryIds: (query) Restrict the search by specific categories (optional)
    /// - parameter parentCategoryIds: (query) Restrict the search by specific parent categories so that only its sub children are searched. (optional)
    /// - parameter rootOnly: (query) Restrict the search to only those categories with no parent category assigned. (optional)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to .display)
    /// - parameter responseGroup: (query) The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
    /// - parameter descending: (query) The order to return the search results (optional, default to false)
    /// - parameter start: (query) The record to begin the return set on (optional, default to 0)
    /// - parameter limit: (query) The number of records to return (optional, default to 20)
    /// - parameter activeOnly: (query) Determines whether to return only active categories (optional, default to true)
    /// - parameter returnExternal: (query) Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional)
    /// - parameter exactMatch: (query) If true search categories using the exact keyword, if false then do a partial match (like) search. (optional)
    /// - parameter type: (query) Filters results by the Category&#39;s type (optional)
    /// - parameter externalType: (query) Filters results by externalType (optional)
    /// - parameter minOfferCount: (query) Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
    /// - parameter latitude: (query) the latitude of where the search is centered on (optional)
    /// - parameter longitude: (query) the longitude of where the search is centered on (optional)
    /// - parameter range: (query) the maximum range the category can be from the center (optional)
    /// - returns: AnyPublisher<[CategoryResponse], Error> 
    open func categoryDistanceSearch(version: Double, accountId: Int64? = nil, keyword: String? = nil, appKey: String? = nil, categoryIds: String? = nil, parentCategoryIds: String? = nil, rootOnly: Bool? = nil, sortField: CategoryDistanceSearchSortField? = nil, responseGroup: CategoryDistanceSearchResponseGroup? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, returnExternal: Bool? = nil, exactMatch: Bool? = nil, type: String? = nil, externalType: String? = nil, minOfferCount: Int? = nil, latitude: Double? = nil, longitude: Double? = nil, range: Double? = nil) -> AnyPublisher<[CategoryResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/distancesearch"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let parentCategoryIds = parentCategoryIds { queryItems.append(URLQueryItem(name: "parentCategoryIds", value: parentCategoryIds)) } 
                if let rootOnly = rootOnly { queryItems.append(URLQueryItem(name: "rootOnly", value: rootOnly ? "true" : "false")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let responseGroup = responseGroup { queryItems.append(URLQueryItem(name: "responseGroup", value: responseGroup.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let returnExternal = returnExternal { queryItems.append(URLQueryItem(name: "returnExternal", value: returnExternal ? "true" : "false")) } 
                if let exactMatch = exactMatch { queryItems.append(URLQueryItem(name: "exactMatch", value: exactMatch ? "true" : "false")) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let externalType = externalType { queryItems.append(URLQueryItem(name: "externalType", value: externalType)) } 
                if let minOfferCount = minOfferCount { queryItems.append(URLQueryItem(name: "minOfferCount", value: "\(minOfferCount)")) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let range = range { queryItems.append(URLQueryItem(name: "range", value: "\(range)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[CategoryResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([CategoryResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Category
    /// - POST /api/{version}/category/create
    /// - Create a new category.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (must have permissions to the target application) 
    /// - parameter name: (query) The name of the category 
    /// - parameter appKey: (query) The appKey of the application to assign the category to, if not provided then the category will be applied to the global application (if the account has permissions) (optional)
    /// - parameter parentCategoryId: (query) The ID of the parent category, if not provided then the parent category will be null (optional)
    /// - parameter description: (query) The description of the category (optional)
    /// - parameter type: (query) The type of the category (optional)
    /// - parameter assetId: (query) The ID of the image asset previously uploaded using the media service (optional)
    /// - parameter externalId: (query) A string identifier used by client applications to store external information (optional)
    /// - parameter externalType: (query) A string type used by client applications to store external information (optional)
    /// - parameter externalCategorySlug: (query) external category slug (optional)
    /// - parameter sqootSlug: (query) sqoot slug (optional)
    /// - parameter active: (query) Sets whether the category is active or inactive (hidden from consumers) (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - parameter searchTags: (query) user defined strings for searching (optional)
    /// - returns: AnyPublisher<CategoryTreeResponse, Error> 
    open func createCategory(version: Double, accountId: Int64, name: String, appKey: String? = nil, parentCategoryId: Int64? = nil, description: String? = nil, type: String? = nil, assetId: Int64? = nil, externalId: String? = nil, externalType: String? = nil, externalCategorySlug: String? = nil, sqootSlug: String? = nil, active: Bool? = nil, metaData: String? = nil, searchTags: String? = nil) -> AnyPublisher<CategoryTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let parentCategoryId = parentCategoryId { queryItems.append(URLQueryItem(name: "parentCategoryId", value: "\(parentCategoryId)")) } 
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let externalType = externalType { queryItems.append(URLQueryItem(name: "externalType", value: externalType)) } 
                if let externalCategorySlug = externalCategorySlug { queryItems.append(URLQueryItem(name: "externalCategorySlug", value: externalCategorySlug)) } 
                if let sqootSlug = sqootSlug { queryItems.append(URLQueryItem(name: "sqootSlug", value: sqootSlug)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CategoryTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CategoryTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Category
    /// - POST /api/{version}/category/delete
    /// - Delete a category.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the ID of the account 
    /// - parameter categoryId: (query) the ID of the category 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteCategory(version: Double, accountId: Int64, categoryId: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "categoryId", value: "\(categoryId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Duplicate Category
    /// - POST /api/{version}/category/duplicate
    /// - Duplicate a category, including all its children.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (must have permissions to the target application) 
    /// - parameter categoryId: (query) The category ID to duplicate (includes all children) 
    /// - parameter appKey: (query) The application to assign the new category to, may be different then the application the source category is assigned to (optional)
    /// - parameter parentCategoryId: (query) The parent category ID to add the target category to. (optional)
    /// - returns: AnyPublisher<CategoryTreeResponse, Error> 
    open func duplicateCategory(version: Double, accountId: Int64, categoryId: Int64, appKey: String? = nil, parentCategoryId: Int64? = nil) -> AnyPublisher<CategoryTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/duplicate"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "categoryId", value: "\(categoryId)"))
                if let parentCategoryId = parentCategoryId { queryItems.append(URLQueryItem(name: "parentCategoryId", value: "\(parentCategoryId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CategoryTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CategoryTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Category
    /// - GET /api/{version}/category/get
    /// - Get the details of a specific category. Recursively include all child categories and their children.
    /// - parameter version: (path)  
    /// - parameter categoryId: (query) the ID of the category 
    /// - parameter returnExternal: (query) Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
    /// - returns: AnyPublisher<CategoryTreeResponse, Error> 
    open func getCategory(version: Double, categoryId: Int64, returnExternal: Bool? = nil) -> AnyPublisher<CategoryTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "categoryId", value: "\(categoryId)"))
                if let returnExternal = returnExternal { queryItems.append(URLQueryItem(name: "returnExternal", value: returnExternal ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CategoryTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CategoryTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchCategoriesSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case name = "NAME"
        case display = "DISPLAY"
    }
    ///
    /// Enum for parameter responseGroup
    ///
    public enum SearchCategoriesResponseGroup: String, Codable, CaseIterable {
        case all = "ALL"
        case global = "GLOBAL"
        case mine = "MINE"
    }

    /// Search Categories
    /// - GET /api/{version}/category/search
    /// - Search for categories.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user (optional)
    /// - parameter keyword: (query) The string to search on (optional)
    /// - parameter appKey: (query) the appKey of the application to retrieve categories for, if not specified then search on the global application. (optional)
    /// - parameter categoryId: (query) @Deprecated, use parentCategoryIds instead (optional)
    /// - parameter categoryIds: (query) Restrict the search by specific categories (optional)
    /// - parameter parentCategoryIds: (query) Restrict the search by specific parent categories so that only its sub children are searched. (optional)
    /// - parameter rootOnly: (query) Restrict the search to only those categories with no parent category assigned. (optional)
    /// - parameter sortField: (query) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (optional, default to .display)
    /// - parameter responseGroup: (query) The group of categories to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (optional)
    /// - parameter descending: (query) The order to return the search results (optional, default to false)
    /// - parameter start: (query) The record to begin the return set on (optional, default to 0)
    /// - parameter limit: (query) The number of records to return (optional, default to 20)
    /// - parameter activeOnly: (query) Determines whether to return only active categories (optional, default to true)
    /// - parameter returnExternal: (query) Determines whether to return extra info about the category&#39;s \&quot;Participant\&quot; reference (optional, default to true)
    /// - parameter exactMatch: (query) If true search categories using the exact keyword, if false then do a partial match (like) search. Default is false. (optional, default to false)
    /// - parameter type: (query) Filters results by the Category&#39;s type (optional)
    /// - parameter externalType: (query) Filters results by externalType (optional)
    /// - parameter excludeExternalType: (query) Determines whether the \&quot;externalType\&quot; param is excluded from the search results (optional)
    /// - parameter minOfferCount: (query) Filters results to only return Categories that have been referenced by a minimum number of Offers (optional)
    /// - parameter searchDepth: (query) When searching by a specific parent category (to return sub children), this determines the number of child layers to search in. The minimum is 1, the maximum is 4. (optional, default to 4)
    /// - parameter searchMode: (query) The search index mode to use (e.g. OPENSEARCH or RDS) (optional)
    /// - returns: AnyPublisher<[CategoryResponse], Error> 
    open func searchCategories(version: Double, accountId: Int64? = nil, keyword: String? = nil, appKey: String? = nil, categoryId: String? = nil, categoryIds: String? = nil, parentCategoryIds: String? = nil, rootOnly: Bool? = nil, sortField: SearchCategoriesSortField? = nil, responseGroup: SearchCategoriesResponseGroup? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, returnExternal: Bool? = nil, exactMatch: Bool? = nil, type: String? = nil, externalType: String? = nil, excludeExternalType: Bool? = nil, minOfferCount: Int? = nil, searchDepth: Int? = nil, searchMode: String? = nil) -> AnyPublisher<[CategoryResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let categoryId = categoryId { queryItems.append(URLQueryItem(name: "categoryId", value: categoryId)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let parentCategoryIds = parentCategoryIds { queryItems.append(URLQueryItem(name: "parentCategoryIds", value: parentCategoryIds)) } 
                if let rootOnly = rootOnly { queryItems.append(URLQueryItem(name: "rootOnly", value: rootOnly ? "true" : "false")) } 
                if let sortField = sortField { queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue)) } 
                if let responseGroup = responseGroup { queryItems.append(URLQueryItem(name: "responseGroup", value: responseGroup.rawValue)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let returnExternal = returnExternal { queryItems.append(URLQueryItem(name: "returnExternal", value: returnExternal ? "true" : "false")) } 
                if let exactMatch = exactMatch { queryItems.append(URLQueryItem(name: "exactMatch", value: exactMatch ? "true" : "false")) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let externalType = externalType { queryItems.append(URLQueryItem(name: "externalType", value: externalType)) } 
                if let excludeExternalType = excludeExternalType { queryItems.append(URLQueryItem(name: "excludeExternalType", value: excludeExternalType ? "true" : "false")) } 
                if let minOfferCount = minOfferCount { queryItems.append(URLQueryItem(name: "minOfferCount", value: "\(minOfferCount)")) } 
                if let searchDepth = searchDepth { queryItems.append(URLQueryItem(name: "searchDepth", value: "\(searchDepth)")) } 
                if let searchMode = searchMode { queryItems.append(URLQueryItem(name: "searchMode", value: searchMode)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[CategoryResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([CategoryResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Category
    /// - POST /api/{version}/category/update
    /// - Update a category.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user 
    /// - parameter categoryId: (query) The ID of the category to edit 
    /// - parameter parentCategoryId: (query) The ID of the parent category, if not provided then the parent category will be null (optional)
    /// - parameter name: (query) The name of the category (optional)
    /// - parameter description: (query) The description of the category (optional)
    /// - parameter type: (query) The type of the category (optional)
    /// - parameter assetId: (query) The ID of the image asset previously uploaded using the media service (optional)
    /// - parameter externalId: (query) A string identifier used by client applications to store external information (optional)
    /// - parameter externalType: (query) A string type used by client applications to store external information (optional)
    /// - parameter externalCategorySlug: (query) external category slug (optional)
    /// - parameter sqootSlug: (query) sqoot slug (optional)
    /// - parameter active: (query) Sets whether the category is active or inactive (hidden from consumers) (optional)
    /// - parameter metaData: (query) external custom client defined data (optional)
    /// - parameter searchTags: (query) user defined strings for searching (optional)
    /// - returns: AnyPublisher<CategoryTreeResponse, Error> 
    open func updateCategory(version: Double, accountId: Int64, categoryId: Int64, parentCategoryId: Int64? = nil, name: String? = nil, description: String? = nil, type: String? = nil, assetId: Int64? = nil, externalId: String? = nil, externalType: String? = nil, externalCategorySlug: String? = nil, sqootSlug: String? = nil, active: Bool? = nil, metaData: String? = nil, searchTags: String? = nil) -> AnyPublisher<CategoryTreeResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/category/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "categoryId", value: "\(categoryId)"))
                if let parentCategoryId = parentCategoryId { queryItems.append(URLQueryItem(name: "parentCategoryId", value: "\(parentCategoryId)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let type = type { queryItems.append(URLQueryItem(name: "type", value: type)) } 
                if let assetId = assetId { queryItems.append(URLQueryItem(name: "assetId", value: "\(assetId)")) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let externalType = externalType { queryItems.append(URLQueryItem(name: "externalType", value: externalType)) } 
                if let externalCategorySlug = externalCategorySlug { queryItems.append(URLQueryItem(name: "externalCategorySlug", value: externalCategorySlug)) } 
                if let sqootSlug = sqootSlug { queryItems.append(URLQueryItem(name: "sqootSlug", value: sqootSlug)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CategoryTreeResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CategoryTreeResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
