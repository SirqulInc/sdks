//
// ThirdPartyCredentialsAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class ThirdPartyCredentialsAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Credential
    /// - POST /api/{version}/thirdparty/credential/create
    /// - This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 
    /// - parameter version: (path)  
    /// - parameter thirdPartyId: (query) the third party user account id 
    /// - parameter thirdPartyToken: (query) the access token to authenticate with (ex: username or fb token or phone number) 
    /// - parameter networkUID: (query) the access provider to authenticate against 
    /// - parameter appKey: (query) the application key 
    /// - parameter accountId: (query) the unique id of the account that needs authenticating (optional for PHONE_V2) (optional)
    /// - parameter deviceId: (query) the unique id of the device making the request (optional)
    /// - parameter sessionId: (query) the session id for the request (optional)
    /// - parameter thirdPartyName: (query) the third party user&#39;s display name (optional)
    /// - parameter emailAddress: (query) optional email address associated with the third party account (optional)
    /// - parameter signinOnlyMode: (query) when true will error out if can&#39;t find any accounts matching (signin only) (optional, default to false)
    /// - parameter responseFilters: (query) this determines how much of the profile should be returned, see ProfileFilters (optional)
    /// - parameter latitude: (query) the latitude of the user (optional)
    /// - parameter longitude: (query) the longitude of the user (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter thirdPartyRefreshToken: (query) optional refresh token for the third party (optional)
    /// - parameter audienceIdsToAdd: (query) audience ids to add to the account (optional)
    /// - parameter audienceIdsToRemove: (query) audience ids to remove from the account (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func createCredential(version: Double, thirdPartyId: String, thirdPartyToken: String, networkUID: String, appKey: String, accountId: Int64? = nil, deviceId: String? = nil, sessionId: String? = nil, thirdPartyName: String? = nil, emailAddress: String? = nil, signinOnlyMode: Bool? = nil, responseFilters: String? = nil, latitude: Double? = nil, longitude: Double? = nil, metaData: String? = nil, thirdPartyRefreshToken: String? = nil, audienceIdsToAdd: String? = nil, audienceIdsToRemove: String? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/credential/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let sessionId = sessionId { queryItems.append(URLQueryItem(name: "sessionId", value: sessionId)) } 
                queryItems.append(URLQueryItem(name: "thirdPartyId", value: thirdPartyId))
                if let thirdPartyName = thirdPartyName { queryItems.append(URLQueryItem(name: "thirdPartyName", value: thirdPartyName)) } 
                queryItems.append(URLQueryItem(name: "thirdPartyToken", value: thirdPartyToken))
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let emailAddress = emailAddress { queryItems.append(URLQueryItem(name: "emailAddress", value: emailAddress)) } 
                if let signinOnlyMode = signinOnlyMode { queryItems.append(URLQueryItem(name: "signinOnlyMode", value: signinOnlyMode ? "true" : "false")) } 
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let thirdPartyRefreshToken = thirdPartyRefreshToken { queryItems.append(URLQueryItem(name: "thirdPartyRefreshToken", value: thirdPartyRefreshToken)) } 
                if let audienceIdsToAdd = audienceIdsToAdd { queryItems.append(URLQueryItem(name: "audienceIdsToAdd", value: audienceIdsToAdd)) } 
                if let audienceIdsToRemove = audienceIdsToRemove { queryItems.append(URLQueryItem(name: "audienceIdsToRemove", value: audienceIdsToRemove)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Network
    /// - POST /api/{version}/thirdparty/network/create
    /// - Creates a custom third party network.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id making the request 
    /// - parameter name: (query) The name of the network 
    /// - parameter enableIntrospection: (query) Whether the network uses introspection calls 
    /// - parameter description: (query) The description of the network (optional)
    /// - parameter introspectionMethod: (query) HTTP method to use for introspection calls (e.g., GET, POST) (optional)
    /// - parameter introspectionURL: (query) The HTTP URL of the introspection call (optional)
    /// - parameter introspectionParams: (query) The parameters of the introspection call (optional)
    /// - parameter requiredRootField: (query) Required response params (optional)
    /// - parameter enableMFA: (query) Whether this network uses MFA (optional)
    /// - parameter sizeMFA: (query) Size of the MFA token (optional)
    /// - parameter shelfLifeMFA: (query) Shelf life (seconds) of the MFA token (optional)
    /// - parameter oauthTokenURL: (query) OAuth token endpoint URL (optional)
    /// - parameter oauthPrivateKey: (query) OAuth private key file (multipart) (optional)
    /// - parameter oauthPublicKey: (query) OAuth public key file (multipart) (optional)
    /// - parameter oauthClientId: (query) OAuth client id (optional)
    /// - parameter oauthSecretKey: (query) OAuth secret key (optional)
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<ThirdPartyNetworkResponse, Error> 
    open func createNetwork(version: Double, accountId: Int64, name: String, enableIntrospection: Bool, description: String? = nil, introspectionMethod: String? = nil, introspectionURL: String? = nil, introspectionParams: String? = nil, requiredRootField: String? = nil, enableMFA: Bool? = nil, sizeMFA: Int? = nil, shelfLifeMFA: Int? = nil, oauthTokenURL: String? = nil, oauthPrivateKey: Data? = nil, oauthPublicKey: Data? = nil, oauthClientId: String? = nil, oauthSecretKey: String? = nil, body: String? = nil) -> AnyPublisher<ThirdPartyNetworkResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/network/create"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                queryItems.append(URLQueryItem(name: "enableIntrospection", value: enableIntrospection ? "true" : "false"))
                if let introspectionMethod = introspectionMethod { queryItems.append(URLQueryItem(name: "introspectionMethod", value: introspectionMethod)) } 
                if let introspectionURL = introspectionURL { queryItems.append(URLQueryItem(name: "introspectionURL", value: introspectionURL)) } 
                if let introspectionParams = introspectionParams { queryItems.append(URLQueryItem(name: "introspectionParams", value: introspectionParams)) } 
                if let requiredRootField = requiredRootField { queryItems.append(URLQueryItem(name: "requiredRootField", value: requiredRootField)) } 
                if let enableMFA = enableMFA { queryItems.append(URLQueryItem(name: "enableMFA", value: enableMFA ? "true" : "false")) } 
                if let sizeMFA = sizeMFA { queryItems.append(URLQueryItem(name: "sizeMFA", value: "\(sizeMFA)")) } 
                if let shelfLifeMFA = shelfLifeMFA { queryItems.append(URLQueryItem(name: "shelfLifeMFA", value: "\(shelfLifeMFA)")) } 
                if let oauthTokenURL = oauthTokenURL { queryItems.append(URLQueryItem(name: "oauthTokenURL", value: oauthTokenURL)) } 
                if let oauthPrivateKey = oauthPrivateKey { queryItems.append(URLQueryItem(name: "oauthPrivateKey", value: )) } 
                if let oauthPublicKey = oauthPublicKey { queryItems.append(URLQueryItem(name: "oauthPublicKey", value: )) } 
                if let oauthClientId = oauthClientId { queryItems.append(URLQueryItem(name: "oauthClientId", value: oauthClientId)) } 
                if let oauthSecretKey = oauthSecretKey { queryItems.append(URLQueryItem(name: "oauthSecretKey", value: oauthSecretKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ThirdPartyNetworkResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ThirdPartyNetworkResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Credential
    /// - POST /api/{version}/thirdparty/credential/delete
    /// - Delete a third party network on a Sirqul account.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user 
    /// - parameter networkUID: (query) The third party network identifier 
    /// - parameter thirdPartyId: (query) The third party user id 
    /// - parameter appKey: (query) the application key 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteCredential(version: Double, accountId: Int64, networkUID: String, thirdPartyId: String, appKey: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/credential/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                queryItems.append(URLQueryItem(name: "thirdPartyId", value: thirdPartyId))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Network
    /// - POST /api/{version}/thirdparty/network/delete
    /// - Marks a custom third party network as deleted. Only the network owners and managers have access to this.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter networkUID: (query) The unique identifier for the third party network defined by Sirqul 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteNetwork(version: Double, accountId: Int64, networkUID: String) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/network/delete"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Credential
    /// - POST /api/{version}/thirdparty/credential/get
    /// - Gets the account information given a third party token.
    /// - parameter version: (path)  
    /// - parameter networkUID: (query) the access provider to authenticate against 
    /// - parameter appKey: (query) the application key 
    /// - parameter accountId: (query) the unique account id of a specific account that will be bound to the third-party credentials (optional)
    /// - parameter deviceId: (query) the unique id of the device making the request (optional)
    /// - parameter sessionId: (query) the session id for the request (optional)
    /// - parameter thirdPartyCredentialId: (query) the third-party credentials id from the response of the credential/create step (optional)
    /// - parameter thirdPartyToken: (query) the access token to authenticate with (optional)
    /// - parameter thirdPartySecret: (query) the secret code to authenticate with (used for MFA) (optional)
    /// - parameter createNewAccount: (query) flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts (optional, default to false)
    /// - parameter responseFilters: (query) this determines how much of the profile should be returned, see ProfileFilters (optional)
    /// - parameter latitude: (query) the latitude of the user (optional)
    /// - parameter longitude: (query) the longitude of the user (optional)
    /// - parameter audienceIdsToAdd: (query) audience ids to add to the account (optional)
    /// - parameter audienceIdsToRemove: (query) audience ids to remove from the account (optional)
    /// - parameter referralAccountId: (query) account id of the referrer (inviter-invitee relationship) (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func getCredential(version: Double, networkUID: String, appKey: String, accountId: Int64? = nil, deviceId: String? = nil, sessionId: String? = nil, thirdPartyCredentialId: Int64? = nil, thirdPartyToken: String? = nil, thirdPartySecret: String? = nil, createNewAccount: Bool? = nil, responseFilters: String? = nil, latitude: Double? = nil, longitude: Double? = nil, audienceIdsToAdd: String? = nil, audienceIdsToRemove: String? = nil, referralAccountId: Int64? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/credential/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let sessionId = sessionId { queryItems.append(URLQueryItem(name: "sessionId", value: sessionId)) } 
                if let thirdPartyCredentialId = thirdPartyCredentialId { queryItems.append(URLQueryItem(name: "thirdPartyCredentialId", value: "\(thirdPartyCredentialId)")) } 
                if let thirdPartyToken = thirdPartyToken { queryItems.append(URLQueryItem(name: "thirdPartyToken", value: thirdPartyToken)) } 
                if let thirdPartySecret = thirdPartySecret { queryItems.append(URLQueryItem(name: "thirdPartySecret", value: thirdPartySecret)) } 
                if let createNewAccount = createNewAccount { queryItems.append(URLQueryItem(name: "createNewAccount", value: createNewAccount ? "true" : "false")) } 
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let audienceIdsToAdd = audienceIdsToAdd { queryItems.append(URLQueryItem(name: "audienceIdsToAdd", value: audienceIdsToAdd)) } 
                if let audienceIdsToRemove = audienceIdsToRemove { queryItems.append(URLQueryItem(name: "audienceIdsToRemove", value: audienceIdsToRemove)) } 
                if let referralAccountId = referralAccountId { queryItems.append(URLQueryItem(name: "referralAccountId", value: "\(referralAccountId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Network
    /// - GET /api/{version}/thirdparty/network/get
    /// - Get the details of a third party network. Only the network owners and managers have access to this.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id making the request 
    /// - parameter networkUID: (query) The unique identifier for the third party network defined by Sirqul 
    /// - returns: AnyPublisher<ThirdPartyNetworkResponse, Error> 
    open func getNetwork(version: Double, accountId: Int64, networkUID: String) -> AnyPublisher<ThirdPartyNetworkResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/network/get"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ThirdPartyNetworkResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ThirdPartyNetworkResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Credentials
    /// - GET /api/{version}/thirdparty/credential/search
    /// - Search on a user's linked third party networks.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id of the user 
    /// - parameter keyword: (query) The keyword used to search on the third party name and network string (optional)
    /// - parameter networkUID: (query) The network UID to filter results with (optional)
    /// - parameter descending: (query) The order to return the search results (optional)
    /// - parameter start: (query) The start of the pagination (optional, default to 0)
    /// - parameter limit: (query) The limit of the pagination (optional, default to 20)
    /// - returns: AnyPublisher<[ThirdPartyCredentialResponse], Error> 
    open func searchCredentials(version: Double, accountId: Int64, keyword: String? = nil, networkUID: String? = nil, descending: Bool? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<[ThirdPartyCredentialResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/credential/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let networkUID = networkUID { queryItems.append(URLQueryItem(name: "networkUID", value: networkUID)) } 
                if let descending = descending { queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ThirdPartyCredentialResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ThirdPartyCredentialResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter sortField
    ///
    public enum SearchNetworksSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
        case name = "NAME"
        case description = "DESCRIPTION"
    }

    /// Search Networks
    /// - GET /api/{version}/thirdparty/network/search
    /// - Search on supported third party networks and custom networks from external users.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id making the request 
    /// - parameter sortField: (query) The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME 
    /// - parameter descending: (query) The order to return the search results 
    /// - parameter start: (query) The start of the pagination 
    /// - parameter limit: (query) The limit of the pagination 
    /// - parameter activeOnly: (query) Return only active results 
    /// - parameter keyword: (query) The keyword used to search on the network name and description fields (optional)
    /// - parameter filterBillable: (query) Determines whether to only return applications that the user has access to (optional)
    /// - returns: AnyPublisher<[ThirdPartyNetworkShortResponse], Error> 
    open func searchNetworks(version: Double, accountId: Int64, sortField: SearchNetworksSortField, descending: Bool, start: Int, limit: Int, activeOnly: Bool, keyword: String? = nil, filterBillable: Bool? = nil) -> AnyPublisher<[ThirdPartyNetworkShortResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/network/search"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                if let filterBillable = filterBillable { queryItems.append(URLQueryItem(name: "filterBillable", value: filterBillable ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[ThirdPartyNetworkShortResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([ThirdPartyNetworkShortResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Send MFA Challenge
    /// - POST /api/{version}/thirdparty/credential/mfa/send
    /// - Sends an MFA challenge (SMS or Email) for networks with MFA enabled.
    /// - parameter version: (path)  
    /// - parameter networkUID: (query) the third party network provider that has MFA enabled 
    /// - parameter appKey: (query) the application key 
    /// - parameter thirdPartyToken: (query) the access token to authenticate with (optional)
    /// - parameter thirdPartyCredentialId: (query) optional id of the existing third party credential (optional)
    /// - parameter deviceId: (query) the unique id of the device making the request (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func sendMFAChallenge(version: Double, networkUID: String, appKey: String, thirdPartyToken: String? = nil, thirdPartyCredentialId: Int64? = nil, deviceId: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/credential/mfa/send"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let thirdPartyToken = thirdPartyToken { queryItems.append(URLQueryItem(name: "thirdPartyToken", value: thirdPartyToken)) } 
                if let thirdPartyCredentialId = thirdPartyCredentialId { queryItems.append(URLQueryItem(name: "thirdPartyCredentialId", value: "\(thirdPartyCredentialId)")) } 
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Credential
    /// - POST /api/{version}/thirdparty/credential/update
    /// - Updates a third-party login for an account.
    /// - parameter version: (path)  
    /// - parameter networkUID: (query) the access provider to authenticate against 
    /// - parameter thirdPartyId: (query) the third party user account id 
    /// - parameter appKey: (query) the application key 
    /// - parameter deviceId: (query) the unique id of the device making the request (optional)
    /// - parameter thirdPartyName: (query) the third party user name (optional)
    /// - parameter thirdPartyToken: (query) the access token to authenticate with (ex: username or fb token) (optional)
    /// - parameter responseFilters: (query) this determines how much of the profile should be returned, see ProfileFilters (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter thirdPartyRefreshToken: (query) optional refresh token for the third party (optional)
    /// - returns: AnyPublisher<ProfileResponse, Error> 
    open func updateCredential(version: Double, networkUID: String, thirdPartyId: String, appKey: String, deviceId: String? = nil, thirdPartyName: String? = nil, thirdPartyToken: String? = nil, responseFilters: String? = nil, metaData: String? = nil, thirdPartyRefreshToken: String? = nil) -> AnyPublisher<ProfileResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/credential/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                queryItems.append(URLQueryItem(name: "thirdPartyId", value: thirdPartyId))
                if let thirdPartyName = thirdPartyName { queryItems.append(URLQueryItem(name: "thirdPartyName", value: thirdPartyName)) } 
                if let thirdPartyToken = thirdPartyToken { queryItems.append(URLQueryItem(name: "thirdPartyToken", value: thirdPartyToken)) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                if let responseFilters = responseFilters { queryItems.append(URLQueryItem(name: "responseFilters", value: responseFilters)) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let thirdPartyRefreshToken = thirdPartyRefreshToken { queryItems.append(URLQueryItem(name: "thirdPartyRefreshToken", value: thirdPartyRefreshToken)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ProfileResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ProfileResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Network
    /// - POST /api/{version}/thirdparty/network/update
    /// - Updates a custom third party network. Only the network owners and managers have access to this.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) The account id making the request 
    /// - parameter networkUID: (query) The unique identifier for the third party network defined by Sirqul 
    /// - parameter name: (query) The name of the network (optional)
    /// - parameter description: (query) The description of the network (optional)
    /// - parameter enableIntrospection: (query) Whether the network uses introspection calls (optional)
    /// - parameter introspectionMethod: (query) HTTP method to use for introspection calls (e.g., GET, POST) (optional)
    /// - parameter introspectionURL: (query) The HTTP URL of the introspection call (optional)
    /// - parameter introspectionParams: (query) The parameters of the introspection call (optional)
    /// - parameter requiredRootField: (query) Required response params (optional)
    /// - parameter enableMFA: (query) Whether this network uses MFA (optional)
    /// - parameter sizeMFA: (query) Size of the MFA token (optional)
    /// - parameter shelfLifeMFA: (query) Shelf life (seconds) of the MFA token (optional)
    /// - parameter oauthTokenURL: (query) OAuth token endpoint URL (optional)
    /// - parameter oauthPrivateKey: (query) OAuth private key file (multipart) (optional)
    /// - parameter oauthPublicKey: (query) OAuth public key file (multipart) (optional)
    /// - parameter oauthClientId: (query) OAuth client id (optional)
    /// - parameter oauthSecretKey: (query) OAuth secret key (optional)
    /// - parameter body: (body)  (optional)
    /// - returns: AnyPublisher<ThirdPartyNetworkResponse, Error> 
    open func updateNetwork(version: Double, accountId: Int64, networkUID: String, name: String? = nil, description: String? = nil, enableIntrospection: Bool? = nil, introspectionMethod: String? = nil, introspectionURL: String? = nil, introspectionParams: String? = nil, requiredRootField: String? = nil, enableMFA: Bool? = nil, sizeMFA: Int? = nil, shelfLifeMFA: Int? = nil, oauthTokenURL: String? = nil, oauthPrivateKey: Data? = nil, oauthPublicKey: Data? = nil, oauthClientId: String? = nil, oauthSecretKey: String? = nil, body: String? = nil) -> AnyPublisher<ThirdPartyNetworkResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/thirdparty/network/update"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "networkUID", value: networkUID))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let description = description { queryItems.append(URLQueryItem(name: "description", value: description)) } 
                if let enableIntrospection = enableIntrospection { queryItems.append(URLQueryItem(name: "enableIntrospection", value: enableIntrospection ? "true" : "false")) } 
                if let introspectionMethod = introspectionMethod { queryItems.append(URLQueryItem(name: "introspectionMethod", value: introspectionMethod)) } 
                if let introspectionURL = introspectionURL { queryItems.append(URLQueryItem(name: "introspectionURL", value: introspectionURL)) } 
                if let introspectionParams = introspectionParams { queryItems.append(URLQueryItem(name: "introspectionParams", value: introspectionParams)) } 
                if let requiredRootField = requiredRootField { queryItems.append(URLQueryItem(name: "requiredRootField", value: requiredRootField)) } 
                if let enableMFA = enableMFA { queryItems.append(URLQueryItem(name: "enableMFA", value: enableMFA ? "true" : "false")) } 
                if let sizeMFA = sizeMFA { queryItems.append(URLQueryItem(name: "sizeMFA", value: "\(sizeMFA)")) } 
                if let shelfLifeMFA = shelfLifeMFA { queryItems.append(URLQueryItem(name: "shelfLifeMFA", value: "\(shelfLifeMFA)")) } 
                if let oauthTokenURL = oauthTokenURL { queryItems.append(URLQueryItem(name: "oauthTokenURL", value: oauthTokenURL)) } 
                if let oauthPrivateKey = oauthPrivateKey { queryItems.append(URLQueryItem(name: "oauthPrivateKey", value: )) } 
                if let oauthPublicKey = oauthPublicKey { queryItems.append(URLQueryItem(name: "oauthPublicKey", value: )) } 
                if let oauthClientId = oauthClientId { queryItems.append(URLQueryItem(name: "oauthClientId", value: oauthClientId)) } 
                if let oauthSecretKey = oauthSecretKey { queryItems.append(URLQueryItem(name: "oauthSecretKey", value: oauthSecretKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                request.httpBody = try self.encoder.encode(body)
                request.setValue("application/json", forHTTPHeaderField: "Content-Type")
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<ThirdPartyNetworkResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(ThirdPartyNetworkResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
