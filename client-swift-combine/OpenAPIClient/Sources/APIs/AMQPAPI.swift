//
// AMQPAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class AMQPAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Create Consumer
    /// - POST /queue/consumer/create
    /// - Create a connection to an existing amqp queue and register as a consumer.
    /// - parameter appKey: (query) The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied. 
    /// - parameter name: (query) The name of the queue to connect to 
    /// - parameter hostname: (query) The hostname of the server the queue is hosted on 
    /// - parameter username: (query) The username to access the server the queue is hosted on 
    /// - parameter password: (query) The password to access the queue to connect to 
    /// - parameter dataMapping: (query) The data mapping information in the format of AMQPRequest 
    /// - parameter deviceId: (query) The client deviceID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter port: (query) The port of the server the queue is hosted on (optional, default to 5672)
    /// - parameter virtualHost: (query) The virtual host defined on the server the queue is associated on (optional)
    /// - parameter exchanger: (query) The exchanger of the queue to connect to (optional)
    /// - parameter exchangerType: (query) The exchanger type of the queue to connect to (optional)
    /// - parameter workers: (query) The number of workers to generate  (optional, default to 1)
    /// - parameter useSSL: (query) Use SSL (optional)
    /// - returns: AnyPublisher<QueueResponse, Error> 
    open func consumerCreate(appKey: String, name: String, hostname: String, username: String, password: String, dataMapping: String, deviceId: String? = nil, accountId: Int64? = nil, port: Int? = nil, virtualHost: String? = nil, exchanger: String? = nil, exchangerType: String? = nil, workers: Int? = nil, useSSL: Bool? = nil) -> AnyPublisher<QueueResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/consumer/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "name", value: name))
                queryItems.append(URLQueryItem(name: "hostname", value: hostname))
                if let port = port { queryItems.append(URLQueryItem(name: "port", value: "\(port)")) } 
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                if let virtualHost = virtualHost { queryItems.append(URLQueryItem(name: "virtualHost", value: virtualHost)) } 
                if let exchanger = exchanger { queryItems.append(URLQueryItem(name: "exchanger", value: exchanger)) } 
                if let exchangerType = exchangerType { queryItems.append(URLQueryItem(name: "exchangerType", value: exchangerType)) } 
                if let workers = workers { queryItems.append(URLQueryItem(name: "workers", value: "\(workers)")) } 
                queryItems.append(URLQueryItem(name: "dataMapping", value: dataMapping))
                if let useSSL = useSSL { queryItems.append(URLQueryItem(name: "useSSL", value: useSSL ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QueueResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QueueResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Consumer
    /// - POST /queue/consumer/update
    /// - Update an existing amqp queue's data mapping.
    /// - parameter appKey: (query) The application key to use when creating an analytic or service request. The account needs to have permissions to the applicaton or it will be denied. 
    /// - parameter queueId: (query) The queue to update 
    /// - parameter dataMapping: (query) The data mapping information in the format of AMQPRequest 
    /// - parameter deviceId: (query) The client deviceID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter useSSL: (query) Use SSL (optional)
    /// - returns: AnyPublisher<QueueResponse, Error> 
    open func consumerUpdate(appKey: String, queueId: Int64, dataMapping: String, deviceId: String? = nil, accountId: Int64? = nil, useSSL: Bool? = nil) -> AnyPublisher<QueueResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/consumer/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "queueId", value: "\(queueId)"))
                queryItems.append(URLQueryItem(name: "dataMapping", value: dataMapping))
                if let useSSL = useSSL { queryItems.append(URLQueryItem(name: "useSSL", value: useSSL ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QueueResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QueueResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Create Queue
    /// - POST /queue/create
    /// - Create a basic AMQP queue. If the username and password and virtual host is not sepcified, the queue will be created on the virtual host assigned to the application.
    /// - parameter appKey: (query) The application key unique to each application. 
    /// - parameter name: (query) The name of the queue to create 
    /// - parameter deviceId: (query) The client deviceID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter workers: (query) The number of workers to generate  (optional, default to 1)
    /// - parameter analyticTags: (query) If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
    /// - parameter hostname: (query) The hostname of the server the queue is hosted on (optional)
    /// - parameter port: (query) The port of the server the queue is hosted on (optional)
    /// - parameter username: (query) The username to access the server that the queue is on (optional)
    /// - parameter password: (query) The password to access the queue to connect to (optional)
    /// - parameter virtualHost: (query) The virtual host defined on the server to queue (optional)
    /// - parameter useSSL: (query) Use SSL (optional)
    /// - returns: AnyPublisher<QueueResponse, Error> 
    open func queueCreate(appKey: String, name: String, deviceId: String? = nil, accountId: Int64? = nil, workers: Int? = nil, analyticTags: String? = nil, hostname: String? = nil, port: Int? = nil, username: String? = nil, password: String? = nil, virtualHost: String? = nil, useSSL: Bool? = nil) -> AnyPublisher<QueueResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "appKey", value: appKey))
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let workers = workers { queryItems.append(URLQueryItem(name: "workers", value: "\(workers)")) } 
                if let analyticTags = analyticTags { queryItems.append(URLQueryItem(name: "analyticTags", value: analyticTags)) } 
                if let hostname = hostname { queryItems.append(URLQueryItem(name: "hostname", value: hostname)) } 
                if let port = port { queryItems.append(URLQueryItem(name: "port", value: "\(port)")) } 
                if let username = username { queryItems.append(URLQueryItem(name: "username", value: username)) } 
                if let password = password { queryItems.append(URLQueryItem(name: "password", value: password)) } 
                if let virtualHost = virtualHost { queryItems.append(URLQueryItem(name: "virtualHost", value: virtualHost)) } 
                if let useSSL = useSSL { queryItems.append(URLQueryItem(name: "useSSL", value: useSSL ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QueueResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QueueResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Queue
    /// - POST /queue/delete
    /// - Delete the stored queue record and close any active connections to the AMQP servers.
    /// - parameter queueId: (query) The id of the queue to find 
    /// - parameter deviceId: (query) The client device ID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func queueDelete(queueId: Int64, deviceId: String? = nil, accountId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "queueId", value: "\(queueId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Queue
    /// - GET /queue/get
    /// - Get the stored queue record. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
    /// - parameter deviceId: (query) The client device ID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter queueId: (query) The id of the queue to find (optional)
    /// - parameter appKey: (query) The application key the queue was assigned to (optional)
    /// - parameter name: (query) The name of the queue to find (optional)
    /// - parameter hostname: (query) The hostname of the queue to find (optional)
    /// - parameter virtualHost: (query) The virtual host of the queue to find (optional)
    /// - returns: AnyPublisher<QueueResponse, Error> 
    open func queueGet(deviceId: String? = nil, accountId: Int64? = nil, queueId: Int64? = nil, appKey: String? = nil, name: String? = nil, hostname: String? = nil, virtualHost: String? = nil) -> AnyPublisher<QueueResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let queueId = queueId { queryItems.append(URLQueryItem(name: "queueId", value: "\(queueId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let hostname = hostname { queryItems.append(URLQueryItem(name: "hostname", value: hostname)) } 
                if let virtualHost = virtualHost { queryItems.append(URLQueryItem(name: "virtualHost", value: virtualHost)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QueueResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QueueResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Publish Queue
    /// - POST /queue/publish
    /// - Publish a message to a stored queue. Must supply the queueId, or the name and hostname and virtualHost, or the name and appKey to find the record.
    /// - parameter message: (query) The payload to send to the queue 
    /// - parameter queueId: (query) The id of the queue to publish to (optional)
    /// - parameter appKey: (query) The application key the queue was assigned to (optional)
    /// - parameter name: (query) The name of the queue to publish to or the analytic tag to handle if the analytic param is true (optional)
    /// - parameter hostname: (query) The hostname of the server the queue is hosted on (optional)
    /// - parameter virtualHost: (query) The virtual host defined on the server to queue (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func queuePublish(message: String, queueId: Int64? = nil, appKey: String? = nil, name: String? = nil, hostname: String? = nil, virtualHost: String? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/publish"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let queueId = queueId { queryItems.append(URLQueryItem(name: "queueId", value: "\(queueId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let hostname = hostname { queryItems.append(URLQueryItem(name: "hostname", value: hostname)) } 
                if let virtualHost = virtualHost { queryItems.append(URLQueryItem(name: "virtualHost", value: virtualHost)) } 
                queryItems.append(URLQueryItem(name: "message", value: message))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Queue
    /// - GET /queue/search
    /// - Get the queues setup for the BillableEntity's applications.
    /// - parameter queueId: (query) The id of the queue to find (optional)
    /// - parameter deviceId: (query) The client device ID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter name: (query) The name of the queue to find (optional)
    /// - parameter start: (query) Start of the index (optional, default to 0)
    /// - parameter limit: (query) Limit of the index (optional, default to 10)
    /// - returns: AnyPublisher<QueueResponse, Error> 
    open func queueSearch(queueId: Int64? = nil, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, start: Int? = nil, limit: Int? = nil) -> AnyPublisher<QueueResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let queueId = queueId { queryItems.append(URLQueryItem(name: "queueId", value: "\(queueId)")) } 
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QueueResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QueueResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Update Queue
    /// - POST /queue/update
    /// - Update the basic AMQP queue.
    /// - parameter queueId: (query) The id of the queue to update 
    /// - parameter deviceId: (query) The client deviceID (optional)
    /// - parameter accountId: (query) The logged in user ID (optional)
    /// - parameter appKey: (query) The application key unique to each application. (optional)
    /// - parameter workers: (query) The number of workers to generate (optional)
    /// - parameter analyticTags: (query) If provided the analytic processing will publsih to this queue instead of the default one for the provided list of tags (optional)
    /// - parameter hostname: (query) The hostname of the server the queue is hosted on (optional)
    /// - parameter port: (query) The port of the server the queue is hosted on (optional)
    /// - parameter username: (query) The username to access the server that the queue is on (optional)
    /// - parameter password: (query) The password to access the queue to connect to (optional)
    /// - parameter virtualHost: (query) The virtual host defined on the server to queue (optional)
    /// - parameter useSSL: (query) the SSL to use (optional)
    /// - returns: AnyPublisher<QueueResponse, Error> 
    open func queueUpdate(queueId: Int64, deviceId: String? = nil, accountId: Int64? = nil, appKey: String? = nil, workers: Int? = nil, analyticTags: String? = nil, hostname: String? = nil, port: Int? = nil, username: String? = nil, password: String? = nil, virtualHost: String? = nil, useSSL: Bool? = nil) -> AnyPublisher<QueueResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/queue/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "queueId", value: "\(queueId)"))
                if let workers = workers { queryItems.append(URLQueryItem(name: "workers", value: "\(workers)")) } 
                if let analyticTags = analyticTags { queryItems.append(URLQueryItem(name: "analyticTags", value: analyticTags)) } 
                if let hostname = hostname { queryItems.append(URLQueryItem(name: "hostname", value: hostname)) } 
                if let port = port { queryItems.append(URLQueryItem(name: "port", value: "\(port)")) } 
                if let username = username { queryItems.append(URLQueryItem(name: "username", value: username)) } 
                if let password = password { queryItems.append(URLQueryItem(name: "password", value: password)) } 
                if let virtualHost = virtualHost { queryItems.append(URLQueryItem(name: "virtualHost", value: virtualHost)) } 
                if let useSSL = useSSL { queryItems.append(URLQueryItem(name: "useSSL", value: useSSL ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<QueueResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(QueueResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
