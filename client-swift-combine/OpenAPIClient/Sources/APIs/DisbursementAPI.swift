//
// DisbursementAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class DisbursementAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }


    /// Check Disbursements
    /// - GET /disbursement/check
    /// - Checks the status of a captured disbrusement to see if it has been settled.
    /// - parameter disbursementId: (query) the ID of the disbursement being checked on 
    /// - returns: AnyPublisher<DisbursementResponse, Error> 
    open func checkDisbursements(disbursementId: Int64) -> AnyPublisher<DisbursementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/disbursement/check"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "disbursementId", value: "\(disbursementId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DisbursementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(DisbursementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter provider
    ///
    public enum CreateDisbursementProvider: String, Codable, CaseIterable {
        case authorizeNet = "AUTHORIZE_NET"
        case amazonFps = "AMAZON_FPS"
        case billCom = "BILL_COM"
    }

    /// Create Disbursement
    /// - POST /disbursement/create
    /// - Creates a Disbursement for sending money to a retailer
    /// - parameter accountId: (query) the ID of the logging in user (must be an EXECUTIVE account) 
    /// - parameter receiverAccountId: (query) the ID of the account receiving the disbursement 
    /// - parameter originalSenderAccountId: (query) the ID of the original sender account 
    /// - parameter amount: (query) the dollar amount of the disbursement 
    /// - parameter provider: (query) the provider (e.g. Authorize.net, Bill.com, etc.) 
    /// - parameter scheduledDate: (query) the date that the disbursement is scheduled to go out to the payment provider (optional)
    /// - parameter title: (query) a title given for the disbursement (optional)
    /// - parameter comment: (query) a comment that could be made for a disbursement (optional)
    /// - parameter externalId: (query) external ID, which can be used as a way to reference the disbursement (optional)
    /// - parameter introspectionParams: (query) This is for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
    /// - returns: AnyPublisher<DisbursementResponse, Error> 
    open func createDisbursement(accountId: Int64, receiverAccountId: Int64, originalSenderAccountId: Int64, amount: Double, provider: CreateDisbursementProvider, scheduledDate: Int64? = nil, title: String? = nil, comment: String? = nil, externalId: String? = nil, introspectionParams: String? = nil) -> AnyPublisher<DisbursementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/disbursement/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "receiverAccountId", value: "\(receiverAccountId)"))
                queryItems.append(URLQueryItem(name: "originalSenderAccountId", value: "\(originalSenderAccountId)"))
                queryItems.append(URLQueryItem(name: "amount", value: "\(amount)"))
                queryItems.append(URLQueryItem(name: "provider", value: provider.rawValue))
                if let scheduledDate = scheduledDate { queryItems.append(URLQueryItem(name: "scheduledDate", value: "\(scheduledDate)")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let comment = comment { queryItems.append(URLQueryItem(name: "comment", value: comment)) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let introspectionParams = introspectionParams { queryItems.append(URLQueryItem(name: "introspectionParams", value: introspectionParams)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DisbursementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(DisbursementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Disbursement
    /// - GET /disbursement/get
    /// - Get Disbursement details
    /// - parameter accountId: (query) The logged in user. 
    /// - parameter disbursementId: (query) the id of the disbursement 
    /// - returns: AnyPublisher<DisbursementResponse, Error> 
    open func getDisbursement(accountId: Int64, disbursementId: Int64) -> AnyPublisher<DisbursementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/disbursement/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "disbursementId", value: "\(disbursementId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DisbursementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(DisbursementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Disbursements
    /// - GET /disbursement/search
    /// - Search Disbursements
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter receiverAccountId: (query) filter results by the id of the account receiving the disbursement (optional)
    /// - parameter statuses: (query) comma separated list of status values to search for, possilbe values include: NEW, APPROVED, VALIDATING, ERROR, AUTHORIZED, CAPTURED, SETTLED (optional)
    /// - parameter providers: (query) comma separated list of payment providers to search for, possbile values include: AUTHORIZE_NET, AMAZON_FPS, BILL_COM (optional)
    /// - parameter beforeDate: (query) the date for searching disbursements before it has been processed (optional)
    /// - parameter afterDate: (query) the date for searching disbursements before it has been processed (optional)
    /// - parameter start: (query) the start index for pagination (optional, default to 0)
    /// - parameter limit: (query) the limit per result set for pagination (optional, default to 20)
    /// - parameter activeOnly: (query) search on disbursements that are active only (optional, default to false)
    /// - parameter externalId: (query) search results by this external ID (that can be used to reference the disbursement) (optional)
    /// - returns: AnyPublisher<[DisbursementResponse], Error> 
    open func searchDisbursements(accountId: Int64, receiverAccountId: Int64? = nil, statuses: String? = nil, providers: String? = nil, beforeDate: Int64? = nil, afterDate: Int64? = nil, start: Int? = nil, limit: Int? = nil, activeOnly: Bool? = nil, externalId: String? = nil) -> AnyPublisher<[DisbursementResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/disbursement/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                if let receiverAccountId = receiverAccountId { queryItems.append(URLQueryItem(name: "receiverAccountId", value: "\(receiverAccountId)")) } 
                if let statuses = statuses { queryItems.append(URLQueryItem(name: "statuses", value: statuses)) } 
                if let providers = providers { queryItems.append(URLQueryItem(name: "providers", value: providers)) } 
                if let beforeDate = beforeDate { queryItems.append(URLQueryItem(name: "beforeDate", value: "\(beforeDate)")) } 
                if let afterDate = afterDate { queryItems.append(URLQueryItem(name: "afterDate", value: "\(afterDate)")) } 
                if let start = start { queryItems.append(URLQueryItem(name: "start", value: "\(start)")) } 
                if let limit = limit { queryItems.append(URLQueryItem(name: "limit", value: "\(limit)")) } 
                if let activeOnly = activeOnly { queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false")) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[DisbursementResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([DisbursementResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter provider
    ///
    public enum UpdateDisbursementProvider: String, Codable, CaseIterable {
        case authorizeNet = "AUTHORIZE_NET"
        case amazonFps = "AMAZON_FPS"
        case billCom = "BILL_COM"
    }

    /// Update Disbursement
    /// - POST /disbursement/update
    /// - Update Disbursement
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter disbursementId: (query) the id of the disbursement being updated 
    /// - parameter amount: (query) the disbursement dollar amount being updated (optional)
    /// - parameter provider: (query) the payments and/or billing provider (e.g. Authorize.net, Bill.com, etc.) (optional)
    /// - parameter scheduledDate: (query) the date that the disbursement is scheduled to go out to the payment provider (optional)
    /// - parameter title: (query) the title given to the disbursement (optional)
    /// - parameter comment: (query) a comment that can be made on a disbursement (optional)
    /// - parameter externalId: (query) an external ID that can be used to reference the disbursement (optional)
    /// - parameter retry: (query) determines whether to try sending the disbursement again in the case of a previous failure (optional)
    /// - parameter introspectionParams: (query) for specifying parameters to make an http callback request for validating that the disbursement is valid (optional)
    /// - returns: AnyPublisher<DisbursementResponse, Error> 
    open func updateDisbursement(accountId: Int64, disbursementId: Int64, amount: Double? = nil, provider: UpdateDisbursementProvider? = nil, scheduledDate: Int64? = nil, title: String? = nil, comment: String? = nil, externalId: String? = nil, retry: Bool? = nil, introspectionParams: String? = nil) -> AnyPublisher<DisbursementResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/disbursement/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "disbursementId", value: "\(disbursementId)"))
                if let amount = amount { queryItems.append(URLQueryItem(name: "amount", value: "\(amount)")) } 
                if let provider = provider { queryItems.append(URLQueryItem(name: "provider", value: provider.rawValue)) } 
                if let scheduledDate = scheduledDate { queryItems.append(URLQueryItem(name: "scheduledDate", value: "\(scheduledDate)")) } 
                if let title = title { queryItems.append(URLQueryItem(name: "title", value: title)) } 
                if let comment = comment { queryItems.append(URLQueryItem(name: "comment", value: comment)) } 
                if let externalId = externalId { queryItems.append(URLQueryItem(name: "externalId", value: externalId)) } 
                if let retry = retry { queryItems.append(URLQueryItem(name: "retry", value: retry ? "true" : "false")) } 
                if let introspectionParams = introspectionParams { queryItems.append(URLQueryItem(name: "introspectionParams", value: introspectionParams)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<DisbursementResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(DisbursementResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
