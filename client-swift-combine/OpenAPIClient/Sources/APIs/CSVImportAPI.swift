//
// CSVImportAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class CSVImportAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "http://localhost")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter responseGroup
    ///
    public enum GetStatusCSVResponseGroup: String, Codable, CaseIterable {
        case summary = "SUMMARY"
        case details = "DETAILS"
        case errors = "ERRORS"
        case all = "ALL"
    }

    /// Detail Status
    /// - GET /api/{version}/csvimport/batch/status/details
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the logged in user 
    /// - parameter batchId: (query) the id of the batch 
    /// - parameter responseGroup: (query) The group of categories to return: SUMMARY, DETAILS, ERRORS, OR ALL 
    /// - parameter start: (query) the start of the pagination 
    /// - parameter limit: (query) the limit of the pagination 
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func getStatusCSV(version: Double, accountId: Int64, batchId: Int64, responseGroup: GetStatusCSVResponseGroup, start: Int64, limit: Int64) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/csvimport/batch/status/details"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "batchId", value: "\(batchId)"))
                queryItems.append(URLQueryItem(name: "responseGroup", value: responseGroup.rawValue))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Search Status
    /// - GET /api/{version}/csvimport/batch/list
    /// - Retrieves batches for a user.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the account 
    /// - parameter start: (query) the start of the pagination 
    /// - parameter limit: (query) the limit of the pagination 
    /// - returns: AnyPublisher<CsvImportResponse, Error> 
    open func listStatusCSV(version: Double, accountId: Int64, start: Int, limit: Int) -> AnyPublisher<CsvImportResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/csvimport/batch/list"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CsvImportResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CsvImportResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Batch Status
    /// - GET /api/{version}/csvimport/batch/status
    /// - Checks status of batch upload.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the account 
    /// - parameter batchId: (query) the id of the batch to get its status 
    /// - returns: AnyPublisher<CsvImportResponse, Error> 
    open func statusCSV(version: Double, accountId: Int64, batchId: Int64) -> AnyPublisher<CsvImportResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/csvimport/batch/status"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "batchId", value: "\(batchId)"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CsvImportResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CsvImportResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter uploadType
    ///
    public enum UploadCSVUploadType: String, Codable, CaseIterable {
        case offers = "OFFERS"
        case retailers = "RETAILERS"
        case retailerlocations = "RETAILERLOCATIONS"
        case categories = "CATEGORIES"
        case filters = "FILTERS"
    }
    ///
    /// Enum for parameter fileFormat
    ///
    public enum UploadCSVFileFormat: String, Codable, CaseIterable {
        case excel = "EXCEL"
        case mysql = "MYSQL"
        case rfc4180 = "RFC4180"
        case tdf = "TDF"
    }

    /// Upload CSV
    /// - POST /api/{version}/csvimport/upload
    /// - Uploads a CSV import file.
    /// - parameter version: (path)  
    /// - parameter accountId: (query) the id of the account 
    /// - parameter uploadType: (query) the upload type: OFFERS, RETAILERS, RETAILERLOCATIONS, CATEGORIES, OR FILTERS 
    /// - parameter importFile: (query) the import file to reference 
    /// - parameter fileFormat: (query) the format of the file 
    /// - parameter appKey: (query) the application key (optional)
    /// - returns: AnyPublisher<CsvImportResponse, Error> 
    open func uploadCSV(version: Double, accountId: Int64, uploadType: UploadCSVUploadType, importFile: Data, fileFormat: UploadCSVFileFormat, appKey: String? = nil) -> AnyPublisher<CsvImportResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                var localVarPath = "/api/{version}/csvimport/upload"
                localVarPath = localVarPath.replacingOccurrences(of: "{version}", with: "\(version)")
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)"))
                queryItems.append(URLQueryItem(name: "uploadType", value: uploadType.rawValue))
                queryItems.append(URLQueryItem(name: "importFile", value: ))
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                queryItems.append(URLQueryItem(name: "fileFormat", value: fileFormat.rawValue))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<CsvImportResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(CsvImportResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
