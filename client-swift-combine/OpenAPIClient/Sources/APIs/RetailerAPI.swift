//
// RetailerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech

import Foundation
import Combine
import OpenAPITransport


open class RetailerAPI {
    private let transport: OpenAPITransport
    public var encoder: JSONEncoder = {
        let encoder = JSONEncoder()
        encoder.dateEncodingStrategy = .formatted(OpenISO8601DateFormatter())
        return encoder
    }()
    public var decoder: JSONDecoder = {
        let decoder = JSONDecoder()
        decoder.dateDecodingStrategy = .formatted(OpenISO8601DateFormatter())
        return decoder
    }()
    public var baseURL = URL(string: "https://dev.sirqul.com/api/3.18")

    public init(_ transport: OpenAPITransport) {
        self.transport = transport
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum CreateRetailerVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }
    ///
    /// Enum for parameter responseFormat
    ///
    public enum CreateRetailerResponseFormat: String, Codable, CaseIterable {
        case html = "HTML"
        case xml = "XML"
        case json = "JSON"
        case csv = "CSV"
    }

    /// Create Retailer
    /// - POST /retailer/create
    /// - Create a retailer record. A billable entity must be created first before a retailer record can be made.
    /// - parameter name: (query) The name of the retailer 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter streetAddress: (query) The street address of the retailer (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the retailer (optional)
    /// - parameter state: (query) The state of the retailer (optional)
    /// - parameter postalCode: (query) The postal code of the retailer (optional)
    /// - parameter country: (query) the country of the retailer (optional)
    /// - parameter businessPhone: (query) The business phone number of the retailer (optional)
    /// - parameter businessPhoneExt: (query) The business phone extension of the retailer (optional)
    /// - parameter website: (query) The website of the retailer (optional)
    /// - parameter email: (query) The email of the retailer (optional)
    /// - parameter facebookUrl: (query) The facebook URL of the retailer (optional)
    /// - parameter twitterUrl: (query) The twitter URL of the retailer (optional)
    /// - parameter logo: (query) The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
    /// - parameter logoAssetId: (query) The retailer logo asset id (optional)
    /// - parameter picture1: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture1AssetId: (query) An asset id (optional)
    /// - parameter picture2: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture2AssetId: (query) An asset id (optional)
    /// - parameter categoryIds: (query) Comma separated list of category IDs used to filter retailers by categories (optional)
    /// - parameter categoryIdsToAdd: (query) Comma separated list of category IDs to add to the retailer (optional)
    /// - parameter categoryIdsToRemove: (query) Comma separated list of category IDs to remove from the retailer (optional)
    /// - parameter filterIds: (query) Comma separated list of filter IDs used to filter retailers (optional)
    /// - parameter latitude: (query) the latitude of the retailer (optional)
    /// - parameter longitude: (query) the longitude of the retailer (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter searchTags: (query) External custom search keywords (optional)
    /// - parameter retailerType: (query) External custom type identifier (optional)
    /// - parameter visibility: (query)  (optional)
    /// - parameter createDefaultLocation: (query) Determines whether to create a default location using the retailer information (optional)
    /// - parameter responseFormat: (query) The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
    /// - returns: AnyPublisher<RetailerFullResponse, Error> 
    open func createRetailer(name: String, deviceId: String? = nil, accountId: Int64? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, postalCode: String? = nil, country: String? = nil, businessPhone: String? = nil, businessPhoneExt: String? = nil, website: String? = nil, email: String? = nil, facebookUrl: String? = nil, twitterUrl: String? = nil, logo: Data? = nil, logoAssetId: Int64? = nil, picture1: Data? = nil, picture1AssetId: Int64? = nil, picture2: Data? = nil, picture2AssetId: Int64? = nil, categoryIds: String? = nil, categoryIdsToAdd: String? = nil, categoryIdsToRemove: String? = nil, filterIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil, metaData: String? = nil, searchTags: String? = nil, retailerType: String? = nil, visibility: CreateRetailerVisibility? = nil, createDefaultLocation: Bool? = nil, responseFormat: CreateRetailerResponseFormat? = nil) -> AnyPublisher<RetailerFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/create"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "name", value: name))
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let businessPhoneExt = businessPhoneExt { queryItems.append(URLQueryItem(name: "businessPhoneExt", value: businessPhoneExt)) } 
                if let website = website { queryItems.append(URLQueryItem(name: "website", value: website)) } 
                if let email = email { queryItems.append(URLQueryItem(name: "email", value: email)) } 
                if let facebookUrl = facebookUrl { queryItems.append(URLQueryItem(name: "facebookUrl", value: facebookUrl)) } 
                if let twitterUrl = twitterUrl { queryItems.append(URLQueryItem(name: "twitterUrl", value: twitterUrl)) } 
                if let logo = logo { queryItems.append(URLQueryItem(name: "logo", value: )) } 
                if let logoAssetId = logoAssetId { queryItems.append(URLQueryItem(name: "logoAssetId", value: "\(logoAssetId)")) } 
                if let picture1 = picture1 { queryItems.append(URLQueryItem(name: "picture1", value: )) } 
                if let picture1AssetId = picture1AssetId { queryItems.append(URLQueryItem(name: "picture1AssetId", value: "\(picture1AssetId)")) } 
                if let picture2 = picture2 { queryItems.append(URLQueryItem(name: "picture2", value: )) } 
                if let picture2AssetId = picture2AssetId { queryItems.append(URLQueryItem(name: "picture2AssetId", value: "\(picture2AssetId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let categoryIdsToAdd = categoryIdsToAdd { queryItems.append(URLQueryItem(name: "categoryIdsToAdd", value: categoryIdsToAdd)) } 
                if let categoryIdsToRemove = categoryIdsToRemove { queryItems.append(URLQueryItem(name: "categoryIdsToRemove", value: categoryIdsToRemove)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let retailerType = retailerType { queryItems.append(URLQueryItem(name: "retailerType", value: retailerType)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let createDefaultLocation = createDefaultLocation { queryItems.append(URLQueryItem(name: "createDefaultLocation", value: createDefaultLocation ? "true" : "false")) } 
                if let responseFormat = responseFormat { queryItems.append(URLQueryItem(name: "responseFormat", value: responseFormat.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Delete Retailer
    /// - POST /retailer/delete
    /// - Set the deleted timestamp to current time.
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account used to perform the delete, must have rights to edit the retailer. (optional)
    /// - parameter retailerId: (query) The ID of the retailer to be deleted (optional)
    /// - returns: AnyPublisher<SirqulResponse, Error> 
    open func deleteRetailer(deviceId: String? = nil, accountId: Int64? = nil, retailerId: Int64? = nil) -> AnyPublisher<SirqulResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/delete"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let retailerId = retailerId { queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<SirqulResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(SirqulResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Get Retailer
    /// - GET /retailer/get
    /// - Gets a retailer. Only the owner and the employees of a retailer have access to view its information.
    /// - parameter retailerId: (query) the ID of the retailer 
    /// - parameter deviceId: (query) the device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) the account id of the user (deviceId or accountId required) (optional)
    /// - parameter includeCounts: (query) Determines whether to include counts in the response (default true) (optional)
    /// - returns: AnyPublisher<RetailerFullResponse, Error> 
    open func getRetailer(retailerId: Int64, deviceId: String? = nil, accountId: Int64? = nil, includeCounts: Bool? = nil) -> AnyPublisher<RetailerFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/get"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)"))
                if let includeCounts = includeCounts { queryItems.append(URLQueryItem(name: "includeCounts", value: includeCounts ? "true" : "false")) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum GetRetailersVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }
    ///
    /// Enum for parameter sortField
    ///
    public enum GetRetailersSortField: String, Codable, CaseIterable {
        case id = "ID"
        case created = "CREATED"
        case updated = "UPDATED"
        case deleted = "DELETED"
        case searchTags = "SEARCH_TAGS"
        case active = "ACTIVE"
        case billableEntityId = "BILLABLE_ENTITY_ID"
        case billableEntityName = "BILLABLE_ENTITY_NAME"
        case responsibleDisplay = "RESPONSIBLE_DISPLAY"
        case addressStreet = "ADDRESS_STREET"
        case addressCity = "ADDRESS_CITY"
        case addressState = "ADDRESS_STATE"
        case addressPostalCode = "ADDRESS_POSTAL_CODE"
        case addressCountry = "ADDRESS_COUNTRY"
        case filters = "FILTERS"
        case categories = "CATEGORIES"
        case visibility = "VISIBILITY"
        case name = "NAME"
    }

    /// Search Retailers
    /// - GET /retailer/search
    /// - earches on retailers that the account has access to.
    /// - parameter visibility: (query)  
    /// - parameter sortField: (query) The column to sort the search on 
    /// - parameter descending: (query) The order to return the search results 
    /// - parameter start: (query) The record to begin the return set on 
    /// - parameter limit: (query) The number of records to return 
    /// - parameter activeOnly: (query) Return only active results 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter q: (query) This parameter is deprecated. (optional)
    /// - parameter keyword: (query) The keyword used to search (optional)
    /// - parameter categoryIds: (query) the categories that the retailer is associated with (optional)
    /// - parameter filterIds: (query) the filters that the retailer is associated with (optional)
    /// - parameter i: (query) This parameter is deprecated. (optional)
    /// - parameter l: (query) This parameter is deprecated. (optional)
    /// - returns: AnyPublisher<[RetailerResponse], Error> 
    open func getRetailers(visibility: GetRetailersVisibility, sortField: GetRetailersSortField, descending: Bool, start: Int, limit: Int, activeOnly: Bool, deviceId: String? = nil, accountId: Int64? = nil, q: String? = nil, keyword: String? = nil, categoryIds: String? = nil, filterIds: String? = nil, i: Int? = nil, l: Int? = nil) -> AnyPublisher<[RetailerResponse], Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/search"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                if let q = q { queryItems.append(URLQueryItem(name: "q", value: q)) } 
                if let keyword = keyword { queryItems.append(URLQueryItem(name: "keyword", value: keyword)) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue))
                queryItems.append(URLQueryItem(name: "sortField", value: sortField.rawValue))
                queryItems.append(URLQueryItem(name: "descending", value: descending ? "true" : "false"))
                if let i = i { queryItems.append(URLQueryItem(name: "_i", value: "\(i)")) } 
                queryItems.append(URLQueryItem(name: "start", value: "\(start)"))
                if let l = l { queryItems.append(URLQueryItem(name: "_l", value: "\(l)")) } 
                queryItems.append(URLQueryItem(name: "limit", value: "\(limit)"))
                queryItems.append(URLQueryItem(name: "activeOnly", value: activeOnly ? "true" : "false"))
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "GET"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<[RetailerResponse], Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode([RetailerResponse].self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }


    /// Login Retailer
    /// - POST /retailer/login
    /// - Retailer login check.
    /// - parameter username: (query) the user&#39;s email address they used to sign-up 
    /// - parameter password: (query) the password 
    /// - parameter deviceId: (query) the device id (optional) (optional)
    /// - parameter latitude: (query) the current latitude of the user (optional)
    /// - parameter longitude: (query) the current longitude of the user (optional)
    /// - parameter appKey: (query) the application key (optional)
    /// - returns: AnyPublisher<AccountLoginResponse, Error> 
    open func retailerLoginCheck(username: String, password: String, deviceId: String? = nil, latitude: Double? = nil, longitude: Double? = nil, appKey: String? = nil) -> AnyPublisher<AccountLoginResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/login"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                queryItems.append(URLQueryItem(name: "username", value: username))
                queryItems.append(URLQueryItem(name: "password", value: password))
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let appKey = appKey { queryItems.append(URLQueryItem(name: "appKey", value: appKey)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<AccountLoginResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(AccountLoginResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }

    ///
    /// Enum for parameter visibility
    ///
    public enum UpdateRetailerVisibility: String, Codable, CaseIterable {
        case _public = "PUBLIC"
        case _private = "PRIVATE"
        case friends = "FRIENDS"
    }
    ///
    /// Enum for parameter responseFormat
    ///
    public enum UpdateRetailerResponseFormat: String, Codable, CaseIterable {
        case html = "HTML"
        case xml = "XML"
        case json = "JSON"
        case csv = "CSV"
    }

    /// Update Retailer
    /// - POST /retailer/update
    /// - Update a retailer record. Only the owner and the employees of the retailer have access to update its information.
    /// - parameter retailerId: (query) The ID of the retailer to update 
    /// - parameter deviceId: (query) The device id (deviceId or accountId required) (optional)
    /// - parameter accountId: (query) The account id of the user (deviceId or accountId required) (optional)
    /// - parameter name: (query) The name of the retailer (optional)
    /// - parameter streetAddress: (query) The street address of the retailer (optional)
    /// - parameter streetAddress2: (query) Additional address information (such as a suite number, floor number, building name, or PO Box) (optional)
    /// - parameter city: (query) The city of the retailer (optional)
    /// - parameter state: (query) The state of the retailer (optional)
    /// - parameter postalCode: (query) The postal code of the retailer (optional)
    /// - parameter country: (query) the country of the retailer (optional)
    /// - parameter businessPhone: (query) The business phone of the retailer (optional)
    /// - parameter businessPhoneExt: (query) The business phone extension of the retailer (optional)
    /// - parameter website: (query) The website of the retailer (optional)
    /// - parameter email: (query) The email of the retailer (optional)
    /// - parameter facebookUrl: (query) The facebook URL of the retailer (optional)
    /// - parameter twitterUrl: (query) The twitter URL of the retailer (optional)
    /// - parameter logo: (query) The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before) (optional)
    /// - parameter logoAssetId: (query) The retailer logo asset id (optional)
    /// - parameter picture1: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture1AssetId: (query) An asset id (optional)
    /// - parameter picture2: (query) Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before) (optional)
    /// - parameter picture2AssetId: (query) An asset id (optional)
    /// - parameter categoryIds: (query) Comma separated list of category IDs used to filter retailers by categories (optional)
    /// - parameter filterIds: (query) Comma separated list of filter IDs used to filter retailers (optional)
    /// - parameter latitude: (query) the latitude of the retailer (optional)
    /// - parameter longitude: (query) the longitude of the retailer (optional)
    /// - parameter metaData: (query) External custom client defined data (optional)
    /// - parameter searchTags: (query) External custom search keywords (optional)
    /// - parameter retailerType: (query) External custom type identifier (optional)
    /// - parameter visibility: (query)  (optional)
    /// - parameter active: (query) Sets whether the retailer is active or inactive (hidden from consumers) (optional)
    /// - parameter responseFormat: (query) The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets} (optional)
    /// - returns: AnyPublisher<RetailerFullResponse, Error> 
    open func updateRetailer(retailerId: Int64, deviceId: String? = nil, accountId: Int64? = nil, name: String? = nil, streetAddress: String? = nil, streetAddress2: String? = nil, city: String? = nil, state: String? = nil, postalCode: String? = nil, country: String? = nil, businessPhone: String? = nil, businessPhoneExt: String? = nil, website: String? = nil, email: String? = nil, facebookUrl: String? = nil, twitterUrl: String? = nil, logo: Data? = nil, logoAssetId: Int64? = nil, picture1: Data? = nil, picture1AssetId: Int64? = nil, picture2: Data? = nil, picture2AssetId: Int64? = nil, categoryIds: String? = nil, filterIds: String? = nil, latitude: Double? = nil, longitude: Double? = nil, metaData: String? = nil, searchTags: String? = nil, retailerType: String? = nil, visibility: UpdateRetailerVisibility? = nil, active: Bool? = nil, responseFormat: UpdateRetailerResponseFormat? = nil) -> AnyPublisher<RetailerFullResponse, Error> {
        Deferred {
            Result<URLRequest, Error> {
                guard let baseURL = self.transport.baseURL ?? self.baseURL else {
                    throw OpenAPITransportError.badURLError()
                }
                let localVarPath = "/retailer/update"
                let localVarURL = baseURL.appendingPathComponent(localVarPath)
                var components = URLComponents(url: localVarURL, resolvingAgainstBaseURL: false)
                var queryItems: [URLQueryItem] = []
                if let deviceId = deviceId { queryItems.append(URLQueryItem(name: "deviceId", value: deviceId)) } 
                if let accountId = accountId { queryItems.append(URLQueryItem(name: "accountId", value: "\(accountId)")) } 
                queryItems.append(URLQueryItem(name: "retailerId", value: "\(retailerId)"))
                if let name = name { queryItems.append(URLQueryItem(name: "name", value: name)) } 
                if let streetAddress = streetAddress { queryItems.append(URLQueryItem(name: "streetAddress", value: streetAddress)) } 
                if let streetAddress2 = streetAddress2 { queryItems.append(URLQueryItem(name: "streetAddress2", value: streetAddress2)) } 
                if let city = city { queryItems.append(URLQueryItem(name: "city", value: city)) } 
                if let state = state { queryItems.append(URLQueryItem(name: "state", value: state)) } 
                if let postalCode = postalCode { queryItems.append(URLQueryItem(name: "postalCode", value: postalCode)) } 
                if let country = country { queryItems.append(URLQueryItem(name: "country", value: country)) } 
                if let businessPhone = businessPhone { queryItems.append(URLQueryItem(name: "businessPhone", value: businessPhone)) } 
                if let businessPhoneExt = businessPhoneExt { queryItems.append(URLQueryItem(name: "businessPhoneExt", value: businessPhoneExt)) } 
                if let website = website { queryItems.append(URLQueryItem(name: "website", value: website)) } 
                if let email = email { queryItems.append(URLQueryItem(name: "email", value: email)) } 
                if let facebookUrl = facebookUrl { queryItems.append(URLQueryItem(name: "facebookUrl", value: facebookUrl)) } 
                if let twitterUrl = twitterUrl { queryItems.append(URLQueryItem(name: "twitterUrl", value: twitterUrl)) } 
                if let logo = logo { queryItems.append(URLQueryItem(name: "logo", value: )) } 
                if let logoAssetId = logoAssetId { queryItems.append(URLQueryItem(name: "logoAssetId", value: "\(logoAssetId)")) } 
                if let picture1 = picture1 { queryItems.append(URLQueryItem(name: "picture1", value: )) } 
                if let picture1AssetId = picture1AssetId { queryItems.append(URLQueryItem(name: "picture1AssetId", value: "\(picture1AssetId)")) } 
                if let picture2 = picture2 { queryItems.append(URLQueryItem(name: "picture2", value: )) } 
                if let picture2AssetId = picture2AssetId { queryItems.append(URLQueryItem(name: "picture2AssetId", value: "\(picture2AssetId)")) } 
                if let categoryIds = categoryIds { queryItems.append(URLQueryItem(name: "categoryIds", value: categoryIds)) } 
                if let filterIds = filterIds { queryItems.append(URLQueryItem(name: "filterIds", value: filterIds)) } 
                if let latitude = latitude { queryItems.append(URLQueryItem(name: "latitude", value: "\(latitude)")) } 
                if let longitude = longitude { queryItems.append(URLQueryItem(name: "longitude", value: "\(longitude)")) } 
                if let metaData = metaData { queryItems.append(URLQueryItem(name: "metaData", value: metaData)) } 
                if let searchTags = searchTags { queryItems.append(URLQueryItem(name: "searchTags", value: searchTags)) } 
                if let retailerType = retailerType { queryItems.append(URLQueryItem(name: "retailerType", value: retailerType)) } 
                if let visibility = visibility { queryItems.append(URLQueryItem(name: "visibility", value: visibility.rawValue)) } 
                if let active = active { queryItems.append(URLQueryItem(name: "active", value: active ? "true" : "false")) } 
                if let responseFormat = responseFormat { queryItems.append(URLQueryItem(name: "responseFormat", value: responseFormat.rawValue)) } 
                components?.queryItems = queryItems
                guard let requestURL = components?.url else {
                    throw OpenAPITransportError.badURLError()
                }
                var request = URLRequest(url: requestURL)
                request.httpMethod = "POST"
                return request
            }.publisher
        }.flatMap { request -> AnyPublisher<RetailerFullResponse, Error> in 
            return self.transport.send(request: request)
                .tryMap { response in
                    try self.decoder.decode(RetailerFullResponse.self, from: response.data)
                }
                .eraseToAnyPublisher()
        }.eraseToAnyPublisher()
    }
}
