# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, Dict, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.rank_full_response import RankFullResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class RankingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_historical_rankings(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        rank_type: Annotated[StrictStr, Field(description="the rank type to return")],
        start_date: Annotated[StrictInt, Field(description="timestamp in milliseconds to filter results with")],
        end_date: Annotated[StrictInt, Field(description="timestamp in milliseconds to filter results with")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in ascending or descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RankFullResponse:
        """Search Historical Rankings

        Get historical leaderboard rankings by time-frame.

        :param version: (required)
        :type version: float
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: the rank type to return (required)
        :type rank_type: str
        :param start_date: timestamp in milliseconds to filter results with (required)
        :type start_date: int
        :param end_date: timestamp in milliseconds to filter results with (required)
        :type end_date: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user
        :type account_id: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param descending: determines whether to return results in ascending or descending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_historical_rankings_serialize(
            version=version,
            app_key=app_key,
            rank_type=rank_type,
            start_date=start_date,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_historical_rankings_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        rank_type: Annotated[StrictStr, Field(description="the rank type to return")],
        start_date: Annotated[StrictInt, Field(description="timestamp in milliseconds to filter results with")],
        end_date: Annotated[StrictInt, Field(description="timestamp in milliseconds to filter results with")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in ascending or descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RankFullResponse]:
        """Search Historical Rankings

        Get historical leaderboard rankings by time-frame.

        :param version: (required)
        :type version: float
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: the rank type to return (required)
        :type rank_type: str
        :param start_date: timestamp in milliseconds to filter results with (required)
        :type start_date: int
        :param end_date: timestamp in milliseconds to filter results with (required)
        :type end_date: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user
        :type account_id: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param descending: determines whether to return results in ascending or descending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_historical_rankings_serialize(
            version=version,
            app_key=app_key,
            rank_type=rank_type,
            start_date=start_date,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_historical_rankings_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        rank_type: Annotated[StrictStr, Field(description="the rank type to return")],
        start_date: Annotated[StrictInt, Field(description="timestamp in milliseconds to filter results with")],
        end_date: Annotated[StrictInt, Field(description="timestamp in milliseconds to filter results with")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in ascending or descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Historical Rankings

        Get historical leaderboard rankings by time-frame.

        :param version: (required)
        :type version: float
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: the rank type to return (required)
        :type rank_type: str
        :param start_date: timestamp in milliseconds to filter results with (required)
        :type start_date: int
        :param end_date: timestamp in milliseconds to filter results with (required)
        :type end_date: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user
        :type account_id: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param descending: determines whether to return results in ascending or descending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_historical_rankings_serialize(
            version=version,
            app_key=app_key,
            rank_type=rank_type,
            start_date=start_date,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_historical_rankings_serialize(
        self,
        version,
        app_key,
        rank_type,
        start_date,
        end_date,
        device_id,
        account_id,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/ranking/historical/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_rankings(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key for filtering results by application (required for non-EXECUTIVE users)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search for")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId")] = None,
        within_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.")] = None,
        return_user_rank: Annotated[Optional[StrictBool], Field(description="determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="album id to use when performing CUSTOM filters")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="audience id to use when performing CUSTOM filters")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in ascending or descending order")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RankFullResponse:
        """Search Rankings

        Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key for filtering results by application (required for non-EXECUTIVE users)
        :type app_key: str
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: keyword to search for
        :type keyword: str
        :param rank_type: a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
        :type leaderboard_mode: str
        :param within_account_ids: comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
        :type within_account_ids: str
        :param return_user_rank: determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
        :type return_user_rank: bool
        :param album_id: album id to use when performing CUSTOM filters
        :type album_id: int
        :param audience_id: audience id to use when performing CUSTOM filters
        :type audience_id: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
        :type sort_field: str
        :param descending: determines whether to return results in ascending or descending order
        :type descending: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: the start index for pagination
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rankings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            q=q,
            keyword=keyword,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            within_account_ids=within_account_ids,
            return_user_rank=return_user_rank,
            album_id=album_id,
            audience_id=audience_id,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_rankings_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key for filtering results by application (required for non-EXECUTIVE users)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search for")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId")] = None,
        within_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.")] = None,
        return_user_rank: Annotated[Optional[StrictBool], Field(description="determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="album id to use when performing CUSTOM filters")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="audience id to use when performing CUSTOM filters")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in ascending or descending order")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RankFullResponse]:
        """Search Rankings

        Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key for filtering results by application (required for non-EXECUTIVE users)
        :type app_key: str
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: keyword to search for
        :type keyword: str
        :param rank_type: a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
        :type leaderboard_mode: str
        :param within_account_ids: comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
        :type within_account_ids: str
        :param return_user_rank: determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
        :type return_user_rank: bool
        :param album_id: album id to use when performing CUSTOM filters
        :type album_id: int
        :param audience_id: audience id to use when performing CUSTOM filters
        :type audience_id: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
        :type sort_field: str
        :param descending: determines whether to return results in ascending or descending order
        :type descending: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: the start index for pagination
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rankings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            q=q,
            keyword=keyword,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            within_account_ids=within_account_ids,
            return_user_rank=return_user_rank,
            album_id=album_id,
            audience_id=audience_id,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_rankings_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key for filtering results by application (required for non-EXECUTIVE users)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search for")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId")] = None,
        within_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.")] = None,
        return_user_rank: Annotated[Optional[StrictBool], Field(description="determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="album id to use when performing CUSTOM filters")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="audience id to use when performing CUSTOM filters")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in ascending or descending order")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Rankings

        Get leader board rankings. This is an all in one endpoint that can return multiple ranking types and also the current user rank.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key for filtering results by application (required for non-EXECUTIVE users)
        :type app_key: str
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: keyword to search for
        :type keyword: str
        :param rank_type: a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId
        :type leaderboard_mode: str
        :param within_account_ids: comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
        :type within_account_ids: str
        :param return_user_rank: determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests.
        :type return_user_rank: bool
        :param album_id: album id to use when performing CUSTOM filters
        :type album_id: int
        :param audience_id: audience id to use when performing CUSTOM filters
        :type audience_id: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score
        :type sort_field: str
        :param descending: determines whether to return results in ascending or descending order
        :type descending: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: the start index for pagination
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_rankings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            q=q,
            keyword=keyword,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            within_account_ids=within_account_ids,
            return_user_rank=return_user_rank,
            album_id=album_id,
            audience_id=audience_id,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RankFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_rankings_serialize(
        self,
        version,
        device_id,
        account_id,
        game_type,
        app_key,
        q,
        keyword,
        rank_type,
        leaderboard_mode,
        within_account_ids,
        return_user_rank,
        album_id,
        audience_id,
        sort_field,
        descending,
        i,
        start,
        l,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if leaderboard_mode is not None:
            
            _query_params.append(('leaderboardMode', leaderboard_mode))
            
        if within_account_ids is not None:
            
            _query_params.append(('withinAccountIds', within_account_ids))
            
        if return_user_rank is not None:
            
            _query_params.append(('returnUserRank', return_user_rank))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/ranking/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_user_rank(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key for filtering results by application (required)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="pass in all rankTypes and children rankTypes")] = None,
        return_user_rank: Annotated[Optional[StrictBool], Field(description="determines whether to return the user's current rank in the response, for each rankType")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search for (on rankType)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get Personal Rankings

        Returns the user's ranks for one or more rank types and modes.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user
        :type account_id: int
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: pass in all rankTypes and children rankTypes
        :type rank_type: str
        :param return_user_rank: determines whether to return the user's current rank in the response, for each rankType
        :type return_user_rank: bool
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        :type leaderboard_mode: str
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param keyword: keyword to search for (on rankType)
        :type keyword: str
        :param descending: determines whether to return results in descending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_rank_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            return_user_rank=return_user_rank,
            leaderboard_mode=leaderboard_mode,
            sort_field=sort_field,
            keyword=keyword,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_user_rank_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key for filtering results by application (required)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="pass in all rankTypes and children rankTypes")] = None,
        return_user_rank: Annotated[Optional[StrictBool], Field(description="determines whether to return the user's current rank in the response, for each rankType")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search for (on rankType)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get Personal Rankings

        Returns the user's ranks for one or more rank types and modes.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user
        :type account_id: int
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: pass in all rankTypes and children rankTypes
        :type rank_type: str
        :param return_user_rank: determines whether to return the user's current rank in the response, for each rankType
        :type return_user_rank: bool
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        :type leaderboard_mode: str
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param keyword: keyword to search for (on rankType)
        :type keyword: str
        :param descending: determines whether to return results in descending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_rank_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            return_user_rank=return_user_rank,
            leaderboard_mode=leaderboard_mode,
            sort_field=sort_field,
            keyword=keyword,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_user_rank_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key for filtering results by application (required)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="pass in all rankTypes and children rankTypes")] = None,
        return_user_rank: Annotated[Optional[StrictBool], Field(description="determines whether to return the user's current rank in the response, for each rankType")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search for (on rankType)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether to return results in descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Personal Rankings

        Returns the user's ranks for one or more rank types and modes.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user
        :type account_id: int
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: pass in all rankTypes and children rankTypes
        :type rank_type: str
        :param return_user_rank: determines whether to return the user's current rank in the response, for each rankType
        :type return_user_rank: bool
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        :type leaderboard_mode: str
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param keyword: keyword to search for (on rankType)
        :type keyword: str
        :param descending: determines whether to return results in descending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_rank_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            return_user_rank=return_user_rank,
            leaderboard_mode=leaderboard_mode,
            sort_field=sort_field,
            keyword=keyword,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_user_rank_serialize(
        self,
        version,
        device_id,
        account_id,
        app_key,
        rank_type,
        return_user_rank,
        leaderboard_mode,
        sort_field,
        keyword,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if return_user_rank is not None:
            
            _query_params.append(('returnUserRank', return_user_rank))
            
        if leaderboard_mode is not None:
            
            _query_params.append(('leaderboardMode', leaderboard_mode))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/ranking/personal/ranks',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def override_user_rank(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the logged in user's account id (must have permissions to manage data for the application)")],
        owner_account_id: Annotated[StrictInt, Field(description="the end user's account id to override")],
        app_key: Annotated[StrictStr, Field(description="the application key the leaderboard is for")],
        rank_type: Annotated[StrictStr, Field(description="the rankType of the leaderboard")],
        total_score: Annotated[Optional[StrictInt], Field(description="the total score to update")] = None,
        total_count: Annotated[Optional[StrictInt], Field(description="the total count to update")] = None,
        total_time: Annotated[Optional[StrictInt], Field(description="the total time to update")] = None,
        daily_score: Annotated[Optional[StrictInt], Field(description="the daily score to update")] = None,
        daily_count: Annotated[Optional[StrictInt], Field(description="the daily count to update")] = None,
        daily_time: Annotated[Optional[StrictInt], Field(description="the daily time to update")] = None,
        weekly_score: Annotated[Optional[StrictInt], Field(description="the weekly score to update")] = None,
        weekly_count: Annotated[Optional[StrictInt], Field(description="the weekly count to update")] = None,
        weekly_time: Annotated[Optional[StrictInt], Field(description="the weekly time to update")] = None,
        monthly_score: Annotated[Optional[StrictInt], Field(description="the monthly score to update")] = None,
        monthly_count: Annotated[Optional[StrictInt], Field(description="the monthly count to update")] = None,
        monthly_time: Annotated[Optional[StrictInt], Field(description="the monthly time to update")] = None,
        top_score: Annotated[Optional[StrictInt], Field(description="the top score to update")] = None,
        lowest_score: Annotated[Optional[StrictInt], Field(description="the lowest score to update")] = None,
        streak_count: Annotated[Optional[StrictInt], Field(description="the streak count to update")] = None,
        streak_best_count: Annotated[Optional[StrictInt], Field(description="the best streak count to update")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date to update")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Override User Rank

        Allows an admin of an application to override a user's scores for a leaderboard.

        :param version: (required)
        :type version: float
        :param account_id: the logged in user's account id (must have permissions to manage data for the application) (required)
        :type account_id: int
        :param owner_account_id: the end user's account id to override (required)
        :type owner_account_id: int
        :param app_key: the application key the leaderboard is for (required)
        :type app_key: str
        :param rank_type: the rankType of the leaderboard (required)
        :type rank_type: str
        :param total_score: the total score to update
        :type total_score: int
        :param total_count: the total count to update
        :type total_count: int
        :param total_time: the total time to update
        :type total_time: int
        :param daily_score: the daily score to update
        :type daily_score: int
        :param daily_count: the daily count to update
        :type daily_count: int
        :param daily_time: the daily time to update
        :type daily_time: int
        :param weekly_score: the weekly score to update
        :type weekly_score: int
        :param weekly_count: the weekly count to update
        :type weekly_count: int
        :param weekly_time: the weekly time to update
        :type weekly_time: int
        :param monthly_score: the monthly score to update
        :type monthly_score: int
        :param monthly_count: the monthly count to update
        :type monthly_count: int
        :param monthly_time: the monthly time to update
        :type monthly_time: int
        :param top_score: the top score to update
        :type top_score: int
        :param lowest_score: the lowest score to update
        :type lowest_score: int
        :param streak_count: the streak count to update
        :type streak_count: int
        :param streak_best_count: the best streak count to update
        :type streak_best_count: int
        :param start_date: the start date to update
        :type start_date: int
        :param end_date: the end date to update
        :type end_date: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._override_user_rank_serialize(
            version=version,
            account_id=account_id,
            owner_account_id=owner_account_id,
            app_key=app_key,
            rank_type=rank_type,
            total_score=total_score,
            total_count=total_count,
            total_time=total_time,
            daily_score=daily_score,
            daily_count=daily_count,
            daily_time=daily_time,
            weekly_score=weekly_score,
            weekly_count=weekly_count,
            weekly_time=weekly_time,
            monthly_score=monthly_score,
            monthly_count=monthly_count,
            monthly_time=monthly_time,
            top_score=top_score,
            lowest_score=lowest_score,
            streak_count=streak_count,
            streak_best_count=streak_best_count,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def override_user_rank_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the logged in user's account id (must have permissions to manage data for the application)")],
        owner_account_id: Annotated[StrictInt, Field(description="the end user's account id to override")],
        app_key: Annotated[StrictStr, Field(description="the application key the leaderboard is for")],
        rank_type: Annotated[StrictStr, Field(description="the rankType of the leaderboard")],
        total_score: Annotated[Optional[StrictInt], Field(description="the total score to update")] = None,
        total_count: Annotated[Optional[StrictInt], Field(description="the total count to update")] = None,
        total_time: Annotated[Optional[StrictInt], Field(description="the total time to update")] = None,
        daily_score: Annotated[Optional[StrictInt], Field(description="the daily score to update")] = None,
        daily_count: Annotated[Optional[StrictInt], Field(description="the daily count to update")] = None,
        daily_time: Annotated[Optional[StrictInt], Field(description="the daily time to update")] = None,
        weekly_score: Annotated[Optional[StrictInt], Field(description="the weekly score to update")] = None,
        weekly_count: Annotated[Optional[StrictInt], Field(description="the weekly count to update")] = None,
        weekly_time: Annotated[Optional[StrictInt], Field(description="the weekly time to update")] = None,
        monthly_score: Annotated[Optional[StrictInt], Field(description="the monthly score to update")] = None,
        monthly_count: Annotated[Optional[StrictInt], Field(description="the monthly count to update")] = None,
        monthly_time: Annotated[Optional[StrictInt], Field(description="the monthly time to update")] = None,
        top_score: Annotated[Optional[StrictInt], Field(description="the top score to update")] = None,
        lowest_score: Annotated[Optional[StrictInt], Field(description="the lowest score to update")] = None,
        streak_count: Annotated[Optional[StrictInt], Field(description="the streak count to update")] = None,
        streak_best_count: Annotated[Optional[StrictInt], Field(description="the best streak count to update")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date to update")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Override User Rank

        Allows an admin of an application to override a user's scores for a leaderboard.

        :param version: (required)
        :type version: float
        :param account_id: the logged in user's account id (must have permissions to manage data for the application) (required)
        :type account_id: int
        :param owner_account_id: the end user's account id to override (required)
        :type owner_account_id: int
        :param app_key: the application key the leaderboard is for (required)
        :type app_key: str
        :param rank_type: the rankType of the leaderboard (required)
        :type rank_type: str
        :param total_score: the total score to update
        :type total_score: int
        :param total_count: the total count to update
        :type total_count: int
        :param total_time: the total time to update
        :type total_time: int
        :param daily_score: the daily score to update
        :type daily_score: int
        :param daily_count: the daily count to update
        :type daily_count: int
        :param daily_time: the daily time to update
        :type daily_time: int
        :param weekly_score: the weekly score to update
        :type weekly_score: int
        :param weekly_count: the weekly count to update
        :type weekly_count: int
        :param weekly_time: the weekly time to update
        :type weekly_time: int
        :param monthly_score: the monthly score to update
        :type monthly_score: int
        :param monthly_count: the monthly count to update
        :type monthly_count: int
        :param monthly_time: the monthly time to update
        :type monthly_time: int
        :param top_score: the top score to update
        :type top_score: int
        :param lowest_score: the lowest score to update
        :type lowest_score: int
        :param streak_count: the streak count to update
        :type streak_count: int
        :param streak_best_count: the best streak count to update
        :type streak_best_count: int
        :param start_date: the start date to update
        :type start_date: int
        :param end_date: the end date to update
        :type end_date: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._override_user_rank_serialize(
            version=version,
            account_id=account_id,
            owner_account_id=owner_account_id,
            app_key=app_key,
            rank_type=rank_type,
            total_score=total_score,
            total_count=total_count,
            total_time=total_time,
            daily_score=daily_score,
            daily_count=daily_count,
            daily_time=daily_time,
            weekly_score=weekly_score,
            weekly_count=weekly_count,
            weekly_time=weekly_time,
            monthly_score=monthly_score,
            monthly_count=monthly_count,
            monthly_time=monthly_time,
            top_score=top_score,
            lowest_score=lowest_score,
            streak_count=streak_count,
            streak_best_count=streak_best_count,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def override_user_rank_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the logged in user's account id (must have permissions to manage data for the application)")],
        owner_account_id: Annotated[StrictInt, Field(description="the end user's account id to override")],
        app_key: Annotated[StrictStr, Field(description="the application key the leaderboard is for")],
        rank_type: Annotated[StrictStr, Field(description="the rankType of the leaderboard")],
        total_score: Annotated[Optional[StrictInt], Field(description="the total score to update")] = None,
        total_count: Annotated[Optional[StrictInt], Field(description="the total count to update")] = None,
        total_time: Annotated[Optional[StrictInt], Field(description="the total time to update")] = None,
        daily_score: Annotated[Optional[StrictInt], Field(description="the daily score to update")] = None,
        daily_count: Annotated[Optional[StrictInt], Field(description="the daily count to update")] = None,
        daily_time: Annotated[Optional[StrictInt], Field(description="the daily time to update")] = None,
        weekly_score: Annotated[Optional[StrictInt], Field(description="the weekly score to update")] = None,
        weekly_count: Annotated[Optional[StrictInt], Field(description="the weekly count to update")] = None,
        weekly_time: Annotated[Optional[StrictInt], Field(description="the weekly time to update")] = None,
        monthly_score: Annotated[Optional[StrictInt], Field(description="the monthly score to update")] = None,
        monthly_count: Annotated[Optional[StrictInt], Field(description="the monthly count to update")] = None,
        monthly_time: Annotated[Optional[StrictInt], Field(description="the monthly time to update")] = None,
        top_score: Annotated[Optional[StrictInt], Field(description="the top score to update")] = None,
        lowest_score: Annotated[Optional[StrictInt], Field(description="the lowest score to update")] = None,
        streak_count: Annotated[Optional[StrictInt], Field(description="the streak count to update")] = None,
        streak_best_count: Annotated[Optional[StrictInt], Field(description="the best streak count to update")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date to update")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date to update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Override User Rank

        Allows an admin of an application to override a user's scores for a leaderboard.

        :param version: (required)
        :type version: float
        :param account_id: the logged in user's account id (must have permissions to manage data for the application) (required)
        :type account_id: int
        :param owner_account_id: the end user's account id to override (required)
        :type owner_account_id: int
        :param app_key: the application key the leaderboard is for (required)
        :type app_key: str
        :param rank_type: the rankType of the leaderboard (required)
        :type rank_type: str
        :param total_score: the total score to update
        :type total_score: int
        :param total_count: the total count to update
        :type total_count: int
        :param total_time: the total time to update
        :type total_time: int
        :param daily_score: the daily score to update
        :type daily_score: int
        :param daily_count: the daily count to update
        :type daily_count: int
        :param daily_time: the daily time to update
        :type daily_time: int
        :param weekly_score: the weekly score to update
        :type weekly_score: int
        :param weekly_count: the weekly count to update
        :type weekly_count: int
        :param weekly_time: the weekly time to update
        :type weekly_time: int
        :param monthly_score: the monthly score to update
        :type monthly_score: int
        :param monthly_count: the monthly count to update
        :type monthly_count: int
        :param monthly_time: the monthly time to update
        :type monthly_time: int
        :param top_score: the top score to update
        :type top_score: int
        :param lowest_score: the lowest score to update
        :type lowest_score: int
        :param streak_count: the streak count to update
        :type streak_count: int
        :param streak_best_count: the best streak count to update
        :type streak_best_count: int
        :param start_date: the start date to update
        :type start_date: int
        :param end_date: the end date to update
        :type end_date: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._override_user_rank_serialize(
            version=version,
            account_id=account_id,
            owner_account_id=owner_account_id,
            app_key=app_key,
            rank_type=rank_type,
            total_score=total_score,
            total_count=total_count,
            total_time=total_time,
            daily_score=daily_score,
            daily_count=daily_count,
            daily_time=daily_time,
            weekly_score=weekly_score,
            weekly_count=weekly_count,
            weekly_time=weekly_time,
            monthly_score=monthly_score,
            monthly_count=monthly_count,
            monthly_time=monthly_time,
            top_score=top_score,
            lowest_score=lowest_score,
            streak_count=streak_count,
            streak_best_count=streak_best_count,
            start_date=start_date,
            end_date=end_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _override_user_rank_serialize(
        self,
        version,
        account_id,
        owner_account_id,
        app_key,
        rank_type,
        total_score,
        total_count,
        total_time,
        daily_score,
        daily_count,
        daily_time,
        weekly_score,
        weekly_count,
        weekly_time,
        monthly_score,
        monthly_count,
        monthly_time,
        top_score,
        lowest_score,
        streak_count,
        streak_best_count,
        start_date,
        end_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if owner_account_id is not None:
            
            _query_params.append(('ownerAccountId', owner_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if total_score is not None:
            
            _query_params.append(('totalScore', total_score))
            
        if total_count is not None:
            
            _query_params.append(('totalCount', total_count))
            
        if total_time is not None:
            
            _query_params.append(('totalTime', total_time))
            
        if daily_score is not None:
            
            _query_params.append(('dailyScore', daily_score))
            
        if daily_count is not None:
            
            _query_params.append(('dailyCount', daily_count))
            
        if daily_time is not None:
            
            _query_params.append(('dailyTime', daily_time))
            
        if weekly_score is not None:
            
            _query_params.append(('weeklyScore', weekly_score))
            
        if weekly_count is not None:
            
            _query_params.append(('weeklyCount', weekly_count))
            
        if weekly_time is not None:
            
            _query_params.append(('weeklyTime', weekly_time))
            
        if monthly_score is not None:
            
            _query_params.append(('monthlyScore', monthly_score))
            
        if monthly_count is not None:
            
            _query_params.append(('monthlyCount', monthly_count))
            
        if monthly_time is not None:
            
            _query_params.append(('monthlyTime', monthly_time))
            
        if top_score is not None:
            
            _query_params.append(('topScore', top_score))
            
        if lowest_score is not None:
            
            _query_params.append(('lowestScore', lowest_score))
            
        if streak_count is not None:
            
            _query_params.append(('streakCount', streak_count))
            
        if streak_best_count is not None:
            
            _query_params.append(('streakBestCount', streak_best_count))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/ranking/override',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_rankings(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        rank_type: Annotated[StrictStr, Field(description="a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS")],
        increment: Annotated[Optional[StrictInt], Field(description="the value to increment")] = None,
        time_increment: Annotated[Optional[StrictInt], Field(description="the time value to increment")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="the analytic tag for this achievement (used to validate scores)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="custom date you can save along with the score for the user")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="custom date you can save along with the score for the user")] = None,
        update_global: Annotated[Optional[StrictBool], Field(description="update the global rankings if true, default is false")] = None,
        create_leaderboard: Annotated[Optional[StrictBool], Field(description="create the leaderboard if it does not exist (default false)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Ranking

        Update the rank value 

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (required)
        :type rank_type: str
        :param increment: the value to increment
        :type increment: int
        :param time_increment: the time value to increment
        :type time_increment: int
        :param tag: the analytic tag for this achievement (used to validate scores)
        :type tag: str
        :param start_date: custom date you can save along with the score for the user
        :type start_date: int
        :param end_date: custom date you can save along with the score for the user
        :type end_date: int
        :param update_global: update the global rankings if true, default is false
        :type update_global: bool
        :param create_leaderboard: create the leaderboard if it does not exist (default false)
        :type create_leaderboard: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_rankings_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            increment=increment,
            time_increment=time_increment,
            tag=tag,
            start_date=start_date,
            end_date=end_date,
            update_global=update_global,
            create_leaderboard=create_leaderboard,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_rankings_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        rank_type: Annotated[StrictStr, Field(description="a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS")],
        increment: Annotated[Optional[StrictInt], Field(description="the value to increment")] = None,
        time_increment: Annotated[Optional[StrictInt], Field(description="the time value to increment")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="the analytic tag for this achievement (used to validate scores)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="custom date you can save along with the score for the user")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="custom date you can save along with the score for the user")] = None,
        update_global: Annotated[Optional[StrictBool], Field(description="update the global rankings if true, default is false")] = None,
        create_leaderboard: Annotated[Optional[StrictBool], Field(description="create the leaderboard if it does not exist (default false)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Ranking

        Update the rank value 

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (required)
        :type rank_type: str
        :param increment: the value to increment
        :type increment: int
        :param time_increment: the time value to increment
        :type time_increment: int
        :param tag: the analytic tag for this achievement (used to validate scores)
        :type tag: str
        :param start_date: custom date you can save along with the score for the user
        :type start_date: int
        :param end_date: custom date you can save along with the score for the user
        :type end_date: int
        :param update_global: update the global rankings if true, default is false
        :type update_global: bool
        :param create_leaderboard: create the leaderboard if it does not exist (default false)
        :type create_leaderboard: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_rankings_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            increment=increment,
            time_increment=time_increment,
            tag=tag,
            start_date=start_date,
            end_date=end_date,
            update_global=update_global,
            create_leaderboard=create_leaderboard,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_rankings_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        rank_type: Annotated[StrictStr, Field(description="a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS")],
        increment: Annotated[Optional[StrictInt], Field(description="the value to increment")] = None,
        time_increment: Annotated[Optional[StrictInt], Field(description="the time value to increment")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="the analytic tag for this achievement (used to validate scores)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="custom date you can save along with the score for the user")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="custom date you can save along with the score for the user")] = None,
        update_global: Annotated[Optional[StrictBool], Field(description="update the global rankings if true, default is false")] = None,
        create_leaderboard: Annotated[Optional[StrictBool], Field(description="create the leaderboard if it does not exist (default false)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Ranking

        Update the rank value 

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS (required)
        :type rank_type: str
        :param increment: the value to increment
        :type increment: int
        :param time_increment: the time value to increment
        :type time_increment: int
        :param tag: the analytic tag for this achievement (used to validate scores)
        :type tag: str
        :param start_date: custom date you can save along with the score for the user
        :type start_date: int
        :param end_date: custom date you can save along with the score for the user
        :type end_date: int
        :param update_global: update the global rankings if true, default is false
        :type update_global: bool
        :param create_leaderboard: create the leaderboard if it does not exist (default false)
        :type create_leaderboard: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_rankings_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            increment=increment,
            time_increment=time_increment,
            tag=tag,
            start_date=start_date,
            end_date=end_date,
            update_global=update_global,
            create_leaderboard=create_leaderboard,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_rankings_serialize(
        self,
        version,
        account_id,
        app_key,
        rank_type,
        increment,
        time_increment,
        tag,
        start_date,
        end_date,
        update_global,
        create_leaderboard,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if increment is not None:
            
            _query_params.append(('increment', increment))
            
        if time_increment is not None:
            
            _query_params.append(('timeIncrement', time_increment))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if update_global is not None:
            
            _query_params.append(('updateGlobal', update_global))
            
        if create_leaderboard is not None:
            
            _query_params.append(('createLeaderboard', create_leaderboard))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/ranking/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


