# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.retailer_location_response import RetailerLocationResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class RetailerLocationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_retailer_location_consumer(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        name: Annotated[StrictStr, Field(description="The name of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Whether the location is public")] = None,
        active: Annotated[Optional[StrictBool], Field(description="whether the retailer location created should be active or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude to center the search on")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude to center the search on")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerLocationResponse:
        """Create Retailer Location (Consumer)

        Creates a location record for an application that can support crowd sourced locations.

        :param version: (required)
        :type version: float
        :param app_key: the application key (required)
        :type app_key: str
        :param name: The name of the retailer location (required)
        :type name: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address: The street address of the retailer location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer location
        :type city: str
        :param state: The state of the retailer location
        :type state: str
        :param postal_code: The postal code of the retailer location
        :type postal_code: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone
        :type business_phone: str
        :param business_phone_ext: The business phone extension
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param public_location: Whether the location is public
        :type public_location: bool
        :param active: whether the retailer location created should be active or not
        :type active: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param latitude: The latitude to center the search on
        :type latitude: float
        :param longitude: The longitude to center the search on
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_location_consumer_serialize(
            version=version,
            app_key=app_key,
            name=name,
            device_id=device_id,
            account_id=account_id,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            tags=tags,
            logo_asset_id=logo_asset_id,
            picture1_asset_id=picture1_asset_id,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            meta_data=meta_data,
            public_location=public_location,
            active=active,
            location_type=location_type,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_retailer_location_consumer_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        name: Annotated[StrictStr, Field(description="The name of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Whether the location is public")] = None,
        active: Annotated[Optional[StrictBool], Field(description="whether the retailer location created should be active or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude to center the search on")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude to center the search on")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerLocationResponse]:
        """Create Retailer Location (Consumer)

        Creates a location record for an application that can support crowd sourced locations.

        :param version: (required)
        :type version: float
        :param app_key: the application key (required)
        :type app_key: str
        :param name: The name of the retailer location (required)
        :type name: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address: The street address of the retailer location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer location
        :type city: str
        :param state: The state of the retailer location
        :type state: str
        :param postal_code: The postal code of the retailer location
        :type postal_code: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone
        :type business_phone: str
        :param business_phone_ext: The business phone extension
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param public_location: Whether the location is public
        :type public_location: bool
        :param active: whether the retailer location created should be active or not
        :type active: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param latitude: The latitude to center the search on
        :type latitude: float
        :param longitude: The longitude to center the search on
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_location_consumer_serialize(
            version=version,
            app_key=app_key,
            name=name,
            device_id=device_id,
            account_id=account_id,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            tags=tags,
            logo_asset_id=logo_asset_id,
            picture1_asset_id=picture1_asset_id,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            meta_data=meta_data,
            public_location=public_location,
            active=active,
            location_type=location_type,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_retailer_location_consumer_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        name: Annotated[StrictStr, Field(description="The name of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Whether the location is public")] = None,
        active: Annotated[Optional[StrictBool], Field(description="whether the retailer location created should be active or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude to center the search on")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude to center the search on")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Retailer Location (Consumer)

        Creates a location record for an application that can support crowd sourced locations.

        :param version: (required)
        :type version: float
        :param app_key: the application key (required)
        :type app_key: str
        :param name: The name of the retailer location (required)
        :type name: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address: The street address of the retailer location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer location
        :type city: str
        :param state: The state of the retailer location
        :type state: str
        :param postal_code: The postal code of the retailer location
        :type postal_code: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone
        :type business_phone: str
        :param business_phone_ext: The business phone extension
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param public_location: Whether the location is public
        :type public_location: bool
        :param active: whether the retailer location created should be active or not
        :type active: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param latitude: The latitude to center the search on
        :type latitude: float
        :param longitude: The longitude to center the search on
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_location_consumer_serialize(
            version=version,
            app_key=app_key,
            name=name,
            device_id=device_id,
            account_id=account_id,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            tags=tags,
            logo_asset_id=logo_asset_id,
            picture1_asset_id=picture1_asset_id,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            meta_data=meta_data,
            public_location=public_location,
            active=active,
            location_type=location_type,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_retailer_location_consumer_serialize(
        self,
        version,
        app_key,
        name,
        device_id,
        account_id,
        street_address,
        street_address2,
        city,
        state,
        postal_code,
        country,
        business_phone,
        business_phone_ext,
        website,
        email,
        details_header,
        details_body,
        hours,
        tags,
        logo_asset_id,
        picture1_asset_id,
        picture2_asset_id,
        category_ids,
        filter_ids,
        meta_data,
        public_location,
        active,
        location_type,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if business_phone_ext is not None:
            
            _query_params.append(('businessPhoneExt', business_phone_ext))
            
        if website is not None:
            
            _query_params.append(('website', website))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if details_header is not None:
            
            _query_params.append(('detailsHeader', details_header))
            
        if details_body is not None:
            
            _query_params.append(('detailsBody', details_body))
            
        if hours is not None:
            
            _query_params.append(('hours', hours))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if logo_asset_id is not None:
            
            _query_params.append(('logoAssetId', logo_asset_id))
            
        if picture1_asset_id is not None:
            
            _query_params.append(('picture1AssetId', picture1_asset_id))
            
        if picture2_asset_id is not None:
            
            _query_params.append(('picture2AssetId', picture2_asset_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if public_location is not None:
            
            _query_params.append(('publicLocation', public_location))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/location/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_retailer_locations(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="The ID of the retailer")],
        name: Annotated[StrictStr, Field(description="The name of the retailer location")],
        street_address: Annotated[StrictStr, Field(description="The street address of the retailer location")],
        city: Annotated[StrictStr, Field(description="The city of the retailer location")],
        state: Annotated[StrictStr, Field(description="The state of the retailer location")],
        postal_code: Annotated[StrictStr, Field(description="The postal code of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer location")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        internal_id: Annotated[Optional[StrictStr], Field(description="An internal identifier used by the retailer")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer location")] = None,
        building: Optional[StrictStr] = None,
        google_place_id: Annotated[Optional[StrictStr], Field(description="the ID of the Google Place that this retailer location is assigned to")] = None,
        yelp_id: Annotated[Optional[StrictStr], Field(description="the Yelp ID that this retailer location is assigned to")] = None,
        active: Annotated[Optional[StrictBool], Field(description="whether the retailer location should be active or inactive")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Sets whether the location is public or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs used to assign audiences to the retailer location")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to add to the retailer location")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to remove from the retailer location")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        response_includes: Annotated[Optional[StrictStr], Field(description="Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerLocationResponse:
        """Create Retailer Location

        Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.

        :param version: (required)
        :type version: float
        :param retailer_id: The ID of the retailer (required)
        :type retailer_id: int
        :param name: The name of the retailer location (required)
        :type name: str
        :param street_address: The street address of the retailer location (required)
        :type street_address: str
        :param city: The city of the retailer location (required)
        :type city: str
        :param state: The state of the retailer location (required)
        :type state: str
        :param postal_code: The postal code of the retailer location (required)
        :type postal_code: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone number of the retailer location
        :type business_phone: str
        :param business_phone_ext: The business phone extension
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param internal_id: An internal identifier used by the retailer
        :type internal_id: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param logo: The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param latitude: the latitude of the retailer location
        :type latitude: float
        :param longitude: the longitude of the retailer location
        :type longitude: float
        :param building: 
        :type building: str
        :param google_place_id: the ID of the Google Place that this retailer location is assigned to
        :type google_place_id: str
        :param yelp_id: the Yelp ID that this retailer location is assigned to
        :type yelp_id: str
        :param active: whether the retailer location should be active or inactive
        :type active: bool
        :param public_location: Sets whether the location is public or not
        :type public_location: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param audience_ids: Comma separated list of audience IDs used to assign audiences to the retailer location
        :type audience_ids: str
        :param audience_ids_to_add: Comma separated list of audience IDs to add to the retailer location
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Comma separated list of audience IDs to remove from the retailer location
        :type audience_ids_to_remove: str
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param response_includes: Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)
        :type response_includes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_locations_serialize(
            version=version,
            retailer_id=retailer_id,
            name=name,
            street_address=street_address,
            city=city,
            state=state,
            postal_code=postal_code,
            device_id=device_id,
            account_id=account_id,
            street_address2=street_address2,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            internal_id=internal_id,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            building=building,
            google_place_id=google_place_id,
            yelp_id=yelp_id,
            active=active,
            public_location=public_location,
            location_type=location_type,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            response_format=response_format,
            response_includes=response_includes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_retailer_locations_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="The ID of the retailer")],
        name: Annotated[StrictStr, Field(description="The name of the retailer location")],
        street_address: Annotated[StrictStr, Field(description="The street address of the retailer location")],
        city: Annotated[StrictStr, Field(description="The city of the retailer location")],
        state: Annotated[StrictStr, Field(description="The state of the retailer location")],
        postal_code: Annotated[StrictStr, Field(description="The postal code of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer location")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        internal_id: Annotated[Optional[StrictStr], Field(description="An internal identifier used by the retailer")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer location")] = None,
        building: Optional[StrictStr] = None,
        google_place_id: Annotated[Optional[StrictStr], Field(description="the ID of the Google Place that this retailer location is assigned to")] = None,
        yelp_id: Annotated[Optional[StrictStr], Field(description="the Yelp ID that this retailer location is assigned to")] = None,
        active: Annotated[Optional[StrictBool], Field(description="whether the retailer location should be active or inactive")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Sets whether the location is public or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs used to assign audiences to the retailer location")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to add to the retailer location")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to remove from the retailer location")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        response_includes: Annotated[Optional[StrictStr], Field(description="Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerLocationResponse]:
        """Create Retailer Location

        Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.

        :param version: (required)
        :type version: float
        :param retailer_id: The ID of the retailer (required)
        :type retailer_id: int
        :param name: The name of the retailer location (required)
        :type name: str
        :param street_address: The street address of the retailer location (required)
        :type street_address: str
        :param city: The city of the retailer location (required)
        :type city: str
        :param state: The state of the retailer location (required)
        :type state: str
        :param postal_code: The postal code of the retailer location (required)
        :type postal_code: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone number of the retailer location
        :type business_phone: str
        :param business_phone_ext: The business phone extension
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param internal_id: An internal identifier used by the retailer
        :type internal_id: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param logo: The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param latitude: the latitude of the retailer location
        :type latitude: float
        :param longitude: the longitude of the retailer location
        :type longitude: float
        :param building: 
        :type building: str
        :param google_place_id: the ID of the Google Place that this retailer location is assigned to
        :type google_place_id: str
        :param yelp_id: the Yelp ID that this retailer location is assigned to
        :type yelp_id: str
        :param active: whether the retailer location should be active or inactive
        :type active: bool
        :param public_location: Sets whether the location is public or not
        :type public_location: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param audience_ids: Comma separated list of audience IDs used to assign audiences to the retailer location
        :type audience_ids: str
        :param audience_ids_to_add: Comma separated list of audience IDs to add to the retailer location
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Comma separated list of audience IDs to remove from the retailer location
        :type audience_ids_to_remove: str
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param response_includes: Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)
        :type response_includes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_locations_serialize(
            version=version,
            retailer_id=retailer_id,
            name=name,
            street_address=street_address,
            city=city,
            state=state,
            postal_code=postal_code,
            device_id=device_id,
            account_id=account_id,
            street_address2=street_address2,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            internal_id=internal_id,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            building=building,
            google_place_id=google_place_id,
            yelp_id=yelp_id,
            active=active,
            public_location=public_location,
            location_type=location_type,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            response_format=response_format,
            response_includes=response_includes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_retailer_locations_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="The ID of the retailer")],
        name: Annotated[StrictStr, Field(description="The name of the retailer location")],
        street_address: Annotated[StrictStr, Field(description="The street address of the retailer location")],
        city: Annotated[StrictStr, Field(description="The city of the retailer location")],
        state: Annotated[StrictStr, Field(description="The state of the retailer location")],
        postal_code: Annotated[StrictStr, Field(description="The postal code of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer location")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        internal_id: Annotated[Optional[StrictStr], Field(description="An internal identifier used by the retailer")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer location")] = None,
        building: Optional[StrictStr] = None,
        google_place_id: Annotated[Optional[StrictStr], Field(description="the ID of the Google Place that this retailer location is assigned to")] = None,
        yelp_id: Annotated[Optional[StrictStr], Field(description="the Yelp ID that this retailer location is assigned to")] = None,
        active: Annotated[Optional[StrictBool], Field(description="whether the retailer location should be active or inactive")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Sets whether the location is public or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs used to assign audiences to the retailer location")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to add to the retailer location")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to remove from the retailer location")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        response_includes: Annotated[Optional[StrictStr], Field(description="Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Retailer Location

        Creates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.

        :param version: (required)
        :type version: float
        :param retailer_id: The ID of the retailer (required)
        :type retailer_id: int
        :param name: The name of the retailer location (required)
        :type name: str
        :param street_address: The street address of the retailer location (required)
        :type street_address: str
        :param city: The city of the retailer location (required)
        :type city: str
        :param state: The state of the retailer location (required)
        :type state: str
        :param postal_code: The postal code of the retailer location (required)
        :type postal_code: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone number of the retailer location
        :type business_phone: str
        :param business_phone_ext: The business phone extension
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param internal_id: An internal identifier used by the retailer
        :type internal_id: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param logo: The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param latitude: the latitude of the retailer location
        :type latitude: float
        :param longitude: the longitude of the retailer location
        :type longitude: float
        :param building: 
        :type building: str
        :param google_place_id: the ID of the Google Place that this retailer location is assigned to
        :type google_place_id: str
        :param yelp_id: the Yelp ID that this retailer location is assigned to
        :type yelp_id: str
        :param active: whether the retailer location should be active or inactive
        :type active: bool
        :param public_location: Sets whether the location is public or not
        :type public_location: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param audience_ids: Comma separated list of audience IDs used to assign audiences to the retailer location
        :type audience_ids: str
        :param audience_ids_to_add: Comma separated list of audience IDs to add to the retailer location
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Comma separated list of audience IDs to remove from the retailer location
        :type audience_ids_to_remove: str
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param response_includes: Comma separated list of response includes (e.g. RETAILER,ASSETS,OFFERS,CATEGORIES,FILTERS,AUDIENCES,QRCODE)
        :type response_includes: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_locations_serialize(
            version=version,
            retailer_id=retailer_id,
            name=name,
            street_address=street_address,
            city=city,
            state=state,
            postal_code=postal_code,
            device_id=device_id,
            account_id=account_id,
            street_address2=street_address2,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            internal_id=internal_id,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            building=building,
            google_place_id=google_place_id,
            yelp_id=yelp_id,
            active=active,
            public_location=public_location,
            location_type=location_type,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            response_format=response_format,
            response_includes=response_includes,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_retailer_locations_serialize(
        self,
        version,
        retailer_id,
        name,
        street_address,
        city,
        state,
        postal_code,
        device_id,
        account_id,
        street_address2,
        country,
        business_phone,
        business_phone_ext,
        website,
        email,
        internal_id,
        details_header,
        details_body,
        hours,
        logo,
        logo_asset_id,
        picture1,
        picture1_asset_id,
        picture2,
        picture2_asset_id,
        category_ids,
        filter_ids,
        latitude,
        longitude,
        building,
        google_place_id,
        yelp_id,
        active,
        public_location,
        location_type,
        audience_ids,
        audience_ids_to_add,
        audience_ids_to_remove,
        response_format,
        response_includes,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if business_phone_ext is not None:
            
            _query_params.append(('businessPhoneExt', business_phone_ext))
            
        if website is not None:
            
            _query_params.append(('website', website))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if internal_id is not None:
            
            _query_params.append(('internalId', internal_id))
            
        if details_header is not None:
            
            _query_params.append(('detailsHeader', details_header))
            
        if details_body is not None:
            
            _query_params.append(('detailsBody', details_body))
            
        if hours is not None:
            
            _query_params.append(('hours', hours))
            
        if logo is not None:
            
            _query_params.append(('logo', logo))
            
        if logo_asset_id is not None:
            
            _query_params.append(('logoAssetId', logo_asset_id))
            
        if picture1 is not None:
            
            _query_params.append(('picture1', picture1))
            
        if picture1_asset_id is not None:
            
            _query_params.append(('picture1AssetId', picture1_asset_id))
            
        if picture2 is not None:
            
            _query_params.append(('picture2', picture2))
            
        if picture2_asset_id is not None:
            
            _query_params.append(('picture2AssetId', picture2_asset_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if building is not None:
            
            _query_params.append(('building', building))
            
        if google_place_id is not None:
            
            _query_params.append(('googlePlaceId', google_place_id))
            
        if yelp_id is not None:
            
            _query_params.append(('yelpId', yelp_id))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if public_location is not None:
            
            _query_params.append(('publicLocation', public_location))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if audience_ids_to_remove is not None:
            
            _query_params.append(('audienceIdsToRemove', audience_ids_to_remove))
            
        if response_format is not None:
            
            _query_params.append(('responseFormat', response_format))
            
        if response_includes is not None:
            
            _query_params.append(('responseIncludes', response_includes))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/location/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_retailer_location(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the logged in user")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location to delete")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Retailer Location

        Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.

        :param version: (required)
        :type version: float
        :param device_id: the device id
        :type device_id: str
        :param account_id: the id of the logged in user
        :type account_id: int
        :param retailer_location_id: the id of the retailer location to delete
        :type retailer_location_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_retailer_location_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            retailer_location_id=retailer_location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_retailer_location_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the logged in user")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location to delete")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Retailer Location

        Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.

        :param version: (required)
        :type version: float
        :param device_id: the device id
        :type device_id: str
        :param account_id: the id of the logged in user
        :type account_id: int
        :param retailer_location_id: the id of the retailer location to delete
        :type retailer_location_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_retailer_location_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            retailer_location_id=retailer_location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_retailer_location_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the logged in user")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location to delete")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Retailer Location

        Set the deleted timestamp to current time. This effectively deletes the retailer location since all queries should ignore any records with a deleted time stamp.

        :param version: (required)
        :type version: float
        :param device_id: the device id
        :type device_id: str
        :param account_id: the id of the logged in user
        :type account_id: int
        :param retailer_location_id: the id of the retailer location to delete
        :type retailer_location_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_retailer_location_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            retailer_location_id=retailer_location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_retailer_location_serialize(
        self,
        version,
        device_id,
        account_id,
        retailer_location_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/location/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_retailer_location(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The ID of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        retailer_location_token: Annotated[Optional[StrictStr], Field(description="the unique token of the retailer location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerLocationResponse:
        """Get Retailer Location

        Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The ID of the retailer location (required)
        :type retailer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param retailer_location_token: the unique token of the retailer location
        :type retailer_location_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_location_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            retailer_location_token=retailer_location_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_retailer_location_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The ID of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        retailer_location_token: Annotated[Optional[StrictStr], Field(description="the unique token of the retailer location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerLocationResponse]:
        """Get Retailer Location

        Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The ID of the retailer location (required)
        :type retailer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param retailer_location_token: the unique token of the retailer location
        :type retailer_location_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_location_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            retailer_location_token=retailer_location_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_retailer_location_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The ID of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        retailer_location_token: Annotated[Optional[StrictStr], Field(description="the unique token of the retailer location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Retailer Location

        Gets a retailer location. Only the owner and the employees of the retailer have access to view its information.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The ID of the retailer location (required)
        :type retailer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param retailer_location_token: the unique token of the retailer location
        :type retailer_location_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_location_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            retailer_location_token=retailer_location_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_retailer_location_serialize(
        self,
        version,
        retailer_location_id,
        device_id,
        account_id,
        retailer_location_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if retailer_location_token is not None:
            
            _query_params.append(('retailerLocationToken', retailer_location_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/retailer/location/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_retailer_location_consumer(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The retailer location id")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. favorites)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. favorites)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerLocationResponse:
        """Get Retailer Location (Consumer)

        Gets the details of a retailer location as a consumer.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The retailer location id (required)
        :type retailer_location_id: int
        :param device_id: The device id for returning account information (i.e. favorites)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. favorites)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_location_consumer_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_retailer_location_consumer_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The retailer location id")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. favorites)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. favorites)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerLocationResponse]:
        """Get Retailer Location (Consumer)

        Gets the details of a retailer location as a consumer.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The retailer location id (required)
        :type retailer_location_id: int
        :param device_id: The device id for returning account information (i.e. favorites)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. favorites)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_location_consumer_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_retailer_location_consumer_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The retailer location id")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. favorites)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. favorites)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Retailer Location (Consumer)

        Gets the details of a retailer location as a consumer.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The retailer location id (required)
        :type retailer_location_id: int
        :param device_id: The device id for returning account information (i.e. favorites)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. favorites)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_location_consumer_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_retailer_location_consumer_serialize(
        self,
        version,
        retailer_location_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/location/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def indexed_retailer_location_distance_search(
        self,
        version: Union[StrictFloat, StrictInt],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude to center the search on")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude to center the search on")],
        search_range: Annotated[Union[StrictFloat, StrictInt], Field(description="The search range in the distanceUnit specified; default is MILES.")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Used to return results using this address as the center")] = None,
        has_offers: Annotated[Optional[StrictBool], Field(description="boolean to indicate whether to include retailer locations that have no offers")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        audiences: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Search by keyword")] = None,
        keyword_operator: Annotated[Optional[StrictStr], Field(description="Determines the operator used when there are multiple words in the 'keyword' parameter")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Search expression to further refine results")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Unit of distance")] = None,
        return_favorited: Annotated[Optional[StrictBool], Field(description="(deprecated) return favorited flag")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        return_external_category_data: Annotated[Optional[StrictBool], Field(description="Return external category data")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RetailerLocationResponse]:
        """Distance Search Retailer Locations (Indexed)

        Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.

        :param version: (required)
        :type version: float
        :param latitude: The latitude to center the search on (required)
        :type latitude: float
        :param longitude: The longitude to center the search on (required)
        :type longitude: float
        :param search_range: The search range in the distanceUnit specified; default is MILES. (required)
        :type search_range: float
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param account_id: The account id of the user
        :type account_id: int
        :param address: Used to return results using this address as the center
        :type address: str
        :param has_offers: boolean to indicate whether to include retailer locations that have no offers
        :type has_offers: bool
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param audiences: Comma separated list of audience ids
        :type audiences: str
        :param retailer_ids: Comma separated list of retailer ids
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location ids
        :type retailer_location_ids: str
        :param tags: Does a full-text search on tags
        :type tags: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: Search by keyword
        :type keyword: str
        :param keyword_operator: Determines the operator used when there are multiple words in the 'keyword' parameter
        :type keyword_operator: str
        :param search_expression: Search expression to further refine results
        :type search_expression: str
        :param distance_unit: Unit of distance
        :type distance_unit: str
        :param return_favorited: (deprecated) return favorited flag
        :type return_favorited: bool
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param return_external_category_data: Return external category data
        :type return_external_category_data: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._indexed_retailer_location_distance_search_serialize(
            version=version,
            latitude=latitude,
            longitude=longitude,
            search_range=search_range,
            start=start,
            limit=limit,
            account_id=account_id,
            address=address,
            has_offers=has_offers,
            categories=categories,
            filters=filters,
            audiences=audiences,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            tags=tags,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            q=q,
            keyword=keyword,
            keyword_operator=keyword_operator,
            search_expression=search_expression,
            distance_unit=distance_unit,
            return_favorited=return_favorited,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            return_external_category_data=return_external_category_data,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def indexed_retailer_location_distance_search_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude to center the search on")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude to center the search on")],
        search_range: Annotated[Union[StrictFloat, StrictInt], Field(description="The search range in the distanceUnit specified; default is MILES.")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Used to return results using this address as the center")] = None,
        has_offers: Annotated[Optional[StrictBool], Field(description="boolean to indicate whether to include retailer locations that have no offers")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        audiences: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Search by keyword")] = None,
        keyword_operator: Annotated[Optional[StrictStr], Field(description="Determines the operator used when there are multiple words in the 'keyword' parameter")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Search expression to further refine results")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Unit of distance")] = None,
        return_favorited: Annotated[Optional[StrictBool], Field(description="(deprecated) return favorited flag")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        return_external_category_data: Annotated[Optional[StrictBool], Field(description="Return external category data")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RetailerLocationResponse]]:
        """Distance Search Retailer Locations (Indexed)

        Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.

        :param version: (required)
        :type version: float
        :param latitude: The latitude to center the search on (required)
        :type latitude: float
        :param longitude: The longitude to center the search on (required)
        :type longitude: float
        :param search_range: The search range in the distanceUnit specified; default is MILES. (required)
        :type search_range: float
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param account_id: The account id of the user
        :type account_id: int
        :param address: Used to return results using this address as the center
        :type address: str
        :param has_offers: boolean to indicate whether to include retailer locations that have no offers
        :type has_offers: bool
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param audiences: Comma separated list of audience ids
        :type audiences: str
        :param retailer_ids: Comma separated list of retailer ids
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location ids
        :type retailer_location_ids: str
        :param tags: Does a full-text search on tags
        :type tags: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: Search by keyword
        :type keyword: str
        :param keyword_operator: Determines the operator used when there are multiple words in the 'keyword' parameter
        :type keyword_operator: str
        :param search_expression: Search expression to further refine results
        :type search_expression: str
        :param distance_unit: Unit of distance
        :type distance_unit: str
        :param return_favorited: (deprecated) return favorited flag
        :type return_favorited: bool
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param return_external_category_data: Return external category data
        :type return_external_category_data: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._indexed_retailer_location_distance_search_serialize(
            version=version,
            latitude=latitude,
            longitude=longitude,
            search_range=search_range,
            start=start,
            limit=limit,
            account_id=account_id,
            address=address,
            has_offers=has_offers,
            categories=categories,
            filters=filters,
            audiences=audiences,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            tags=tags,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            q=q,
            keyword=keyword,
            keyword_operator=keyword_operator,
            search_expression=search_expression,
            distance_unit=distance_unit,
            return_favorited=return_favorited,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            return_external_category_data=return_external_category_data,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def indexed_retailer_location_distance_search_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude to center the search on")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude to center the search on")],
        search_range: Annotated[Union[StrictFloat, StrictInt], Field(description="The search range in the distanceUnit specified; default is MILES.")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        address: Annotated[Optional[StrictStr], Field(description="Used to return results using this address as the center")] = None,
        has_offers: Annotated[Optional[StrictBool], Field(description="boolean to indicate whether to include retailer locations that have no offers")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        audiences: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Search by keyword")] = None,
        keyword_operator: Annotated[Optional[StrictStr], Field(description="Determines the operator used when there are multiple words in the 'keyword' parameter")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Search expression to further refine results")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Unit of distance")] = None,
        return_favorited: Annotated[Optional[StrictBool], Field(description="(deprecated) return favorited flag")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        return_external_category_data: Annotated[Optional[StrictBool], Field(description="Return external category data")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Distance Search Retailer Locations (Indexed)

        Retailer location indexed search by distance. This searches on any retailer location with location data and returns the results sorted by distance.

        :param version: (required)
        :type version: float
        :param latitude: The latitude to center the search on (required)
        :type latitude: float
        :param longitude: The longitude to center the search on (required)
        :type longitude: float
        :param search_range: The search range in the distanceUnit specified; default is MILES. (required)
        :type search_range: float
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param account_id: The account id of the user
        :type account_id: int
        :param address: Used to return results using this address as the center
        :type address: str
        :param has_offers: boolean to indicate whether to include retailer locations that have no offers
        :type has_offers: bool
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param audiences: Comma separated list of audience ids
        :type audiences: str
        :param retailer_ids: Comma separated list of retailer ids
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location ids
        :type retailer_location_ids: str
        :param tags: Does a full-text search on tags
        :type tags: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The field to sort the result set on. Possible values include: DISTANCE, RETAILER_NAME, RETAILER_LOCATION_NAME
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: Search by keyword
        :type keyword: str
        :param keyword_operator: Determines the operator used when there are multiple words in the 'keyword' parameter
        :type keyword_operator: str
        :param search_expression: Search expression to further refine results
        :type search_expression: str
        :param distance_unit: Unit of distance
        :type distance_unit: str
        :param return_favorited: (deprecated) return favorited flag
        :type return_favorited: bool
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param return_external_category_data: Return external category data
        :type return_external_category_data: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._indexed_retailer_location_distance_search_serialize(
            version=version,
            latitude=latitude,
            longitude=longitude,
            search_range=search_range,
            start=start,
            limit=limit,
            account_id=account_id,
            address=address,
            has_offers=has_offers,
            categories=categories,
            filters=filters,
            audiences=audiences,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            tags=tags,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            q=q,
            keyword=keyword,
            keyword_operator=keyword_operator,
            search_expression=search_expression,
            distance_unit=distance_unit,
            return_favorited=return_favorited,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            return_external_category_data=return_external_category_data,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _indexed_retailer_location_distance_search_serialize(
        self,
        version,
        latitude,
        longitude,
        search_range,
        start,
        limit,
        account_id,
        address,
        has_offers,
        categories,
        filters,
        audiences,
        retailer_ids,
        retailer_location_ids,
        tags,
        location_type,
        sort_field,
        descending,
        q,
        keyword,
        keyword_operator,
        search_expression,
        distance_unit,
        return_favorited,
        return_retailer,
        return_assets,
        return_offers,
        return_categories,
        return_filters,
        return_audiences,
        return_qr_code,
        return_external_category_data,
        include_favorite,
        include_liked,
        include_rating,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if address is not None:
            
            _query_params.append(('address', address))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if has_offers is not None:
            
            _query_params.append(('hasOffers', has_offers))
            
        if categories is not None:
            
            _query_params.append(('categories', categories))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if audiences is not None:
            
            _query_params.append(('audiences', audiences))
            
        if retailer_ids is not None:
            
            _query_params.append(('retailerIds', retailer_ids))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if keyword_operator is not None:
            
            _query_params.append(('keywordOperator', keyword_operator))
            
        if search_expression is not None:
            
            _query_params.append(('searchExpression', search_expression))
            
        if distance_unit is not None:
            
            _query_params.append(('distanceUnit', distance_unit))
            
        if return_favorited is not None:
            
            _query_params.append(('returnFavorited', return_favorited))
            
        if return_retailer is not None:
            
            _query_params.append(('returnRetailer', return_retailer))
            
        if return_assets is not None:
            
            _query_params.append(('returnAssets', return_assets))
            
        if return_offers is not None:
            
            _query_params.append(('returnOffers', return_offers))
            
        if return_categories is not None:
            
            _query_params.append(('returnCategories', return_categories))
            
        if return_filters is not None:
            
            _query_params.append(('returnFilters', return_filters))
            
        if return_audiences is not None:
            
            _query_params.append(('returnAudiences', return_audiences))
            
        if return_qr_code is not None:
            
            _query_params.append(('returnQrCode', return_qr_code))
            
        if return_external_category_data is not None:
            
            _query_params.append(('returnExternalCategoryData', return_external_category_data))
            
        if include_favorite is not None:
            
            _query_params.append(('includeFavorite', include_favorite))
            
        if include_liked is not None:
            
            _query_params.append(('includeLiked', include_liked))
            
        if include_rating is not None:
            
            _query_params.append(('includeRating', include_rating))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/retailer/location/idistancesearch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def indexed_retailer_location_search(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        has_offers: Annotated[Optional[StrictBool], Field(description="boolean to indicate whether to include retailer locations that have no offers")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        audiences: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Search by keyword")] = None,
        keyword_operator: Annotated[Optional[StrictStr], Field(description="Determines the operator used when there are multiple words in the 'keyword' parameter")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Search expression to further refine results")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        return_external_category_data: Annotated[Optional[StrictBool], Field(description="Return external category data")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RetailerLocationResponse]:
        """Keyword Search Retailer Locations (Indexed)

        Retailer location (faster) indexed search. This searches all retailer locations.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user
        :type account_id: int
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param has_offers: boolean to indicate whether to include retailer locations that have no offers
        :type has_offers: bool
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param audiences: Comma separated list of audience ids
        :type audiences: str
        :param retailer_ids: Comma separated list of retailer ids
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location ids
        :type retailer_location_ids: str
        :param tags: Does a full-text search on tags
        :type tags: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: Search by keyword
        :type keyword: str
        :param keyword_operator: Determines the operator used when there are multiple words in the 'keyword' parameter
        :type keyword_operator: str
        :param search_expression: Search expression to further refine results
        :type search_expression: str
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param return_external_category_data: Return external category data
        :type return_external_category_data: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._indexed_retailer_location_search_serialize(
            version=version,
            account_id=account_id,
            start=start,
            limit=limit,
            has_offers=has_offers,
            categories=categories,
            filters=filters,
            audiences=audiences,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            tags=tags,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            q=q,
            keyword=keyword,
            keyword_operator=keyword_operator,
            search_expression=search_expression,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            return_external_category_data=return_external_category_data,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def indexed_retailer_location_search_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        has_offers: Annotated[Optional[StrictBool], Field(description="boolean to indicate whether to include retailer locations that have no offers")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        audiences: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Search by keyword")] = None,
        keyword_operator: Annotated[Optional[StrictStr], Field(description="Determines the operator used when there are multiple words in the 'keyword' parameter")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Search expression to further refine results")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        return_external_category_data: Annotated[Optional[StrictBool], Field(description="Return external category data")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RetailerLocationResponse]]:
        """Keyword Search Retailer Locations (Indexed)

        Retailer location (faster) indexed search. This searches all retailer locations.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user
        :type account_id: int
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param has_offers: boolean to indicate whether to include retailer locations that have no offers
        :type has_offers: bool
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param audiences: Comma separated list of audience ids
        :type audiences: str
        :param retailer_ids: Comma separated list of retailer ids
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location ids
        :type retailer_location_ids: str
        :param tags: Does a full-text search on tags
        :type tags: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: Search by keyword
        :type keyword: str
        :param keyword_operator: Determines the operator used when there are multiple words in the 'keyword' parameter
        :type keyword_operator: str
        :param search_expression: Search expression to further refine results
        :type search_expression: str
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param return_external_category_data: Return external category data
        :type return_external_category_data: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._indexed_retailer_location_search_serialize(
            version=version,
            account_id=account_id,
            start=start,
            limit=limit,
            has_offers=has_offers,
            categories=categories,
            filters=filters,
            audiences=audiences,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            tags=tags,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            q=q,
            keyword=keyword,
            keyword_operator=keyword_operator,
            search_expression=search_expression,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            return_external_category_data=return_external_category_data,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def indexed_retailer_location_search_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        has_offers: Annotated[Optional[StrictBool], Field(description="boolean to indicate whether to include retailer locations that have no offers")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        audiences: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Search by keyword")] = None,
        keyword_operator: Annotated[Optional[StrictStr], Field(description="Determines the operator used when there are multiple words in the 'keyword' parameter")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Search expression to further refine results")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        return_external_category_data: Annotated[Optional[StrictBool], Field(description="Return external category data")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Keyword Search Retailer Locations (Indexed)

        Retailer location (faster) indexed search. This searches all retailer locations.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user
        :type account_id: int
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param has_offers: boolean to indicate whether to include retailer locations that have no offers
        :type has_offers: bool
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param audiences: Comma separated list of audience ids
        :type audiences: str
        :param retailer_ids: Comma separated list of retailer ids
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location ids
        :type retailer_location_ids: str
        :param tags: Does a full-text search on tags
        :type tags: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The field to sort the result set on. Possible values include: RETAILER_NAME, RETAILER_LOCATION_NAME
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: Search by keyword
        :type keyword: str
        :param keyword_operator: Determines the operator used when there are multiple words in the 'keyword' parameter
        :type keyword_operator: str
        :param search_expression: Search expression to further refine results
        :type search_expression: str
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param return_external_category_data: Return external category data
        :type return_external_category_data: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._indexed_retailer_location_search_serialize(
            version=version,
            account_id=account_id,
            start=start,
            limit=limit,
            has_offers=has_offers,
            categories=categories,
            filters=filters,
            audiences=audiences,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            tags=tags,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            q=q,
            keyword=keyword,
            keyword_operator=keyword_operator,
            search_expression=search_expression,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            return_external_category_data=return_external_category_data,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _indexed_retailer_location_search_serialize(
        self,
        version,
        account_id,
        start,
        limit,
        has_offers,
        categories,
        filters,
        audiences,
        retailer_ids,
        retailer_location_ids,
        tags,
        location_type,
        sort_field,
        descending,
        q,
        keyword,
        keyword_operator,
        search_expression,
        return_retailer,
        return_assets,
        return_offers,
        return_categories,
        return_filters,
        return_audiences,
        return_qr_code,
        return_external_category_data,
        include_favorite,
        include_liked,
        include_rating,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if has_offers is not None:
            
            _query_params.append(('hasOffers', has_offers))
            
        if categories is not None:
            
            _query_params.append(('categories', categories))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if audiences is not None:
            
            _query_params.append(('audiences', audiences))
            
        if retailer_ids is not None:
            
            _query_params.append(('retailerIds', retailer_ids))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if keyword_operator is not None:
            
            _query_params.append(('keywordOperator', keyword_operator))
            
        if search_expression is not None:
            
            _query_params.append(('searchExpression', search_expression))
            
        if return_retailer is not None:
            
            _query_params.append(('returnRetailer', return_retailer))
            
        if return_assets is not None:
            
            _query_params.append(('returnAssets', return_assets))
            
        if return_offers is not None:
            
            _query_params.append(('returnOffers', return_offers))
            
        if return_categories is not None:
            
            _query_params.append(('returnCategories', return_categories))
            
        if return_filters is not None:
            
            _query_params.append(('returnFilters', return_filters))
            
        if return_audiences is not None:
            
            _query_params.append(('returnAudiences', return_audiences))
            
        if return_qr_code is not None:
            
            _query_params.append(('returnQrCode', return_qr_code))
            
        if return_external_category_data is not None:
            
            _query_params.append(('returnExternalCategoryData', return_external_category_data))
            
        if include_favorite is not None:
            
            _query_params.append(('includeFavorite', include_favorite))
            
        if include_liked is not None:
            
            _query_params.append(('includeLiked', include_liked))
            
        if include_rating is not None:
            
            _query_params.append(('includeRating', include_rating))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/retailer/location/isearch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_retailer_locations(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location IDs")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        show_public_locations: Annotated[Optional[StrictBool], Field(description="Whether to include public locations in the results")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RetailerLocationResponse]:
        """Search Retailer Locations (Owned)

        Searches on retailer locations that the account has access to.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_ids: Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location IDs
        :type retailer_location_ids: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: The record to begin the return set on
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: The number of records to return
        :type limit: int
        :param show_public_locations: Whether to include public locations in the results
        :type show_public_locations: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_retailer_locations_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            show_public_locations=show_public_locations,
            active_only=active_only,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_retailer_locations_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location IDs")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        show_public_locations: Annotated[Optional[StrictBool], Field(description="Whether to include public locations in the results")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RetailerLocationResponse]]:
        """Search Retailer Locations (Owned)

        Searches on retailer locations that the account has access to.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_ids: Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location IDs
        :type retailer_location_ids: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: The record to begin the return set on
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: The number of records to return
        :type limit: int
        :param show_public_locations: Whether to include public locations in the results
        :type show_public_locations: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_retailer_locations_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            show_public_locations=show_public_locations,
            active_only=active_only,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_retailer_locations_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location IDs")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="Location type filter")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        show_public_locations: Annotated[Optional[StrictBool], Field(description="Whether to include public locations in the results")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="Return retailer info")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="Return assets")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="Return offers")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="Return categories")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="Return filters")] = None,
        return_audiences: Annotated[Optional[StrictBool], Field(description="Return audiences")] = None,
        return_qr_code: Annotated[Optional[StrictBool], Field(description="Return QR code info")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="Include favorites in response")] = None,
        include_liked: Annotated[Optional[StrictBool], Field(description="Include liked flag in response")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="Include rating info in response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Retailer Locations (Owned)

        Searches on retailer locations that the account has access to.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_ids: Comma separated list of retailer IDs which when passed in will filter the results to only return these retailers.
        :type retailer_ids: str
        :param retailer_location_ids: Comma separated list of retailer location IDs
        :type retailer_location_ids: str
        :param location_type: Location type filter
        :type location_type: str
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: The record to begin the return set on
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: The number of records to return
        :type limit: int
        :param show_public_locations: Whether to include public locations in the results
        :type show_public_locations: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param return_retailer: Return retailer info
        :type return_retailer: bool
        :param return_assets: Return assets
        :type return_assets: bool
        :param return_offers: Return offers
        :type return_offers: bool
        :param return_categories: Return categories
        :type return_categories: bool
        :param return_filters: Return filters
        :type return_filters: bool
        :param return_audiences: Return audiences
        :type return_audiences: bool
        :param return_qr_code: Return QR code info
        :type return_qr_code: bool
        :param include_favorite: Include favorites in response
        :type include_favorite: bool
        :param include_liked: Include liked flag in response
        :type include_liked: bool
        :param include_rating: Include rating info in response
        :type include_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_retailer_locations_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            show_public_locations=show_public_locations,
            active_only=active_only,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            return_audiences=return_audiences,
            return_qr_code=return_qr_code,
            include_favorite=include_favorite,
            include_liked=include_liked,
            include_rating=include_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_retailer_locations_serialize(
        self,
        version,
        device_id,
        account_id,
        q,
        keyword,
        retailer_ids,
        retailer_location_ids,
        location_type,
        sort_field,
        descending,
        i,
        start,
        l,
        limit,
        show_public_locations,
        active_only,
        return_retailer,
        return_assets,
        return_offers,
        return_categories,
        return_filters,
        return_audiences,
        return_qr_code,
        include_favorite,
        include_liked,
        include_rating,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if retailer_ids is not None:
            
            _query_params.append(('retailerIds', retailer_ids))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if show_public_locations is not None:
            
            _query_params.append(('showPublicLocations', show_public_locations))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if return_retailer is not None:
            
            _query_params.append(('returnRetailer', return_retailer))
            
        if return_assets is not None:
            
            _query_params.append(('returnAssets', return_assets))
            
        if return_offers is not None:
            
            _query_params.append(('returnOffers', return_offers))
            
        if return_categories is not None:
            
            _query_params.append(('returnCategories', return_categories))
            
        if return_filters is not None:
            
            _query_params.append(('returnFilters', return_filters))
            
        if return_audiences is not None:
            
            _query_params.append(('returnAudiences', return_audiences))
            
        if return_qr_code is not None:
            
            _query_params.append(('returnQrCode', return_qr_code))
            
        if include_favorite is not None:
            
            _query_params.append(('includeFavorite', include_favorite))
            
        if include_liked is not None:
            
            _query_params.append(('includeLiked', include_liked))
            
        if include_rating is not None:
            
            _query_params.append(('includeRating', include_rating))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/retailer/location/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_retailer_locations(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The ID of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the retailer location")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer location")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer location")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        internal_id: Annotated[Optional[StrictStr], Field(description="An internal identifier used by the retailer")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latituede of the retailer location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer location")] = None,
        building: Optional[StrictStr] = None,
        google_place_id: Annotated[Optional[StrictStr], Field(description="the Google Place ID that the retailer location is associated with")] = None,
        yelp_id: Annotated[Optional[StrictStr], Field(description="the Yelp ID that the retailer location is associated with")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        payment_provider: Annotated[Optional[StrictStr], Field(description="Specifies which payment provider Sirqul will use when making payments")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the retailer is active or inactive (hidden from consumers)")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Sets whether the location is public or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs used to assign audiences to the retailer location")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to add to the retailer location")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to remove from the retailer location")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerLocationResponse:
        """Update Retailer Location

        Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The ID of the retailer location (required)
        :type retailer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the retailer location
        :type name: str
        :param street_address: The street address of the retailer location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer location
        :type city: str
        :param state: The state of the retailer location
        :type state: str
        :param postal_code: The postal code of the retailer location
        :type postal_code: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone number of the retailer location
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer location
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param internal_id: An internal identifier used by the retailer
        :type internal_id: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param logo: The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param latitude: the latituede of the retailer location
        :type latitude: float
        :param longitude: the longitude of the retailer location
        :type longitude: float
        :param building: 
        :type building: str
        :param google_place_id: the Google Place ID that the retailer location is associated with
        :type google_place_id: str
        :param yelp_id: the Yelp ID that the retailer location is associated with
        :type yelp_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param payment_provider: Specifies which payment provider Sirqul will use when making payments
        :type payment_provider: str
        :param active: Sets whether the retailer is active or inactive (hidden from consumers)
        :type active: bool
        :param public_location: Sets whether the location is public or not
        :type public_location: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param audience_ids: Comma separated list of audience IDs used to assign audiences to the retailer location
        :type audience_ids: str
        :param audience_ids_to_add: Comma separated list of audience IDs to add to the retailer location
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Comma separated list of audience IDs to remove from the retailer location
        :type audience_ids_to_remove: str
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_retailer_locations_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            internal_id=internal_id,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            building=building,
            google_place_id=google_place_id,
            yelp_id=yelp_id,
            meta_data=meta_data,
            payment_provider=payment_provider,
            active=active,
            public_location=public_location,
            location_type=location_type,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            response_format=response_format,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_retailer_locations_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The ID of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the retailer location")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer location")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer location")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        internal_id: Annotated[Optional[StrictStr], Field(description="An internal identifier used by the retailer")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latituede of the retailer location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer location")] = None,
        building: Optional[StrictStr] = None,
        google_place_id: Annotated[Optional[StrictStr], Field(description="the Google Place ID that the retailer location is associated with")] = None,
        yelp_id: Annotated[Optional[StrictStr], Field(description="the Yelp ID that the retailer location is associated with")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        payment_provider: Annotated[Optional[StrictStr], Field(description="Specifies which payment provider Sirqul will use when making payments")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the retailer is active or inactive (hidden from consumers)")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Sets whether the location is public or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs used to assign audiences to the retailer location")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to add to the retailer location")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to remove from the retailer location")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerLocationResponse]:
        """Update Retailer Location

        Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The ID of the retailer location (required)
        :type retailer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the retailer location
        :type name: str
        :param street_address: The street address of the retailer location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer location
        :type city: str
        :param state: The state of the retailer location
        :type state: str
        :param postal_code: The postal code of the retailer location
        :type postal_code: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone number of the retailer location
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer location
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param internal_id: An internal identifier used by the retailer
        :type internal_id: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param logo: The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param latitude: the latituede of the retailer location
        :type latitude: float
        :param longitude: the longitude of the retailer location
        :type longitude: float
        :param building: 
        :type building: str
        :param google_place_id: the Google Place ID that the retailer location is associated with
        :type google_place_id: str
        :param yelp_id: the Yelp ID that the retailer location is associated with
        :type yelp_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param payment_provider: Specifies which payment provider Sirqul will use when making payments
        :type payment_provider: str
        :param active: Sets whether the retailer is active or inactive (hidden from consumers)
        :type active: bool
        :param public_location: Sets whether the location is public or not
        :type public_location: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param audience_ids: Comma separated list of audience IDs used to assign audiences to the retailer location
        :type audience_ids: str
        :param audience_ids_to_add: Comma separated list of audience IDs to add to the retailer location
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Comma separated list of audience IDs to remove from the retailer location
        :type audience_ids_to_remove: str
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_retailer_locations_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            internal_id=internal_id,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            building=building,
            google_place_id=google_place_id,
            yelp_id=yelp_id,
            meta_data=meta_data,
            payment_provider=payment_provider,
            active=active,
            public_location=public_location,
            location_type=location_type,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            response_format=response_format,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_retailer_locations_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_location_id: Annotated[StrictInt, Field(description="The ID of the retailer location")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the retailer location")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer location")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer location")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer location")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer location")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer location")] = None,
        internal_id: Annotated[Optional[StrictStr], Field(description="An internal identifier used by the retailer")] = None,
        details_header: Annotated[Optional[StrictStr], Field(description="A brief description about the retailer location (255 character limit)")] = None,
        details_body: Annotated[Optional[StrictStr], Field(description="A detailed description about the retailer location")] = None,
        hours: Annotated[Optional[StrictStr], Field(description="The hours of operation")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer location logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailer locations by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailer locations")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latituede of the retailer location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer location")] = None,
        building: Optional[StrictStr] = None,
        google_place_id: Annotated[Optional[StrictStr], Field(description="the Google Place ID that the retailer location is associated with")] = None,
        yelp_id: Annotated[Optional[StrictStr], Field(description="the Yelp ID that the retailer location is associated with")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        payment_provider: Annotated[Optional[StrictStr], Field(description="Specifies which payment provider Sirqul will use when making payments")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the retailer is active or inactive (hidden from consumers)")] = None,
        public_location: Annotated[Optional[StrictBool], Field(description="Sets whether the location is public or not")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs used to assign audiences to the retailer location")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to add to the retailer location")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience IDs to remove from the retailer location")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Retailer Location

        Updates a location record for a retailer. Only the owner and the employees of the retailer have access to do this.

        :param version: (required)
        :type version: float
        :param retailer_location_id: The ID of the retailer location (required)
        :type retailer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the retailer location
        :type name: str
        :param street_address: The street address of the retailer location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer location
        :type city: str
        :param state: The state of the retailer location
        :type state: str
        :param postal_code: The postal code of the retailer location
        :type postal_code: str
        :param country: the country of the retailer location
        :type country: str
        :param business_phone: The business phone number of the retailer location
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer location
        :type business_phone_ext: str
        :param website: The website of the retailer location
        :type website: str
        :param email: The email of the retailer location
        :type email: str
        :param internal_id: An internal identifier used by the retailer
        :type internal_id: str
        :param details_header: A brief description about the retailer location (255 character limit)
        :type details_header: str
        :param details_body: A detailed description about the retailer location
        :type details_body: str
        :param hours: The hours of operation
        :type hours: str
        :param logo: The retailer location logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer location logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailer locations by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailer locations
        :type filter_ids: str
        :param latitude: the latituede of the retailer location
        :type latitude: float
        :param longitude: the longitude of the retailer location
        :type longitude: float
        :param building: 
        :type building: str
        :param google_place_id: the Google Place ID that the retailer location is associated with
        :type google_place_id: str
        :param yelp_id: the Yelp ID that the retailer location is associated with
        :type yelp_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param payment_provider: Specifies which payment provider Sirqul will use when making payments
        :type payment_provider: str
        :param active: Sets whether the retailer is active or inactive (hidden from consumers)
        :type active: bool
        :param public_location: Sets whether the location is public or not
        :type public_location: bool
        :param location_type: External custom type identifier
        :type location_type: str
        :param audience_ids: Comma separated list of audience IDs used to assign audiences to the retailer location
        :type audience_ids: str
        :param audience_ids_to_add: Comma separated list of audience IDs to add to the retailer location
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Comma separated list of audience IDs to remove from the retailer location
        :type audience_ids_to_remove: str
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_retailer_locations_serialize(
            version=version,
            retailer_location_id=retailer_location_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            internal_id=internal_id,
            details_header=details_header,
            details_body=details_body,
            hours=hours,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            building=building,
            google_place_id=google_place_id,
            yelp_id=yelp_id,
            meta_data=meta_data,
            payment_provider=payment_provider,
            active=active,
            public_location=public_location,
            location_type=location_type,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            response_format=response_format,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_retailer_locations_serialize(
        self,
        version,
        retailer_location_id,
        device_id,
        account_id,
        name,
        street_address,
        street_address2,
        city,
        state,
        postal_code,
        country,
        business_phone,
        business_phone_ext,
        website,
        email,
        internal_id,
        details_header,
        details_body,
        hours,
        logo,
        logo_asset_id,
        picture1,
        picture1_asset_id,
        picture2,
        picture2_asset_id,
        category_ids,
        filter_ids,
        latitude,
        longitude,
        building,
        google_place_id,
        yelp_id,
        meta_data,
        payment_provider,
        active,
        public_location,
        location_type,
        audience_ids,
        audience_ids_to_add,
        audience_ids_to_remove,
        response_format,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if business_phone_ext is not None:
            
            _query_params.append(('businessPhoneExt', business_phone_ext))
            
        if website is not None:
            
            _query_params.append(('website', website))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if internal_id is not None:
            
            _query_params.append(('internalId', internal_id))
            
        if details_header is not None:
            
            _query_params.append(('detailsHeader', details_header))
            
        if details_body is not None:
            
            _query_params.append(('detailsBody', details_body))
            
        if hours is not None:
            
            _query_params.append(('hours', hours))
            
        if logo is not None:
            
            _query_params.append(('logo', logo))
            
        if logo_asset_id is not None:
            
            _query_params.append(('logoAssetId', logo_asset_id))
            
        if picture1 is not None:
            
            _query_params.append(('picture1', picture1))
            
        if picture1_asset_id is not None:
            
            _query_params.append(('picture1AssetId', picture1_asset_id))
            
        if picture2 is not None:
            
            _query_params.append(('picture2', picture2))
            
        if picture2_asset_id is not None:
            
            _query_params.append(('picture2AssetId', picture2_asset_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if building is not None:
            
            _query_params.append(('building', building))
            
        if google_place_id is not None:
            
            _query_params.append(('googlePlaceId', google_place_id))
            
        if yelp_id is not None:
            
            _query_params.append(('yelpId', yelp_id))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if payment_provider is not None:
            
            _query_params.append(('paymentProvider', payment_provider))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if public_location is not None:
            
            _query_params.append(('publicLocation', public_location))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if audience_ids_to_remove is not None:
            
            _query_params.append(('audienceIdsToRemove', audience_ids_to_remove))
            
        if response_format is not None:
            
            _query_params.append(('responseFormat', response_format))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/location/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


