# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.account_login_response import AccountLoginResponse
from openapi_client.models.asset_list_response import AssetListResponse
from openapi_client.models.profile_info_response import ProfileInfoResponse
from openapi_client.models.profile_response import ProfileResponse
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.user_location_search_response import UserLocationSearchResponse
from openapi_client.models.user_settings_response import UserSettingsResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AccountApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def account_location_search(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Deprecated - legacy query parameter")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="An optional keyword to search on, will be ignore if empty (NOT implemented yet)")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code to search on, either postalCode or the user's exact location is required")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the user, either postalCode or the user's exact location is required")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the user, either postalCode or the user's exact location is required")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range to search on")] = None,
        location_last_updated: Annotated[Optional[StrictInt], Field(description="Searches for user's that has updated their location since this date")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The preferred gender")] = None,
        min_age: Annotated[Optional[StrictInt], Field(description="The preferred min age")] = None,
        max_age: Annotated[Optional[StrictInt], Field(description="The preferred max age")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The preferred companionship index")] = None,
        i: Annotated[Optional[StrictInt], Field(description="this is the start index of a query")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="this is the limit index of a query")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit of the pagination")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Sorting field for results (default: DISTANCE)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Whether to sort descending (default: false)")] = None,
        roles: Annotated[Optional[StrictStr], Field(description="Roles to filter on")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Tags to filter on")] = None,
        experience: Annotated[Optional[StrictStr], Field(description="The experience to filter on")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The category ids to filter on (comma separated)")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audience ids to filter on (comma separated)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="Operator used to combine audience filters (default: AND)")] = None,
        update_current_location: Annotated[Optional[StrictBool], Field(description="Whether to use the given lat & long to update the user's current location")] = None,
        update_preferred_settings: Annotated[Optional[StrictBool], Field(description="Whether to use the given parameters to update the user's preferred settings")] = None,
        show_exact_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to always display user exact locations")] = None,
        show_connection_to_searcher: Annotated[Optional[StrictBool], Field(description="Return connection of the accounts in the result to the passed in account if there exists any")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)")] = None,
        verified_user_only: Annotated[Optional[StrictBool], Field(description="Returns only verified users")] = None,
        content_admin_only: Annotated[Optional[StrictBool], Field(description="Returns only content admin users")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UserLocationSearchResponse:
        """Search Accounts by Location

        Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: Deprecated - legacy query parameter
        :type q: str
        :param keyword: An optional keyword to search on, will be ignore if empty (NOT implemented yet)
        :type keyword: str
        :param postal_code: The postal code to search on, either postalCode or the user's exact location is required
        :type postal_code: str
        :param latitude: The latitude of the user, either postalCode or the user's exact location is required
        :type latitude: float
        :param longitude: The longitude of the user, either postalCode or the user's exact location is required
        :type longitude: float
        :param app_key: The application key
        :type app_key: str
        :param range: The range to search on
        :type range: float
        :param location_last_updated: Searches for user's that has updated their location since this date
        :type location_last_updated: int
        :param gender: The preferred gender
        :type gender: str
        :param min_age: The preferred min age
        :type min_age: int
        :param max_age: The preferred max age
        :type max_age: int
        :param companionship_index: The preferred companionship index
        :type companionship_index: int
        :param i: this is the start index of a query
        :type i: int
        :param start: Start of the pagination
        :type start: int
        :param l: this is the limit index of a query
        :type l: int
        :param limit: Limit of the pagination
        :type limit: int
        :param search_mode: Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)
        :type search_mode: str
        :param sort_field: Sorting field for results (default: DISTANCE)
        :type sort_field: str
        :param descending: Whether to sort descending (default: false)
        :type descending: bool
        :param roles: Roles to filter on
        :type roles: str
        :param tags: Tags to filter on
        :type tags: str
        :param experience: The experience to filter on
        :type experience: str
        :param category_ids: The category ids to filter on (comma separated)
        :type category_ids: str
        :param audience_ids: The audience ids to filter on (comma separated)
        :type audience_ids: str
        :param audience_operator: Operator used to combine audience filters (default: AND)
        :type audience_operator: str
        :param update_current_location: Whether to use the given lat & long to update the user's current location
        :type update_current_location: bool
        :param update_preferred_settings: Whether to use the given parameters to update the user's preferred settings
        :type update_preferred_settings: bool
        :param show_exact_locations: Determines whether to always display user exact locations
        :type show_exact_locations: bool
        :param show_connection_to_searcher: Return connection of the accounts in the result to the passed in account if there exists any
        :type show_connection_to_searcher: bool
        :param flag_count_minimum: Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        :type flag_count_minimum: int
        :param verified_user_only: Returns only verified users
        :type verified_user_only: bool
        :param content_admin_only: Returns only content admin users
        :type content_admin_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_location_search_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            postal_code=postal_code,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            range=range,
            location_last_updated=location_last_updated,
            gender=gender,
            min_age=min_age,
            max_age=max_age,
            companionship_index=companionship_index,
            i=i,
            start=start,
            l=l,
            limit=limit,
            search_mode=search_mode,
            sort_field=sort_field,
            descending=descending,
            roles=roles,
            tags=tags,
            experience=experience,
            category_ids=category_ids,
            audience_ids=audience_ids,
            audience_operator=audience_operator,
            update_current_location=update_current_location,
            update_preferred_settings=update_preferred_settings,
            show_exact_locations=show_exact_locations,
            show_connection_to_searcher=show_connection_to_searcher,
            flag_count_minimum=flag_count_minimum,
            verified_user_only=verified_user_only,
            content_admin_only=content_admin_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserLocationSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def account_location_search_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Deprecated - legacy query parameter")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="An optional keyword to search on, will be ignore if empty (NOT implemented yet)")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code to search on, either postalCode or the user's exact location is required")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the user, either postalCode or the user's exact location is required")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the user, either postalCode or the user's exact location is required")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range to search on")] = None,
        location_last_updated: Annotated[Optional[StrictInt], Field(description="Searches for user's that has updated their location since this date")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The preferred gender")] = None,
        min_age: Annotated[Optional[StrictInt], Field(description="The preferred min age")] = None,
        max_age: Annotated[Optional[StrictInt], Field(description="The preferred max age")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The preferred companionship index")] = None,
        i: Annotated[Optional[StrictInt], Field(description="this is the start index of a query")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="this is the limit index of a query")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit of the pagination")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Sorting field for results (default: DISTANCE)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Whether to sort descending (default: false)")] = None,
        roles: Annotated[Optional[StrictStr], Field(description="Roles to filter on")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Tags to filter on")] = None,
        experience: Annotated[Optional[StrictStr], Field(description="The experience to filter on")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The category ids to filter on (comma separated)")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audience ids to filter on (comma separated)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="Operator used to combine audience filters (default: AND)")] = None,
        update_current_location: Annotated[Optional[StrictBool], Field(description="Whether to use the given lat & long to update the user's current location")] = None,
        update_preferred_settings: Annotated[Optional[StrictBool], Field(description="Whether to use the given parameters to update the user's preferred settings")] = None,
        show_exact_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to always display user exact locations")] = None,
        show_connection_to_searcher: Annotated[Optional[StrictBool], Field(description="Return connection of the accounts in the result to the passed in account if there exists any")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)")] = None,
        verified_user_only: Annotated[Optional[StrictBool], Field(description="Returns only verified users")] = None,
        content_admin_only: Annotated[Optional[StrictBool], Field(description="Returns only content admin users")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UserLocationSearchResponse]:
        """Search Accounts by Location

        Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: Deprecated - legacy query parameter
        :type q: str
        :param keyword: An optional keyword to search on, will be ignore if empty (NOT implemented yet)
        :type keyword: str
        :param postal_code: The postal code to search on, either postalCode or the user's exact location is required
        :type postal_code: str
        :param latitude: The latitude of the user, either postalCode or the user's exact location is required
        :type latitude: float
        :param longitude: The longitude of the user, either postalCode or the user's exact location is required
        :type longitude: float
        :param app_key: The application key
        :type app_key: str
        :param range: The range to search on
        :type range: float
        :param location_last_updated: Searches for user's that has updated their location since this date
        :type location_last_updated: int
        :param gender: The preferred gender
        :type gender: str
        :param min_age: The preferred min age
        :type min_age: int
        :param max_age: The preferred max age
        :type max_age: int
        :param companionship_index: The preferred companionship index
        :type companionship_index: int
        :param i: this is the start index of a query
        :type i: int
        :param start: Start of the pagination
        :type start: int
        :param l: this is the limit index of a query
        :type l: int
        :param limit: Limit of the pagination
        :type limit: int
        :param search_mode: Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)
        :type search_mode: str
        :param sort_field: Sorting field for results (default: DISTANCE)
        :type sort_field: str
        :param descending: Whether to sort descending (default: false)
        :type descending: bool
        :param roles: Roles to filter on
        :type roles: str
        :param tags: Tags to filter on
        :type tags: str
        :param experience: The experience to filter on
        :type experience: str
        :param category_ids: The category ids to filter on (comma separated)
        :type category_ids: str
        :param audience_ids: The audience ids to filter on (comma separated)
        :type audience_ids: str
        :param audience_operator: Operator used to combine audience filters (default: AND)
        :type audience_operator: str
        :param update_current_location: Whether to use the given lat & long to update the user's current location
        :type update_current_location: bool
        :param update_preferred_settings: Whether to use the given parameters to update the user's preferred settings
        :type update_preferred_settings: bool
        :param show_exact_locations: Determines whether to always display user exact locations
        :type show_exact_locations: bool
        :param show_connection_to_searcher: Return connection of the accounts in the result to the passed in account if there exists any
        :type show_connection_to_searcher: bool
        :param flag_count_minimum: Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        :type flag_count_minimum: int
        :param verified_user_only: Returns only verified users
        :type verified_user_only: bool
        :param content_admin_only: Returns only content admin users
        :type content_admin_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_location_search_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            postal_code=postal_code,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            range=range,
            location_last_updated=location_last_updated,
            gender=gender,
            min_age=min_age,
            max_age=max_age,
            companionship_index=companionship_index,
            i=i,
            start=start,
            l=l,
            limit=limit,
            search_mode=search_mode,
            sort_field=sort_field,
            descending=descending,
            roles=roles,
            tags=tags,
            experience=experience,
            category_ids=category_ids,
            audience_ids=audience_ids,
            audience_operator=audience_operator,
            update_current_location=update_current_location,
            update_preferred_settings=update_preferred_settings,
            show_exact_locations=show_exact_locations,
            show_connection_to_searcher=show_connection_to_searcher,
            flag_count_minimum=flag_count_minimum,
            verified_user_only=verified_user_only,
            content_admin_only=content_admin_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserLocationSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def account_location_search_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Deprecated - legacy query parameter")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="An optional keyword to search on, will be ignore if empty (NOT implemented yet)")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code to search on, either postalCode or the user's exact location is required")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude of the user, either postalCode or the user's exact location is required")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude of the user, either postalCode or the user's exact location is required")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range to search on")] = None,
        location_last_updated: Annotated[Optional[StrictInt], Field(description="Searches for user's that has updated their location since this date")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The preferred gender")] = None,
        min_age: Annotated[Optional[StrictInt], Field(description="The preferred min age")] = None,
        max_age: Annotated[Optional[StrictInt], Field(description="The preferred max age")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The preferred companionship index")] = None,
        i: Annotated[Optional[StrictInt], Field(description="this is the start index of a query")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="this is the limit index of a query")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit of the pagination")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Sorting field for results (default: DISTANCE)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Whether to sort descending (default: false)")] = None,
        roles: Annotated[Optional[StrictStr], Field(description="Roles to filter on")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Tags to filter on")] = None,
        experience: Annotated[Optional[StrictStr], Field(description="The experience to filter on")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The category ids to filter on (comma separated)")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audience ids to filter on (comma separated)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="Operator used to combine audience filters (default: AND)")] = None,
        update_current_location: Annotated[Optional[StrictBool], Field(description="Whether to use the given lat & long to update the user's current location")] = None,
        update_preferred_settings: Annotated[Optional[StrictBool], Field(description="Whether to use the given parameters to update the user's preferred settings")] = None,
        show_exact_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to always display user exact locations")] = None,
        show_connection_to_searcher: Annotated[Optional[StrictBool], Field(description="Return connection of the accounts in the result to the passed in account if there exists any")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)")] = None,
        verified_user_only: Annotated[Optional[StrictBool], Field(description="Returns only verified users")] = None,
        content_admin_only: Annotated[Optional[StrictBool], Field(description="Returns only content admin users")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Accounts by Location

        Search accounts by their location. This only searches on users that have location data. Use ConnectionApi to perform a regular search on accounts.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: Deprecated - legacy query parameter
        :type q: str
        :param keyword: An optional keyword to search on, will be ignore if empty (NOT implemented yet)
        :type keyword: str
        :param postal_code: The postal code to search on, either postalCode or the user's exact location is required
        :type postal_code: str
        :param latitude: The latitude of the user, either postalCode or the user's exact location is required
        :type latitude: float
        :param longitude: The longitude of the user, either postalCode or the user's exact location is required
        :type longitude: float
        :param app_key: The application key
        :type app_key: str
        :param range: The range to search on
        :type range: float
        :param location_last_updated: Searches for user's that has updated their location since this date
        :type location_last_updated: int
        :param gender: The preferred gender
        :type gender: str
        :param min_age: The preferred min age
        :type min_age: int
        :param max_age: The preferred max age
        :type max_age: int
        :param companionship_index: The preferred companionship index
        :type companionship_index: int
        :param i: this is the start index of a query
        :type i: int
        :param start: Start of the pagination
        :type start: int
        :param l: this is the limit index of a query
        :type l: int
        :param limit: Limit of the pagination
        :type limit: int
        :param search_mode: Search mode to use for index searches (e.g. CLOUDINDEX, OPENSEARCH)
        :type search_mode: str
        :param sort_field: Sorting field for results (default: DISTANCE)
        :type sort_field: str
        :param descending: Whether to sort descending (default: false)
        :type descending: bool
        :param roles: Roles to filter on
        :type roles: str
        :param tags: Tags to filter on
        :type tags: str
        :param experience: The experience to filter on
        :type experience: str
        :param category_ids: The category ids to filter on (comma separated)
        :type category_ids: str
        :param audience_ids: The audience ids to filter on (comma separated)
        :type audience_ids: str
        :param audience_operator: Operator used to combine audience filters (default: AND)
        :type audience_operator: str
        :param update_current_location: Whether to use the given lat & long to update the user's current location
        :type update_current_location: bool
        :param update_preferred_settings: Whether to use the given parameters to update the user's preferred settings
        :type update_preferred_settings: bool
        :param show_exact_locations: Determines whether to always display user exact locations
        :type show_exact_locations: bool
        :param show_connection_to_searcher: Return connection of the accounts in the result to the passed in account if there exists any
        :type show_connection_to_searcher: bool
        :param flag_count_minimum: Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        :type flag_count_minimum: int
        :param verified_user_only: Returns only verified users
        :type verified_user_only: bool
        :param content_admin_only: Returns only content admin users
        :type content_admin_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._account_location_search_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            postal_code=postal_code,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            range=range,
            location_last_updated=location_last_updated,
            gender=gender,
            min_age=min_age,
            max_age=max_age,
            companionship_index=companionship_index,
            i=i,
            start=start,
            l=l,
            limit=limit,
            search_mode=search_mode,
            sort_field=sort_field,
            descending=descending,
            roles=roles,
            tags=tags,
            experience=experience,
            category_ids=category_ids,
            audience_ids=audience_ids,
            audience_operator=audience_operator,
            update_current_location=update_current_location,
            update_preferred_settings=update_preferred_settings,
            show_exact_locations=show_exact_locations,
            show_connection_to_searcher=show_connection_to_searcher,
            flag_count_minimum=flag_count_minimum,
            verified_user_only=verified_user_only,
            content_admin_only=content_admin_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserLocationSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _account_location_search_serialize(
        self,
        version,
        device_id,
        account_id,
        q,
        keyword,
        postal_code,
        latitude,
        longitude,
        app_key,
        range,
        location_last_updated,
        gender,
        min_age,
        max_age,
        companionship_index,
        i,
        start,
        l,
        limit,
        search_mode,
        sort_field,
        descending,
        roles,
        tags,
        experience,
        category_ids,
        audience_ids,
        audience_operator,
        update_current_location,
        update_preferred_settings,
        show_exact_locations,
        show_connection_to_searcher,
        flag_count_minimum,
        verified_user_only,
        content_admin_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if range is not None:
            
            _query_params.append(('range', range))
            
        if location_last_updated is not None:
            
            _query_params.append(('locationLastUpdated', location_last_updated))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if min_age is not None:
            
            _query_params.append(('minAge', min_age))
            
        if max_age is not None:
            
            _query_params.append(('maxAge', max_age))
            
        if companionship_index is not None:
            
            _query_params.append(('companionshipIndex', companionship_index))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if search_mode is not None:
            
            _query_params.append(('searchMode', search_mode))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if roles is not None:
            
            _query_params.append(('roles', roles))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if experience is not None:
            
            _query_params.append(('experience', experience))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if audience_operator is not None:
            
            _query_params.append(('audienceOperator', audience_operator))
            
        if update_current_location is not None:
            
            _query_params.append(('updateCurrentLocation', update_current_location))
            
        if update_preferred_settings is not None:
            
            _query_params.append(('updatePreferredSettings', update_preferred_settings))
            
        if show_exact_locations is not None:
            
            _query_params.append(('showExactLocations', show_exact_locations))
            
        if show_connection_to_searcher is not None:
            
            _query_params.append(('showConnectionToSearcher', show_connection_to_searcher))
            
        if flag_count_minimum is not None:
            
            _query_params.append(('flagCountMinimum', flag_count_minimum))
            
        if verified_user_only is not None:
            
            _query_params.append(('verifiedUserOnly', verified_user_only))
            
        if content_admin_only is not None:
            
            _query_params.append(('contentAdminOnly', content_admin_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def block_account(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id_being_blocked: Annotated[StrictInt, Field(description="The id of the account to be blocked/unblocked")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        block_flag_value: Annotated[Optional[StrictBool], Field(description="Determines whether the account is blocked or unblocked")] = None,
        remove_from_groups_if_blocked: Annotated[Optional[StrictBool], Field(description="Determines whether the account is removed from all other groups if blocked")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Block Account

        Moves or removes an account into the user's blocked group.

        :param version: (required)
        :type version: float
        :param account_id_being_blocked: The id of the account to be blocked/unblocked (required)
        :type account_id_being_blocked: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param block_flag_value: Determines whether the account is blocked or unblocked
        :type block_flag_value: bool
        :param remove_from_groups_if_blocked: Determines whether the account is removed from all other groups if blocked
        :type remove_from_groups_if_blocked: bool
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_account_serialize(
            version=version,
            account_id_being_blocked=account_id_being_blocked,
            device_id=device_id,
            account_id=account_id,
            block_flag_value=block_flag_value,
            remove_from_groups_if_blocked=remove_from_groups_if_blocked,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def block_account_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id_being_blocked: Annotated[StrictInt, Field(description="The id of the account to be blocked/unblocked")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        block_flag_value: Annotated[Optional[StrictBool], Field(description="Determines whether the account is blocked or unblocked")] = None,
        remove_from_groups_if_blocked: Annotated[Optional[StrictBool], Field(description="Determines whether the account is removed from all other groups if blocked")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Block Account

        Moves or removes an account into the user's blocked group.

        :param version: (required)
        :type version: float
        :param account_id_being_blocked: The id of the account to be blocked/unblocked (required)
        :type account_id_being_blocked: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param block_flag_value: Determines whether the account is blocked or unblocked
        :type block_flag_value: bool
        :param remove_from_groups_if_blocked: Determines whether the account is removed from all other groups if blocked
        :type remove_from_groups_if_blocked: bool
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_account_serialize(
            version=version,
            account_id_being_blocked=account_id_being_blocked,
            device_id=device_id,
            account_id=account_id,
            block_flag_value=block_flag_value,
            remove_from_groups_if_blocked=remove_from_groups_if_blocked,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def block_account_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id_being_blocked: Annotated[StrictInt, Field(description="The id of the account to be blocked/unblocked")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        block_flag_value: Annotated[Optional[StrictBool], Field(description="Determines whether the account is blocked or unblocked")] = None,
        remove_from_groups_if_blocked: Annotated[Optional[StrictBool], Field(description="Determines whether the account is removed from all other groups if blocked")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Block Account

        Moves or removes an account into the user's blocked group.

        :param version: (required)
        :type version: float
        :param account_id_being_blocked: The id of the account to be blocked/unblocked (required)
        :type account_id_being_blocked: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param block_flag_value: Determines whether the account is blocked or unblocked
        :type block_flag_value: bool
        :param remove_from_groups_if_blocked: Determines whether the account is removed from all other groups if blocked
        :type remove_from_groups_if_blocked: bool
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._block_account_serialize(
            version=version,
            account_id_being_blocked=account_id_being_blocked,
            device_id=device_id,
            account_id=account_id,
            block_flag_value=block_flag_value,
            remove_from_groups_if_blocked=remove_from_groups_if_blocked,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _block_account_serialize(
        self,
        version,
        account_id_being_blocked,
        device_id,
        account_id,
        block_flag_value,
        remove_from_groups_if_blocked,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if account_id_being_blocked is not None:
            
            _query_params.append(('accountIdBeingBlocked', account_id_being_blocked))
            
        if block_flag_value is not None:
            
            _query_params.append(('blockFlagValue', block_flag_value))
            
        if remove_from_groups_if_blocked is not None:
            
            _query_params.append(('removeFromGroupsIfBlocked', remove_from_groups_if_blocked))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/block',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_account(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="The access token to authenticate with (ex: username)")],
        password: Annotated[StrictStr, Field(description="The secret to authenticate with (ex: password)")],
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="This field will be used to set the user's job title")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the user's contact location")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The zipcode of the user's contact location")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user (AudienceGender)")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in UTC milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="The home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="The cellular phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="The cellular service provider")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The account role (default: MEMBER)")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Comma separated list of development platforms")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Search tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About us information")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game experience of the user")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's marital status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred location in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        invite_token: Annotated[Optional[StrictStr], Field(description="The inviteToken that the referrer used for this account to sign up")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="The accountId of the referrer (used if there is no inviteToken)")] = None,
        send_validation: Annotated[Optional[StrictBool], Field(description="Whether to send validation email")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Deprecated: use appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The application version")] = None,
        response_type: Annotated[Optional[StrictStr], Field(description="Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids to assign to the user")] = None,
        app_blob: Annotated[Optional[StrictStr], Field(description="Application blob data")] = None,
        app_enable_push: Annotated[Optional[StrictBool], Field(description="Enable push for the app")] = None,
        app_enable_sms: Annotated[Optional[StrictBool], Field(description="Enable SMS for the app")] = None,
        app_enable_email: Annotated[Optional[StrictBool], Field(description="Enable email for the app")] = None,
        location_visibility: Annotated[Optional[StrictStr], Field(description="Location visibility setting")] = None,
        home_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Home latitude")] = None,
        home_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Home longitude")] = None,
        app_nickname: Annotated[Optional[StrictStr], Field(description="The nickname used in the application for this account")] = None,
        personal_audience_id: Annotated[Optional[StrictInt], Field(description="Personal audience id to associate with this account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountLoginResponse:
        """Create Account

        Create a new account by role.

        :param version: (required)
        :type version: float
        :param username: The access token to authenticate with (ex: username) (required)
        :type username: str
        :param password: The secret to authenticate with (ex: password) (required)
        :type password: str
        :param name: The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName
        :type name: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: This field will be used to set the user's job title
        :type title: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param device_id_type: The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        :type device_id_type: str
        :param email_address: The user's contact email address (NOT the username)
        :type email_address: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param street_address: The street address of the user's contact location
        :type street_address: str
        :param zipcode: The zipcode of the user's contact location
        :type zipcode: str
        :param gender: The gender of the user (AudienceGender)
        :type gender: str
        :param birthday: The birthday date of the user in UTC milliseconds
        :type birthday: int
        :param home_phone: The home phone number
        :type home_phone: str
        :param cell_phone: The cellular phone number
        :type cell_phone: str
        :param cell_phone_carrier: The cellular service provider
        :type cell_phone_carrier: str
        :param business_phone: The business phone number
        :type business_phone: str
        :param role: The account role (default: MEMBER)
        :type role: str
        :param platforms: Comma separated list of development platforms
        :type platforms: str
        :param tags: Search tags
        :type tags: str
        :param about_us: About us information
        :type about_us: str
        :param game_experience: Game experience of the user
        :type game_experience: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's marital status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred location in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param invite_token: The inviteToken that the referrer used for this account to sign up
        :type invite_token: str
        :param referral_account_id: The accountId of the referrer (used if there is no inviteToken)
        :type referral_account_id: int
        :param send_validation: Whether to send validation email
        :type send_validation: bool
        :param game_type: Deprecated: use appKey
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param app_version: The application version
        :type app_version: str
        :param response_type: Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in
        :type response_type: str
        :param audience_ids_to_add: Comma separated list of audience ids to assign to the user
        :type audience_ids_to_add: str
        :param app_blob: Application blob data
        :type app_blob: str
        :param app_enable_push: Enable push for the app
        :type app_enable_push: bool
        :param app_enable_sms: Enable SMS for the app
        :type app_enable_sms: bool
        :param app_enable_email: Enable email for the app
        :type app_enable_email: bool
        :param location_visibility: Location visibility setting
        :type location_visibility: str
        :param home_latitude: Home latitude
        :type home_latitude: float
        :param home_longitude: Home longitude
        :type home_longitude: float
        :param app_nickname: The nickname used in the application for this account
        :type app_nickname: str
        :param personal_audience_id: Personal audience id to associate with this account
        :type personal_audience_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_account_serialize(
            version=version,
            username=username,
            password=password,
            name=name,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            device_id=device_id,
            device_id_type=device_id_type,
            email_address=email_address,
            asset_id=asset_id,
            street_address=street_address,
            zipcode=zipcode,
            gender=gender,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            role=role,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            game_experience=game_experience,
            category_ids=category_ids,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            latitude=latitude,
            longitude=longitude,
            accepted_terms=accepted_terms,
            invite_token=invite_token,
            referral_account_id=referral_account_id,
            send_validation=send_validation,
            game_type=game_type,
            app_key=app_key,
            app_version=app_version,
            response_type=response_type,
            audience_ids_to_add=audience_ids_to_add,
            app_blob=app_blob,
            app_enable_push=app_enable_push,
            app_enable_sms=app_enable_sms,
            app_enable_email=app_enable_email,
            location_visibility=location_visibility,
            home_latitude=home_latitude,
            home_longitude=home_longitude,
            app_nickname=app_nickname,
            personal_audience_id=personal_audience_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_account_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="The access token to authenticate with (ex: username)")],
        password: Annotated[StrictStr, Field(description="The secret to authenticate with (ex: password)")],
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="This field will be used to set the user's job title")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the user's contact location")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The zipcode of the user's contact location")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user (AudienceGender)")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in UTC milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="The home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="The cellular phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="The cellular service provider")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The account role (default: MEMBER)")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Comma separated list of development platforms")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Search tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About us information")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game experience of the user")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's marital status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred location in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        invite_token: Annotated[Optional[StrictStr], Field(description="The inviteToken that the referrer used for this account to sign up")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="The accountId of the referrer (used if there is no inviteToken)")] = None,
        send_validation: Annotated[Optional[StrictBool], Field(description="Whether to send validation email")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Deprecated: use appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The application version")] = None,
        response_type: Annotated[Optional[StrictStr], Field(description="Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids to assign to the user")] = None,
        app_blob: Annotated[Optional[StrictStr], Field(description="Application blob data")] = None,
        app_enable_push: Annotated[Optional[StrictBool], Field(description="Enable push for the app")] = None,
        app_enable_sms: Annotated[Optional[StrictBool], Field(description="Enable SMS for the app")] = None,
        app_enable_email: Annotated[Optional[StrictBool], Field(description="Enable email for the app")] = None,
        location_visibility: Annotated[Optional[StrictStr], Field(description="Location visibility setting")] = None,
        home_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Home latitude")] = None,
        home_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Home longitude")] = None,
        app_nickname: Annotated[Optional[StrictStr], Field(description="The nickname used in the application for this account")] = None,
        personal_audience_id: Annotated[Optional[StrictInt], Field(description="Personal audience id to associate with this account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountLoginResponse]:
        """Create Account

        Create a new account by role.

        :param version: (required)
        :type version: float
        :param username: The access token to authenticate with (ex: username) (required)
        :type username: str
        :param password: The secret to authenticate with (ex: password) (required)
        :type password: str
        :param name: The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName
        :type name: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: This field will be used to set the user's job title
        :type title: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param device_id_type: The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        :type device_id_type: str
        :param email_address: The user's contact email address (NOT the username)
        :type email_address: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param street_address: The street address of the user's contact location
        :type street_address: str
        :param zipcode: The zipcode of the user's contact location
        :type zipcode: str
        :param gender: The gender of the user (AudienceGender)
        :type gender: str
        :param birthday: The birthday date of the user in UTC milliseconds
        :type birthday: int
        :param home_phone: The home phone number
        :type home_phone: str
        :param cell_phone: The cellular phone number
        :type cell_phone: str
        :param cell_phone_carrier: The cellular service provider
        :type cell_phone_carrier: str
        :param business_phone: The business phone number
        :type business_phone: str
        :param role: The account role (default: MEMBER)
        :type role: str
        :param platforms: Comma separated list of development platforms
        :type platforms: str
        :param tags: Search tags
        :type tags: str
        :param about_us: About us information
        :type about_us: str
        :param game_experience: Game experience of the user
        :type game_experience: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's marital status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred location in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param invite_token: The inviteToken that the referrer used for this account to sign up
        :type invite_token: str
        :param referral_account_id: The accountId of the referrer (used if there is no inviteToken)
        :type referral_account_id: int
        :param send_validation: Whether to send validation email
        :type send_validation: bool
        :param game_type: Deprecated: use appKey
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param app_version: The application version
        :type app_version: str
        :param response_type: Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in
        :type response_type: str
        :param audience_ids_to_add: Comma separated list of audience ids to assign to the user
        :type audience_ids_to_add: str
        :param app_blob: Application blob data
        :type app_blob: str
        :param app_enable_push: Enable push for the app
        :type app_enable_push: bool
        :param app_enable_sms: Enable SMS for the app
        :type app_enable_sms: bool
        :param app_enable_email: Enable email for the app
        :type app_enable_email: bool
        :param location_visibility: Location visibility setting
        :type location_visibility: str
        :param home_latitude: Home latitude
        :type home_latitude: float
        :param home_longitude: Home longitude
        :type home_longitude: float
        :param app_nickname: The nickname used in the application for this account
        :type app_nickname: str
        :param personal_audience_id: Personal audience id to associate with this account
        :type personal_audience_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_account_serialize(
            version=version,
            username=username,
            password=password,
            name=name,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            device_id=device_id,
            device_id_type=device_id_type,
            email_address=email_address,
            asset_id=asset_id,
            street_address=street_address,
            zipcode=zipcode,
            gender=gender,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            role=role,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            game_experience=game_experience,
            category_ids=category_ids,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            latitude=latitude,
            longitude=longitude,
            accepted_terms=accepted_terms,
            invite_token=invite_token,
            referral_account_id=referral_account_id,
            send_validation=send_validation,
            game_type=game_type,
            app_key=app_key,
            app_version=app_version,
            response_type=response_type,
            audience_ids_to_add=audience_ids_to_add,
            app_blob=app_blob,
            app_enable_push=app_enable_push,
            app_enable_sms=app_enable_sms,
            app_enable_email=app_enable_email,
            location_visibility=location_visibility,
            home_latitude=home_latitude,
            home_longitude=home_longitude,
            app_nickname=app_nickname,
            personal_audience_id=personal_audience_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_account_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="The access token to authenticate with (ex: username)")],
        password: Annotated[StrictStr, Field(description="The secret to authenticate with (ex: password)")],
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="This field will be used to set the user's job title")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the user's contact location")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The zipcode of the user's contact location")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user (AudienceGender)")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in UTC milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="The home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="The cellular phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="The cellular service provider")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The account role (default: MEMBER)")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Comma separated list of development platforms")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Search tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About us information")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game experience of the user")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's marital status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred location in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        invite_token: Annotated[Optional[StrictStr], Field(description="The inviteToken that the referrer used for this account to sign up")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="The accountId of the referrer (used if there is no inviteToken)")] = None,
        send_validation: Annotated[Optional[StrictBool], Field(description="Whether to send validation email")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Deprecated: use appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The application version")] = None,
        response_type: Annotated[Optional[StrictStr], Field(description="Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of audience ids to assign to the user")] = None,
        app_blob: Annotated[Optional[StrictStr], Field(description="Application blob data")] = None,
        app_enable_push: Annotated[Optional[StrictBool], Field(description="Enable push for the app")] = None,
        app_enable_sms: Annotated[Optional[StrictBool], Field(description="Enable SMS for the app")] = None,
        app_enable_email: Annotated[Optional[StrictBool], Field(description="Enable email for the app")] = None,
        location_visibility: Annotated[Optional[StrictStr], Field(description="Location visibility setting")] = None,
        home_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Home latitude")] = None,
        home_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Home longitude")] = None,
        app_nickname: Annotated[Optional[StrictStr], Field(description="The nickname used in the application for this account")] = None,
        personal_audience_id: Annotated[Optional[StrictInt], Field(description="Personal audience id to associate with this account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Account

        Create a new account by role.

        :param version: (required)
        :type version: float
        :param username: The access token to authenticate with (ex: username) (required)
        :type username: str
        :param password: The secret to authenticate with (ex: password) (required)
        :type password: str
        :param name: The full name of the user. If this parameter is NOT empty, the following parameters will be ignored: prefixName, firstName, middleName, lastName, and suffixName
        :type name: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: This field will be used to set the user's job title
        :type title: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param device_id_type: The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        :type device_id_type: str
        :param email_address: The user's contact email address (NOT the username)
        :type email_address: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param street_address: The street address of the user's contact location
        :type street_address: str
        :param zipcode: The zipcode of the user's contact location
        :type zipcode: str
        :param gender: The gender of the user (AudienceGender)
        :type gender: str
        :param birthday: The birthday date of the user in UTC milliseconds
        :type birthday: int
        :param home_phone: The home phone number
        :type home_phone: str
        :param cell_phone: The cellular phone number
        :type cell_phone: str
        :param cell_phone_carrier: The cellular service provider
        :type cell_phone_carrier: str
        :param business_phone: The business phone number
        :type business_phone: str
        :param role: The account role (default: MEMBER)
        :type role: str
        :param platforms: Comma separated list of development platforms
        :type platforms: str
        :param tags: Search tags
        :type tags: str
        :param about_us: About us information
        :type about_us: str
        :param game_experience: Game experience of the user
        :type game_experience: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's marital status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred location in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param invite_token: The inviteToken that the referrer used for this account to sign up
        :type invite_token: str
        :param referral_account_id: The accountId of the referrer (used if there is no inviteToken)
        :type referral_account_id: int
        :param send_validation: Whether to send validation email
        :type send_validation: bool
        :param game_type: Deprecated: use appKey
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param app_version: The application version
        :type app_version: str
        :param response_type: Returns an AccountLoginResponse if \"AccountLoginResponse\" is passed in
        :type response_type: str
        :param audience_ids_to_add: Comma separated list of audience ids to assign to the user
        :type audience_ids_to_add: str
        :param app_blob: Application blob data
        :type app_blob: str
        :param app_enable_push: Enable push for the app
        :type app_enable_push: bool
        :param app_enable_sms: Enable SMS for the app
        :type app_enable_sms: bool
        :param app_enable_email: Enable email for the app
        :type app_enable_email: bool
        :param location_visibility: Location visibility setting
        :type location_visibility: str
        :param home_latitude: Home latitude
        :type home_latitude: float
        :param home_longitude: Home longitude
        :type home_longitude: float
        :param app_nickname: The nickname used in the application for this account
        :type app_nickname: str
        :param personal_audience_id: Personal audience id to associate with this account
        :type personal_audience_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_account_serialize(
            version=version,
            username=username,
            password=password,
            name=name,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            device_id=device_id,
            device_id_type=device_id_type,
            email_address=email_address,
            asset_id=asset_id,
            street_address=street_address,
            zipcode=zipcode,
            gender=gender,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            role=role,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            game_experience=game_experience,
            category_ids=category_ids,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            latitude=latitude,
            longitude=longitude,
            accepted_terms=accepted_terms,
            invite_token=invite_token,
            referral_account_id=referral_account_id,
            send_validation=send_validation,
            game_type=game_type,
            app_key=app_key,
            app_version=app_version,
            response_type=response_type,
            audience_ids_to_add=audience_ids_to_add,
            app_blob=app_blob,
            app_enable_push=app_enable_push,
            app_enable_sms=app_enable_sms,
            app_enable_email=app_enable_email,
            location_visibility=location_visibility,
            home_latitude=home_latitude,
            home_longitude=home_longitude,
            app_nickname=app_nickname,
            personal_audience_id=personal_audience_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_account_serialize(
        self,
        version,
        username,
        password,
        name,
        prefix_name,
        first_name,
        middle_name,
        last_name,
        suffix_name,
        title,
        device_id,
        device_id_type,
        email_address,
        asset_id,
        street_address,
        zipcode,
        gender,
        birthday,
        home_phone,
        cell_phone,
        cell_phone_carrier,
        business_phone,
        role,
        platforms,
        tags,
        about_us,
        game_experience,
        category_ids,
        hometown,
        height,
        height_index,
        ethnicity,
        body_type,
        marital_status,
        children,
        religion,
        education,
        education_index,
        smoke,
        drink,
        companionship,
        companionship_index,
        preferred_min_age,
        preferred_max_age,
        preferred_min_height,
        preferred_max_height,
        preferred_gender,
        preferred_education,
        preferred_education_index,
        preferred_body_type,
        preferred_ethnicity,
        preferred_location,
        preferred_location_range,
        latitude,
        longitude,
        accepted_terms,
        invite_token,
        referral_account_id,
        send_validation,
        game_type,
        app_key,
        app_version,
        response_type,
        audience_ids_to_add,
        app_blob,
        app_enable_push,
        app_enable_sms,
        app_enable_email,
        location_visibility,
        home_latitude,
        home_longitude,
        app_nickname,
        personal_audience_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if prefix_name is not None:
            
            _query_params.append(('prefixName', prefix_name))
            
        if first_name is not None:
            
            _query_params.append(('firstName', first_name))
            
        if middle_name is not None:
            
            _query_params.append(('middleName', middle_name))
            
        if last_name is not None:
            
            _query_params.append(('lastName', last_name))
            
        if suffix_name is not None:
            
            _query_params.append(('suffixName', suffix_name))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if device_id_type is not None:
            
            _query_params.append(('deviceIdType', device_id_type))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if password is not None:
            
            _query_params.append(('password', password))
            
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if zipcode is not None:
            
            _query_params.append(('zipcode', zipcode))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if birthday is not None:
            
            _query_params.append(('birthday', birthday))
            
        if home_phone is not None:
            
            _query_params.append(('homePhone', home_phone))
            
        if cell_phone is not None:
            
            _query_params.append(('cellPhone', cell_phone))
            
        if cell_phone_carrier is not None:
            
            _query_params.append(('cellPhoneCarrier', cell_phone_carrier))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if platforms is not None:
            
            _query_params.append(('platforms', platforms))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if about_us is not None:
            
            _query_params.append(('aboutUs', about_us))
            
        if game_experience is not None:
            
            _query_params.append(('gameExperience', game_experience))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if hometown is not None:
            
            _query_params.append(('hometown', hometown))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if height_index is not None:
            
            _query_params.append(('heightIndex', height_index))
            
        if ethnicity is not None:
            
            _query_params.append(('ethnicity', ethnicity))
            
        if body_type is not None:
            
            _query_params.append(('bodyType', body_type))
            
        if marital_status is not None:
            
            _query_params.append(('maritalStatus', marital_status))
            
        if children is not None:
            
            _query_params.append(('children', children))
            
        if religion is not None:
            
            _query_params.append(('religion', religion))
            
        if education is not None:
            
            _query_params.append(('education', education))
            
        if education_index is not None:
            
            _query_params.append(('educationIndex', education_index))
            
        if smoke is not None:
            
            _query_params.append(('smoke', smoke))
            
        if drink is not None:
            
            _query_params.append(('drink', drink))
            
        if companionship is not None:
            
            _query_params.append(('companionship', companionship))
            
        if companionship_index is not None:
            
            _query_params.append(('companionshipIndex', companionship_index))
            
        if preferred_min_age is not None:
            
            _query_params.append(('preferredMinAge', preferred_min_age))
            
        if preferred_max_age is not None:
            
            _query_params.append(('preferredMaxAge', preferred_max_age))
            
        if preferred_min_height is not None:
            
            _query_params.append(('preferredMinHeight', preferred_min_height))
            
        if preferred_max_height is not None:
            
            _query_params.append(('preferredMaxHeight', preferred_max_height))
            
        if preferred_gender is not None:
            
            _query_params.append(('preferredGender', preferred_gender))
            
        if preferred_education is not None:
            
            _query_params.append(('preferredEducation', preferred_education))
            
        if preferred_education_index is not None:
            
            _query_params.append(('preferredEducationIndex', preferred_education_index))
            
        if preferred_body_type is not None:
            
            _query_params.append(('preferredBodyType', preferred_body_type))
            
        if preferred_ethnicity is not None:
            
            _query_params.append(('preferredEthnicity', preferred_ethnicity))
            
        if preferred_location is not None:
            
            _query_params.append(('preferredLocation', preferred_location))
            
        if preferred_location_range is not None:
            
            _query_params.append(('preferredLocationRange', preferred_location_range))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if accepted_terms is not None:
            
            _query_params.append(('acceptedTerms', accepted_terms))
            
        if invite_token is not None:
            
            _query_params.append(('inviteToken', invite_token))
            
        if referral_account_id is not None:
            
            _query_params.append(('referralAccountId', referral_account_id))
            
        if send_validation is not None:
            
            _query_params.append(('sendValidation', send_validation))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if app_version is not None:
            
            _query_params.append(('appVersion', app_version))
            
        if response_type is not None:
            
            _query_params.append(('responseType', response_type))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if app_blob is not None:
            
            _query_params.append(('appBlob', app_blob))
            
        if app_enable_push is not None:
            
            _query_params.append(('appEnablePush', app_enable_push))
            
        if app_enable_sms is not None:
            
            _query_params.append(('appEnableSMS', app_enable_sms))
            
        if app_enable_email is not None:
            
            _query_params.append(('appEnableEmail', app_enable_email))
            
        if location_visibility is not None:
            
            _query_params.append(('locationVisibility', location_visibility))
            
        if home_latitude is not None:
            
            _query_params.append(('homeLatitude', home_latitude))
            
        if home_longitude is not None:
            
            _query_params.append(('homeLongitude', home_longitude))
            
        if app_nickname is not None:
            
            _query_params.append(('appNickname', app_nickname))
            
        if personal_audience_id is not None:
            
            _query_params.append(('personalAudienceId', personal_audience_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def edit_account(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to edit another person's account")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The account role to change to")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="This field will be used to set the user's job title")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user AudienceGender")] = None,
        age: Annotated[Optional[StrictInt], Field(description="This is deperecated, use the birthday parameter")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in UTC milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="The home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="The cellular phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="The cellular service provider")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the user's contact location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the user's contact location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the user's contact location")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The zipcode of the user's contact location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country of the user's contact location")] = None,
        make_profile_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's personal profile")] = None,
        make_game_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's game/app info")] = None,
        make_friends_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's friends list")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's marital status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Platforms")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About Us")] = None,
        match_token: Annotated[Optional[StrictStr], Field(description="Match Token")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game Experience")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Deprecated use categoryIds")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        show_as_zipcode: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to be shown by zipcode on a map")] = None,
        show_exact_location: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to be shown by their exact location on a map")] = None,
        show_others_exact_location: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to see others exact location on a map")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        location_visibility: Annotated[Optional[StrictStr], Field(description="Location Visibility")] = None,
        app_blob: Annotated[Optional[StrictStr], Field(description="App Blob")] = None,
        app_enable_push: Annotated[Optional[StrictBool], Field(description="App Enable Push")] = None,
        app_enable_sms: Annotated[Optional[StrictBool], Field(description="App Enable SMS")] = None,
        app_enable_email: Annotated[Optional[StrictBool], Field(description="App Enable Email")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="Return Profile")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Audience Ids to add")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Audience Ids to remove")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="The account id of the referrer")] = None,
        app_nickname: Annotated[Optional[StrictStr], Field(description="App nickname")] = None,
        personal_audience_id: Annotated[Optional[StrictInt], Field(description="Personal Audience")] = None,
        non_guest_username: Annotated[Optional[StrictStr], Field(description="The user's username to update with if they currently have a guest username")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileInfoResponse:
        """Update Account

        Edit the user's profile information

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: The account id used to edit another person's account
        :type connection_account_id: int
        :param role: The account role to change to
        :type role: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param name: The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        :type name: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: This field will be used to set the user's job title
        :type title: str
        :param gender: The gender of the user AudienceGender
        :type gender: str
        :param age: This is deperecated, use the birthday parameter
        :type age: int
        :param birthday: The birthday date of the user in UTC milliseconds
        :type birthday: int
        :param home_phone: The home phone number
        :type home_phone: str
        :param cell_phone: The cellular phone number
        :type cell_phone: str
        :param cell_phone_carrier: The cellular service provider
        :type cell_phone_carrier: str
        :param business_phone: The business phone number
        :type business_phone: str
        :param email_address: The user's contact email address (NOT the username)
        :type email_address: str
        :param street_address: The street address of the user's contact location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the user's contact location
        :type city: str
        :param state: The state of the user's contact location
        :type state: str
        :param zipcode: The zipcode of the user's contact location
        :type zipcode: str
        :param country: The country of the user's contact location
        :type country: str
        :param make_profile_info_public: Allow anyone to view the user's personal profile
        :type make_profile_info_public: bool
        :param make_game_info_public: Allow anyone to view the user's game/app info
        :type make_game_info_public: bool
        :param make_friends_info_public: Allow anyone to view the user's friends list
        :type make_friends_info_public: bool
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's marital status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred education in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param platforms: Platforms
        :type platforms: str
        :param tags: Tags
        :type tags: str
        :param about_us: About Us
        :type about_us: str
        :param match_token: Match Token
        :type match_token: str
        :param game_experience: Game Experience
        :type game_experience: str
        :param categories: Deprecated use categoryIds
        :type categories: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param show_as_zipcode: The user's preference if they want to be shown by zipcode on a map
        :type show_as_zipcode: bool
        :param show_exact_location: The user's preference if they want to be shown by their exact location on a map
        :type show_exact_location: bool
        :param show_others_exact_location: The user's preference if they want to see others exact location on a map
        :type show_others_exact_location: bool
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param location_visibility: Location Visibility
        :type location_visibility: str
        :param app_blob: App Blob
        :type app_blob: str
        :param app_enable_push: App Enable Push
        :type app_enable_push: bool
        :param app_enable_sms: App Enable SMS
        :type app_enable_sms: bool
        :param app_enable_email: App Enable Email
        :type app_enable_email: bool
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param return_profile: Return Profile
        :type return_profile: bool
        :param audience_ids_to_add: Audience Ids to add
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Audience Ids to remove
        :type audience_ids_to_remove: str
        :param referral_account_id: The account id of the referrer
        :type referral_account_id: int
        :param app_nickname: App nickname
        :type app_nickname: str
        :param personal_audience_id: Personal Audience
        :type personal_audience_id: int
        :param non_guest_username: The user's username to update with if they currently have a guest username
        :type non_guest_username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_account_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            role=role,
            asset_id=asset_id,
            name=name,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            gender=gender,
            age=age,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            email_address=email_address,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            zipcode=zipcode,
            country=country,
            make_profile_info_public=make_profile_info_public,
            make_game_info_public=make_game_info_public,
            make_friends_info_public=make_friends_info_public,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            match_token=match_token,
            game_experience=game_experience,
            categories=categories,
            category_ids=category_ids,
            response_filters=response_filters,
            show_as_zipcode=show_as_zipcode,
            show_exact_location=show_exact_location,
            show_others_exact_location=show_others_exact_location,
            accepted_terms=accepted_terms,
            location_visibility=location_visibility,
            app_blob=app_blob,
            app_enable_push=app_enable_push,
            app_enable_sms=app_enable_sms,
            app_enable_email=app_enable_email,
            game_type=game_type,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            return_profile=return_profile,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            referral_account_id=referral_account_id,
            app_nickname=app_nickname,
            personal_audience_id=personal_audience_id,
            non_guest_username=non_guest_username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileInfoResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def edit_account_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to edit another person's account")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The account role to change to")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="This field will be used to set the user's job title")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user AudienceGender")] = None,
        age: Annotated[Optional[StrictInt], Field(description="This is deperecated, use the birthday parameter")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in UTC milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="The home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="The cellular phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="The cellular service provider")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the user's contact location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the user's contact location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the user's contact location")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The zipcode of the user's contact location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country of the user's contact location")] = None,
        make_profile_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's personal profile")] = None,
        make_game_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's game/app info")] = None,
        make_friends_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's friends list")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's marital status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Platforms")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About Us")] = None,
        match_token: Annotated[Optional[StrictStr], Field(description="Match Token")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game Experience")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Deprecated use categoryIds")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        show_as_zipcode: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to be shown by zipcode on a map")] = None,
        show_exact_location: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to be shown by their exact location on a map")] = None,
        show_others_exact_location: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to see others exact location on a map")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        location_visibility: Annotated[Optional[StrictStr], Field(description="Location Visibility")] = None,
        app_blob: Annotated[Optional[StrictStr], Field(description="App Blob")] = None,
        app_enable_push: Annotated[Optional[StrictBool], Field(description="App Enable Push")] = None,
        app_enable_sms: Annotated[Optional[StrictBool], Field(description="App Enable SMS")] = None,
        app_enable_email: Annotated[Optional[StrictBool], Field(description="App Enable Email")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="Return Profile")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Audience Ids to add")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Audience Ids to remove")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="The account id of the referrer")] = None,
        app_nickname: Annotated[Optional[StrictStr], Field(description="App nickname")] = None,
        personal_audience_id: Annotated[Optional[StrictInt], Field(description="Personal Audience")] = None,
        non_guest_username: Annotated[Optional[StrictStr], Field(description="The user's username to update with if they currently have a guest username")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileInfoResponse]:
        """Update Account

        Edit the user's profile information

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: The account id used to edit another person's account
        :type connection_account_id: int
        :param role: The account role to change to
        :type role: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param name: The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        :type name: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: This field will be used to set the user's job title
        :type title: str
        :param gender: The gender of the user AudienceGender
        :type gender: str
        :param age: This is deperecated, use the birthday parameter
        :type age: int
        :param birthday: The birthday date of the user in UTC milliseconds
        :type birthday: int
        :param home_phone: The home phone number
        :type home_phone: str
        :param cell_phone: The cellular phone number
        :type cell_phone: str
        :param cell_phone_carrier: The cellular service provider
        :type cell_phone_carrier: str
        :param business_phone: The business phone number
        :type business_phone: str
        :param email_address: The user's contact email address (NOT the username)
        :type email_address: str
        :param street_address: The street address of the user's contact location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the user's contact location
        :type city: str
        :param state: The state of the user's contact location
        :type state: str
        :param zipcode: The zipcode of the user's contact location
        :type zipcode: str
        :param country: The country of the user's contact location
        :type country: str
        :param make_profile_info_public: Allow anyone to view the user's personal profile
        :type make_profile_info_public: bool
        :param make_game_info_public: Allow anyone to view the user's game/app info
        :type make_game_info_public: bool
        :param make_friends_info_public: Allow anyone to view the user's friends list
        :type make_friends_info_public: bool
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's marital status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred education in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param platforms: Platforms
        :type platforms: str
        :param tags: Tags
        :type tags: str
        :param about_us: About Us
        :type about_us: str
        :param match_token: Match Token
        :type match_token: str
        :param game_experience: Game Experience
        :type game_experience: str
        :param categories: Deprecated use categoryIds
        :type categories: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param show_as_zipcode: The user's preference if they want to be shown by zipcode on a map
        :type show_as_zipcode: bool
        :param show_exact_location: The user's preference if they want to be shown by their exact location on a map
        :type show_exact_location: bool
        :param show_others_exact_location: The user's preference if they want to see others exact location on a map
        :type show_others_exact_location: bool
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param location_visibility: Location Visibility
        :type location_visibility: str
        :param app_blob: App Blob
        :type app_blob: str
        :param app_enable_push: App Enable Push
        :type app_enable_push: bool
        :param app_enable_sms: App Enable SMS
        :type app_enable_sms: bool
        :param app_enable_email: App Enable Email
        :type app_enable_email: bool
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param return_profile: Return Profile
        :type return_profile: bool
        :param audience_ids_to_add: Audience Ids to add
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Audience Ids to remove
        :type audience_ids_to_remove: str
        :param referral_account_id: The account id of the referrer
        :type referral_account_id: int
        :param app_nickname: App nickname
        :type app_nickname: str
        :param personal_audience_id: Personal Audience
        :type personal_audience_id: int
        :param non_guest_username: The user's username to update with if they currently have a guest username
        :type non_guest_username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_account_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            role=role,
            asset_id=asset_id,
            name=name,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            gender=gender,
            age=age,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            email_address=email_address,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            zipcode=zipcode,
            country=country,
            make_profile_info_public=make_profile_info_public,
            make_game_info_public=make_game_info_public,
            make_friends_info_public=make_friends_info_public,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            match_token=match_token,
            game_experience=game_experience,
            categories=categories,
            category_ids=category_ids,
            response_filters=response_filters,
            show_as_zipcode=show_as_zipcode,
            show_exact_location=show_exact_location,
            show_others_exact_location=show_others_exact_location,
            accepted_terms=accepted_terms,
            location_visibility=location_visibility,
            app_blob=app_blob,
            app_enable_push=app_enable_push,
            app_enable_sms=app_enable_sms,
            app_enable_email=app_enable_email,
            game_type=game_type,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            return_profile=return_profile,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            referral_account_id=referral_account_id,
            app_nickname=app_nickname,
            personal_audience_id=personal_audience_id,
            non_guest_username=non_guest_username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileInfoResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def edit_account_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to edit another person's account")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The account role to change to")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="This field will be used to set the user's job title")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user AudienceGender")] = None,
        age: Annotated[Optional[StrictInt], Field(description="This is deperecated, use the birthday parameter")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in UTC milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="The home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="The cellular phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="The cellular service provider")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the user's contact location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the user's contact location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the user's contact location")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The zipcode of the user's contact location")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country of the user's contact location")] = None,
        make_profile_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's personal profile")] = None,
        make_game_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's game/app info")] = None,
        make_friends_info_public: Annotated[Optional[StrictBool], Field(description="Allow anyone to view the user's friends list")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's marital status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Platforms")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About Us")] = None,
        match_token: Annotated[Optional[StrictStr], Field(description="Match Token")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game Experience")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Deprecated use categoryIds")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        show_as_zipcode: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to be shown by zipcode on a map")] = None,
        show_exact_location: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to be shown by their exact location on a map")] = None,
        show_others_exact_location: Annotated[Optional[StrictBool], Field(description="The user's preference if they want to see others exact location on a map")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        location_visibility: Annotated[Optional[StrictStr], Field(description="Location Visibility")] = None,
        app_blob: Annotated[Optional[StrictStr], Field(description="App Blob")] = None,
        app_enable_push: Annotated[Optional[StrictBool], Field(description="App Enable Push")] = None,
        app_enable_sms: Annotated[Optional[StrictBool], Field(description="App Enable SMS")] = None,
        app_enable_email: Annotated[Optional[StrictBool], Field(description="App Enable Email")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="Return Profile")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="Audience Ids to add")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Audience Ids to remove")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="The account id of the referrer")] = None,
        app_nickname: Annotated[Optional[StrictStr], Field(description="App nickname")] = None,
        personal_audience_id: Annotated[Optional[StrictInt], Field(description="Personal Audience")] = None,
        non_guest_username: Annotated[Optional[StrictStr], Field(description="The user's username to update with if they currently have a guest username")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Account

        Edit the user's profile information

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: The account id used to edit another person's account
        :type connection_account_id: int
        :param role: The account role to change to
        :type role: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param name: The full name of the user. If this parameter is NOT empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        :type name: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: This field will be used to set the user's job title
        :type title: str
        :param gender: The gender of the user AudienceGender
        :type gender: str
        :param age: This is deperecated, use the birthday parameter
        :type age: int
        :param birthday: The birthday date of the user in UTC milliseconds
        :type birthday: int
        :param home_phone: The home phone number
        :type home_phone: str
        :param cell_phone: The cellular phone number
        :type cell_phone: str
        :param cell_phone_carrier: The cellular service provider
        :type cell_phone_carrier: str
        :param business_phone: The business phone number
        :type business_phone: str
        :param email_address: The user's contact email address (NOT the username)
        :type email_address: str
        :param street_address: The street address of the user's contact location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the user's contact location
        :type city: str
        :param state: The state of the user's contact location
        :type state: str
        :param zipcode: The zipcode of the user's contact location
        :type zipcode: str
        :param country: The country of the user's contact location
        :type country: str
        :param make_profile_info_public: Allow anyone to view the user's personal profile
        :type make_profile_info_public: bool
        :param make_game_info_public: Allow anyone to view the user's game/app info
        :type make_game_info_public: bool
        :param make_friends_info_public: Allow anyone to view the user's friends list
        :type make_friends_info_public: bool
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's marital status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred education in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param platforms: Platforms
        :type platforms: str
        :param tags: Tags
        :type tags: str
        :param about_us: About Us
        :type about_us: str
        :param match_token: Match Token
        :type match_token: str
        :param game_experience: Game Experience
        :type game_experience: str
        :param categories: Deprecated use categoryIds
        :type categories: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param show_as_zipcode: The user's preference if they want to be shown by zipcode on a map
        :type show_as_zipcode: bool
        :param show_exact_location: The user's preference if they want to be shown by their exact location on a map
        :type show_exact_location: bool
        :param show_others_exact_location: The user's preference if they want to see others exact location on a map
        :type show_others_exact_location: bool
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param location_visibility: Location Visibility
        :type location_visibility: str
        :param app_blob: App Blob
        :type app_blob: str
        :param app_enable_push: App Enable Push
        :type app_enable_push: bool
        :param app_enable_sms: App Enable SMS
        :type app_enable_sms: bool
        :param app_enable_email: App Enable Email
        :type app_enable_email: bool
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param return_profile: Return Profile
        :type return_profile: bool
        :param audience_ids_to_add: Audience Ids to add
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: Audience Ids to remove
        :type audience_ids_to_remove: str
        :param referral_account_id: The account id of the referrer
        :type referral_account_id: int
        :param app_nickname: App nickname
        :type app_nickname: str
        :param personal_audience_id: Personal Audience
        :type personal_audience_id: int
        :param non_guest_username: The user's username to update with if they currently have a guest username
        :type non_guest_username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_account_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            role=role,
            asset_id=asset_id,
            name=name,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            gender=gender,
            age=age,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            email_address=email_address,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            zipcode=zipcode,
            country=country,
            make_profile_info_public=make_profile_info_public,
            make_game_info_public=make_game_info_public,
            make_friends_info_public=make_friends_info_public,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            match_token=match_token,
            game_experience=game_experience,
            categories=categories,
            category_ids=category_ids,
            response_filters=response_filters,
            show_as_zipcode=show_as_zipcode,
            show_exact_location=show_exact_location,
            show_others_exact_location=show_others_exact_location,
            accepted_terms=accepted_terms,
            location_visibility=location_visibility,
            app_blob=app_blob,
            app_enable_push=app_enable_push,
            app_enable_sms=app_enable_sms,
            app_enable_email=app_enable_email,
            game_type=game_type,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            return_profile=return_profile,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            referral_account_id=referral_account_id,
            app_nickname=app_nickname,
            personal_audience_id=personal_audience_id,
            non_guest_username=non_guest_username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileInfoResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _edit_account_serialize(
        self,
        version,
        device_id,
        account_id,
        connection_account_id,
        role,
        asset_id,
        name,
        prefix_name,
        first_name,
        middle_name,
        last_name,
        suffix_name,
        title,
        gender,
        age,
        birthday,
        home_phone,
        cell_phone,
        cell_phone_carrier,
        business_phone,
        email_address,
        street_address,
        street_address2,
        city,
        state,
        zipcode,
        country,
        make_profile_info_public,
        make_game_info_public,
        make_friends_info_public,
        hometown,
        height,
        height_index,
        ethnicity,
        body_type,
        marital_status,
        children,
        religion,
        education,
        education_index,
        smoke,
        drink,
        companionship,
        companionship_index,
        preferred_min_age,
        preferred_max_age,
        preferred_min_height,
        preferred_max_height,
        preferred_gender,
        preferred_education,
        preferred_education_index,
        preferred_body_type,
        preferred_ethnicity,
        preferred_location,
        preferred_location_range,
        platforms,
        tags,
        about_us,
        match_token,
        game_experience,
        categories,
        category_ids,
        response_filters,
        show_as_zipcode,
        show_exact_location,
        show_others_exact_location,
        accepted_terms,
        location_visibility,
        app_blob,
        app_enable_push,
        app_enable_sms,
        app_enable_email,
        game_type,
        app_key,
        latitude,
        longitude,
        return_profile,
        audience_ids_to_add,
        audience_ids_to_remove,
        referral_account_id,
        app_nickname,
        personal_audience_id,
        non_guest_username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if prefix_name is not None:
            
            _query_params.append(('prefixName', prefix_name))
            
        if first_name is not None:
            
            _query_params.append(('firstName', first_name))
            
        if middle_name is not None:
            
            _query_params.append(('middleName', middle_name))
            
        if last_name is not None:
            
            _query_params.append(('lastName', last_name))
            
        if suffix_name is not None:
            
            _query_params.append(('suffixName', suffix_name))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age is not None:
            
            _query_params.append(('age', age))
            
        if birthday is not None:
            
            _query_params.append(('birthday', birthday))
            
        if home_phone is not None:
            
            _query_params.append(('homePhone', home_phone))
            
        if cell_phone is not None:
            
            _query_params.append(('cellPhone', cell_phone))
            
        if cell_phone_carrier is not None:
            
            _query_params.append(('cellPhoneCarrier', cell_phone_carrier))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if zipcode is not None:
            
            _query_params.append(('zipcode', zipcode))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if make_profile_info_public is not None:
            
            _query_params.append(('makeProfileInfoPublic', make_profile_info_public))
            
        if make_game_info_public is not None:
            
            _query_params.append(('makeGameInfoPublic', make_game_info_public))
            
        if make_friends_info_public is not None:
            
            _query_params.append(('makeFriendsInfoPublic', make_friends_info_public))
            
        if hometown is not None:
            
            _query_params.append(('hometown', hometown))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if height_index is not None:
            
            _query_params.append(('heightIndex', height_index))
            
        if ethnicity is not None:
            
            _query_params.append(('ethnicity', ethnicity))
            
        if body_type is not None:
            
            _query_params.append(('bodyType', body_type))
            
        if marital_status is not None:
            
            _query_params.append(('maritalStatus', marital_status))
            
        if children is not None:
            
            _query_params.append(('children', children))
            
        if religion is not None:
            
            _query_params.append(('religion', religion))
            
        if education is not None:
            
            _query_params.append(('education', education))
            
        if education_index is not None:
            
            _query_params.append(('educationIndex', education_index))
            
        if smoke is not None:
            
            _query_params.append(('smoke', smoke))
            
        if drink is not None:
            
            _query_params.append(('drink', drink))
            
        if companionship is not None:
            
            _query_params.append(('companionship', companionship))
            
        if companionship_index is not None:
            
            _query_params.append(('companionshipIndex', companionship_index))
            
        if preferred_min_age is not None:
            
            _query_params.append(('preferredMinAge', preferred_min_age))
            
        if preferred_max_age is not None:
            
            _query_params.append(('preferredMaxAge', preferred_max_age))
            
        if preferred_min_height is not None:
            
            _query_params.append(('preferredMinHeight', preferred_min_height))
            
        if preferred_max_height is not None:
            
            _query_params.append(('preferredMaxHeight', preferred_max_height))
            
        if preferred_gender is not None:
            
            _query_params.append(('preferredGender', preferred_gender))
            
        if preferred_education is not None:
            
            _query_params.append(('preferredEducation', preferred_education))
            
        if preferred_education_index is not None:
            
            _query_params.append(('preferredEducationIndex', preferred_education_index))
            
        if preferred_body_type is not None:
            
            _query_params.append(('preferredBodyType', preferred_body_type))
            
        if preferred_ethnicity is not None:
            
            _query_params.append(('preferredEthnicity', preferred_ethnicity))
            
        if preferred_location is not None:
            
            _query_params.append(('preferredLocation', preferred_location))
            
        if preferred_location_range is not None:
            
            _query_params.append(('preferredLocationRange', preferred_location_range))
            
        if platforms is not None:
            
            _query_params.append(('platforms', platforms))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if about_us is not None:
            
            _query_params.append(('aboutUs', about_us))
            
        if match_token is not None:
            
            _query_params.append(('matchToken', match_token))
            
        if game_experience is not None:
            
            _query_params.append(('gameExperience', game_experience))
            
        if categories is not None:
            
            _query_params.append(('categories', categories))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if show_as_zipcode is not None:
            
            _query_params.append(('showAsZipcode', show_as_zipcode))
            
        if show_exact_location is not None:
            
            _query_params.append(('showExactLocation', show_exact_location))
            
        if show_others_exact_location is not None:
            
            _query_params.append(('showOthersExactLocation', show_others_exact_location))
            
        if accepted_terms is not None:
            
            _query_params.append(('acceptedTerms', accepted_terms))
            
        if location_visibility is not None:
            
            _query_params.append(('locationVisibility', location_visibility))
            
        if app_blob is not None:
            
            _query_params.append(('appBlob', app_blob))
            
        if app_enable_push is not None:
            
            _query_params.append(('appEnablePush', app_enable_push))
            
        if app_enable_sms is not None:
            
            _query_params.append(('appEnableSMS', app_enable_sms))
            
        if app_enable_email is not None:
            
            _query_params.append(('appEnableEmail', app_enable_email))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if return_profile is not None:
            
            _query_params.append(('returnProfile', return_profile))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if audience_ids_to_remove is not None:
            
            _query_params.append(('audienceIdsToRemove', audience_ids_to_remove))
            
        if referral_account_id is not None:
            
            _query_params.append(('referralAccountId', referral_account_id))
            
        if app_nickname is not None:
            
            _query_params.append(('appNickname', app_nickname))
            
        if personal_audience_id is not None:
            
            _query_params.append(('personalAudienceId', personal_audience_id))
            
        if non_guest_username is not None:
            
            _query_params.append(('nonGuestUsername', non_guest_username))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/profile/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def edit_username(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="the user's contact email address (NOT the username) which is also used for email validation")] = None,
        username: Annotated[Optional[StrictStr], Field(description="the user's username to update with if they currently have a guest username")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Username and Email

        Update account's own username and/or emailAddress

        :param version: (required)
        :type version: float
        :param device_id: The device id
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param email_address: the user's contact email address (NOT the username) which is also used for email validation
        :type email_address: str
        :param username: the user's username to update with if they currently have a guest username
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_username_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            email_address=email_address,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def edit_username_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="the user's contact email address (NOT the username) which is also used for email validation")] = None,
        username: Annotated[Optional[StrictStr], Field(description="the user's username to update with if they currently have a guest username")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Username and Email

        Update account's own username and/or emailAddress

        :param version: (required)
        :type version: float
        :param device_id: The device id
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param email_address: the user's contact email address (NOT the username) which is also used for email validation
        :type email_address: str
        :param username: the user's username to update with if they currently have a guest username
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_username_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            email_address=email_address,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def edit_username_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="the user's contact email address (NOT the username) which is also used for email validation")] = None,
        username: Annotated[Optional[StrictStr], Field(description="the user's username to update with if they currently have a guest username")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Username and Email

        Update account's own username and/or emailAddress

        :param version: (required)
        :type version: float
        :param device_id: The device id
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param email_address: the user's contact email address (NOT the username) which is also used for email validation
        :type email_address: str
        :param username: the user's username to update with if they currently have a guest username
        :type username: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._edit_username_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            email_address=email_address,
            username=username,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _edit_username_serialize(
        self,
        version,
        device_id,
        account_id,
        email_address,
        username,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/username/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_account(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="Return Nulls")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_email: Annotated[Optional[StrictStr], Field(description="Connection Account Email")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to view another person's account")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="Purchase Type")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Determines whether to track if a person has viewed someone's profile")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Get Account

        Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.

        :param version: (required)
        :type version: float
        :param return_nulls: Return Nulls
        :type return_nulls: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_email: Connection Account Email
        :type connection_account_email: str
        :param connection_account_id: The account id used to view another person's account
        :type connection_account_id: int
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param purchase_type: Purchase Type
        :type purchase_type: str
        :param update_viewed_date: Determines whether to track if a person has viewed someone's profile
        :type update_viewed_date: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            connection_account_email=connection_account_email,
            connection_account_id=connection_account_id,
            response_filters=response_filters,
            game_type=game_type,
            app_key=app_key,
            purchase_type=purchase_type,
            update_viewed_date=update_viewed_date,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_account_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="Return Nulls")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_email: Annotated[Optional[StrictStr], Field(description="Connection Account Email")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to view another person's account")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="Purchase Type")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Determines whether to track if a person has viewed someone's profile")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Get Account

        Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.

        :param version: (required)
        :type version: float
        :param return_nulls: Return Nulls
        :type return_nulls: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_email: Connection Account Email
        :type connection_account_email: str
        :param connection_account_id: The account id used to view another person's account
        :type connection_account_id: int
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param purchase_type: Purchase Type
        :type purchase_type: str
        :param update_viewed_date: Determines whether to track if a person has viewed someone's profile
        :type update_viewed_date: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            connection_account_email=connection_account_email,
            connection_account_id=connection_account_id,
            response_filters=response_filters,
            game_type=game_type,
            app_key=app_key,
            purchase_type=purchase_type,
            update_viewed_date=update_viewed_date,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_account_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="Return Nulls")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_email: Annotated[Optional[StrictStr], Field(description="Connection Account Email")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to view another person's account")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="Purchase Type")] = None,
        update_viewed_date: Annotated[Optional[StrictBool], Field(description="Determines whether to track if a person has viewed someone's profile")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Account

        Gets a user's account profile. Application settings and account settings will also be returned for the owner of the account.

        :param version: (required)
        :type version: float
        :param return_nulls: Return Nulls
        :type return_nulls: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_email: Connection Account Email
        :type connection_account_email: str
        :param connection_account_id: The account id used to view another person's account
        :type connection_account_id: int
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param purchase_type: Purchase Type
        :type purchase_type: str
        :param update_viewed_date: Determines whether to track if a person has viewed someone's profile
        :type update_viewed_date: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_account_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            connection_account_email=connection_account_email,
            connection_account_id=connection_account_id,
            response_filters=response_filters,
            game_type=game_type,
            app_key=app_key,
            purchase_type=purchase_type,
            update_viewed_date=update_viewed_date,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_account_serialize(
        self,
        version,
        return_nulls,
        device_id,
        account_id,
        connection_account_email,
        connection_account_id,
        response_filters,
        game_type,
        app_key,
        purchase_type,
        update_viewed_date,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_email is not None:
            
            _query_params.append(('connectionAccountEmail', connection_account_email))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if purchase_type is not None:
            
            _query_params.append(('purchaseType', purchase_type))
            
        if update_viewed_date is not None:
            
            _query_params.append(('updateViewedDate', update_viewed_date))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/profile/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_profile_assets(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="Determines whether to return null fields in the response")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="The account id of the person the user wants to view")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of MediaType")] = None,
        mime_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of mime types")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what the returning list will be sorted by (see AssetApiMap)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return the resulting list in descending or ascending order")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        i: Annotated[Optional[StrictInt], Field(description="_i")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="_l")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AssetListResponse:
        """Get Profile Assets

        Get a list of assets a person has ever uploaded. Filters the list based on parameters.

        :param version: (required)
        :type version: float
        :param return_nulls: Determines whether to return null fields in the response
        :type return_nulls: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param owner_id: The account id of the person the user wants to view
        :type owner_id: int
        :param media_types: Comma separated list of MediaType
        :type media_types: str
        :param mime_types: Comma separated list of mime types
        :type mime_types: str
        :param sort_field: Determines what the returning list will be sorted by (see AssetApiMap)
        :type sort_field: str
        :param descending: Determines whether to return the resulting list in descending or ascending order
        :type descending: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param i: _i
        :type i: int
        :param start: Start of the pagination
        :type start: int
        :param l: _l
        :type l: int
        :param limit: Limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_profile_assets_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            owner_id=owner_id,
            media_types=media_types,
            mime_types=mime_types,
            sort_field=sort_field,
            descending=descending,
            latitude=latitude,
            longitude=longitude,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_profile_assets_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="Determines whether to return null fields in the response")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="The account id of the person the user wants to view")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of MediaType")] = None,
        mime_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of mime types")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what the returning list will be sorted by (see AssetApiMap)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return the resulting list in descending or ascending order")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        i: Annotated[Optional[StrictInt], Field(description="_i")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="_l")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AssetListResponse]:
        """Get Profile Assets

        Get a list of assets a person has ever uploaded. Filters the list based on parameters.

        :param version: (required)
        :type version: float
        :param return_nulls: Determines whether to return null fields in the response
        :type return_nulls: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param owner_id: The account id of the person the user wants to view
        :type owner_id: int
        :param media_types: Comma separated list of MediaType
        :type media_types: str
        :param mime_types: Comma separated list of mime types
        :type mime_types: str
        :param sort_field: Determines what the returning list will be sorted by (see AssetApiMap)
        :type sort_field: str
        :param descending: Determines whether to return the resulting list in descending or ascending order
        :type descending: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param i: _i
        :type i: int
        :param start: Start of the pagination
        :type start: int
        :param l: _l
        :type l: int
        :param limit: Limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_profile_assets_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            owner_id=owner_id,
            media_types=media_types,
            mime_types=mime_types,
            sort_field=sort_field,
            descending=descending,
            latitude=latitude,
            longitude=longitude,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_profile_assets_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="Determines whether to return null fields in the response")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="The account id of the person the user wants to view")] = None,
        media_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of MediaType")] = None,
        mime_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of mime types")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what the returning list will be sorted by (see AssetApiMap)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return the resulting list in descending or ascending order")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        i: Annotated[Optional[StrictInt], Field(description="_i")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="_l")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Profile Assets

        Get a list of assets a person has ever uploaded. Filters the list based on parameters.

        :param version: (required)
        :type version: float
        :param return_nulls: Determines whether to return null fields in the response
        :type return_nulls: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param owner_id: The account id of the person the user wants to view
        :type owner_id: int
        :param media_types: Comma separated list of MediaType
        :type media_types: str
        :param mime_types: Comma separated list of mime types
        :type mime_types: str
        :param sort_field: Determines what the returning list will be sorted by (see AssetApiMap)
        :type sort_field: str
        :param descending: Determines whether to return the resulting list in descending or ascending order
        :type descending: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param i: _i
        :type i: int
        :param start: Start of the pagination
        :type start: int
        :param l: _l
        :type l: int
        :param limit: Limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_profile_assets_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            owner_id=owner_id,
            media_types=media_types,
            mime_types=mime_types,
            sort_field=sort_field,
            descending=descending,
            latitude=latitude,
            longitude=longitude,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_profile_assets_serialize(
        self,
        version,
        return_nulls,
        device_id,
        account_id,
        owner_id,
        media_types,
        mime_types,
        sort_field,
        descending,
        latitude,
        longitude,
        i,
        start,
        l,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if owner_id is not None:
            
            _query_params.append(('ownerId', owner_id))
            
        if media_types is not None:
            
            _query_params.append(('mediaTypes', media_types))
            
        if mime_types is not None:
            
            _query_params.append(('mimeTypes', mime_types))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/profile/assets',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_referral_list(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        retrieve_type: Annotated[Optional[StrictStr], Field(description="one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above")] = None,
        level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for children and ancestors of current account, starts from current account")] = None,
        ancestor_level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for ancestors, will override levelLimit if this is set")] = None,
        children_level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for children, will override levelLimit if this is set")] = None,
        ancestor_list_start: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination start for children list")] = None,
        ancestor_list_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination limit for children list")] = None,
        children_list_start: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination start for children list")] = None,
        children_list_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination limit for children list")] = None,
        children_children: Annotated[Optional[StrictBool], Field(description="if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> None:
        """Search Accounts

        Gets a user's account profile and their referral List.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param retrieve_type: one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above
        :type retrieve_type: str
        :param level_limit: level limit for children and ancestors of current account, starts from current account
        :type level_limit: float
        :param ancestor_level_limit: level limit for ancestors, will override levelLimit if this is set
        :type ancestor_level_limit: float
        :param children_level_limit: level limit for children, will override levelLimit if this is set
        :type children_level_limit: float
        :param ancestor_list_start: pagination start for children list
        :type ancestor_list_start: float
        :param ancestor_list_limit: pagination limit for children list
        :type ancestor_list_limit: float
        :param children_list_start: pagination start for children list
        :type children_list_start: float
        :param children_list_limit: pagination limit for children list
        :type children_list_limit: float
        :param children_children: if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item
        :type children_children: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_referral_list_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            retrieve_type=retrieve_type,
            level_limit=level_limit,
            ancestor_level_limit=ancestor_level_limit,
            children_level_limit=children_level_limit,
            ancestor_list_start=ancestor_list_start,
            ancestor_list_limit=ancestor_list_limit,
            children_list_start=children_list_start,
            children_list_limit=children_list_limit,
            children_children=children_children,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_referral_list_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        retrieve_type: Annotated[Optional[StrictStr], Field(description="one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above")] = None,
        level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for children and ancestors of current account, starts from current account")] = None,
        ancestor_level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for ancestors, will override levelLimit if this is set")] = None,
        children_level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for children, will override levelLimit if this is set")] = None,
        ancestor_list_start: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination start for children list")] = None,
        ancestor_list_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination limit for children list")] = None,
        children_list_start: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination start for children list")] = None,
        children_list_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination limit for children list")] = None,
        children_children: Annotated[Optional[StrictBool], Field(description="if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[None]:
        """Search Accounts

        Gets a user's account profile and their referral List.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param retrieve_type: one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above
        :type retrieve_type: str
        :param level_limit: level limit for children and ancestors of current account, starts from current account
        :type level_limit: float
        :param ancestor_level_limit: level limit for ancestors, will override levelLimit if this is set
        :type ancestor_level_limit: float
        :param children_level_limit: level limit for children, will override levelLimit if this is set
        :type children_level_limit: float
        :param ancestor_list_start: pagination start for children list
        :type ancestor_list_start: float
        :param ancestor_list_limit: pagination limit for children list
        :type ancestor_list_limit: float
        :param children_list_start: pagination start for children list
        :type children_list_start: float
        :param children_list_limit: pagination limit for children list
        :type children_list_limit: float
        :param children_children: if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item
        :type children_children: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_referral_list_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            retrieve_type=retrieve_type,
            level_limit=level_limit,
            ancestor_level_limit=ancestor_level_limit,
            children_level_limit=children_level_limit,
            ancestor_list_start=ancestor_list_start,
            ancestor_list_limit=ancestor_list_limit,
            children_list_start=children_list_start,
            children_list_limit=children_list_limit,
            children_children=children_children,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_referral_list_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        retrieve_type: Annotated[Optional[StrictStr], Field(description="one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above")] = None,
        level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for children and ancestors of current account, starts from current account")] = None,
        ancestor_level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for ancestors, will override levelLimit if this is set")] = None,
        children_level_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="level limit for children, will override levelLimit if this is set")] = None,
        ancestor_list_start: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination start for children list")] = None,
        ancestor_list_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination limit for children list")] = None,
        children_list_start: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination start for children list")] = None,
        children_list_limit: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="pagination limit for children list")] = None,
        children_children: Annotated[Optional[StrictBool], Field(description="if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Accounts

        Gets a user's account profile and their referral List.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param retrieve_type: one of these option - GET_CHILDREN will get all accounts that had signed up using the current account invite link - GET_ANCESTOR will get all accounts that referred the current account and it's parents, recursively - GET_ALL will get all of the above
        :type retrieve_type: str
        :param level_limit: level limit for children and ancestors of current account, starts from current account
        :type level_limit: float
        :param ancestor_level_limit: level limit for ancestors, will override levelLimit if this is set
        :type ancestor_level_limit: float
        :param children_level_limit: level limit for children, will override levelLimit if this is set
        :type children_level_limit: float
        :param ancestor_list_start: pagination start for children list
        :type ancestor_list_start: float
        :param ancestor_list_limit: pagination limit for children list
        :type ancestor_list_limit: float
        :param children_list_start: pagination start for children list
        :type children_list_start: float
        :param children_list_limit: pagination limit for children list
        :type children_list_limit: float
        :param children_children: if true, on each item in ancestor and children list, return the childrenTotalNumber and ancestorTotalNumber for that item
        :type children_children: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_referral_list_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            retrieve_type=retrieve_type,
            level_limit=level_limit,
            ancestor_level_limit=ancestor_level_limit,
            children_level_limit=children_level_limit,
            ancestor_list_start=ancestor_list_start,
            ancestor_list_limit=ancestor_list_limit,
            children_list_start=children_list_start,
            children_list_limit=children_list_limit,
            children_children=children_children,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_referral_list_serialize(
        self,
        version,
        account_id,
        app_key,
        retrieve_type,
        level_limit,
        ancestor_level_limit,
        children_level_limit,
        ancestor_list_start,
        ancestor_list_limit,
        children_list_start,
        children_list_limit,
        children_children,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if retrieve_type is not None:
            
            _query_params.append(('retrieveType', retrieve_type))
            
        if level_limit is not None:
            
            _query_params.append(('levelLimit', level_limit))
            
        if ancestor_level_limit is not None:
            
            _query_params.append(('ancestorLevelLimit', ancestor_level_limit))
            
        if children_level_limit is not None:
            
            _query_params.append(('childrenLevelLimit', children_level_limit))
            
        if ancestor_list_start is not None:
            
            _query_params.append(('ancestorListStart', ancestor_list_start))
            
        if ancestor_list_limit is not None:
            
            _query_params.append(('ancestorListLimit', ancestor_list_limit))
            
        if children_list_start is not None:
            
            _query_params.append(('childrenListStart', children_list_start))
            
        if children_list_limit is not None:
            
            _query_params.append(('childrenListLimit', children_list_limit))
            
        if children_children is not None:
            
            _query_params.append(('childrenChildren', children_children))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter




        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/referral/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_settings(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UserSettingsResponse:
        """Get Account Settings

        Get the account settings for a user

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_settings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_settings_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UserSettingsResponse]:
        """Get Account Settings

        Get the account settings for a user

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_settings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_settings_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Account Settings

        Get the account settings for a user

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_settings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_settings_serialize(
        self,
        version,
        device_id,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/settings/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def login_delegate(
        self,
        version: Union[StrictFloat, StrictInt],
        access_token: StrictStr,
        app_key: StrictStr,
        device_id: Optional[StrictStr] = None,
        access_token_secret: Optional[StrictStr] = None,
        delegated_account_id: Optional[StrictInt] = None,
        delegated_username: Optional[StrictStr] = None,
        network_uid: Annotated[Optional[StrictStr], Field(description="The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE")] = None,
        age_restriction: Annotated[Optional[StrictInt], Field(description="Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="This determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Login as Account

        A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.

        :param version: (required)
        :type version: float
        :param access_token: (required)
        :type access_token: str
        :param app_key: (required)
        :type app_key: str
        :param device_id:
        :type device_id: str
        :param access_token_secret:
        :type access_token_secret: str
        :param delegated_account_id:
        :type delegated_account_id: int
        :param delegated_username:
        :type delegated_username: str
        :param network_uid: The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE
        :type network_uid: str
        :param age_restriction: Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        :type age_restriction: int
        :param response_filters: This determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude:
        :type latitude: float
        :param longitude:
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_delegate_serialize(
            version=version,
            access_token=access_token,
            app_key=app_key,
            device_id=device_id,
            access_token_secret=access_token_secret,
            delegated_account_id=delegated_account_id,
            delegated_username=delegated_username,
            network_uid=network_uid,
            age_restriction=age_restriction,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def login_delegate_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        access_token: StrictStr,
        app_key: StrictStr,
        device_id: Optional[StrictStr] = None,
        access_token_secret: Optional[StrictStr] = None,
        delegated_account_id: Optional[StrictInt] = None,
        delegated_username: Optional[StrictStr] = None,
        network_uid: Annotated[Optional[StrictStr], Field(description="The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE")] = None,
        age_restriction: Annotated[Optional[StrictInt], Field(description="Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="This determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Login as Account

        A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.

        :param version: (required)
        :type version: float
        :param access_token: (required)
        :type access_token: str
        :param app_key: (required)
        :type app_key: str
        :param device_id:
        :type device_id: str
        :param access_token_secret:
        :type access_token_secret: str
        :param delegated_account_id:
        :type delegated_account_id: int
        :param delegated_username:
        :type delegated_username: str
        :param network_uid: The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE
        :type network_uid: str
        :param age_restriction: Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        :type age_restriction: int
        :param response_filters: This determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude:
        :type latitude: float
        :param longitude:
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_delegate_serialize(
            version=version,
            access_token=access_token,
            app_key=app_key,
            device_id=device_id,
            access_token_secret=access_token_secret,
            delegated_account_id=delegated_account_id,
            delegated_username=delegated_username,
            network_uid=network_uid,
            age_restriction=age_restriction,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def login_delegate_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        access_token: StrictStr,
        app_key: StrictStr,
        device_id: Optional[StrictStr] = None,
        access_token_secret: Optional[StrictStr] = None,
        delegated_account_id: Optional[StrictInt] = None,
        delegated_username: Optional[StrictStr] = None,
        network_uid: Annotated[Optional[StrictStr], Field(description="The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE")] = None,
        age_restriction: Annotated[Optional[StrictInt], Field(description="Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="This determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Login as Account

        A login service that supports logging in as someone else (accounts that the user manages). Intended for internal use for now.

        :param version: (required)
        :type version: float
        :param access_token: (required)
        :type access_token: str
        :param app_key: (required)
        :type app_key: str
        :param device_id:
        :type device_id: str
        :param access_token_secret:
        :type access_token_secret: str
        :param delegated_account_id:
        :type delegated_account_id: int
        :param delegated_username:
        :type delegated_username: str
        :param network_uid: The access provider to authenticate against (default: USERNAME). Supported values: FACEBOOK, TWITTER, USERNAME, PHONE
        :type network_uid: str
        :param age_restriction: Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        :type age_restriction: int
        :param response_filters: This determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude:
        :type latitude: float
        :param longitude:
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_delegate_serialize(
            version=version,
            access_token=access_token,
            app_key=app_key,
            device_id=device_id,
            access_token_secret=access_token_secret,
            delegated_account_id=delegated_account_id,
            delegated_username=delegated_username,
            network_uid=network_uid,
            age_restriction=age_restriction,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _login_delegate_serialize(
        self,
        version,
        access_token,
        app_key,
        device_id,
        access_token_secret,
        delegated_account_id,
        delegated_username,
        network_uid,
        age_restriction,
        response_filters,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if access_token is not None:
            
            _query_params.append(('accessToken', access_token))
            
        if access_token_secret is not None:
            
            _query_params.append(('accessTokenSecret', access_token_secret))
            
        if delegated_account_id is not None:
            
            _query_params.append(('delegatedAccountId', delegated_account_id))
            
        if delegated_username is not None:
            
            _query_params.append(('delegatedUsername', delegated_username))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if age_restriction is not None:
            
            _query_params.append(('ageRestriction', age_restriction))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/login/delegate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def login_general(
        self,
        version: Union[StrictFloat, StrictInt],
        access_token: Annotated[StrictStr, Field(description="The access token to authenticate with (ex: username or fb token)")],
        network_uid: Annotated[StrictStr, Field(description="The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE ")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc")] = None,
        access_token_secret: Annotated[Optional[StrictStr], Field(description="The secret to authenticate with (ex: password)")] = None,
        age_restriction: Annotated[Optional[StrictInt], Field(description="Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="This determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to update the user's current location")] = None,
        email_match: Annotated[Optional[StrictBool], Field(description="Option to check for email if username doesn't match, also support multiple accounts")] = None,
        chosen_account_id: Annotated[Optional[StrictInt], Field(description="Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Login Account

        General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}

        :param version: (required)
        :type version: float
        :param access_token: The access token to authenticate with (ex: username or fb token) (required)
        :type access_token: str
        :param network_uid: The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (required)
        :type network_uid: str
        :param app_key: The application key (required)
        :type app_key: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param device_id_type: The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        :type device_id_type: str
        :param access_token_secret: The secret to authenticate with (ex: password)
        :type access_token_secret: str
        :param age_restriction: Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        :type age_restriction: int
        :param response_filters: This determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: Used to update the user's current location
        :type latitude: float
        :param longitude: Used to update the user's current location
        :type longitude: float
        :param email_match: Option to check for email if username doesn't match, also support multiple accounts
        :type email_match: bool
        :param chosen_account_id: Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request
        :type chosen_account_id: int
        :param third_party_credential_id: Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object
        :type third_party_credential_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_general_serialize(
            version=version,
            access_token=access_token,
            network_uid=network_uid,
            app_key=app_key,
            device_id=device_id,
            device_id_type=device_id_type,
            access_token_secret=access_token_secret,
            age_restriction=age_restriction,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            email_match=email_match,
            chosen_account_id=chosen_account_id,
            third_party_credential_id=third_party_credential_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def login_general_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        access_token: Annotated[StrictStr, Field(description="The access token to authenticate with (ex: username or fb token)")],
        network_uid: Annotated[StrictStr, Field(description="The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE ")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc")] = None,
        access_token_secret: Annotated[Optional[StrictStr], Field(description="The secret to authenticate with (ex: password)")] = None,
        age_restriction: Annotated[Optional[StrictInt], Field(description="Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="This determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to update the user's current location")] = None,
        email_match: Annotated[Optional[StrictBool], Field(description="Option to check for email if username doesn't match, also support multiple accounts")] = None,
        chosen_account_id: Annotated[Optional[StrictInt], Field(description="Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Login Account

        General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}

        :param version: (required)
        :type version: float
        :param access_token: The access token to authenticate with (ex: username or fb token) (required)
        :type access_token: str
        :param network_uid: The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (required)
        :type network_uid: str
        :param app_key: The application key (required)
        :type app_key: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param device_id_type: The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        :type device_id_type: str
        :param access_token_secret: The secret to authenticate with (ex: password)
        :type access_token_secret: str
        :param age_restriction: Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        :type age_restriction: int
        :param response_filters: This determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: Used to update the user's current location
        :type latitude: float
        :param longitude: Used to update the user's current location
        :type longitude: float
        :param email_match: Option to check for email if username doesn't match, also support multiple accounts
        :type email_match: bool
        :param chosen_account_id: Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request
        :type chosen_account_id: int
        :param third_party_credential_id: Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object
        :type third_party_credential_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_general_serialize(
            version=version,
            access_token=access_token,
            network_uid=network_uid,
            app_key=app_key,
            device_id=device_id,
            device_id_type=device_id_type,
            access_token_secret=access_token_secret,
            age_restriction=age_restriction,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            email_match=email_match,
            chosen_account_id=chosen_account_id,
            third_party_credential_id=third_party_credential_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def login_general_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        access_token: Annotated[StrictStr, Field(description="The access token to authenticate with (ex: username or fb token)")],
        network_uid: Annotated[StrictStr, Field(description="The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE ")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc")] = None,
        access_token_secret: Annotated[Optional[StrictStr], Field(description="The secret to authenticate with (ex: password)")] = None,
        age_restriction: Annotated[Optional[StrictInt], Field(description="Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="This determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Used to update the user's current location")] = None,
        email_match: Annotated[Optional[StrictBool], Field(description="Option to check for email if username doesn't match, also support multiple accounts")] = None,
        chosen_account_id: Annotated[Optional[StrictInt], Field(description="Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Login Account

        General login service that supports various authentication methods. Currently supports Facebook, Twitter, Sirqul Username, and Sirqul Phone by default. Can also support custom networks created using the {@link ThirdPartyApi}

        :param version: (required)
        :type version: float
        :param access_token: The access token to authenticate with (ex: username or fb token) (required)
        :type access_token: str
        :param network_uid: The access provider to authenticate against. This can be custom  networks created using the ThirdPartyApi as well. Supported values by default  include: FACEBOOK, TWITTER, USERNAME, PHONE  (required)
        :type network_uid: str
        :param app_key: The application key (required)
        :type app_key: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param device_id_type: The type of device id (this is defined by the client), ie. MAC_ADDRESS, APPLE_UDID, etc
        :type device_id_type: str
        :param access_token_secret: The secret to authenticate with (ex: password)
        :type access_token_secret: str
        :param age_restriction: Checks user's birthday to see if they meet an age requirement. If the user is under age, an error message is returned.
        :type age_restriction: int
        :param response_filters: This determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: Used to update the user's current location
        :type latitude: float
        :param longitude: Used to update the user's current location
        :type longitude: float
        :param email_match: Option to check for email if username doesn't match, also support multiple accounts
        :type email_match: bool
        :param chosen_account_id: Chosen account Id sent from the app - pass in the 2nd request to choose an account from multiple accounts matching the email - use one of the account id from the previous request
        :type chosen_account_id: int
        :param third_party_credential_id: Third-party credential Id, pass in the 2nd request to choose an account from multiple accounts matching the email - use the id from the previous call ThirdPartyCredential object
        :type third_party_credential_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_general_serialize(
            version=version,
            access_token=access_token,
            network_uid=network_uid,
            app_key=app_key,
            device_id=device_id,
            device_id_type=device_id_type,
            access_token_secret=access_token_secret,
            age_restriction=age_restriction,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            email_match=email_match,
            chosen_account_id=chosen_account_id,
            third_party_credential_id=third_party_credential_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _login_general_serialize(
        self,
        version,
        access_token,
        network_uid,
        app_key,
        device_id,
        device_id_type,
        access_token_secret,
        age_restriction,
        response_filters,
        latitude,
        longitude,
        email_match,
        chosen_account_id,
        third_party_credential_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if device_id_type is not None:
            
            _query_params.append(('deviceIdType', device_id_type))
            
        if access_token is not None:
            
            _query_params.append(('accessToken', access_token))
            
        if access_token_secret is not None:
            
            _query_params.append(('accessTokenSecret', access_token_secret))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if age_restriction is not None:
            
            _query_params.append(('ageRestriction', age_restriction))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if email_match is not None:
            
            _query_params.append(('emailMatch', email_match))
            
        if chosen_account_id is not None:
            
            _query_params.append(('chosenAccountId', chosen_account_id))
            
        if third_party_credential_id is not None:
            
            _query_params.append(('thirdPartyCredentialId', third_party_credential_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/login',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def login_username(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="the user's email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="the password")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        app: Annotated[Optional[StrictStr], Field(description="the app")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. This is deprecated, use appKey.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="the profile to return")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="a comma separated list of ProfileFilters for filtering the returned response data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Login Account (Username)

        Login to system with an account

        :param version: (required)
        :type version: float
        :param username: the user's email address they used to sign-up (required)
        :type username: str
        :param password: the password (required)
        :type password: str
        :param device_id: the device id
        :type device_id: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param app: the app
        :type app: str
        :param game_type: This parameter is deprecated. This is deprecated, use appKey.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param return_profile: the profile to return
        :type return_profile: bool
        :param response_filters: a comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_username_serialize(
            version=version,
            username=username,
            password=password,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            app=app,
            game_type=game_type,
            app_key=app_key,
            return_profile=return_profile,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def login_username_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="the user's email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="the password")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        app: Annotated[Optional[StrictStr], Field(description="the app")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. This is deprecated, use appKey.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="the profile to return")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="a comma separated list of ProfileFilters for filtering the returned response data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Login Account (Username)

        Login to system with an account

        :param version: (required)
        :type version: float
        :param username: the user's email address they used to sign-up (required)
        :type username: str
        :param password: the password (required)
        :type password: str
        :param device_id: the device id
        :type device_id: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param app: the app
        :type app: str
        :param game_type: This parameter is deprecated. This is deprecated, use appKey.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param return_profile: the profile to return
        :type return_profile: bool
        :param response_filters: a comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_username_serialize(
            version=version,
            username=username,
            password=password,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            app=app,
            game_type=game_type,
            app_key=app_key,
            return_profile=return_profile,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def login_username_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="the user's email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="the password")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        app: Annotated[Optional[StrictStr], Field(description="the app")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. This is deprecated, use appKey.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="the profile to return")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="a comma separated list of ProfileFilters for filtering the returned response data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Login Account (Username)

        Login to system with an account

        :param version: (required)
        :type version: float
        :param username: the user's email address they used to sign-up (required)
        :type username: str
        :param password: the password (required)
        :type password: str
        :param device_id: the device id
        :type device_id: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param app: the app
        :type app: str
        :param game_type: This parameter is deprecated. This is deprecated, use appKey.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param return_profile: the profile to return
        :type return_profile: bool
        :param response_filters: a comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._login_username_serialize(
            version=version,
            username=username,
            password=password,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            app=app,
            game_type=game_type,
            app_key=app_key,
            return_profile=return_profile,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _login_username_serialize(
        self,
        version,
        username,
        password,
        device_id,
        latitude,
        longitude,
        app,
        game_type,
        app_key,
        return_profile,
        response_filters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if password is not None:
            
            _query_params.append(('password', password))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if app is not None:
            
            _query_params.append(('app', app))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if return_profile is not None:
            
            _query_params.append(('returnProfile', return_profile))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def logout(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="Device Id Type")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Logout Account

        Cleans up the users data for logging out.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param device_id_type: Device Id Type
        :type device_id_type: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logout_serialize(
            version=version,
            device_id=device_id,
            device_id_type=device_id_type,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def logout_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="Device Id Type")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Logout Account

        Cleans up the users data for logging out.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param device_id_type: Device Id Type
        :type device_id_type: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logout_serialize(
            version=version,
            device_id=device_id,
            device_id_type=device_id_type,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def logout_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="Device Id Type")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Logout Account

        Cleans up the users data for logging out.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param device_id_type: Device Id Type
        :type device_id_type: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._logout_serialize(
            version=version,
            device_id=device_id,
            device_id_type=device_id_type,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _logout_serialize(
        self,
        version,
        device_id,
        device_id_type,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if device_id_type is not None:
            
            _query_params.append(('deviceIdType', device_id_type))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/logout',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def merge_account(
        self,
        version: Union[StrictFloat, StrictInt],
        merge_account_id: Annotated[StrictInt, Field(description="The id of the account to being merged")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Merge Account

        Merges the analytics, achievements, leaderboards of two accounts.

        :param version: (required)
        :type version: float
        :param merge_account_id: The id of the account to being merged (required)
        :type merge_account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._merge_account_serialize(
            version=version,
            merge_account_id=merge_account_id,
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def merge_account_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        merge_account_id: Annotated[StrictInt, Field(description="The id of the account to being merged")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Merge Account

        Merges the analytics, achievements, leaderboards of two accounts.

        :param version: (required)
        :type version: float
        :param merge_account_id: The id of the account to being merged (required)
        :type merge_account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._merge_account_serialize(
            version=version,
            merge_account_id=merge_account_id,
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def merge_account_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        merge_account_id: Annotated[StrictInt, Field(description="The id of the account to being merged")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Merge Account

        Merges the analytics, achievements, leaderboards of two accounts.

        :param version: (required)
        :type version: float
        :param merge_account_id: The id of the account to being merged (required)
        :type merge_account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._merge_account_serialize(
            version=version,
            merge_account_id=merge_account_id,
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _merge_account_serialize(
        self,
        version,
        merge_account_id,
        app_key,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if merge_account_id is not None:
            
            _query_params.append(('mergeAccountId', merge_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/merge',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def password_change(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account to update")],
        old_password: Annotated[StrictStr, Field(description="The current password, used to validate access")],
        new_password: Annotated[StrictStr, Field(description="The new password to set, cannot be empty")],
        confirm_password: Annotated[StrictStr, Field(description="The new password to confirm, must match newPassword")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Password

        Update the account password.

        :param version: (required)
        :type version: float
        :param account_id: The account to update (required)
        :type account_id: int
        :param old_password: The current password, used to validate access (required)
        :type old_password: str
        :param new_password: The new password to set, cannot be empty (required)
        :type new_password: str
        :param confirm_password: The new password to confirm, must match newPassword (required)
        :type confirm_password: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._password_change_serialize(
            version=version,
            account_id=account_id,
            old_password=old_password,
            new_password=new_password,
            confirm_password=confirm_password,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def password_change_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account to update")],
        old_password: Annotated[StrictStr, Field(description="The current password, used to validate access")],
        new_password: Annotated[StrictStr, Field(description="The new password to set, cannot be empty")],
        confirm_password: Annotated[StrictStr, Field(description="The new password to confirm, must match newPassword")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Password

        Update the account password.

        :param version: (required)
        :type version: float
        :param account_id: The account to update (required)
        :type account_id: int
        :param old_password: The current password, used to validate access (required)
        :type old_password: str
        :param new_password: The new password to set, cannot be empty (required)
        :type new_password: str
        :param confirm_password: The new password to confirm, must match newPassword (required)
        :type confirm_password: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._password_change_serialize(
            version=version,
            account_id=account_id,
            old_password=old_password,
            new_password=new_password,
            confirm_password=confirm_password,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def password_change_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account to update")],
        old_password: Annotated[StrictStr, Field(description="The current password, used to validate access")],
        new_password: Annotated[StrictStr, Field(description="The new password to set, cannot be empty")],
        confirm_password: Annotated[StrictStr, Field(description="The new password to confirm, must match newPassword")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Password

        Update the account password.

        :param version: (required)
        :type version: float
        :param account_id: The account to update (required)
        :type account_id: int
        :param old_password: The current password, used to validate access (required)
        :type old_password: str
        :param new_password: The new password to set, cannot be empty (required)
        :type new_password: str
        :param confirm_password: The new password to confirm, must match newPassword (required)
        :type confirm_password: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._password_change_serialize(
            version=version,
            account_id=account_id,
            old_password=old_password,
            new_password=new_password,
            confirm_password=confirm_password,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _password_change_serialize(
        self,
        version,
        account_id,
        old_password,
        new_password,
        confirm_password,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if old_password is not None:
            
            _query_params.append(('oldPassword', old_password))
            
        if new_password is not None:
            
            _query_params.append(('newPassword', new_password))
            
        if confirm_password is not None:
            
            _query_params.append(('confirmPassword', confirm_password))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/passwordchange',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def password_reset(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        password: Annotated[StrictStr, Field(description="The new password to set, cannot be empty")],
        confirm: Annotated[StrictStr, Field(description="The new password to confirm, must match newPassword")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Reset Password

        Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param password: The new password to set, cannot be empty (required)
        :type password: str
        :param confirm: The new password to confirm, must match newPassword (required)
        :type confirm: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._password_reset_serialize(
            version=version,
            token=token,
            password=password,
            confirm=confirm,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def password_reset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        password: Annotated[StrictStr, Field(description="The new password to set, cannot be empty")],
        confirm: Annotated[StrictStr, Field(description="The new password to confirm, must match newPassword")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Reset Password

        Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param password: The new password to set, cannot be empty (required)
        :type password: str
        :param confirm: The new password to confirm, must match newPassword (required)
        :type confirm: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._password_reset_serialize(
            version=version,
            token=token,
            password=password,
            confirm=confirm,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def password_reset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        password: Annotated[StrictStr, Field(description="The new password to set, cannot be empty")],
        confirm: Annotated[StrictStr, Field(description="The new password to confirm, must match newPassword")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Reset Password

        Reset the account password. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param password: The new password to set, cannot be empty (required)
        :type password: str
        :param confirm: The new password to confirm, must match newPassword (required)
        :type confirm: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._password_reset_serialize(
            version=version,
            token=token,
            password=password,
            confirm=confirm,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _password_reset_serialize(
        self,
        version,
        token,
        password,
        confirm,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        if password is not None:
            
            _query_params.append(('password', password))
            
        if confirm is not None:
            
            _query_params.append(('confirm', confirm))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/passwordreset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def request_password_reset(
        self,
        version: Union[StrictFloat, StrictInt],
        email: Annotated[StrictStr, Field(description="The email/username of the account")],
        var_from: Annotated[Optional[StrictStr], Field(description="this is the sender email")] = None,
        domain: Annotated[Optional[StrictStr], Field(description="this is the domain (like dev.sirqul.com) used to generate the password reset link")] = None,
        sub_url: Annotated[Optional[StrictStr], Field(description="this is the the subUrl (like resetpassword) used to generate a password reset link")] = None,
        referer: Annotated[Optional[StrictStr], Field(description="this is used to generate a password reset link")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Request Password Reset

        Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.

        :param version: (required)
        :type version: float
        :param email: The email/username of the account (required)
        :type email: str
        :param var_from: this is the sender email
        :type var_from: str
        :param domain: this is the domain (like dev.sirqul.com) used to generate the password reset link
        :type domain: str
        :param sub_url: this is the the subUrl (like resetpassword) used to generate a password reset link
        :type sub_url: str
        :param referer: this is used to generate a password reset link
        :type referer: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._request_password_reset_serialize(
            version=version,
            email=email,
            var_from=var_from,
            domain=domain,
            sub_url=sub_url,
            referer=referer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def request_password_reset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        email: Annotated[StrictStr, Field(description="The email/username of the account")],
        var_from: Annotated[Optional[StrictStr], Field(description="this is the sender email")] = None,
        domain: Annotated[Optional[StrictStr], Field(description="this is the domain (like dev.sirqul.com) used to generate the password reset link")] = None,
        sub_url: Annotated[Optional[StrictStr], Field(description="this is the the subUrl (like resetpassword) used to generate a password reset link")] = None,
        referer: Annotated[Optional[StrictStr], Field(description="this is used to generate a password reset link")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Request Password Reset

        Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.

        :param version: (required)
        :type version: float
        :param email: The email/username of the account (required)
        :type email: str
        :param var_from: this is the sender email
        :type var_from: str
        :param domain: this is the domain (like dev.sirqul.com) used to generate the password reset link
        :type domain: str
        :param sub_url: this is the the subUrl (like resetpassword) used to generate a password reset link
        :type sub_url: str
        :param referer: this is used to generate a password reset link
        :type referer: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._request_password_reset_serialize(
            version=version,
            email=email,
            var_from=var_from,
            domain=domain,
            sub_url=sub_url,
            referer=referer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def request_password_reset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        email: Annotated[StrictStr, Field(description="The email/username of the account")],
        var_from: Annotated[Optional[StrictStr], Field(description="this is the sender email")] = None,
        domain: Annotated[Optional[StrictStr], Field(description="this is the domain (like dev.sirqul.com) used to generate the password reset link")] = None,
        sub_url: Annotated[Optional[StrictStr], Field(description="this is the the subUrl (like resetpassword) used to generate a password reset link")] = None,
        referer: Annotated[Optional[StrictStr], Field(description="this is used to generate a password reset link")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Request Password Reset

        Request that an account password be reset. The account is looked up by email address and then a link is sent via email to that account with a reset token. The token is valid for 24 hours.

        :param version: (required)
        :type version: float
        :param email: The email/username of the account (required)
        :type email: str
        :param var_from: this is the sender email
        :type var_from: str
        :param domain: this is the domain (like dev.sirqul.com) used to generate the password reset link
        :type domain: str
        :param sub_url: this is the the subUrl (like resetpassword) used to generate a password reset link
        :type sub_url: str
        :param referer: this is used to generate a password reset link
        :type referer: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._request_password_reset_serialize(
            version=version,
            email=email,
            var_from=var_from,
            domain=domain,
            sub_url=sub_url,
            referer=referer,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _request_password_reset_serialize(
        self,
        version,
        email,
        var_from,
        domain,
        sub_url,
        referer,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if email is not None:
            
            _query_params.append(('email', email))
            
        if var_from is not None:
            
            _query_params.append(('from', var_from))
            
        if domain is not None:
            
            _query_params.append(('domain', domain))
            
        if sub_url is not None:
            
            _query_params.append(('subUrl', sub_url))
            
        if referer is not None:
            
            _query_params.append(('referer', referer))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/requestpasswordreset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def request_validate_account(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Send Validation Request

        Send an email to validate a user's account.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._request_validate_account_serialize(
            version=version,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def request_validate_account_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Send Validation Request

        Send an email to validate a user's account.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._request_validate_account_serialize(
            version=version,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def request_validate_account_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Validation Request

        Send an email to validate a user's account.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._request_validate_account_serialize(
            version=version,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _request_validate_account_serialize(
        self,
        version,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/requestValidateAccount',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_accounts(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The id of the account requesting")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword for for querying the account")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude")] = None,
        radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the radius")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="the user's gender")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="the user's Game Experience")] = None,
        age: Annotated[Optional[StrictInt], Field(description="the user's age")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the user's Category Ids")] = None,
        return_nulls: Annotated[Optional[StrictBool], Field(description="Return Nulls")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="A comma separated list of PurchaseType")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ProfileResponse]:
        """Search Accounts

        Search for account profiles.

        :param version: (required)
        :type version: float
        :param account_id: The id of the account requesting (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param keyword: The keyword for for querying the account
        :type keyword: str
        :param latitude: the latitude
        :type latitude: float
        :param longitude: the longitude
        :type longitude: float
        :param radius: the radius
        :type radius: float
        :param gender: the user's gender
        :type gender: str
        :param game_experience: the user's Game Experience
        :type game_experience: str
        :param age: the user's age
        :type age: int
        :param category_ids: the user's Category Ids
        :type category_ids: str
        :param return_nulls: Return Nulls
        :type return_nulls: bool
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param purchase_type: A comma separated list of PurchaseType
        :type purchase_type: str
        :param sort_field: The field to sort by
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with.
        :type start: int
        :param limit: The total number of record to return.
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_accounts_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            gender=gender,
            game_experience=game_experience,
            age=age,
            category_ids=category_ids,
            return_nulls=return_nulls,
            response_filters=response_filters,
            purchase_type=purchase_type,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProfileResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_accounts_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The id of the account requesting")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword for for querying the account")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude")] = None,
        radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the radius")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="the user's gender")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="the user's Game Experience")] = None,
        age: Annotated[Optional[StrictInt], Field(description="the user's age")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the user's Category Ids")] = None,
        return_nulls: Annotated[Optional[StrictBool], Field(description="Return Nulls")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="A comma separated list of PurchaseType")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ProfileResponse]]:
        """Search Accounts

        Search for account profiles.

        :param version: (required)
        :type version: float
        :param account_id: The id of the account requesting (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param keyword: The keyword for for querying the account
        :type keyword: str
        :param latitude: the latitude
        :type latitude: float
        :param longitude: the longitude
        :type longitude: float
        :param radius: the radius
        :type radius: float
        :param gender: the user's gender
        :type gender: str
        :param game_experience: the user's Game Experience
        :type game_experience: str
        :param age: the user's age
        :type age: int
        :param category_ids: the user's Category Ids
        :type category_ids: str
        :param return_nulls: Return Nulls
        :type return_nulls: bool
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param purchase_type: A comma separated list of PurchaseType
        :type purchase_type: str
        :param sort_field: The field to sort by
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with.
        :type start: int
        :param limit: The total number of record to return.
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_accounts_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            gender=gender,
            game_experience=game_experience,
            age=age,
            category_ids=category_ids,
            return_nulls=return_nulls,
            response_filters=response_filters,
            purchase_type=purchase_type,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProfileResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_accounts_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The id of the account requesting")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword for for querying the account")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude")] = None,
        radius: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the radius")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="the user's gender")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="the user's Game Experience")] = None,
        age: Annotated[Optional[StrictInt], Field(description="the user's age")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the user's Category Ids")] = None,
        return_nulls: Annotated[Optional[StrictBool], Field(description="Return Nulls")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="A comma separated list of PurchaseType")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Accounts

        Search for account profiles.

        :param version: (required)
        :type version: float
        :param account_id: The id of the account requesting (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param keyword: The keyword for for querying the account
        :type keyword: str
        :param latitude: the latitude
        :type latitude: float
        :param longitude: the longitude
        :type longitude: float
        :param radius: the radius
        :type radius: float
        :param gender: the user's gender
        :type gender: str
        :param game_experience: the user's Game Experience
        :type game_experience: str
        :param age: the user's age
        :type age: int
        :param category_ids: the user's Category Ids
        :type category_ids: str
        :param return_nulls: Return Nulls
        :type return_nulls: bool
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param purchase_type: A comma separated list of PurchaseType
        :type purchase_type: str
        :param sort_field: The field to sort by
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with.
        :type start: int
        :param limit: The total number of record to return.
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_accounts_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            radius=radius,
            gender=gender,
            game_experience=game_experience,
            age=age,
            category_ids=category_ids,
            return_nulls=return_nulls,
            response_filters=response_filters,
            purchase_type=purchase_type,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ProfileResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_accounts_serialize(
        self,
        version,
        account_id,
        app_key,
        keyword,
        latitude,
        longitude,
        radius,
        gender,
        game_experience,
        age,
        category_ids,
        return_nulls,
        response_filters,
        purchase_type,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if radius is not None:
            
            _query_params.append(('radius', radius))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if game_experience is not None:
            
            _query_params.append(('gameExperience', game_experience))
            
        if age is not None:
            
            _query_params.append(('age', age))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if purchase_type is not None:
            
            _query_params.append(('purchaseType', purchase_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/profile/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def secure_login(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="The user's encrypted email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="The encrypted password")],
        game_type: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id")] = None,
        charset_name: Annotated[Optional[StrictStr], Field(description="Charset Name")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="Return Profile")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Login Account (Encrypted Username)

        ogin with encrypted user-name and password.

        :param version: (required)
        :type version: float
        :param username: The user's encrypted email address they used to sign-up (required)
        :type username: str
        :param password: The encrypted password (required)
        :type password: str
        :param game_type: The application key (required)
        :type game_type: str
        :param device_id: The device id
        :type device_id: str
        :param charset_name: Charset Name
        :type charset_name: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param return_profile: Return Profile
        :type return_profile: bool
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._secure_login_serialize(
            version=version,
            username=username,
            password=password,
            game_type=game_type,
            device_id=device_id,
            charset_name=charset_name,
            latitude=latitude,
            longitude=longitude,
            return_profile=return_profile,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def secure_login_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="The user's encrypted email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="The encrypted password")],
        game_type: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id")] = None,
        charset_name: Annotated[Optional[StrictStr], Field(description="Charset Name")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="Return Profile")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Login Account (Encrypted Username)

        ogin with encrypted user-name and password.

        :param version: (required)
        :type version: float
        :param username: The user's encrypted email address they used to sign-up (required)
        :type username: str
        :param password: The encrypted password (required)
        :type password: str
        :param game_type: The application key (required)
        :type game_type: str
        :param device_id: The device id
        :type device_id: str
        :param charset_name: Charset Name
        :type charset_name: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param return_profile: Return Profile
        :type return_profile: bool
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._secure_login_serialize(
            version=version,
            username=username,
            password=password,
            game_type=game_type,
            device_id=device_id,
            charset_name=charset_name,
            latitude=latitude,
            longitude=longitude,
            return_profile=return_profile,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def secure_login_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="The user's encrypted email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="The encrypted password")],
        game_type: Annotated[StrictStr, Field(description="The application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id")] = None,
        charset_name: Annotated[Optional[StrictStr], Field(description="Charset Name")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        return_profile: Annotated[Optional[StrictBool], Field(description="Return Profile")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="A comma separated list of ProfileFilters for filtering the returned response data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Login Account (Encrypted Username)

        ogin with encrypted user-name and password.

        :param version: (required)
        :type version: float
        :param username: The user's encrypted email address they used to sign-up (required)
        :type username: str
        :param password: The encrypted password (required)
        :type password: str
        :param game_type: The application key (required)
        :type game_type: str
        :param device_id: The device id
        :type device_id: str
        :param charset_name: Charset Name
        :type charset_name: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param return_profile: Return Profile
        :type return_profile: bool
        :param response_filters: A comma separated list of ProfileFilters for filtering the returned response data
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._secure_login_serialize(
            version=version,
            username=username,
            password=password,
            game_type=game_type,
            device_id=device_id,
            charset_name=charset_name,
            latitude=latitude,
            longitude=longitude,
            return_profile=return_profile,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _secure_login_serialize(
        self,
        version,
        username,
        password,
        game_type,
        device_id,
        charset_name,
        latitude,
        longitude,
        return_profile,
        response_filters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if password is not None:
            
            _query_params.append(('password', password))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if charset_name is not None:
            
            _query_params.append(('charsetName', charset_name))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if return_profile is not None:
            
            _query_params.append(('returnProfile', return_profile))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/login/validate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def secure_signup(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[StrictStr, Field(description="The device id")],
        username: Annotated[StrictStr, Field(description="The encrypted email of the user, this is what will be used when they login")],
        password: Annotated[StrictStr, Field(description="The encrypted password of the user")],
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ")] = None,
        invite_token: Annotated[Optional[StrictStr], Field(description="the inviteToken that the referrer use for this account to sign up")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="Device Id Type")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username) which is also used for email validation")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        address: Annotated[Optional[StrictStr], Field(description="the user's address")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The street zipcode of the user's contact location")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user AudienceGender")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="the user's home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the user's cell phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="the user's Cell Phone Carrier")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="the user's Business Phone Number")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Search tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About Us information")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's maritial status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        charset_name: Annotated[Optional[StrictStr], Field(description="Charset Name")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="App Version")] = None,
        response_type: Annotated[Optional[StrictStr], Field(description="Response Type")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileInfoResponse:
        """Create Account (Encrypted Username)

        Create a new account by role (with encrypted user-name and password)

        :param version: (required)
        :type version: float
        :param device_id: The device id (required)
        :type device_id: str
        :param username: The encrypted email of the user, this is what will be used when they login (required)
        :type username: str
        :param password: The encrypted password of the user (required)
        :type password: str
        :param name: The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        :type name: str
        :param invite_token: the inviteToken that the referrer use for this account to sign up
        :type invite_token: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: Title
        :type title: str
        :param device_id_type: Device Id Type
        :type device_id_type: str
        :param email_address: The user's contact email address (NOT the username) which is also used for email validation
        :type email_address: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param address: the user's address
        :type address: str
        :param zipcode: The street zipcode of the user's contact location
        :type zipcode: str
        :param gender: The gender of the user AudienceGender
        :type gender: str
        :param birthday: The birthday date of the user in milliseconds
        :type birthday: int
        :param home_phone: the user's home phone number
        :type home_phone: str
        :param cell_phone: the user's cell phone number
        :type cell_phone: str
        :param cell_phone_carrier: the user's Cell Phone Carrier
        :type cell_phone_carrier: str
        :param business_phone: the user's Business Phone Number
        :type business_phone: str
        :param role: The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST
        :type role: str
        :param platforms: Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK
        :type platforms: str
        :param tags: Search tags
        :type tags: str
        :param about_us: About Us information
        :type about_us: str
        :param game_experience: Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's maritial status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred education in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param charset_name: Charset Name
        :type charset_name: str
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param app_version: App Version
        :type app_version: str
        :param response_type: Response Type
        :type response_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._secure_signup_serialize(
            version=version,
            device_id=device_id,
            username=username,
            password=password,
            name=name,
            invite_token=invite_token,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            device_id_type=device_id_type,
            email_address=email_address,
            asset_id=asset_id,
            address=address,
            zipcode=zipcode,
            gender=gender,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            role=role,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            game_experience=game_experience,
            category_ids=category_ids,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            latitude=latitude,
            longitude=longitude,
            accepted_terms=accepted_terms,
            charset_name=charset_name,
            game_type=game_type,
            app_key=app_key,
            app_version=app_version,
            response_type=response_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileInfoResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def secure_signup_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[StrictStr, Field(description="The device id")],
        username: Annotated[StrictStr, Field(description="The encrypted email of the user, this is what will be used when they login")],
        password: Annotated[StrictStr, Field(description="The encrypted password of the user")],
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ")] = None,
        invite_token: Annotated[Optional[StrictStr], Field(description="the inviteToken that the referrer use for this account to sign up")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="Device Id Type")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username) which is also used for email validation")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        address: Annotated[Optional[StrictStr], Field(description="the user's address")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The street zipcode of the user's contact location")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user AudienceGender")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="the user's home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the user's cell phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="the user's Cell Phone Carrier")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="the user's Business Phone Number")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Search tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About Us information")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's maritial status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        charset_name: Annotated[Optional[StrictStr], Field(description="Charset Name")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="App Version")] = None,
        response_type: Annotated[Optional[StrictStr], Field(description="Response Type")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileInfoResponse]:
        """Create Account (Encrypted Username)

        Create a new account by role (with encrypted user-name and password)

        :param version: (required)
        :type version: float
        :param device_id: The device id (required)
        :type device_id: str
        :param username: The encrypted email of the user, this is what will be used when they login (required)
        :type username: str
        :param password: The encrypted password of the user (required)
        :type password: str
        :param name: The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        :type name: str
        :param invite_token: the inviteToken that the referrer use for this account to sign up
        :type invite_token: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: Title
        :type title: str
        :param device_id_type: Device Id Type
        :type device_id_type: str
        :param email_address: The user's contact email address (NOT the username) which is also used for email validation
        :type email_address: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param address: the user's address
        :type address: str
        :param zipcode: The street zipcode of the user's contact location
        :type zipcode: str
        :param gender: The gender of the user AudienceGender
        :type gender: str
        :param birthday: The birthday date of the user in milliseconds
        :type birthday: int
        :param home_phone: the user's home phone number
        :type home_phone: str
        :param cell_phone: the user's cell phone number
        :type cell_phone: str
        :param cell_phone_carrier: the user's Cell Phone Carrier
        :type cell_phone_carrier: str
        :param business_phone: the user's Business Phone Number
        :type business_phone: str
        :param role: The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST
        :type role: str
        :param platforms: Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK
        :type platforms: str
        :param tags: Search tags
        :type tags: str
        :param about_us: About Us information
        :type about_us: str
        :param game_experience: Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's maritial status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred education in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param charset_name: Charset Name
        :type charset_name: str
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param app_version: App Version
        :type app_version: str
        :param response_type: Response Type
        :type response_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._secure_signup_serialize(
            version=version,
            device_id=device_id,
            username=username,
            password=password,
            name=name,
            invite_token=invite_token,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            device_id_type=device_id_type,
            email_address=email_address,
            asset_id=asset_id,
            address=address,
            zipcode=zipcode,
            gender=gender,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            role=role,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            game_experience=game_experience,
            category_ids=category_ids,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            latitude=latitude,
            longitude=longitude,
            accepted_terms=accepted_terms,
            charset_name=charset_name,
            game_type=game_type,
            app_key=app_key,
            app_version=app_version,
            response_type=response_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileInfoResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def secure_signup_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[StrictStr, Field(description="The device id")],
        username: Annotated[StrictStr, Field(description="The encrypted email of the user, this is what will be used when they login")],
        password: Annotated[StrictStr, Field(description="The encrypted password of the user")],
        name: Annotated[Optional[StrictStr], Field(description="The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName ")] = None,
        invite_token: Annotated[Optional[StrictStr], Field(description="the inviteToken that the referrer use for this account to sign up")] = None,
        prefix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name")] = None,
        first_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's first name")] = None,
        middle_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's middle name")] = None,
        last_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the user's last name")] = None,
        suffix_name: Annotated[Optional[StrictStr], Field(description="If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name")] = None,
        title: Annotated[Optional[StrictStr], Field(description="Title")] = None,
        device_id_type: Annotated[Optional[StrictStr], Field(description="Device Id Type")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="The user's contact email address (NOT the username) which is also used for email validation")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset id to set the user's profile image")] = None,
        address: Annotated[Optional[StrictStr], Field(description="the user's address")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="The street zipcode of the user's contact location")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender of the user AudienceGender")] = None,
        birthday: Annotated[Optional[StrictInt], Field(description="The birthday date of the user in milliseconds")] = None,
        home_phone: Annotated[Optional[StrictStr], Field(description="the user's home phone number")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the user's cell phone number")] = None,
        cell_phone_carrier: Annotated[Optional[StrictStr], Field(description="the user's Cell Phone Carrier")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="the user's Business Phone Number")] = None,
        role: Annotated[Optional[StrictStr], Field(description="The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Search tags")] = None,
        about_us: Annotated[Optional[StrictStr], Field(description="About Us information")] = None,
        game_experience: Annotated[Optional[StrictStr], Field(description="Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="A list of category ids that represent interests and associations")] = None,
        hometown: Annotated[Optional[StrictStr], Field(description="The user's hometown")] = None,
        height: Annotated[Optional[StrictStr], Field(description="The user's height")] = None,
        height_index: Annotated[Optional[StrictInt], Field(description="The user's height in a numerical value that can be used for ordering/searching")] = None,
        ethnicity: Annotated[Optional[StrictStr], Field(description="The user's ethnicity")] = None,
        body_type: Annotated[Optional[StrictStr], Field(description="The user's body type")] = None,
        marital_status: Annotated[Optional[StrictStr], Field(description="The user's maritial status")] = None,
        children: Annotated[Optional[StrictStr], Field(description="The user's children status")] = None,
        religion: Annotated[Optional[StrictStr], Field(description="The user's religion")] = None,
        education: Annotated[Optional[StrictStr], Field(description="The user's education")] = None,
        education_index: Annotated[Optional[StrictInt], Field(description="The user's education in a numerical value that can be used for ordering/searching")] = None,
        smoke: Annotated[Optional[StrictStr], Field(description="The user's smoke status")] = None,
        drink: Annotated[Optional[StrictStr], Field(description="The user's drink status")] = None,
        companionship: Annotated[Optional[StrictStr], Field(description="The user's companionship status")] = None,
        companionship_index: Annotated[Optional[StrictInt], Field(description="The user's companionship index")] = None,
        preferred_min_age: Annotated[Optional[StrictInt], Field(description="The preferred minimum age in the account location search")] = None,
        preferred_max_age: Annotated[Optional[StrictInt], Field(description="The preferred maximum age in the account location search")] = None,
        preferred_min_height: Annotated[Optional[StrictInt], Field(description="The preferred minimum height in the account location search")] = None,
        preferred_max_height: Annotated[Optional[StrictInt], Field(description="The preferred maximum height in the account location search")] = None,
        preferred_gender: Annotated[Optional[StrictStr], Field(description="The preferred gender in the account location search")] = None,
        preferred_education: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_education_index: Annotated[Optional[StrictInt], Field(description="The preferred education in a numerical value that can be used for ordering/searching")] = None,
        preferred_body_type: Annotated[Optional[StrictStr], Field(description="The preferred body type in the account location search")] = None,
        preferred_ethnicity: Annotated[Optional[StrictStr], Field(description="The preferred ethnicity in the account location search")] = None,
        preferred_location: Annotated[Optional[StrictStr], Field(description="The preferred education in the account location search")] = None,
        preferred_location_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The preferred location range in the account location search")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        accepted_terms: Annotated[Optional[StrictBool], Field(description="Accepted Terms")] = None,
        charset_name: Annotated[Optional[StrictStr], Field(description="Charset Name")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="App Version")] = None,
        response_type: Annotated[Optional[StrictStr], Field(description="Response Type")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Account (Encrypted Username)

        Create a new account by role (with encrypted user-name and password)

        :param version: (required)
        :type version: float
        :param device_id: The device id (required)
        :type device_id: str
        :param username: The encrypted email of the user, this is what will be used when they login (required)
        :type username: str
        :param password: The encrypted password of the user (required)
        :type password: str
        :param name: The full name of the user. If this parameter is not empty, the  following parameters will be ignored: prefixName, firstName, middleName,  lastName, and suffixName 
        :type name: str
        :param invite_token: the inviteToken that the referrer use for this account to sign up
        :type invite_token: str
        :param prefix_name: If the parameter 'name' is empty or not present, this field will be used to set the prefix of the user's name
        :type prefix_name: str
        :param first_name: If the parameter 'name' is empty or not present, this field will be used to set the user's first name
        :type first_name: str
        :param middle_name: If the parameter 'name' is empty or not present, this field will be used to set the user's middle name
        :type middle_name: str
        :param last_name: If the parameter 'name' is empty or not present, this field will be used to set the user's last name
        :type last_name: str
        :param suffix_name: If the parameter 'name' is empty or not present, this field will be used to set the suffix of the user's name
        :type suffix_name: str
        :param title: Title
        :type title: str
        :param device_id_type: Device Id Type
        :type device_id_type: str
        :param email_address: The user's contact email address (NOT the username) which is also used for email validation
        :type email_address: str
        :param asset_id: The asset id to set the user's profile image
        :type asset_id: int
        :param address: the user's address
        :type address: str
        :param zipcode: The street zipcode of the user's contact location
        :type zipcode: str
        :param gender: The gender of the user AudienceGender
        :type gender: str
        :param birthday: The birthday date of the user in milliseconds
        :type birthday: int
        :param home_phone: the user's home phone number
        :type home_phone: str
        :param cell_phone: the user's cell phone number
        :type cell_phone: str
        :param cell_phone_carrier: the user's Cell Phone Carrier
        :type cell_phone_carrier: str
        :param business_phone: the user's Business Phone Number
        :type business_phone: str
        :param role: The type of account being created {RETAILER, MEMBER, DEVELOPER, GUEST
        :type role: str
        :param platforms: Comma separated list of development platforms: MAC, WINDOWS, IOS, ANDROID, WINDOWSPHONE, KINDLE, UNITY3D, COCOS2D, HTML5, FACEBOOK
        :type platforms: str
        :param tags: Search tags
        :type tags: str
        :param about_us: About Us information
        :type about_us: str
        :param game_experience: Game experience level of the user {ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience: str
        :param category_ids: A list of category ids that represent interests and associations
        :type category_ids: str
        :param hometown: The user's hometown
        :type hometown: str
        :param height: The user's height
        :type height: str
        :param height_index: The user's height in a numerical value that can be used for ordering/searching
        :type height_index: int
        :param ethnicity: The user's ethnicity
        :type ethnicity: str
        :param body_type: The user's body type
        :type body_type: str
        :param marital_status: The user's maritial status
        :type marital_status: str
        :param children: The user's children status
        :type children: str
        :param religion: The user's religion
        :type religion: str
        :param education: The user's education
        :type education: str
        :param education_index: The user's education in a numerical value that can be used for ordering/searching
        :type education_index: int
        :param smoke: The user's smoke status
        :type smoke: str
        :param drink: The user's drink status
        :type drink: str
        :param companionship: The user's companionship status
        :type companionship: str
        :param companionship_index: The user's companionship index
        :type companionship_index: int
        :param preferred_min_age: The preferred minimum age in the account location search
        :type preferred_min_age: int
        :param preferred_max_age: The preferred maximum age in the account location search
        :type preferred_max_age: int
        :param preferred_min_height: The preferred minimum height in the account location search
        :type preferred_min_height: int
        :param preferred_max_height: The preferred maximum height in the account location search
        :type preferred_max_height: int
        :param preferred_gender: The preferred gender in the account location search
        :type preferred_gender: str
        :param preferred_education: The preferred education in the account location search
        :type preferred_education: str
        :param preferred_education_index: The preferred education in a numerical value that can be used for ordering/searching
        :type preferred_education_index: int
        :param preferred_body_type: The preferred body type in the account location search
        :type preferred_body_type: str
        :param preferred_ethnicity: The preferred ethnicity in the account location search
        :type preferred_ethnicity: str
        :param preferred_location: The preferred education in the account location search
        :type preferred_location: str
        :param preferred_location_range: The preferred location range in the account location search
        :type preferred_location_range: float
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param accepted_terms: Accepted Terms
        :type accepted_terms: bool
        :param charset_name: Charset Name
        :type charset_name: str
        :param game_type: Game Type
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param app_version: App Version
        :type app_version: str
        :param response_type: Response Type
        :type response_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._secure_signup_serialize(
            version=version,
            device_id=device_id,
            username=username,
            password=password,
            name=name,
            invite_token=invite_token,
            prefix_name=prefix_name,
            first_name=first_name,
            middle_name=middle_name,
            last_name=last_name,
            suffix_name=suffix_name,
            title=title,
            device_id_type=device_id_type,
            email_address=email_address,
            asset_id=asset_id,
            address=address,
            zipcode=zipcode,
            gender=gender,
            birthday=birthday,
            home_phone=home_phone,
            cell_phone=cell_phone,
            cell_phone_carrier=cell_phone_carrier,
            business_phone=business_phone,
            role=role,
            platforms=platforms,
            tags=tags,
            about_us=about_us,
            game_experience=game_experience,
            category_ids=category_ids,
            hometown=hometown,
            height=height,
            height_index=height_index,
            ethnicity=ethnicity,
            body_type=body_type,
            marital_status=marital_status,
            children=children,
            religion=religion,
            education=education,
            education_index=education_index,
            smoke=smoke,
            drink=drink,
            companionship=companionship,
            companionship_index=companionship_index,
            preferred_min_age=preferred_min_age,
            preferred_max_age=preferred_max_age,
            preferred_min_height=preferred_min_height,
            preferred_max_height=preferred_max_height,
            preferred_gender=preferred_gender,
            preferred_education=preferred_education,
            preferred_education_index=preferred_education_index,
            preferred_body_type=preferred_body_type,
            preferred_ethnicity=preferred_ethnicity,
            preferred_location=preferred_location,
            preferred_location_range=preferred_location_range,
            latitude=latitude,
            longitude=longitude,
            accepted_terms=accepted_terms,
            charset_name=charset_name,
            game_type=game_type,
            app_key=app_key,
            app_version=app_version,
            response_type=response_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileInfoResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _secure_signup_serialize(
        self,
        version,
        device_id,
        username,
        password,
        name,
        invite_token,
        prefix_name,
        first_name,
        middle_name,
        last_name,
        suffix_name,
        title,
        device_id_type,
        email_address,
        asset_id,
        address,
        zipcode,
        gender,
        birthday,
        home_phone,
        cell_phone,
        cell_phone_carrier,
        business_phone,
        role,
        platforms,
        tags,
        about_us,
        game_experience,
        category_ids,
        hometown,
        height,
        height_index,
        ethnicity,
        body_type,
        marital_status,
        children,
        religion,
        education,
        education_index,
        smoke,
        drink,
        companionship,
        companionship_index,
        preferred_min_age,
        preferred_max_age,
        preferred_min_height,
        preferred_max_height,
        preferred_gender,
        preferred_education,
        preferred_education_index,
        preferred_body_type,
        preferred_ethnicity,
        preferred_location,
        preferred_location_range,
        latitude,
        longitude,
        accepted_terms,
        charset_name,
        game_type,
        app_key,
        app_version,
        response_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if name is not None:
            
            _query_params.append(('name', name))
            
        if invite_token is not None:
            
            _query_params.append(('inviteToken', invite_token))
            
        if prefix_name is not None:
            
            _query_params.append(('prefixName', prefix_name))
            
        if first_name is not None:
            
            _query_params.append(('firstName', first_name))
            
        if middle_name is not None:
            
            _query_params.append(('middleName', middle_name))
            
        if last_name is not None:
            
            _query_params.append(('lastName', last_name))
            
        if suffix_name is not None:
            
            _query_params.append(('suffixName', suffix_name))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if device_id_type is not None:
            
            _query_params.append(('deviceIdType', device_id_type))
            
        if username is not None:
            
            _query_params.append(('username', username))
            
        if password is not None:
            
            _query_params.append(('password', password))
            
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if address is not None:
            
            _query_params.append(('address', address))
            
        if zipcode is not None:
            
            _query_params.append(('zipcode', zipcode))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if birthday is not None:
            
            _query_params.append(('birthday', birthday))
            
        if home_phone is not None:
            
            _query_params.append(('homePhone', home_phone))
            
        if cell_phone is not None:
            
            _query_params.append(('cellPhone', cell_phone))
            
        if cell_phone_carrier is not None:
            
            _query_params.append(('cellPhoneCarrier', cell_phone_carrier))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if role is not None:
            
            _query_params.append(('role', role))
            
        if platforms is not None:
            
            _query_params.append(('platforms', platforms))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if about_us is not None:
            
            _query_params.append(('aboutUs', about_us))
            
        if game_experience is not None:
            
            _query_params.append(('gameExperience', game_experience))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if hometown is not None:
            
            _query_params.append(('hometown', hometown))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if height_index is not None:
            
            _query_params.append(('heightIndex', height_index))
            
        if ethnicity is not None:
            
            _query_params.append(('ethnicity', ethnicity))
            
        if body_type is not None:
            
            _query_params.append(('bodyType', body_type))
            
        if marital_status is not None:
            
            _query_params.append(('maritalStatus', marital_status))
            
        if children is not None:
            
            _query_params.append(('children', children))
            
        if religion is not None:
            
            _query_params.append(('religion', religion))
            
        if education is not None:
            
            _query_params.append(('education', education))
            
        if education_index is not None:
            
            _query_params.append(('educationIndex', education_index))
            
        if smoke is not None:
            
            _query_params.append(('smoke', smoke))
            
        if drink is not None:
            
            _query_params.append(('drink', drink))
            
        if companionship is not None:
            
            _query_params.append(('companionship', companionship))
            
        if companionship_index is not None:
            
            _query_params.append(('companionshipIndex', companionship_index))
            
        if preferred_min_age is not None:
            
            _query_params.append(('preferredMinAge', preferred_min_age))
            
        if preferred_max_age is not None:
            
            _query_params.append(('preferredMaxAge', preferred_max_age))
            
        if preferred_min_height is not None:
            
            _query_params.append(('preferredMinHeight', preferred_min_height))
            
        if preferred_max_height is not None:
            
            _query_params.append(('preferredMaxHeight', preferred_max_height))
            
        if preferred_gender is not None:
            
            _query_params.append(('preferredGender', preferred_gender))
            
        if preferred_education is not None:
            
            _query_params.append(('preferredEducation', preferred_education))
            
        if preferred_education_index is not None:
            
            _query_params.append(('preferredEducationIndex', preferred_education_index))
            
        if preferred_body_type is not None:
            
            _query_params.append(('preferredBodyType', preferred_body_type))
            
        if preferred_ethnicity is not None:
            
            _query_params.append(('preferredEthnicity', preferred_ethnicity))
            
        if preferred_location is not None:
            
            _query_params.append(('preferredLocation', preferred_location))
            
        if preferred_location_range is not None:
            
            _query_params.append(('preferredLocationRange', preferred_location_range))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if accepted_terms is not None:
            
            _query_params.append(('acceptedTerms', accepted_terms))
            
        if charset_name is not None:
            
            _query_params.append(('charsetName', charset_name))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if app_version is not None:
            
            _query_params.append(('appVersion', app_version))
            
        if response_type is not None:
            
            _query_params.append(('responseType', response_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/create/validate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def set_match_token(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        match_token: Annotated[Optional[StrictStr], Field(description="A string of numbers")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type (deprecated)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Save Match Token

        Save user's match token to be used for profile match making

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param match_token: A string of numbers
        :type match_token: str
        :param game_type: Game Type (deprecated)
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_match_token_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            match_token=match_token,
            game_type=game_type,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def set_match_token_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        match_token: Annotated[Optional[StrictStr], Field(description="A string of numbers")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type (deprecated)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Save Match Token

        Save user's match token to be used for profile match making

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param match_token: A string of numbers
        :type match_token: str
        :param game_type: Game Type (deprecated)
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_match_token_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            match_token=match_token,
            game_type=game_type,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def set_match_token_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        match_token: Annotated[Optional[StrictStr], Field(description="A string of numbers")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="Game Type (deprecated)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save Match Token

        Save user's match token to be used for profile match making

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param match_token: A string of numbers
        :type match_token: str
        :param game_type: Game Type (deprecated)
        :type game_type: str
        :param app_key: The application key
        :type app_key: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._set_match_token_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            match_token=match_token,
            game_type=game_type,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _set_match_token_serialize(
        self,
        version,
        device_id,
        account_id,
        match_token,
        game_type,
        app_key,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if match_token is not None:
            
            _query_params.append(('matchToken', match_token))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/consumer/profile/matchToken',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_actve_status(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user (deviceId or accountId required)")],
        connection_account_id: Annotated[StrictInt, Field(description="The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)")],
        active: Annotated[StrictBool, Field(description="true will activate the user and false will deactivate")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key that the user belongs to")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Account Active Status

        Activate or deactivate an account (requires appropriate permissions).

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (deviceId or accountId required) (required)
        :type account_id: int
        :param connection_account_id: The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead) (required)
        :type connection_account_id: int
        :param active: true will activate the user and false will deactivate (required)
        :type active: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param app_key: the application key that the user belongs to
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_actve_status_serialize(
            version=version,
            account_id=account_id,
            connection_account_id=connection_account_id,
            active=active,
            device_id=device_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_actve_status_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user (deviceId or accountId required)")],
        connection_account_id: Annotated[StrictInt, Field(description="The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)")],
        active: Annotated[StrictBool, Field(description="true will activate the user and false will deactivate")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key that the user belongs to")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Account Active Status

        Activate or deactivate an account (requires appropriate permissions).

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (deviceId or accountId required) (required)
        :type account_id: int
        :param connection_account_id: The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead) (required)
        :type connection_account_id: int
        :param active: true will activate the user and false will deactivate (required)
        :type active: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param app_key: the application key that the user belongs to
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_actve_status_serialize(
            version=version,
            account_id=account_id,
            connection_account_id=connection_account_id,
            active=active,
            device_id=device_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_actve_status_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user (deviceId or accountId required)")],
        connection_account_id: Annotated[StrictInt, Field(description="The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead)")],
        active: Annotated[StrictBool, Field(description="true will activate the user and false will deactivate")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key that the user belongs to")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Account Active Status

        Activate or deactivate an account (requires appropriate permissions).

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (deviceId or accountId required) (required)
        :type account_id: int
        :param connection_account_id: The account id of the user you want to modify (if this is not set, then the accountId parameter will be used instead) (required)
        :type connection_account_id: int
        :param active: true will activate the user and false will deactivate (required)
        :type active: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param app_key: the application key that the user belongs to
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_actve_status_serialize(
            version=version,
            account_id=account_id,
            connection_account_id=connection_account_id,
            active=active,
            device_id=device_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_actve_status_serialize(
        self,
        version,
        account_id,
        connection_account_id,
        active,
        device_id,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/active/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_location(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        client_time: Annotated[Optional[StrictInt], Field(description="The time of the update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Location

        Update the account location

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param client_time: The time of the update
        :type client_time: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_location_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            client_time=client_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_location_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        client_time: Annotated[Optional[StrictInt], Field(description="The time of the update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Location

        Update the account location

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param client_time: The time of the update
        :type client_time: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_location_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            client_time=client_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_location_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        client_time: Annotated[Optional[StrictInt], Field(description="The time of the update")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Location

        Update the account location

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param client_time: The time of the update
        :type client_time: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_location_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            client_time=client_time,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_location_serialize(
        self,
        version,
        device_id,
        account_id,
        latitude,
        longitude,
        client_time,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if client_time is not None:
            
            _query_params.append(('clientTime', client_time))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/location/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_settings(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        blocked_notifications: Annotated[Optional[StrictStr], Field(description="The notifications to be blocked")] = None,
        suggestion_method: Annotated[Optional[StrictStr], Field(description="How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)")] = None,
        suggestion_count: Annotated[Optional[StrictInt], Field(description="How many suggestions to receive per time frame")] = None,
        suggestion_time_frame: Annotated[Optional[StrictInt], Field(description="The time frame in seconds, 3600 would be a 1 hour time frame")] = None,
        show_others_exact_location: Annotated[Optional[StrictBool], Field(description="Show Others Exact Location")] = None,
        show_as_zipcode: Annotated[Optional[StrictBool], Field(description="Show As Zipcode")] = None,
        show_exact_location: Annotated[Optional[StrictBool], Field(description="Show Exact Location")] = None,
        favorite_visibility: Annotated[Optional[StrictStr], Field(description="Show favorites")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> UserSettingsResponse:
        """Update Account Settings

        Update the account settings for a user

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param blocked_notifications: The notifications to be blocked
        :type blocked_notifications: str
        :param suggestion_method: How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)
        :type suggestion_method: str
        :param suggestion_count: How many suggestions to receive per time frame
        :type suggestion_count: int
        :param suggestion_time_frame: The time frame in seconds, 3600 would be a 1 hour time frame
        :type suggestion_time_frame: int
        :param show_others_exact_location: Show Others Exact Location
        :type show_others_exact_location: bool
        :param show_as_zipcode: Show As Zipcode
        :type show_as_zipcode: bool
        :param show_exact_location: Show Exact Location
        :type show_exact_location: bool
        :param favorite_visibility: Show favorites
        :type favorite_visibility: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_settings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            blocked_notifications=blocked_notifications,
            suggestion_method=suggestion_method,
            suggestion_count=suggestion_count,
            suggestion_time_frame=suggestion_time_frame,
            show_others_exact_location=show_others_exact_location,
            show_as_zipcode=show_as_zipcode,
            show_exact_location=show_exact_location,
            favorite_visibility=favorite_visibility,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_settings_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        blocked_notifications: Annotated[Optional[StrictStr], Field(description="The notifications to be blocked")] = None,
        suggestion_method: Annotated[Optional[StrictStr], Field(description="How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)")] = None,
        suggestion_count: Annotated[Optional[StrictInt], Field(description="How many suggestions to receive per time frame")] = None,
        suggestion_time_frame: Annotated[Optional[StrictInt], Field(description="The time frame in seconds, 3600 would be a 1 hour time frame")] = None,
        show_others_exact_location: Annotated[Optional[StrictBool], Field(description="Show Others Exact Location")] = None,
        show_as_zipcode: Annotated[Optional[StrictBool], Field(description="Show As Zipcode")] = None,
        show_exact_location: Annotated[Optional[StrictBool], Field(description="Show Exact Location")] = None,
        favorite_visibility: Annotated[Optional[StrictStr], Field(description="Show favorites")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[UserSettingsResponse]:
        """Update Account Settings

        Update the account settings for a user

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param blocked_notifications: The notifications to be blocked
        :type blocked_notifications: str
        :param suggestion_method: How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)
        :type suggestion_method: str
        :param suggestion_count: How many suggestions to receive per time frame
        :type suggestion_count: int
        :param suggestion_time_frame: The time frame in seconds, 3600 would be a 1 hour time frame
        :type suggestion_time_frame: int
        :param show_others_exact_location: Show Others Exact Location
        :type show_others_exact_location: bool
        :param show_as_zipcode: Show As Zipcode
        :type show_as_zipcode: bool
        :param show_exact_location: Show Exact Location
        :type show_exact_location: bool
        :param favorite_visibility: Show favorites
        :type favorite_visibility: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_settings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            blocked_notifications=blocked_notifications,
            suggestion_method=suggestion_method,
            suggestion_count=suggestion_count,
            suggestion_time_frame=suggestion_time_frame,
            show_others_exact_location=show_others_exact_location,
            show_as_zipcode=show_as_zipcode,
            show_exact_location=show_exact_location,
            favorite_visibility=favorite_visibility,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_settings_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        blocked_notifications: Annotated[Optional[StrictStr], Field(description="The notifications to be blocked")] = None,
        suggestion_method: Annotated[Optional[StrictStr], Field(description="How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)")] = None,
        suggestion_count: Annotated[Optional[StrictInt], Field(description="How many suggestions to receive per time frame")] = None,
        suggestion_time_frame: Annotated[Optional[StrictInt], Field(description="The time frame in seconds, 3600 would be a 1 hour time frame")] = None,
        show_others_exact_location: Annotated[Optional[StrictBool], Field(description="Show Others Exact Location")] = None,
        show_as_zipcode: Annotated[Optional[StrictBool], Field(description="Show As Zipcode")] = None,
        show_exact_location: Annotated[Optional[StrictBool], Field(description="Show Exact Location")] = None,
        favorite_visibility: Annotated[Optional[StrictStr], Field(description="Show favorites")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Account Settings

        Update the account settings for a user

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param blocked_notifications: The notifications to be blocked
        :type blocked_notifications: str
        :param suggestion_method: How suggestions are to be sent (APNS, MOBILE_NOTIFICATION, SMS)
        :type suggestion_method: str
        :param suggestion_count: How many suggestions to receive per time frame
        :type suggestion_count: int
        :param suggestion_time_frame: The time frame in seconds, 3600 would be a 1 hour time frame
        :type suggestion_time_frame: int
        :param show_others_exact_location: Show Others Exact Location
        :type show_others_exact_location: bool
        :param show_as_zipcode: Show As Zipcode
        :type show_as_zipcode: bool
        :param show_exact_location: Show Exact Location
        :type show_exact_location: bool
        :param favorite_visibility: Show favorites
        :type favorite_visibility: str
        :param latitude: The current latitude of the user
        :type latitude: float
        :param longitude: The current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_settings_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            blocked_notifications=blocked_notifications,
            suggestion_method=suggestion_method,
            suggestion_count=suggestion_count,
            suggestion_time_frame=suggestion_time_frame,
            show_others_exact_location=show_others_exact_location,
            show_as_zipcode=show_as_zipcode,
            show_exact_location=show_exact_location,
            favorite_visibility=favorite_visibility,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "UserSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_settings_serialize(
        self,
        version,
        device_id,
        account_id,
        blocked_notifications,
        suggestion_method,
        suggestion_count,
        suggestion_time_frame,
        show_others_exact_location,
        show_as_zipcode,
        show_exact_location,
        favorite_visibility,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if blocked_notifications is not None:
            
            _query_params.append(('blockedNotifications', blocked_notifications))
            
        if suggestion_method is not None:
            
            _query_params.append(('suggestionMethod', suggestion_method))
            
        if suggestion_count is not None:
            
            _query_params.append(('suggestionCount', suggestion_count))
            
        if suggestion_time_frame is not None:
            
            _query_params.append(('suggestionTimeFrame', suggestion_time_frame))
            
        if show_others_exact_location is not None:
            
            _query_params.append(('showOthersExactLocation', show_others_exact_location))
            
        if show_as_zipcode is not None:
            
            _query_params.append(('showAsZipcode', show_as_zipcode))
            
        if show_exact_location is not None:
            
            _query_params.append(('showExactLocation', show_exact_location))
            
        if favorite_visibility is not None:
            
            _query_params.append(('favoriteVisibility', favorite_visibility))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/settings/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_account_signup(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountLoginResponse:
        """Save Validation Status

        Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_account_signup_serialize(
            version=version,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_account_signup_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountLoginResponse]:
        """Save Validation Status

        Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_account_signup_serialize(
            version=version,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_account_signup_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save Validation Status

        Validate the account's email address. The token must be valid and not expired. Use the RequestValidateAccount end point to request a new token.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_account_signup_serialize(
            version=version,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_account_signup_serialize(
        self,
        version,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/validateAccountSignup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def validate_password_reset(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Validate Password Reset Token

        Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_password_reset_serialize(
            version=version,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def validate_password_reset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Validate Password Reset Token

        Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_password_reset_serialize(
            version=version,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def validate_password_reset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="The token associated with the account to update, good for 24 hours")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Validate Password Reset Token

        Validate the password reset token. The token must be valid and not expired. Use the RequestPasswordReset end point to request a token. The user receives and email with the reset page, therefore it should be validated before bwing used to reset the password.

        :param version: (required)
        :type version: float
        :param token: The token associated with the account to update, good for 24 hours (required)
        :type token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._validate_password_reset_serialize(
            version=version,
            token=token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _validate_password_reset_serialize(
        self,
        version,
        token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if token is not None:
            
            _query_params.append(('token', token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/account/validatepasswordreset',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


