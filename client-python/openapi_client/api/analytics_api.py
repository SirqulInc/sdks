# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.chart_data import ChartData
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.user_activity_response import UserActivityResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AnalyticsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def activities(
        self,
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination")],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[UserActivityResponse]:
        """Get User Activity

        Get an activity feed by user.

        :param start: The start of the pagination (required)
        :type start: int
        :param limit: The limit of the pagination (required)
        :type limit: int
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._activities_serialize(
            start=start,
            limit=limit,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserActivityResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def activities_with_http_info(
        self,
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination")],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[UserActivityResponse]]:
        """Get User Activity

        Get an activity feed by user.

        :param start: The start of the pagination (required)
        :type start: int
        :param limit: The limit of the pagination (required)
        :type limit: int
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._activities_serialize(
            start=start,
            limit=limit,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserActivityResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def activities_without_preload_content(
        self,
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination")],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get User Activity

        Get an activity feed by user.

        :param start: The start of the pagination (required)
        :type start: int
        :param limit: The limit of the pagination (required)
        :type limit: int
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._activities_serialize(
            start=start,
            limit=limit,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserActivityResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _activities_serialize(
        self,
        start,
        limit,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/analytics/useractivity',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def aggregated_filtered_usage(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to filter results by application")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The device type to filter results by (performs a LIKE search)")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The device to filter results by (performs a LIKE search)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The device OS to filter results by (performs a LIKE search)")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender to filter results by {MALE, FEMALE}")] = None,
        age_group: Annotated[Optional[StrictStr], Field(description="Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to filter results by (performs a wild-card search)")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state to filter results by (performs a wild-card search)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city to filter results by (performs a wild-card search)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The zip to filter results by (performs a wild-card search)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model to filter results by (performs a wild-card search)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="The tag to filter results by (performs a wild-card search)")] = None,
        user_account_id: Annotated[Optional[StrictInt], Field(description="The account id to filter results for a particular user")] = None,
        user_account_display: Annotated[Optional[StrictStr], Field(description="The user display to filter results by (performs a wild-card search)")] = None,
        user_account_username: Annotated[Optional[StrictStr], Field(description="The username to filter results by (performs a wild-card search)")] = None,
        group_by_root: Annotated[Optional[StrictStr], Field(description="Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}")] = None,
        distinct_count: Annotated[Optional[StrictStr], Field(description="Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order")] = None,
        hide_unknown: Annotated[Optional[StrictBool], Field(description="Determines whether to return data that has empty or unknown values")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Determines whether to return a JOSN or XML representation of the graph results")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Used to limit results to get a cleaner graph. The results that gets filtered out will be combined")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChartData:
        """Get Aggregated Filtered Usage

        Query analytics to get data used for nested graphs and charts

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param application_id: This parameter is deprecated.
        :type application_id: int
        :param app_key: The application key used to filter results by application
        :type app_key: str
        :param start_date: Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        :type start_date: int
        :param end_date: Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        :type end_date: int
        :param device_type: The device type to filter results by (performs a LIKE search)
        :type device_type: str
        :param device: The device to filter results by (performs a LIKE search)
        :type device: str
        :param device_os: The device OS to filter results by (performs a LIKE search)
        :type device_os: str
        :param gender: The gender to filter results by {MALE, FEMALE}
        :type gender: str
        :param age_group: Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        :type age_group: str
        :param country: The country to filter results by (performs a wild-card search)
        :type country: str
        :param state: The state to filter results by (performs a wild-card search)
        :type state: str
        :param city: The city to filter results by (performs a wild-card search)
        :type city: str
        :param zip: The zip to filter results by (performs a wild-card search)
        :type zip: str
        :param model: The model to filter results by (performs a wild-card search)
        :type model: str
        :param tag: The tag to filter results by (performs a wild-card search)
        :type tag: str
        :param user_account_id: The account id to filter results for a particular user
        :type user_account_id: int
        :param user_account_display: The user display to filter results by (performs a wild-card search)
        :type user_account_display: str
        :param user_account_username: The username to filter results by (performs a wild-card search)
        :type user_account_username: str
        :param group_by_root: Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        :type group_by_root: str
        :param group_by: Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        :type group_by: str
        :param distinct_count: Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}
        :type distinct_count: str
        :param sort_field: Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        :type sort_field: str
        :param descending: Determines whether to return results in descending order
        :type descending: bool
        :param hide_unknown: Determines whether to return data that has empty or unknown values
        :type hide_unknown: bool
        :param response_format: Determines whether to return a JOSN or XML representation of the graph results
        :type response_format: str
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        :type limit: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._aggregated_filtered_usage_serialize(
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            start_date=start_date,
            end_date=end_date,
            device_type=device_type,
            device=device,
            device_os=device_os,
            gender=gender,
            age_group=age_group,
            country=country,
            state=state,
            city=city,
            zip=zip,
            model=model,
            tag=tag,
            user_account_id=user_account_id,
            user_account_display=user_account_display,
            user_account_username=user_account_username,
            group_by_root=group_by_root,
            group_by=group_by,
            distinct_count=distinct_count,
            sort_field=sort_field,
            descending=descending,
            hide_unknown=hide_unknown,
            response_format=response_format,
            l=l,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChartData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def aggregated_filtered_usage_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to filter results by application")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The device type to filter results by (performs a LIKE search)")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The device to filter results by (performs a LIKE search)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The device OS to filter results by (performs a LIKE search)")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender to filter results by {MALE, FEMALE}")] = None,
        age_group: Annotated[Optional[StrictStr], Field(description="Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to filter results by (performs a wild-card search)")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state to filter results by (performs a wild-card search)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city to filter results by (performs a wild-card search)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The zip to filter results by (performs a wild-card search)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model to filter results by (performs a wild-card search)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="The tag to filter results by (performs a wild-card search)")] = None,
        user_account_id: Annotated[Optional[StrictInt], Field(description="The account id to filter results for a particular user")] = None,
        user_account_display: Annotated[Optional[StrictStr], Field(description="The user display to filter results by (performs a wild-card search)")] = None,
        user_account_username: Annotated[Optional[StrictStr], Field(description="The username to filter results by (performs a wild-card search)")] = None,
        group_by_root: Annotated[Optional[StrictStr], Field(description="Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}")] = None,
        distinct_count: Annotated[Optional[StrictStr], Field(description="Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order")] = None,
        hide_unknown: Annotated[Optional[StrictBool], Field(description="Determines whether to return data that has empty or unknown values")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Determines whether to return a JOSN or XML representation of the graph results")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Used to limit results to get a cleaner graph. The results that gets filtered out will be combined")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChartData]:
        """Get Aggregated Filtered Usage

        Query analytics to get data used for nested graphs and charts

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param application_id: This parameter is deprecated.
        :type application_id: int
        :param app_key: The application key used to filter results by application
        :type app_key: str
        :param start_date: Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        :type start_date: int
        :param end_date: Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        :type end_date: int
        :param device_type: The device type to filter results by (performs a LIKE search)
        :type device_type: str
        :param device: The device to filter results by (performs a LIKE search)
        :type device: str
        :param device_os: The device OS to filter results by (performs a LIKE search)
        :type device_os: str
        :param gender: The gender to filter results by {MALE, FEMALE}
        :type gender: str
        :param age_group: Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        :type age_group: str
        :param country: The country to filter results by (performs a wild-card search)
        :type country: str
        :param state: The state to filter results by (performs a wild-card search)
        :type state: str
        :param city: The city to filter results by (performs a wild-card search)
        :type city: str
        :param zip: The zip to filter results by (performs a wild-card search)
        :type zip: str
        :param model: The model to filter results by (performs a wild-card search)
        :type model: str
        :param tag: The tag to filter results by (performs a wild-card search)
        :type tag: str
        :param user_account_id: The account id to filter results for a particular user
        :type user_account_id: int
        :param user_account_display: The user display to filter results by (performs a wild-card search)
        :type user_account_display: str
        :param user_account_username: The username to filter results by (performs a wild-card search)
        :type user_account_username: str
        :param group_by_root: Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        :type group_by_root: str
        :param group_by: Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        :type group_by: str
        :param distinct_count: Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}
        :type distinct_count: str
        :param sort_field: Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        :type sort_field: str
        :param descending: Determines whether to return results in descending order
        :type descending: bool
        :param hide_unknown: Determines whether to return data that has empty or unknown values
        :type hide_unknown: bool
        :param response_format: Determines whether to return a JOSN or XML representation of the graph results
        :type response_format: str
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        :type limit: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._aggregated_filtered_usage_serialize(
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            start_date=start_date,
            end_date=end_date,
            device_type=device_type,
            device=device,
            device_os=device_os,
            gender=gender,
            age_group=age_group,
            country=country,
            state=state,
            city=city,
            zip=zip,
            model=model,
            tag=tag,
            user_account_id=user_account_id,
            user_account_display=user_account_display,
            user_account_username=user_account_username,
            group_by_root=group_by_root,
            group_by=group_by,
            distinct_count=distinct_count,
            sort_field=sort_field,
            descending=descending,
            hide_unknown=hide_unknown,
            response_format=response_format,
            l=l,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChartData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def aggregated_filtered_usage_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to filter results by application")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The device type to filter results by (performs a LIKE search)")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The device to filter results by (performs a LIKE search)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The device OS to filter results by (performs a LIKE search)")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender to filter results by {MALE, FEMALE}")] = None,
        age_group: Annotated[Optional[StrictStr], Field(description="Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to filter results by (performs a wild-card search)")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state to filter results by (performs a wild-card search)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city to filter results by (performs a wild-card search)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The zip to filter results by (performs a wild-card search)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model to filter results by (performs a wild-card search)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="The tag to filter results by (performs a wild-card search)")] = None,
        user_account_id: Annotated[Optional[StrictInt], Field(description="The account id to filter results for a particular user")] = None,
        user_account_display: Annotated[Optional[StrictStr], Field(description="The user display to filter results by (performs a wild-card search)")] = None,
        user_account_username: Annotated[Optional[StrictStr], Field(description="The username to filter results by (performs a wild-card search)")] = None,
        group_by_root: Annotated[Optional[StrictStr], Field(description="Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}")] = None,
        distinct_count: Annotated[Optional[StrictStr], Field(description="Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order")] = None,
        hide_unknown: Annotated[Optional[StrictBool], Field(description="Determines whether to return data that has empty or unknown values")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Determines whether to return a JOSN or XML representation of the graph results")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Used to limit results to get a cleaner graph. The results that gets filtered out will be combined")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Aggregated Filtered Usage

        Query analytics to get data used for nested graphs and charts

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param application_id: This parameter is deprecated.
        :type application_id: int
        :param app_key: The application key used to filter results by application
        :type app_key: str
        :param start_date: Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        :type start_date: int
        :param end_date: Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        :type end_date: int
        :param device_type: The device type to filter results by (performs a LIKE search)
        :type device_type: str
        :param device: The device to filter results by (performs a LIKE search)
        :type device: str
        :param device_os: The device OS to filter results by (performs a LIKE search)
        :type device_os: str
        :param gender: The gender to filter results by {MALE, FEMALE}
        :type gender: str
        :param age_group: Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        :type age_group: str
        :param country: The country to filter results by (performs a wild-card search)
        :type country: str
        :param state: The state to filter results by (performs a wild-card search)
        :type state: str
        :param city: The city to filter results by (performs a wild-card search)
        :type city: str
        :param zip: The zip to filter results by (performs a wild-card search)
        :type zip: str
        :param model: The model to filter results by (performs a wild-card search)
        :type model: str
        :param tag: The tag to filter results by (performs a wild-card search)
        :type tag: str
        :param user_account_id: The account id to filter results for a particular user
        :type user_account_id: int
        :param user_account_display: The user display to filter results by (performs a wild-card search)
        :type user_account_display: str
        :param user_account_username: The username to filter results by (performs a wild-card search)
        :type user_account_username: str
        :param group_by_root: Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        :type group_by_root: str
        :param group_by: Determines how to group the nested data. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, APPLICATION_NAME_BY_ID}
        :type group_by: str
        :param distinct_count: Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID, NEW_ACCOUNT}
        :type distinct_count: str
        :param sort_field: Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        :type sort_field: str
        :param descending: Determines whether to return results in descending order
        :type descending: bool
        :param hide_unknown: Determines whether to return data that has empty or unknown values
        :type hide_unknown: bool
        :param response_format: Determines whether to return a JOSN or XML representation of the graph results
        :type response_format: str
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        :type limit: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._aggregated_filtered_usage_serialize(
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            start_date=start_date,
            end_date=end_date,
            device_type=device_type,
            device=device,
            device_os=device_os,
            gender=gender,
            age_group=age_group,
            country=country,
            state=state,
            city=city,
            zip=zip,
            model=model,
            tag=tag,
            user_account_id=user_account_id,
            user_account_display=user_account_display,
            user_account_username=user_account_username,
            group_by_root=group_by_root,
            group_by=group_by,
            distinct_count=distinct_count,
            sort_field=sort_field,
            descending=descending,
            hide_unknown=hide_unknown,
            response_format=response_format,
            l=l,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChartData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _aggregated_filtered_usage_serialize(
        self,
        device_id,
        account_id,
        application_id,
        app_key,
        start_date,
        end_date,
        device_type,
        device,
        device_os,
        gender,
        age_group,
        country,
        state,
        city,
        zip,
        model,
        tag,
        user_account_id,
        user_account_display,
        user_account_username,
        group_by_root,
        group_by,
        distinct_count,
        sort_field,
        descending,
        hide_unknown,
        response_format,
        l,
        limit,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if application_id is not None:
            
            _query_params.append(('applicationId', application_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if device_type is not None:
            
            _query_params.append(('deviceType', device_type))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_os is not None:
            
            _query_params.append(('deviceOS', device_os))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age_group is not None:
            
            _query_params.append(('ageGroup', age_group))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if zip is not None:
            
            _query_params.append(('zip', zip))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if user_account_id is not None:
            
            _query_params.append(('userAccountId', user_account_id))
            
        if user_account_display is not None:
            
            _query_params.append(('userAccountDisplay', user_account_display))
            
        if user_account_username is not None:
            
            _query_params.append(('userAccountUsername', user_account_username))
            
        if group_by_root is not None:
            
            _query_params.append(('groupByRoot', group_by_root))
            
        if group_by is not None:
            
            _query_params.append(('groupBy', group_by))
            
        if distinct_count is not None:
            
            _query_params.append(('distinctCount', distinct_count))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if hide_unknown is not None:
            
            _query_params.append(('hideUnknown', hide_unknown))
            
        if response_format is not None:
            
            _query_params.append(('responseFormat', response_format))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/analytics/aggregatedFilteredUsage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def filtered_usage(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to filter results by application")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The device type to filter results by (performs a LIKE search)")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The device to filter results by (performs a LIKE search)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The device OS to filter results by (performs a LIKE search)")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender to filter results by {MALE, FEMALE}")] = None,
        age_group: Annotated[Optional[StrictStr], Field(description="Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to filter results by (performs a wild-card search)")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state to filter results by (performs a wild-card search)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city to filter results by (performs a wild-card search)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The zip to filter results by (performs a wild-card search)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model to filter results by (performs a wild-card search)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="The tag to filter results by (performs a wild-card search)")] = None,
        user_account_id: Annotated[Optional[StrictInt], Field(description="The account id to filter results for a particular user")] = None,
        user_account_display: Annotated[Optional[StrictStr], Field(description="The user display to filter results by (performs a wild-card search)")] = None,
        user_account_username: Annotated[Optional[StrictStr], Field(description="The username to filter results by (performs a wild-card search)")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="The ID for the custom table column")] = None,
        custom_type: Annotated[Optional[StrictStr], Field(description="The type defined for the custom table column")] = None,
        custom_value: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The value for the custom table column")] = None,
        custom_value2: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The value for another custom table column")] = None,
        custom_long: Annotated[Optional[StrictInt], Field(description="The value that supports Longs for custom table column")] = None,
        custom_long2: Annotated[Optional[StrictInt], Field(description="The value that supports Longs for custom table column")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="The message for the custom table column")] = None,
        custom_message2: Annotated[Optional[StrictStr], Field(description="The message for the custom table column")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}")] = None,
        distinct_count: Annotated[Optional[StrictStr], Field(description="Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}")] = None,
        sum_column: Annotated[Optional[StrictStr], Field(description="sum of the column values")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order")] = None,
        hide_unknown: Annotated[Optional[StrictBool], Field(description="Determines whether to return data that has empty or unknown values")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Determines whether to return a JOSN or XML representation of the graph results")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Used to limit results to get a cleaner graph. The results that gets filtered out will be combined")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ChartData:
        """Get Filtered Usage

        Query analytics to get data used for graphs and charts

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param application_id: This parameter is deprecated.
        :type application_id: int
        :param app_key: The application key used to filter results by application
        :type app_key: str
        :param start_date: Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        :type start_date: int
        :param end_date: Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        :type end_date: int
        :param device_type: The device type to filter results by (performs a LIKE search)
        :type device_type: str
        :param device: The device to filter results by (performs a LIKE search)
        :type device: str
        :param device_os: The device OS to filter results by (performs a LIKE search)
        :type device_os: str
        :param gender: The gender to filter results by {MALE, FEMALE}
        :type gender: str
        :param age_group: Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        :type age_group: str
        :param country: The country to filter results by (performs a wild-card search)
        :type country: str
        :param state: The state to filter results by (performs a wild-card search)
        :type state: str
        :param city: The city to filter results by (performs a wild-card search)
        :type city: str
        :param zip: The zip to filter results by (performs a wild-card search)
        :type zip: str
        :param model: The model to filter results by (performs a wild-card search)
        :type model: str
        :param tag: The tag to filter results by (performs a wild-card search)
        :type tag: str
        :param user_account_id: The account id to filter results for a particular user
        :type user_account_id: int
        :param user_account_display: The user display to filter results by (performs a wild-card search)
        :type user_account_display: str
        :param user_account_username: The username to filter results by (performs a wild-card search)
        :type user_account_username: str
        :param custom_id: The ID for the custom table column
        :type custom_id: int
        :param custom_type: The type defined for the custom table column
        :type custom_type: str
        :param custom_value: The value for the custom table column
        :type custom_value: float
        :param custom_value2: The value for another custom table column
        :type custom_value2: float
        :param custom_long: The value that supports Longs for custom table column
        :type custom_long: int
        :param custom_long2: The value that supports Longs for custom table column
        :type custom_long2: int
        :param custom_message: The message for the custom table column
        :type custom_message: str
        :param custom_message2: The message for the custom table column
        :type custom_message2: str
        :param group_by: Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        :type group_by: str
        :param distinct_count: Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        :type distinct_count: str
        :param sum_column: sum of the column values
        :type sum_column: str
        :param sort_field: Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        :type sort_field: str
        :param descending: Determines whether to return results in descending order
        :type descending: bool
        :param hide_unknown: Determines whether to return data that has empty or unknown values
        :type hide_unknown: bool
        :param response_format: Determines whether to return a JOSN or XML representation of the graph results
        :type response_format: str
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        :type limit: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._filtered_usage_serialize(
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            start_date=start_date,
            end_date=end_date,
            device_type=device_type,
            device=device,
            device_os=device_os,
            gender=gender,
            age_group=age_group,
            country=country,
            state=state,
            city=city,
            zip=zip,
            model=model,
            tag=tag,
            user_account_id=user_account_id,
            user_account_display=user_account_display,
            user_account_username=user_account_username,
            custom_id=custom_id,
            custom_type=custom_type,
            custom_value=custom_value,
            custom_value2=custom_value2,
            custom_long=custom_long,
            custom_long2=custom_long2,
            custom_message=custom_message,
            custom_message2=custom_message2,
            group_by=group_by,
            distinct_count=distinct_count,
            sum_column=sum_column,
            sort_field=sort_field,
            descending=descending,
            hide_unknown=hide_unknown,
            response_format=response_format,
            l=l,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChartData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def filtered_usage_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to filter results by application")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The device type to filter results by (performs a LIKE search)")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The device to filter results by (performs a LIKE search)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The device OS to filter results by (performs a LIKE search)")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender to filter results by {MALE, FEMALE}")] = None,
        age_group: Annotated[Optional[StrictStr], Field(description="Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to filter results by (performs a wild-card search)")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state to filter results by (performs a wild-card search)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city to filter results by (performs a wild-card search)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The zip to filter results by (performs a wild-card search)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model to filter results by (performs a wild-card search)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="The tag to filter results by (performs a wild-card search)")] = None,
        user_account_id: Annotated[Optional[StrictInt], Field(description="The account id to filter results for a particular user")] = None,
        user_account_display: Annotated[Optional[StrictStr], Field(description="The user display to filter results by (performs a wild-card search)")] = None,
        user_account_username: Annotated[Optional[StrictStr], Field(description="The username to filter results by (performs a wild-card search)")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="The ID for the custom table column")] = None,
        custom_type: Annotated[Optional[StrictStr], Field(description="The type defined for the custom table column")] = None,
        custom_value: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The value for the custom table column")] = None,
        custom_value2: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The value for another custom table column")] = None,
        custom_long: Annotated[Optional[StrictInt], Field(description="The value that supports Longs for custom table column")] = None,
        custom_long2: Annotated[Optional[StrictInt], Field(description="The value that supports Longs for custom table column")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="The message for the custom table column")] = None,
        custom_message2: Annotated[Optional[StrictStr], Field(description="The message for the custom table column")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}")] = None,
        distinct_count: Annotated[Optional[StrictStr], Field(description="Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}")] = None,
        sum_column: Annotated[Optional[StrictStr], Field(description="sum of the column values")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order")] = None,
        hide_unknown: Annotated[Optional[StrictBool], Field(description="Determines whether to return data that has empty or unknown values")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Determines whether to return a JOSN or XML representation of the graph results")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Used to limit results to get a cleaner graph. The results that gets filtered out will be combined")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ChartData]:
        """Get Filtered Usage

        Query analytics to get data used for graphs and charts

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param application_id: This parameter is deprecated.
        :type application_id: int
        :param app_key: The application key used to filter results by application
        :type app_key: str
        :param start_date: Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        :type start_date: int
        :param end_date: Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        :type end_date: int
        :param device_type: The device type to filter results by (performs a LIKE search)
        :type device_type: str
        :param device: The device to filter results by (performs a LIKE search)
        :type device: str
        :param device_os: The device OS to filter results by (performs a LIKE search)
        :type device_os: str
        :param gender: The gender to filter results by {MALE, FEMALE}
        :type gender: str
        :param age_group: Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        :type age_group: str
        :param country: The country to filter results by (performs a wild-card search)
        :type country: str
        :param state: The state to filter results by (performs a wild-card search)
        :type state: str
        :param city: The city to filter results by (performs a wild-card search)
        :type city: str
        :param zip: The zip to filter results by (performs a wild-card search)
        :type zip: str
        :param model: The model to filter results by (performs a wild-card search)
        :type model: str
        :param tag: The tag to filter results by (performs a wild-card search)
        :type tag: str
        :param user_account_id: The account id to filter results for a particular user
        :type user_account_id: int
        :param user_account_display: The user display to filter results by (performs a wild-card search)
        :type user_account_display: str
        :param user_account_username: The username to filter results by (performs a wild-card search)
        :type user_account_username: str
        :param custom_id: The ID for the custom table column
        :type custom_id: int
        :param custom_type: The type defined for the custom table column
        :type custom_type: str
        :param custom_value: The value for the custom table column
        :type custom_value: float
        :param custom_value2: The value for another custom table column
        :type custom_value2: float
        :param custom_long: The value that supports Longs for custom table column
        :type custom_long: int
        :param custom_long2: The value that supports Longs for custom table column
        :type custom_long2: int
        :param custom_message: The message for the custom table column
        :type custom_message: str
        :param custom_message2: The message for the custom table column
        :type custom_message2: str
        :param group_by: Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        :type group_by: str
        :param distinct_count: Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        :type distinct_count: str
        :param sum_column: sum of the column values
        :type sum_column: str
        :param sort_field: Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        :type sort_field: str
        :param descending: Determines whether to return results in descending order
        :type descending: bool
        :param hide_unknown: Determines whether to return data that has empty or unknown values
        :type hide_unknown: bool
        :param response_format: Determines whether to return a JOSN or XML representation of the graph results
        :type response_format: str
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        :type limit: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._filtered_usage_serialize(
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            start_date=start_date,
            end_date=end_date,
            device_type=device_type,
            device=device,
            device_os=device_os,
            gender=gender,
            age_group=age_group,
            country=country,
            state=state,
            city=city,
            zip=zip,
            model=model,
            tag=tag,
            user_account_id=user_account_id,
            user_account_display=user_account_display,
            user_account_username=user_account_username,
            custom_id=custom_id,
            custom_type=custom_type,
            custom_value=custom_value,
            custom_value2=custom_value2,
            custom_long=custom_long,
            custom_long2=custom_long2,
            custom_message=custom_message,
            custom_message2=custom_message2,
            group_by=group_by,
            distinct_count=distinct_count,
            sum_column=sum_column,
            sort_field=sort_field,
            descending=descending,
            hide_unknown=hide_unknown,
            response_format=response_format,
            l=l,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChartData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def filtered_usage_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to filter results by application")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The device type to filter results by (performs a LIKE search)")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The device to filter results by (performs a LIKE search)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The device OS to filter results by (performs a LIKE search)")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender to filter results by {MALE, FEMALE}")] = None,
        age_group: Annotated[Optional[StrictStr], Field(description="Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The country to filter results by (performs a wild-card search)")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state to filter results by (performs a wild-card search)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city to filter results by (performs a wild-card search)")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The zip to filter results by (performs a wild-card search)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model to filter results by (performs a wild-card search)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="The tag to filter results by (performs a wild-card search)")] = None,
        user_account_id: Annotated[Optional[StrictInt], Field(description="The account id to filter results for a particular user")] = None,
        user_account_display: Annotated[Optional[StrictStr], Field(description="The user display to filter results by (performs a wild-card search)")] = None,
        user_account_username: Annotated[Optional[StrictStr], Field(description="The username to filter results by (performs a wild-card search)")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="The ID for the custom table column")] = None,
        custom_type: Annotated[Optional[StrictStr], Field(description="The type defined for the custom table column")] = None,
        custom_value: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The value for the custom table column")] = None,
        custom_value2: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The value for another custom table column")] = None,
        custom_long: Annotated[Optional[StrictInt], Field(description="The value that supports Longs for custom table column")] = None,
        custom_long2: Annotated[Optional[StrictInt], Field(description="The value that supports Longs for custom table column")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="The message for the custom table column")] = None,
        custom_message2: Annotated[Optional[StrictStr], Field(description="The message for the custom table column")] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}")] = None,
        distinct_count: Annotated[Optional[StrictStr], Field(description="Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}")] = None,
        sum_column: Annotated[Optional[StrictStr], Field(description="sum of the column values")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order")] = None,
        hide_unknown: Annotated[Optional[StrictBool], Field(description="Determines whether to return data that has empty or unknown values")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="Determines whether to return a JOSN or XML representation of the graph results")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Used to limit results to get a cleaner graph. The results that gets filtered out will be combined")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Filtered Usage

        Query analytics to get data used for graphs and charts

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param application_id: This parameter is deprecated.
        :type application_id: int
        :param app_key: The application key used to filter results by application
        :type app_key: str
        :param start_date: Used to search for results after or equal to this date (UNIX time-stamp in milliseconds)
        :type start_date: int
        :param end_date: Used to search for results before or equal to this date (UNIX time-stamp in milliseconds)
        :type end_date: int
        :param device_type: The device type to filter results by (performs a LIKE search)
        :type device_type: str
        :param device: The device to filter results by (performs a LIKE search)
        :type device: str
        :param device_os: The device OS to filter results by (performs a LIKE search)
        :type device_os: str
        :param gender: The gender to filter results by {MALE, FEMALE}
        :type gender: str
        :param age_group: Comma separated list of age groups to filter by {AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS}
        :type age_group: str
        :param country: The country to filter results by (performs a wild-card search)
        :type country: str
        :param state: The state to filter results by (performs a wild-card search)
        :type state: str
        :param city: The city to filter results by (performs a wild-card search)
        :type city: str
        :param zip: The zip to filter results by (performs a wild-card search)
        :type zip: str
        :param model: The model to filter results by (performs a wild-card search)
        :type model: str
        :param tag: The tag to filter results by (performs a wild-card search)
        :type tag: str
        :param user_account_id: The account id to filter results for a particular user
        :type user_account_id: int
        :param user_account_display: The user display to filter results by (performs a wild-card search)
        :type user_account_display: str
        :param user_account_username: The username to filter results by (performs a wild-card search)
        :type user_account_username: str
        :param custom_id: The ID for the custom table column
        :type custom_id: int
        :param custom_type: The type defined for the custom table column
        :type custom_type: str
        :param custom_value: The value for the custom table column
        :type custom_value: float
        :param custom_value2: The value for another custom table column
        :type custom_value2: float
        :param custom_long: The value that supports Longs for custom table column
        :type custom_long: int
        :param custom_long2: The value that supports Longs for custom table column
        :type custom_long2: int
        :param custom_message: The message for the custom table column
        :type custom_message: str
        :param custom_message2: The message for the custom table column
        :type custom_message2: str
        :param group_by: Determines how to group results. For example, passing in 'CREATED' will return results by date. Passing in 'ACCOUNT' will return results by user {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        :type group_by: str
        :param distinct_count: Performs a unique query on the specified column. For example, passing in 'ACCOUNT' will return the number of unique users. {TAG, CUSTOM_ID, TOKEN, MODEL, DEVICE_TYPE, DEVICE, DEVICE_OS, DEVICE_ID, IP_ADDRESS, STATE, CITY, ZIP, COUNTRY, ACCOUNT, APPLICATION_ID}
        :type distinct_count: str
        :param sum_column: sum of the column values
        :type sum_column: str
        :param sort_field: Determines whether the results will be sorted by day or by number of hits {CREATED, TAG_COUNT}
        :type sort_field: str
        :param descending: Determines whether to return results in descending order
        :type descending: bool
        :param hide_unknown: Determines whether to return data that has empty or unknown values
        :type hide_unknown: bool
        :param response_format: Determines whether to return a JOSN or XML representation of the graph results
        :type response_format: str
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: Used to limit results to get a cleaner graph. The results that gets filtered out will be combined
        :type limit: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._filtered_usage_serialize(
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            start_date=start_date,
            end_date=end_date,
            device_type=device_type,
            device=device,
            device_os=device_os,
            gender=gender,
            age_group=age_group,
            country=country,
            state=state,
            city=city,
            zip=zip,
            model=model,
            tag=tag,
            user_account_id=user_account_id,
            user_account_display=user_account_display,
            user_account_username=user_account_username,
            custom_id=custom_id,
            custom_type=custom_type,
            custom_value=custom_value,
            custom_value2=custom_value2,
            custom_long=custom_long,
            custom_long2=custom_long2,
            custom_message=custom_message,
            custom_message2=custom_message2,
            group_by=group_by,
            distinct_count=distinct_count,
            sum_column=sum_column,
            sort_field=sort_field,
            descending=descending,
            hide_unknown=hide_unknown,
            response_format=response_format,
            l=l,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ChartData",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _filtered_usage_serialize(
        self,
        device_id,
        account_id,
        application_id,
        app_key,
        start_date,
        end_date,
        device_type,
        device,
        device_os,
        gender,
        age_group,
        country,
        state,
        city,
        zip,
        model,
        tag,
        user_account_id,
        user_account_display,
        user_account_username,
        custom_id,
        custom_type,
        custom_value,
        custom_value2,
        custom_long,
        custom_long2,
        custom_message,
        custom_message2,
        group_by,
        distinct_count,
        sum_column,
        sort_field,
        descending,
        hide_unknown,
        response_format,
        l,
        limit,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if application_id is not None:
            
            _query_params.append(('applicationId', application_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if device_type is not None:
            
            _query_params.append(('deviceType', device_type))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_os is not None:
            
            _query_params.append(('deviceOS', device_os))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age_group is not None:
            
            _query_params.append(('ageGroup', age_group))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if zip is not None:
            
            _query_params.append(('zip', zip))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if user_account_id is not None:
            
            _query_params.append(('userAccountId', user_account_id))
            
        if user_account_display is not None:
            
            _query_params.append(('userAccountDisplay', user_account_display))
            
        if user_account_username is not None:
            
            _query_params.append(('userAccountUsername', user_account_username))
            
        if custom_id is not None:
            
            _query_params.append(('customId', custom_id))
            
        if custom_type is not None:
            
            _query_params.append(('customType', custom_type))
            
        if custom_value is not None:
            
            _query_params.append(('customValue', custom_value))
            
        if custom_value2 is not None:
            
            _query_params.append(('customValue2', custom_value2))
            
        if custom_long is not None:
            
            _query_params.append(('customLong', custom_long))
            
        if custom_long2 is not None:
            
            _query_params.append(('customLong2', custom_long2))
            
        if custom_message is not None:
            
            _query_params.append(('customMessage', custom_message))
            
        if custom_message2 is not None:
            
            _query_params.append(('customMessage2', custom_message2))
            
        if group_by is not None:
            
            _query_params.append(('groupBy', group_by))
            
        if distinct_count is not None:
            
            _query_params.append(('distinctCount', distinct_count))
            
        if sum_column is not None:
            
            _query_params.append(('sumColumn', sum_column))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if hide_unknown is not None:
            
            _query_params.append(('hideUnknown', hide_unknown))
            
        if response_format is not None:
            
            _query_params.append(('responseFormat', response_format))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/analytics/filteredUsage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def usage(
        self,
        tag: Annotated[StrictStr, Field(description="The tag to apply: the name of the action or thing being logged.")],
        device_id: Annotated[Optional[StrictStr], Field(description="The client deviceID")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The logged in user ID")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. This is deprecated, use appKey.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key unique to each application.")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The current build version of the application")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of device (Handheld or Desktop)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model of the device (iPhone5,1 , Nexus One, etc.)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current position of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current position of the user")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="A customId used to associate the usage record with some other record in the system")] = None,
        custom_type: Annotated[Optional[StrictStr], Field(description="The type of record the customId is recorded for")] = None,
        achievement_increment: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The current city of the user")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The current state of the user")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The current country of the user")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The current zip of the user")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The general description of the user's location")] = None,
        client_time: Annotated[Optional[StrictInt], Field(description="Timestamp sent from device")] = None,
        error_message: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        ip: Annotated[Optional[StrictStr], Field(description="the ip address of the client device")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="this is a description of the client (might contain the device's OS, browser version etc - its a common term)")] = None,
        background_event: Annotated[Optional[StrictBool], Field(description="This is deprecated.")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="a custom message for the usage record")] = None,
        custom_message2: Annotated[Optional[StrictStr], Field(description="a custom message for the usage record")] = None,
        custom_value: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="a custom value for the usage record")] = None,
        custom_value2: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="a custom value for the usage record")] = None,
        custom_long: Annotated[Optional[StrictInt], Field(description="a custom long value for the usage record")] = None,
        custom_long2: Annotated[Optional[StrictInt], Field(description="a custom long value for the usage record")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Usage Record

        Record an analytic record for a known state within the application.

        :param tag: The tag to apply: the name of the action or thing being logged. (required)
        :type tag: str
        :param device_id: The client deviceID
        :type device_id: str
        :param account_id: The logged in user ID
        :type account_id: int
        :param application_id: This parameter is deprecated. This is deprecated, use appKey.
        :type application_id: int
        :param app_key: The application key unique to each application.
        :type app_key: str
        :param app_version: The current build version of the application
        :type app_version: str
        :param device: The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
        :type device: str
        :param device_type: The type of device (Handheld or Desktop)
        :type device_type: str
        :param device_os: The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)
        :type device_os: str
        :param model: The model of the device (iPhone5,1 , Nexus One, etc.)
        :type model: str
        :param latitude: The current position of the user
        :type latitude: float
        :param longitude: The current position of the user
        :type longitude: float
        :param custom_id: A customId used to associate the usage record with some other record in the system
        :type custom_id: int
        :param custom_type: The type of record the customId is recorded for
        :type custom_type: str
        :param achievement_increment: This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement
        :type achievement_increment: int
        :param city: The current city of the user
        :type city: str
        :param state: The current state of the user
        :type state: str
        :param country: The current country of the user
        :type country: str
        :param zip: The current zip of the user
        :type zip: str
        :param location_description: The general description of the user's location
        :type location_description: str
        :param client_time: Timestamp sent from device
        :type client_time: int
        :param error_message: This parameter is deprecated.
        :type error_message: str
        :param ip: the ip address of the client device
        :type ip: str
        :param user_agent: this is a description of the client (might contain the device's OS, browser version etc - its a common term)
        :type user_agent: str
        :param background_event: This is deprecated.
        :type background_event: bool
        :param custom_message: a custom message for the usage record
        :type custom_message: str
        :param custom_message2: a custom message for the usage record
        :type custom_message2: str
        :param custom_value: a custom value for the usage record
        :type custom_value: float
        :param custom_value2: a custom value for the usage record
        :type custom_value2: float
        :param custom_long: a custom long value for the usage record
        :type custom_long: int
        :param custom_long2: a custom long value for the usage record
        :type custom_long2: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._usage_serialize(
            tag=tag,
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            app_version=app_version,
            device=device,
            device_type=device_type,
            device_os=device_os,
            model=model,
            latitude=latitude,
            longitude=longitude,
            custom_id=custom_id,
            custom_type=custom_type,
            achievement_increment=achievement_increment,
            city=city,
            state=state,
            country=country,
            zip=zip,
            location_description=location_description,
            client_time=client_time,
            error_message=error_message,
            ip=ip,
            user_agent=user_agent,
            background_event=background_event,
            custom_message=custom_message,
            custom_message2=custom_message2,
            custom_value=custom_value,
            custom_value2=custom_value2,
            custom_long=custom_long,
            custom_long2=custom_long2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def usage_with_http_info(
        self,
        tag: Annotated[StrictStr, Field(description="The tag to apply: the name of the action or thing being logged.")],
        device_id: Annotated[Optional[StrictStr], Field(description="The client deviceID")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The logged in user ID")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. This is deprecated, use appKey.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key unique to each application.")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The current build version of the application")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of device (Handheld or Desktop)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model of the device (iPhone5,1 , Nexus One, etc.)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current position of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current position of the user")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="A customId used to associate the usage record with some other record in the system")] = None,
        custom_type: Annotated[Optional[StrictStr], Field(description="The type of record the customId is recorded for")] = None,
        achievement_increment: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The current city of the user")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The current state of the user")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The current country of the user")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The current zip of the user")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The general description of the user's location")] = None,
        client_time: Annotated[Optional[StrictInt], Field(description="Timestamp sent from device")] = None,
        error_message: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        ip: Annotated[Optional[StrictStr], Field(description="the ip address of the client device")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="this is a description of the client (might contain the device's OS, browser version etc - its a common term)")] = None,
        background_event: Annotated[Optional[StrictBool], Field(description="This is deprecated.")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="a custom message for the usage record")] = None,
        custom_message2: Annotated[Optional[StrictStr], Field(description="a custom message for the usage record")] = None,
        custom_value: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="a custom value for the usage record")] = None,
        custom_value2: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="a custom value for the usage record")] = None,
        custom_long: Annotated[Optional[StrictInt], Field(description="a custom long value for the usage record")] = None,
        custom_long2: Annotated[Optional[StrictInt], Field(description="a custom long value for the usage record")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Usage Record

        Record an analytic record for a known state within the application.

        :param tag: The tag to apply: the name of the action or thing being logged. (required)
        :type tag: str
        :param device_id: The client deviceID
        :type device_id: str
        :param account_id: The logged in user ID
        :type account_id: int
        :param application_id: This parameter is deprecated. This is deprecated, use appKey.
        :type application_id: int
        :param app_key: The application key unique to each application.
        :type app_key: str
        :param app_version: The current build version of the application
        :type app_version: str
        :param device: The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
        :type device: str
        :param device_type: The type of device (Handheld or Desktop)
        :type device_type: str
        :param device_os: The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)
        :type device_os: str
        :param model: The model of the device (iPhone5,1 , Nexus One, etc.)
        :type model: str
        :param latitude: The current position of the user
        :type latitude: float
        :param longitude: The current position of the user
        :type longitude: float
        :param custom_id: A customId used to associate the usage record with some other record in the system
        :type custom_id: int
        :param custom_type: The type of record the customId is recorded for
        :type custom_type: str
        :param achievement_increment: This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement
        :type achievement_increment: int
        :param city: The current city of the user
        :type city: str
        :param state: The current state of the user
        :type state: str
        :param country: The current country of the user
        :type country: str
        :param zip: The current zip of the user
        :type zip: str
        :param location_description: The general description of the user's location
        :type location_description: str
        :param client_time: Timestamp sent from device
        :type client_time: int
        :param error_message: This parameter is deprecated.
        :type error_message: str
        :param ip: the ip address of the client device
        :type ip: str
        :param user_agent: this is a description of the client (might contain the device's OS, browser version etc - its a common term)
        :type user_agent: str
        :param background_event: This is deprecated.
        :type background_event: bool
        :param custom_message: a custom message for the usage record
        :type custom_message: str
        :param custom_message2: a custom message for the usage record
        :type custom_message2: str
        :param custom_value: a custom value for the usage record
        :type custom_value: float
        :param custom_value2: a custom value for the usage record
        :type custom_value2: float
        :param custom_long: a custom long value for the usage record
        :type custom_long: int
        :param custom_long2: a custom long value for the usage record
        :type custom_long2: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._usage_serialize(
            tag=tag,
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            app_version=app_version,
            device=device,
            device_type=device_type,
            device_os=device_os,
            model=model,
            latitude=latitude,
            longitude=longitude,
            custom_id=custom_id,
            custom_type=custom_type,
            achievement_increment=achievement_increment,
            city=city,
            state=state,
            country=country,
            zip=zip,
            location_description=location_description,
            client_time=client_time,
            error_message=error_message,
            ip=ip,
            user_agent=user_agent,
            background_event=background_event,
            custom_message=custom_message,
            custom_message2=custom_message2,
            custom_value=custom_value,
            custom_value2=custom_value2,
            custom_long=custom_long,
            custom_long2=custom_long2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def usage_without_preload_content(
        self,
        tag: Annotated[StrictStr, Field(description="The tag to apply: the name of the action or thing being logged.")],
        device_id: Annotated[Optional[StrictStr], Field(description="The client deviceID")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The logged in user ID")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. This is deprecated, use appKey.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key unique to each application.")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The current build version of the application")] = None,
        device: Annotated[Optional[StrictStr], Field(description="The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of device (Handheld or Desktop)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model of the device (iPhone5,1 , Nexus One, etc.)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current position of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current position of the user")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="A customId used to associate the usage record with some other record in the system")] = None,
        custom_type: Annotated[Optional[StrictStr], Field(description="The type of record the customId is recorded for")] = None,
        achievement_increment: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The current city of the user")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The current state of the user")] = None,
        country: Annotated[Optional[StrictStr], Field(description="The current country of the user")] = None,
        zip: Annotated[Optional[StrictStr], Field(description="The current zip of the user")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The general description of the user's location")] = None,
        client_time: Annotated[Optional[StrictInt], Field(description="Timestamp sent from device")] = None,
        error_message: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        ip: Annotated[Optional[StrictStr], Field(description="the ip address of the client device")] = None,
        user_agent: Annotated[Optional[StrictStr], Field(description="this is a description of the client (might contain the device's OS, browser version etc - its a common term)")] = None,
        background_event: Annotated[Optional[StrictBool], Field(description="This is deprecated.")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="a custom message for the usage record")] = None,
        custom_message2: Annotated[Optional[StrictStr], Field(description="a custom message for the usage record")] = None,
        custom_value: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="a custom value for the usage record")] = None,
        custom_value2: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="a custom value for the usage record")] = None,
        custom_long: Annotated[Optional[StrictInt], Field(description="a custom long value for the usage record")] = None,
        custom_long2: Annotated[Optional[StrictInt], Field(description="a custom long value for the usage record")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Usage Record

        Record an analytic record for a known state within the application.

        :param tag: The tag to apply: the name of the action or thing being logged. (required)
        :type tag: str
        :param device_id: The client deviceID
        :type device_id: str
        :param account_id: The logged in user ID
        :type account_id: int
        :param application_id: This parameter is deprecated. This is deprecated, use appKey.
        :type application_id: int
        :param app_key: The application key unique to each application.
        :type app_key: str
        :param app_version: The current build version of the application
        :type app_version: str
        :param device: The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)
        :type device: str
        :param device_type: The type of device (Handheld or Desktop)
        :type device_type: str
        :param device_os: The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc)
        :type device_os: str
        :param model: The model of the device (iPhone5,1 , Nexus One, etc.)
        :type model: str
        :param latitude: The current position of the user
        :type latitude: float
        :param longitude: The current position of the user
        :type longitude: float
        :param custom_id: A customId used to associate the usage record with some other record in the system
        :type custom_id: int
        :param custom_type: The type of record the customId is recorded for
        :type custom_type: str
        :param achievement_increment: This parameter is deprecated. This is deprecated, use \"customValue\". Determines how many achievement points and/or ranking points the user gets if this analytic is associated with an achievement
        :type achievement_increment: int
        :param city: The current city of the user
        :type city: str
        :param state: The current state of the user
        :type state: str
        :param country: The current country of the user
        :type country: str
        :param zip: The current zip of the user
        :type zip: str
        :param location_description: The general description of the user's location
        :type location_description: str
        :param client_time: Timestamp sent from device
        :type client_time: int
        :param error_message: This parameter is deprecated.
        :type error_message: str
        :param ip: the ip address of the client device
        :type ip: str
        :param user_agent: this is a description of the client (might contain the device's OS, browser version etc - its a common term)
        :type user_agent: str
        :param background_event: This is deprecated.
        :type background_event: bool
        :param custom_message: a custom message for the usage record
        :type custom_message: str
        :param custom_message2: a custom message for the usage record
        :type custom_message2: str
        :param custom_value: a custom value for the usage record
        :type custom_value: float
        :param custom_value2: a custom value for the usage record
        :type custom_value2: float
        :param custom_long: a custom long value for the usage record
        :type custom_long: int
        :param custom_long2: a custom long value for the usage record
        :type custom_long2: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._usage_serialize(
            tag=tag,
            device_id=device_id,
            account_id=account_id,
            application_id=application_id,
            app_key=app_key,
            app_version=app_version,
            device=device,
            device_type=device_type,
            device_os=device_os,
            model=model,
            latitude=latitude,
            longitude=longitude,
            custom_id=custom_id,
            custom_type=custom_type,
            achievement_increment=achievement_increment,
            city=city,
            state=state,
            country=country,
            zip=zip,
            location_description=location_description,
            client_time=client_time,
            error_message=error_message,
            ip=ip,
            user_agent=user_agent,
            background_event=background_event,
            custom_message=custom_message,
            custom_message2=custom_message2,
            custom_value=custom_value,
            custom_value2=custom_value2,
            custom_long=custom_long,
            custom_long2=custom_long2,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _usage_serialize(
        self,
        tag,
        device_id,
        account_id,
        application_id,
        app_key,
        app_version,
        device,
        device_type,
        device_os,
        model,
        latitude,
        longitude,
        custom_id,
        custom_type,
        achievement_increment,
        city,
        state,
        country,
        zip,
        location_description,
        client_time,
        error_message,
        ip,
        user_agent,
        background_event,
        custom_message,
        custom_message2,
        custom_value,
        custom_value2,
        custom_long,
        custom_long2,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if application_id is not None:
            
            _query_params.append(('applicationId', application_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if app_version is not None:
            
            _query_params.append(('appVersion', app_version))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_type is not None:
            
            _query_params.append(('deviceType', device_type))
            
        if device_os is not None:
            
            _query_params.append(('deviceOS', device_os))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if custom_id is not None:
            
            _query_params.append(('customId', custom_id))
            
        if custom_type is not None:
            
            _query_params.append(('customType', custom_type))
            
        if achievement_increment is not None:
            
            _query_params.append(('achievementIncrement', achievement_increment))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if zip is not None:
            
            _query_params.append(('zip', zip))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if client_time is not None:
            
            _query_params.append(('clientTime', client_time))
            
        if error_message is not None:
            
            _query_params.append(('errorMessage', error_message))
            
        if ip is not None:
            
            _query_params.append(('ip', ip))
            
        if user_agent is not None:
            
            _query_params.append(('userAgent', user_agent))
            
        if background_event is not None:
            
            _query_params.append(('backgroundEvent', background_event))
            
        if custom_message is not None:
            
            _query_params.append(('customMessage', custom_message))
            
        if custom_message2 is not None:
            
            _query_params.append(('customMessage2', custom_message2))
            
        if custom_value is not None:
            
            _query_params.append(('customValue', custom_value))
            
        if custom_value2 is not None:
            
            _query_params.append(('customValue2', custom_value2))
            
        if custom_long is not None:
            
            _query_params.append(('customLong', custom_long))
            
        if custom_long2 is not None:
            
            _query_params.append(('customLong2', custom_long2))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/analytics/usage',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def usage_batch(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key unique to each application.")],
        device: Annotated[StrictStr, Field(description="The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)")],
        data: Annotated[StrictStr, Field(description="The analytic data AnalyticListResponse")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the logged in user making the request")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The current build version of the application")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of device (Handheld or Desktop)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model of the device (iPhone5,1 , Nexus One, etc.)")] = None,
        update_ranking: Annotated[Optional[StrictBool], Field(description="Will create a leaderboard if one does not exist for the \"tag\" yet")] = None,
        return_summary_response: Annotated[Optional[StrictBool], Field(description="Returns a summary response of the achievements that have been completed due to the analytics")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Multiple Usage Records

        Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.

        :param app_key: The application key unique to each application. (required)
        :type app_key: str
        :param device: The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (required)
        :type device: str
        :param data: The analytic data AnalyticListResponse (required)
        :type data: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param account_id: The account ID of the logged in user making the request
        :type account_id: int
        :param app_version: The current build version of the application
        :type app_version: str
        :param device_type: The type of device (Handheld or Desktop)
        :type device_type: str
        :param device_os: The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)
        :type device_os: str
        :param model: The model of the device (iPhone5,1 , Nexus One, etc.)
        :type model: str
        :param update_ranking: Will create a leaderboard if one does not exist for the \"tag\" yet
        :type update_ranking: bool
        :param return_summary_response: Returns a summary response of the achievements that have been completed due to the analytics
        :type return_summary_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._usage_batch_serialize(
            app_key=app_key,
            device=device,
            data=data,
            device_id=device_id,
            account_id=account_id,
            app_version=app_version,
            device_type=device_type,
            device_os=device_os,
            model=model,
            update_ranking=update_ranking,
            return_summary_response=return_summary_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def usage_batch_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key unique to each application.")],
        device: Annotated[StrictStr, Field(description="The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)")],
        data: Annotated[StrictStr, Field(description="The analytic data AnalyticListResponse")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the logged in user making the request")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The current build version of the application")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of device (Handheld or Desktop)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model of the device (iPhone5,1 , Nexus One, etc.)")] = None,
        update_ranking: Annotated[Optional[StrictBool], Field(description="Will create a leaderboard if one does not exist for the \"tag\" yet")] = None,
        return_summary_response: Annotated[Optional[StrictBool], Field(description="Returns a summary response of the achievements that have been completed due to the analytics")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Multiple Usage Records

        Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.

        :param app_key: The application key unique to each application. (required)
        :type app_key: str
        :param device: The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (required)
        :type device: str
        :param data: The analytic data AnalyticListResponse (required)
        :type data: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param account_id: The account ID of the logged in user making the request
        :type account_id: int
        :param app_version: The current build version of the application
        :type app_version: str
        :param device_type: The type of device (Handheld or Desktop)
        :type device_type: str
        :param device_os: The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)
        :type device_os: str
        :param model: The model of the device (iPhone5,1 , Nexus One, etc.)
        :type model: str
        :param update_ranking: Will create a leaderboard if one does not exist for the \"tag\" yet
        :type update_ranking: bool
        :param return_summary_response: Returns a summary response of the achievements that have been completed due to the analytics
        :type return_summary_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._usage_batch_serialize(
            app_key=app_key,
            device=device,
            data=data,
            device_id=device_id,
            account_id=account_id,
            app_version=app_version,
            device_type=device_type,
            device_os=device_os,
            model=model,
            update_ranking=update_ranking,
            return_summary_response=return_summary_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def usage_batch_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key unique to each application.")],
        device: Annotated[StrictStr, Field(description="The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.)")],
        data: Annotated[StrictStr, Field(description="The analytic data AnalyticListResponse")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the logged in user making the request")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="The current build version of the application")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of device (Handheld or Desktop)")] = None,
        device_os: Annotated[Optional[StrictStr], Field(description="The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)")] = None,
        model: Annotated[Optional[StrictStr], Field(description="The model of the device (iPhone5,1 , Nexus One, etc.)")] = None,
        update_ranking: Annotated[Optional[StrictBool], Field(description="Will create a leaderboard if one does not exist for the \"tag\" yet")] = None,
        return_summary_response: Annotated[Optional[StrictBool], Field(description="Returns a summary response of the achievements that have been completed due to the analytics")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Multiple Usage Records

        Sends multiple analytics. Can be used to send in the user's stored usage when they did not have internet access. Should not include more than 100 items per batch.

        :param app_key: The application key unique to each application. (required)
        :type app_key: str
        :param device: The name of the device being used (iPhone5,1 , HTC Nexus One, x86_64, etc.) (required)
        :type device: str
        :param data: The analytic data AnalyticListResponse (required)
        :type data: str
        :param device_id: The unique id of the device making the request
        :type device_id: str
        :param account_id: The account ID of the logged in user making the request
        :type account_id: int
        :param app_version: The current build version of the application
        :type app_version: str
        :param device_type: The type of device (Handheld or Desktop)
        :type device_type: str
        :param device_os: The operating system that the device is using (iPhone OS 5.0, Android OS 2.3.6, Windows 7 Service Pack 1, etc.)
        :type device_os: str
        :param model: The model of the device (iPhone5,1 , Nexus One, etc.)
        :type model: str
        :param update_ranking: Will create a leaderboard if one does not exist for the \"tag\" yet
        :type update_ranking: bool
        :param return_summary_response: Returns a summary response of the achievements that have been completed due to the analytics
        :type return_summary_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._usage_batch_serialize(
            app_key=app_key,
            device=device,
            data=data,
            device_id=device_id,
            account_id=account_id,
            app_version=app_version,
            device_type=device_type,
            device_os=device_os,
            model=model,
            update_ranking=update_ranking,
            return_summary_response=return_summary_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _usage_batch_serialize(
        self,
        app_key,
        device,
        data,
        device_id,
        account_id,
        app_version,
        device_type,
        device_os,
        model,
        update_ranking,
        return_summary_response,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if app_version is not None:
            
            _query_params.append(('appVersion', app_version))
            
        if device is not None:
            
            _query_params.append(('device', device))
            
        if device_type is not None:
            
            _query_params.append(('deviceType', device_type))
            
        if device_os is not None:
            
            _query_params.append(('deviceOS', device_os))
            
        if model is not None:
            
            _query_params.append(('model', model))
            
        if data is not None:
            
            _query_params.append(('data', data))
            
        if update_ranking is not None:
            
            _query_params.append(('updateRanking', update_ranking))
            
        if return_summary_response is not None:
            
            _query_params.append(('returnSummaryResponse', return_summary_response))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/analytics/usage/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


