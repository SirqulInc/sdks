# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.account_list_response import AccountListResponse
from openapi_client.models.application_response import ApplicationResponse
from openapi_client.models.application_settings_response import ApplicationSettingsResponse
from openapi_client.models.application_short_response import ApplicationShortResponse
from openapi_client.models.placement_response import PlacementResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ApplicationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_application(
        self,
        app_name: Annotated[StrictStr, Field(description="The name of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        about: Annotated[Optional[StrictStr], Field(description="The description of the application")] = None,
        bundle_id: Annotated[Optional[StrictStr], Field(description="The application bundle identifier (format - com.company.appName)")] = None,
        app_icon_asset_id: Annotated[Optional[StrictInt], Field(description="The application icon asset id")] = None,
        app_logo_asset_id: Annotated[Optional[StrictInt], Field(description="The application logo asset id")] = None,
        facebook_app_id: Annotated[Optional[StrictStr], Field(description="The Facebook application id")] = None,
        facebook_app_secret: Annotated[Optional[StrictStr], Field(description="The Facebook application secret")] = None,
        google_api_key: Annotated[Optional[StrictStr], Field(description="This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging")] = None,
        update_eula_date: Annotated[Optional[StrictBool], Field(description="Determines whether to update the EULA date")] = None,
        eula_version: Annotated[Optional[StrictStr], Field(description="The EULA version")] = None,
        landing_page_url: Annotated[Optional[StrictStr], Field(description="The landing page URL")] = None,
        show_in_activities: Annotated[Optional[StrictBool], Field(description="Determines whether to show the application in the activity feed")] = None,
        activity_description: Annotated[Optional[StrictStr], Field(description="The description of the application in the activity feed")] = None,
        invite_welcome_text: Annotated[Optional[StrictStr], Field(description="The text to display on the invite page")] = None,
        invite_page_url: Annotated[Optional[StrictStr], Field(description="The url to the application invite page")] = None,
        url_scheme: Annotated[Optional[StrictStr], Field(description="The protocal the app uses to load the app via a browser")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ")] = None,
        download_urls: Annotated[Optional[StrictStr], Field(description="Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="List of categories to apply")] = None,
        scoring_type: Annotated[Optional[StrictStr], Field(description="The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT")] = None,
        hint_cost: Annotated[Optional[StrictInt], Field(description="The cost of hints")] = None,
        max_score: Annotated[Optional[StrictInt], Field(description="The maximum score that will be possible")] = None,
        tickets_per_point: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The point-to-ticket conversion ratio")] = None,
        has_game_data: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses services to save custom game objects")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Public Notifications")] = None,
        use_matching_algorithm: Annotated[Optional[StrictBool], Field(description="Use Matching Algorithm")] = None,
        global_tickets: Annotated[Optional[StrictBool], Field(description="Determines whether earned tickets are applied across all applications")] = None,
        build_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current build version of the application")] = None,
        api_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current API version the application uses")] = None,
        placement_name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        placement_description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        placement_size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)")] = None,
        placement_height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        placement_width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        placement_refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        create_object_store: Annotated[Optional[StrictBool], Field(description="Generate a custom object store to use")] = None,
        public_content_approval: Annotated[Optional[StrictBool], Field(description="Determine whether or not public content requires admin approval before it becomes public")] = None,
        production_mode: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses production or sandbox services")] = None,
        minimum_session_length: Annotated[Optional[StrictInt], Field(description="Minimum Session Length")] = None,
        session_gap_length: Annotated[Optional[StrictInt], Field(description="Session Gap Length")] = None,
        local_ads_enabled: Annotated[Optional[StrictBool], Field(description="Local Ads Enabled")] = None,
        sqoot_api_key: Annotated[Optional[StrictStr], Field(description="Sqoot Api Key")] = None,
        trilat_processing_type: Annotated[Optional[StrictStr], Field(description="Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT")] = None,
        max_sample_size: Annotated[Optional[StrictInt], Field(description="Determines what the maximum sample size during trilateration")] = None,
        min_rssi: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Determines what the minimum acceptable RSSI value")] = None,
        modules: Annotated[Optional[StrictStr], Field(description="List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL")] = None,
        authorized_count: Annotated[Optional[StrictInt], Field(description="How many servers the license will support")] = None,
        authorized_servers: Annotated[Optional[StrictStr], Field(description="The list of ip addresses of servers the license will support, leave null for any server")] = None,
        default_timezone: Annotated[Optional[StrictStr], Field(description="Sets the default timezone for the app (used for leaderboards and other time specific content)")] = None,
        smtp_pass: Annotated[Optional[StrictStr], Field(description="SMTP Pass")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="The application meta data. Defined by the client")] = None,
        placement_meta_data: Annotated[Optional[StrictStr], Field(description="The ad placement meta data. Defined by the client")] = None,
        ips_floor: Annotated[Optional[StrictBool], Field(description="Create floor tables for Ips")] = None,
        enable_apns_badge: Annotated[Optional[StrictBool], Field(description="Enables setting the APNS badge value in the payload")] = None,
        include_in_report: Annotated[Optional[StrictBool], Field(description="Enables using the application in session reports")] = None,
        default_app_filter_id: Annotated[Optional[StrictInt], Field(description="Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.")] = None,
        enable_welcome_email: Annotated[Optional[StrictBool], Field(description="Enables whether the default welcome email will be sent for new app users")] = None,
        apple_app_id: Annotated[Optional[StrictStr], Field(description="The Apple Application ID")] = None,
        apple_team_id: Annotated[Optional[StrictStr], Field(description="The Apple Team ID")] = None,
        apple_auth_key_id: Annotated[Optional[StrictStr], Field(description="The Apple Auth Key ID")] = None,
        apple_auth_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple Auth Signin Key (p8) File")] = None,
        apple_issuer_id: Annotated[Optional[StrictStr], Field(description="The Apple Issuer ID")] = None,
        app_store_key_id: Annotated[Optional[StrictStr], Field(description="The Apple App Store Key ID")] = None,
        app_store_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple App Store Key (p8) File")] = None,
        google_private_key_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="This is the private key file for your Google service account.")] = None,
        authorize_net_api_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Api Key")] = None,
        authorize_net_transaction_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Transaction Key")] = None,
        email_sender: Annotated[Optional[StrictStr], Field(description="Email Sender")] = None,
        smtp_user: Annotated[Optional[StrictStr], Field(description="SMTP User")] = None,
        smtp_host: Annotated[Optional[StrictStr], Field(description="SMTP Host")] = None,
        vatom_business_id: Annotated[Optional[StrictStr], Field(description="Vatom Business Id")] = None,
        vatom_rest_client_id: Annotated[Optional[StrictStr], Field(description="Vatom REST Client Id")] = None,
        vatom_rest_secret_key: Annotated[Optional[StrictStr], Field(description="Vatom Secret Key")] = None,
        twilio_account_sid: Annotated[Optional[StrictStr], Field(description="Twilio Account SID")] = None,
        twilio_auth_token: Annotated[Optional[StrictStr], Field(description="Twilio Auth Token")] = None,
        twilio_sender_phone_number: Annotated[Optional[StrictStr], Field(description="Twilio Sender Phone Number")] = None,
        open_ai_secret_key: Annotated[Optional[StrictStr], Field(description="OpenAI Secret API Key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationResponse:
        """Create Application

        Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.

        :param app_name: The name of the application (required)
        :type app_name: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param about: The description of the application
        :type about: str
        :param bundle_id: The application bundle identifier (format - com.company.appName)
        :type bundle_id: str
        :param app_icon_asset_id: The application icon asset id
        :type app_icon_asset_id: int
        :param app_logo_asset_id: The application logo asset id
        :type app_logo_asset_id: int
        :param facebook_app_id: The Facebook application id
        :type facebook_app_id: str
        :param facebook_app_secret: The Facebook application secret
        :type facebook_app_secret: str
        :param google_api_key: This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        :type google_api_key: str
        :param update_eula_date: Determines whether to update the EULA date
        :type update_eula_date: bool
        :param eula_version: The EULA version
        :type eula_version: str
        :param landing_page_url: The landing page URL
        :type landing_page_url: str
        :param show_in_activities: Determines whether to show the application in the activity feed
        :type show_in_activities: bool
        :param activity_description: The description of the application in the activity feed
        :type activity_description: str
        :param invite_welcome_text: The text to display on the invite page
        :type invite_welcome_text: str
        :param invite_page_url: The url to the application invite page
        :type invite_page_url: str
        :param url_scheme: The protocal the app uses to load the app via a browser
        :type url_scheme: str
        :param platforms: A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        :type platforms: str
        :param download_urls: Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        :type download_urls: str
        :param category_ids: List of categories to apply
        :type category_ids: str
        :param scoring_type: The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        :type scoring_type: str
        :param hint_cost: The cost of hints
        :type hint_cost: int
        :param max_score: The maximum score that will be possible
        :type max_score: int
        :param tickets_per_point: The point-to-ticket conversion ratio
        :type tickets_per_point: float
        :param has_game_data: Determines whether the application uses services to save custom game objects
        :type has_game_data: bool
        :param public_notifications: Public Notifications
        :type public_notifications: bool
        :param use_matching_algorithm: Use Matching Algorithm
        :type use_matching_algorithm: bool
        :param global_tickets: Determines whether earned tickets are applied across all applications
        :type global_tickets: bool
        :param build_version: The current build version of the application
        :type build_version: float
        :param api_version: The current API version the application uses
        :type api_version: float
        :param placement_name: The name of the placement
        :type placement_name: str
        :param placement_description: The description of the placement
        :type placement_description: str
        :param placement_size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        :type placement_size: str
        :param placement_height: The height of a custom ad size
        :type placement_height: int
        :param placement_width: The width of a custom ad size
        :type placement_width: int
        :param placement_refresh_interval: The refresh interval in seconds
        :type placement_refresh_interval: int
        :param create_object_store: Generate a custom object store to use
        :type create_object_store: bool
        :param public_content_approval: Determine whether or not public content requires admin approval before it becomes public
        :type public_content_approval: bool
        :param production_mode: Determines whether the application uses production or sandbox services
        :type production_mode: bool
        :param minimum_session_length: Minimum Session Length
        :type minimum_session_length: int
        :param session_gap_length: Session Gap Length
        :type session_gap_length: int
        :param local_ads_enabled: Local Ads Enabled
        :type local_ads_enabled: bool
        :param sqoot_api_key: Sqoot Api Key
        :type sqoot_api_key: str
        :param trilat_processing_type: Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        :type trilat_processing_type: str
        :param max_sample_size: Determines what the maximum sample size during trilateration
        :type max_sample_size: int
        :param min_rssi: Determines what the minimum acceptable RSSI value
        :type min_rssi: float
        :param modules: List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        :type modules: str
        :param authorized_count: How many servers the license will support
        :type authorized_count: int
        :param authorized_servers: The list of ip addresses of servers the license will support, leave null for any server
        :type authorized_servers: str
        :param default_timezone: Sets the default timezone for the app (used for leaderboards and other time specific content)
        :type default_timezone: str
        :param smtp_pass: SMTP Pass
        :type smtp_pass: str
        :param meta_data: The application meta data. Defined by the client
        :type meta_data: str
        :param placement_meta_data: The ad placement meta data. Defined by the client
        :type placement_meta_data: str
        :param ips_floor: Create floor tables for Ips
        :type ips_floor: bool
        :param enable_apns_badge: Enables setting the APNS badge value in the payload
        :type enable_apns_badge: bool
        :param include_in_report: Enables using the application in session reports
        :type include_in_report: bool
        :param default_app_filter_id: Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        :type default_app_filter_id: int
        :param enable_welcome_email: Enables whether the default welcome email will be sent for new app users
        :type enable_welcome_email: bool
        :param apple_app_id: The Apple Application ID
        :type apple_app_id: str
        :param apple_team_id: The Apple Team ID
        :type apple_team_id: str
        :param apple_auth_key_id: The Apple Auth Key ID
        :type apple_auth_key_id: str
        :param apple_auth_key: The Apple Auth Signin Key (p8) File
        :type apple_auth_key: bytearray
        :param apple_issuer_id: The Apple Issuer ID
        :type apple_issuer_id: str
        :param app_store_key_id: The Apple App Store Key ID
        :type app_store_key_id: str
        :param app_store_key: The Apple App Store Key (p8) File
        :type app_store_key: bytearray
        :param google_private_key_file: This is the private key file for your Google service account.
        :type google_private_key_file: bytearray
        :param authorize_net_api_key: Authorize Net Api Key
        :type authorize_net_api_key: str
        :param authorize_net_transaction_key: Authorize Net Transaction Key
        :type authorize_net_transaction_key: str
        :param email_sender: Email Sender
        :type email_sender: str
        :param smtp_user: SMTP User
        :type smtp_user: str
        :param smtp_host: SMTP Host
        :type smtp_host: str
        :param vatom_business_id: Vatom Business Id
        :type vatom_business_id: str
        :param vatom_rest_client_id: Vatom REST Client Id
        :type vatom_rest_client_id: str
        :param vatom_rest_secret_key: Vatom Secret Key
        :type vatom_rest_secret_key: str
        :param twilio_account_sid: Twilio Account SID
        :type twilio_account_sid: str
        :param twilio_auth_token: Twilio Auth Token
        :type twilio_auth_token: str
        :param twilio_sender_phone_number: Twilio Sender Phone Number
        :type twilio_sender_phone_number: str
        :param open_ai_secret_key: OpenAI Secret API Key
        :type open_ai_secret_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_serialize(
            app_name=app_name,
            device_id=device_id,
            account_id=account_id,
            about=about,
            bundle_id=bundle_id,
            app_icon_asset_id=app_icon_asset_id,
            app_logo_asset_id=app_logo_asset_id,
            facebook_app_id=facebook_app_id,
            facebook_app_secret=facebook_app_secret,
            google_api_key=google_api_key,
            update_eula_date=update_eula_date,
            eula_version=eula_version,
            landing_page_url=landing_page_url,
            show_in_activities=show_in_activities,
            activity_description=activity_description,
            invite_welcome_text=invite_welcome_text,
            invite_page_url=invite_page_url,
            url_scheme=url_scheme,
            platforms=platforms,
            download_urls=download_urls,
            category_ids=category_ids,
            scoring_type=scoring_type,
            hint_cost=hint_cost,
            max_score=max_score,
            tickets_per_point=tickets_per_point,
            has_game_data=has_game_data,
            public_notifications=public_notifications,
            use_matching_algorithm=use_matching_algorithm,
            global_tickets=global_tickets,
            build_version=build_version,
            api_version=api_version,
            placement_name=placement_name,
            placement_description=placement_description,
            placement_size=placement_size,
            placement_height=placement_height,
            placement_width=placement_width,
            placement_refresh_interval=placement_refresh_interval,
            create_object_store=create_object_store,
            public_content_approval=public_content_approval,
            production_mode=production_mode,
            minimum_session_length=minimum_session_length,
            session_gap_length=session_gap_length,
            local_ads_enabled=local_ads_enabled,
            sqoot_api_key=sqoot_api_key,
            trilat_processing_type=trilat_processing_type,
            max_sample_size=max_sample_size,
            min_rssi=min_rssi,
            modules=modules,
            authorized_count=authorized_count,
            authorized_servers=authorized_servers,
            default_timezone=default_timezone,
            smtp_pass=smtp_pass,
            meta_data=meta_data,
            placement_meta_data=placement_meta_data,
            ips_floor=ips_floor,
            enable_apns_badge=enable_apns_badge,
            include_in_report=include_in_report,
            default_app_filter_id=default_app_filter_id,
            enable_welcome_email=enable_welcome_email,
            apple_app_id=apple_app_id,
            apple_team_id=apple_team_id,
            apple_auth_key_id=apple_auth_key_id,
            apple_auth_key=apple_auth_key,
            apple_issuer_id=apple_issuer_id,
            app_store_key_id=app_store_key_id,
            app_store_key=app_store_key,
            google_private_key_file=google_private_key_file,
            authorize_net_api_key=authorize_net_api_key,
            authorize_net_transaction_key=authorize_net_transaction_key,
            email_sender=email_sender,
            smtp_user=smtp_user,
            smtp_host=smtp_host,
            vatom_business_id=vatom_business_id,
            vatom_rest_client_id=vatom_rest_client_id,
            vatom_rest_secret_key=vatom_rest_secret_key,
            twilio_account_sid=twilio_account_sid,
            twilio_auth_token=twilio_auth_token,
            twilio_sender_phone_number=twilio_sender_phone_number,
            open_ai_secret_key=open_ai_secret_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_application_with_http_info(
        self,
        app_name: Annotated[StrictStr, Field(description="The name of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        about: Annotated[Optional[StrictStr], Field(description="The description of the application")] = None,
        bundle_id: Annotated[Optional[StrictStr], Field(description="The application bundle identifier (format - com.company.appName)")] = None,
        app_icon_asset_id: Annotated[Optional[StrictInt], Field(description="The application icon asset id")] = None,
        app_logo_asset_id: Annotated[Optional[StrictInt], Field(description="The application logo asset id")] = None,
        facebook_app_id: Annotated[Optional[StrictStr], Field(description="The Facebook application id")] = None,
        facebook_app_secret: Annotated[Optional[StrictStr], Field(description="The Facebook application secret")] = None,
        google_api_key: Annotated[Optional[StrictStr], Field(description="This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging")] = None,
        update_eula_date: Annotated[Optional[StrictBool], Field(description="Determines whether to update the EULA date")] = None,
        eula_version: Annotated[Optional[StrictStr], Field(description="The EULA version")] = None,
        landing_page_url: Annotated[Optional[StrictStr], Field(description="The landing page URL")] = None,
        show_in_activities: Annotated[Optional[StrictBool], Field(description="Determines whether to show the application in the activity feed")] = None,
        activity_description: Annotated[Optional[StrictStr], Field(description="The description of the application in the activity feed")] = None,
        invite_welcome_text: Annotated[Optional[StrictStr], Field(description="The text to display on the invite page")] = None,
        invite_page_url: Annotated[Optional[StrictStr], Field(description="The url to the application invite page")] = None,
        url_scheme: Annotated[Optional[StrictStr], Field(description="The protocal the app uses to load the app via a browser")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ")] = None,
        download_urls: Annotated[Optional[StrictStr], Field(description="Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="List of categories to apply")] = None,
        scoring_type: Annotated[Optional[StrictStr], Field(description="The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT")] = None,
        hint_cost: Annotated[Optional[StrictInt], Field(description="The cost of hints")] = None,
        max_score: Annotated[Optional[StrictInt], Field(description="The maximum score that will be possible")] = None,
        tickets_per_point: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The point-to-ticket conversion ratio")] = None,
        has_game_data: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses services to save custom game objects")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Public Notifications")] = None,
        use_matching_algorithm: Annotated[Optional[StrictBool], Field(description="Use Matching Algorithm")] = None,
        global_tickets: Annotated[Optional[StrictBool], Field(description="Determines whether earned tickets are applied across all applications")] = None,
        build_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current build version of the application")] = None,
        api_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current API version the application uses")] = None,
        placement_name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        placement_description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        placement_size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)")] = None,
        placement_height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        placement_width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        placement_refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        create_object_store: Annotated[Optional[StrictBool], Field(description="Generate a custom object store to use")] = None,
        public_content_approval: Annotated[Optional[StrictBool], Field(description="Determine whether or not public content requires admin approval before it becomes public")] = None,
        production_mode: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses production or sandbox services")] = None,
        minimum_session_length: Annotated[Optional[StrictInt], Field(description="Minimum Session Length")] = None,
        session_gap_length: Annotated[Optional[StrictInt], Field(description="Session Gap Length")] = None,
        local_ads_enabled: Annotated[Optional[StrictBool], Field(description="Local Ads Enabled")] = None,
        sqoot_api_key: Annotated[Optional[StrictStr], Field(description="Sqoot Api Key")] = None,
        trilat_processing_type: Annotated[Optional[StrictStr], Field(description="Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT")] = None,
        max_sample_size: Annotated[Optional[StrictInt], Field(description="Determines what the maximum sample size during trilateration")] = None,
        min_rssi: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Determines what the minimum acceptable RSSI value")] = None,
        modules: Annotated[Optional[StrictStr], Field(description="List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL")] = None,
        authorized_count: Annotated[Optional[StrictInt], Field(description="How many servers the license will support")] = None,
        authorized_servers: Annotated[Optional[StrictStr], Field(description="The list of ip addresses of servers the license will support, leave null for any server")] = None,
        default_timezone: Annotated[Optional[StrictStr], Field(description="Sets the default timezone for the app (used for leaderboards and other time specific content)")] = None,
        smtp_pass: Annotated[Optional[StrictStr], Field(description="SMTP Pass")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="The application meta data. Defined by the client")] = None,
        placement_meta_data: Annotated[Optional[StrictStr], Field(description="The ad placement meta data. Defined by the client")] = None,
        ips_floor: Annotated[Optional[StrictBool], Field(description="Create floor tables for Ips")] = None,
        enable_apns_badge: Annotated[Optional[StrictBool], Field(description="Enables setting the APNS badge value in the payload")] = None,
        include_in_report: Annotated[Optional[StrictBool], Field(description="Enables using the application in session reports")] = None,
        default_app_filter_id: Annotated[Optional[StrictInt], Field(description="Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.")] = None,
        enable_welcome_email: Annotated[Optional[StrictBool], Field(description="Enables whether the default welcome email will be sent for new app users")] = None,
        apple_app_id: Annotated[Optional[StrictStr], Field(description="The Apple Application ID")] = None,
        apple_team_id: Annotated[Optional[StrictStr], Field(description="The Apple Team ID")] = None,
        apple_auth_key_id: Annotated[Optional[StrictStr], Field(description="The Apple Auth Key ID")] = None,
        apple_auth_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple Auth Signin Key (p8) File")] = None,
        apple_issuer_id: Annotated[Optional[StrictStr], Field(description="The Apple Issuer ID")] = None,
        app_store_key_id: Annotated[Optional[StrictStr], Field(description="The Apple App Store Key ID")] = None,
        app_store_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple App Store Key (p8) File")] = None,
        google_private_key_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="This is the private key file for your Google service account.")] = None,
        authorize_net_api_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Api Key")] = None,
        authorize_net_transaction_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Transaction Key")] = None,
        email_sender: Annotated[Optional[StrictStr], Field(description="Email Sender")] = None,
        smtp_user: Annotated[Optional[StrictStr], Field(description="SMTP User")] = None,
        smtp_host: Annotated[Optional[StrictStr], Field(description="SMTP Host")] = None,
        vatom_business_id: Annotated[Optional[StrictStr], Field(description="Vatom Business Id")] = None,
        vatom_rest_client_id: Annotated[Optional[StrictStr], Field(description="Vatom REST Client Id")] = None,
        vatom_rest_secret_key: Annotated[Optional[StrictStr], Field(description="Vatom Secret Key")] = None,
        twilio_account_sid: Annotated[Optional[StrictStr], Field(description="Twilio Account SID")] = None,
        twilio_auth_token: Annotated[Optional[StrictStr], Field(description="Twilio Auth Token")] = None,
        twilio_sender_phone_number: Annotated[Optional[StrictStr], Field(description="Twilio Sender Phone Number")] = None,
        open_ai_secret_key: Annotated[Optional[StrictStr], Field(description="OpenAI Secret API Key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationResponse]:
        """Create Application

        Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.

        :param app_name: The name of the application (required)
        :type app_name: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param about: The description of the application
        :type about: str
        :param bundle_id: The application bundle identifier (format - com.company.appName)
        :type bundle_id: str
        :param app_icon_asset_id: The application icon asset id
        :type app_icon_asset_id: int
        :param app_logo_asset_id: The application logo asset id
        :type app_logo_asset_id: int
        :param facebook_app_id: The Facebook application id
        :type facebook_app_id: str
        :param facebook_app_secret: The Facebook application secret
        :type facebook_app_secret: str
        :param google_api_key: This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        :type google_api_key: str
        :param update_eula_date: Determines whether to update the EULA date
        :type update_eula_date: bool
        :param eula_version: The EULA version
        :type eula_version: str
        :param landing_page_url: The landing page URL
        :type landing_page_url: str
        :param show_in_activities: Determines whether to show the application in the activity feed
        :type show_in_activities: bool
        :param activity_description: The description of the application in the activity feed
        :type activity_description: str
        :param invite_welcome_text: The text to display on the invite page
        :type invite_welcome_text: str
        :param invite_page_url: The url to the application invite page
        :type invite_page_url: str
        :param url_scheme: The protocal the app uses to load the app via a browser
        :type url_scheme: str
        :param platforms: A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        :type platforms: str
        :param download_urls: Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        :type download_urls: str
        :param category_ids: List of categories to apply
        :type category_ids: str
        :param scoring_type: The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        :type scoring_type: str
        :param hint_cost: The cost of hints
        :type hint_cost: int
        :param max_score: The maximum score that will be possible
        :type max_score: int
        :param tickets_per_point: The point-to-ticket conversion ratio
        :type tickets_per_point: float
        :param has_game_data: Determines whether the application uses services to save custom game objects
        :type has_game_data: bool
        :param public_notifications: Public Notifications
        :type public_notifications: bool
        :param use_matching_algorithm: Use Matching Algorithm
        :type use_matching_algorithm: bool
        :param global_tickets: Determines whether earned tickets are applied across all applications
        :type global_tickets: bool
        :param build_version: The current build version of the application
        :type build_version: float
        :param api_version: The current API version the application uses
        :type api_version: float
        :param placement_name: The name of the placement
        :type placement_name: str
        :param placement_description: The description of the placement
        :type placement_description: str
        :param placement_size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        :type placement_size: str
        :param placement_height: The height of a custom ad size
        :type placement_height: int
        :param placement_width: The width of a custom ad size
        :type placement_width: int
        :param placement_refresh_interval: The refresh interval in seconds
        :type placement_refresh_interval: int
        :param create_object_store: Generate a custom object store to use
        :type create_object_store: bool
        :param public_content_approval: Determine whether or not public content requires admin approval before it becomes public
        :type public_content_approval: bool
        :param production_mode: Determines whether the application uses production or sandbox services
        :type production_mode: bool
        :param minimum_session_length: Minimum Session Length
        :type minimum_session_length: int
        :param session_gap_length: Session Gap Length
        :type session_gap_length: int
        :param local_ads_enabled: Local Ads Enabled
        :type local_ads_enabled: bool
        :param sqoot_api_key: Sqoot Api Key
        :type sqoot_api_key: str
        :param trilat_processing_type: Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        :type trilat_processing_type: str
        :param max_sample_size: Determines what the maximum sample size during trilateration
        :type max_sample_size: int
        :param min_rssi: Determines what the minimum acceptable RSSI value
        :type min_rssi: float
        :param modules: List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        :type modules: str
        :param authorized_count: How many servers the license will support
        :type authorized_count: int
        :param authorized_servers: The list of ip addresses of servers the license will support, leave null for any server
        :type authorized_servers: str
        :param default_timezone: Sets the default timezone for the app (used for leaderboards and other time specific content)
        :type default_timezone: str
        :param smtp_pass: SMTP Pass
        :type smtp_pass: str
        :param meta_data: The application meta data. Defined by the client
        :type meta_data: str
        :param placement_meta_data: The ad placement meta data. Defined by the client
        :type placement_meta_data: str
        :param ips_floor: Create floor tables for Ips
        :type ips_floor: bool
        :param enable_apns_badge: Enables setting the APNS badge value in the payload
        :type enable_apns_badge: bool
        :param include_in_report: Enables using the application in session reports
        :type include_in_report: bool
        :param default_app_filter_id: Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        :type default_app_filter_id: int
        :param enable_welcome_email: Enables whether the default welcome email will be sent for new app users
        :type enable_welcome_email: bool
        :param apple_app_id: The Apple Application ID
        :type apple_app_id: str
        :param apple_team_id: The Apple Team ID
        :type apple_team_id: str
        :param apple_auth_key_id: The Apple Auth Key ID
        :type apple_auth_key_id: str
        :param apple_auth_key: The Apple Auth Signin Key (p8) File
        :type apple_auth_key: bytearray
        :param apple_issuer_id: The Apple Issuer ID
        :type apple_issuer_id: str
        :param app_store_key_id: The Apple App Store Key ID
        :type app_store_key_id: str
        :param app_store_key: The Apple App Store Key (p8) File
        :type app_store_key: bytearray
        :param google_private_key_file: This is the private key file for your Google service account.
        :type google_private_key_file: bytearray
        :param authorize_net_api_key: Authorize Net Api Key
        :type authorize_net_api_key: str
        :param authorize_net_transaction_key: Authorize Net Transaction Key
        :type authorize_net_transaction_key: str
        :param email_sender: Email Sender
        :type email_sender: str
        :param smtp_user: SMTP User
        :type smtp_user: str
        :param smtp_host: SMTP Host
        :type smtp_host: str
        :param vatom_business_id: Vatom Business Id
        :type vatom_business_id: str
        :param vatom_rest_client_id: Vatom REST Client Id
        :type vatom_rest_client_id: str
        :param vatom_rest_secret_key: Vatom Secret Key
        :type vatom_rest_secret_key: str
        :param twilio_account_sid: Twilio Account SID
        :type twilio_account_sid: str
        :param twilio_auth_token: Twilio Auth Token
        :type twilio_auth_token: str
        :param twilio_sender_phone_number: Twilio Sender Phone Number
        :type twilio_sender_phone_number: str
        :param open_ai_secret_key: OpenAI Secret API Key
        :type open_ai_secret_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_serialize(
            app_name=app_name,
            device_id=device_id,
            account_id=account_id,
            about=about,
            bundle_id=bundle_id,
            app_icon_asset_id=app_icon_asset_id,
            app_logo_asset_id=app_logo_asset_id,
            facebook_app_id=facebook_app_id,
            facebook_app_secret=facebook_app_secret,
            google_api_key=google_api_key,
            update_eula_date=update_eula_date,
            eula_version=eula_version,
            landing_page_url=landing_page_url,
            show_in_activities=show_in_activities,
            activity_description=activity_description,
            invite_welcome_text=invite_welcome_text,
            invite_page_url=invite_page_url,
            url_scheme=url_scheme,
            platforms=platforms,
            download_urls=download_urls,
            category_ids=category_ids,
            scoring_type=scoring_type,
            hint_cost=hint_cost,
            max_score=max_score,
            tickets_per_point=tickets_per_point,
            has_game_data=has_game_data,
            public_notifications=public_notifications,
            use_matching_algorithm=use_matching_algorithm,
            global_tickets=global_tickets,
            build_version=build_version,
            api_version=api_version,
            placement_name=placement_name,
            placement_description=placement_description,
            placement_size=placement_size,
            placement_height=placement_height,
            placement_width=placement_width,
            placement_refresh_interval=placement_refresh_interval,
            create_object_store=create_object_store,
            public_content_approval=public_content_approval,
            production_mode=production_mode,
            minimum_session_length=minimum_session_length,
            session_gap_length=session_gap_length,
            local_ads_enabled=local_ads_enabled,
            sqoot_api_key=sqoot_api_key,
            trilat_processing_type=trilat_processing_type,
            max_sample_size=max_sample_size,
            min_rssi=min_rssi,
            modules=modules,
            authorized_count=authorized_count,
            authorized_servers=authorized_servers,
            default_timezone=default_timezone,
            smtp_pass=smtp_pass,
            meta_data=meta_data,
            placement_meta_data=placement_meta_data,
            ips_floor=ips_floor,
            enable_apns_badge=enable_apns_badge,
            include_in_report=include_in_report,
            default_app_filter_id=default_app_filter_id,
            enable_welcome_email=enable_welcome_email,
            apple_app_id=apple_app_id,
            apple_team_id=apple_team_id,
            apple_auth_key_id=apple_auth_key_id,
            apple_auth_key=apple_auth_key,
            apple_issuer_id=apple_issuer_id,
            app_store_key_id=app_store_key_id,
            app_store_key=app_store_key,
            google_private_key_file=google_private_key_file,
            authorize_net_api_key=authorize_net_api_key,
            authorize_net_transaction_key=authorize_net_transaction_key,
            email_sender=email_sender,
            smtp_user=smtp_user,
            smtp_host=smtp_host,
            vatom_business_id=vatom_business_id,
            vatom_rest_client_id=vatom_rest_client_id,
            vatom_rest_secret_key=vatom_rest_secret_key,
            twilio_account_sid=twilio_account_sid,
            twilio_auth_token=twilio_auth_token,
            twilio_sender_phone_number=twilio_sender_phone_number,
            open_ai_secret_key=open_ai_secret_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_application_without_preload_content(
        self,
        app_name: Annotated[StrictStr, Field(description="The name of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        about: Annotated[Optional[StrictStr], Field(description="The description of the application")] = None,
        bundle_id: Annotated[Optional[StrictStr], Field(description="The application bundle identifier (format - com.company.appName)")] = None,
        app_icon_asset_id: Annotated[Optional[StrictInt], Field(description="The application icon asset id")] = None,
        app_logo_asset_id: Annotated[Optional[StrictInt], Field(description="The application logo asset id")] = None,
        facebook_app_id: Annotated[Optional[StrictStr], Field(description="The Facebook application id")] = None,
        facebook_app_secret: Annotated[Optional[StrictStr], Field(description="The Facebook application secret")] = None,
        google_api_key: Annotated[Optional[StrictStr], Field(description="This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging")] = None,
        update_eula_date: Annotated[Optional[StrictBool], Field(description="Determines whether to update the EULA date")] = None,
        eula_version: Annotated[Optional[StrictStr], Field(description="The EULA version")] = None,
        landing_page_url: Annotated[Optional[StrictStr], Field(description="The landing page URL")] = None,
        show_in_activities: Annotated[Optional[StrictBool], Field(description="Determines whether to show the application in the activity feed")] = None,
        activity_description: Annotated[Optional[StrictStr], Field(description="The description of the application in the activity feed")] = None,
        invite_welcome_text: Annotated[Optional[StrictStr], Field(description="The text to display on the invite page")] = None,
        invite_page_url: Annotated[Optional[StrictStr], Field(description="The url to the application invite page")] = None,
        url_scheme: Annotated[Optional[StrictStr], Field(description="The protocal the app uses to load the app via a browser")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ")] = None,
        download_urls: Annotated[Optional[StrictStr], Field(description="Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="List of categories to apply")] = None,
        scoring_type: Annotated[Optional[StrictStr], Field(description="The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT")] = None,
        hint_cost: Annotated[Optional[StrictInt], Field(description="The cost of hints")] = None,
        max_score: Annotated[Optional[StrictInt], Field(description="The maximum score that will be possible")] = None,
        tickets_per_point: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The point-to-ticket conversion ratio")] = None,
        has_game_data: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses services to save custom game objects")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Public Notifications")] = None,
        use_matching_algorithm: Annotated[Optional[StrictBool], Field(description="Use Matching Algorithm")] = None,
        global_tickets: Annotated[Optional[StrictBool], Field(description="Determines whether earned tickets are applied across all applications")] = None,
        build_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current build version of the application")] = None,
        api_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current API version the application uses")] = None,
        placement_name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        placement_description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        placement_size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)")] = None,
        placement_height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        placement_width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        placement_refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        create_object_store: Annotated[Optional[StrictBool], Field(description="Generate a custom object store to use")] = None,
        public_content_approval: Annotated[Optional[StrictBool], Field(description="Determine whether or not public content requires admin approval before it becomes public")] = None,
        production_mode: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses production or sandbox services")] = None,
        minimum_session_length: Annotated[Optional[StrictInt], Field(description="Minimum Session Length")] = None,
        session_gap_length: Annotated[Optional[StrictInt], Field(description="Session Gap Length")] = None,
        local_ads_enabled: Annotated[Optional[StrictBool], Field(description="Local Ads Enabled")] = None,
        sqoot_api_key: Annotated[Optional[StrictStr], Field(description="Sqoot Api Key")] = None,
        trilat_processing_type: Annotated[Optional[StrictStr], Field(description="Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT")] = None,
        max_sample_size: Annotated[Optional[StrictInt], Field(description="Determines what the maximum sample size during trilateration")] = None,
        min_rssi: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Determines what the minimum acceptable RSSI value")] = None,
        modules: Annotated[Optional[StrictStr], Field(description="List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL")] = None,
        authorized_count: Annotated[Optional[StrictInt], Field(description="How many servers the license will support")] = None,
        authorized_servers: Annotated[Optional[StrictStr], Field(description="The list of ip addresses of servers the license will support, leave null for any server")] = None,
        default_timezone: Annotated[Optional[StrictStr], Field(description="Sets the default timezone for the app (used for leaderboards and other time specific content)")] = None,
        smtp_pass: Annotated[Optional[StrictStr], Field(description="SMTP Pass")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="The application meta data. Defined by the client")] = None,
        placement_meta_data: Annotated[Optional[StrictStr], Field(description="The ad placement meta data. Defined by the client")] = None,
        ips_floor: Annotated[Optional[StrictBool], Field(description="Create floor tables for Ips")] = None,
        enable_apns_badge: Annotated[Optional[StrictBool], Field(description="Enables setting the APNS badge value in the payload")] = None,
        include_in_report: Annotated[Optional[StrictBool], Field(description="Enables using the application in session reports")] = None,
        default_app_filter_id: Annotated[Optional[StrictInt], Field(description="Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.")] = None,
        enable_welcome_email: Annotated[Optional[StrictBool], Field(description="Enables whether the default welcome email will be sent for new app users")] = None,
        apple_app_id: Annotated[Optional[StrictStr], Field(description="The Apple Application ID")] = None,
        apple_team_id: Annotated[Optional[StrictStr], Field(description="The Apple Team ID")] = None,
        apple_auth_key_id: Annotated[Optional[StrictStr], Field(description="The Apple Auth Key ID")] = None,
        apple_auth_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple Auth Signin Key (p8) File")] = None,
        apple_issuer_id: Annotated[Optional[StrictStr], Field(description="The Apple Issuer ID")] = None,
        app_store_key_id: Annotated[Optional[StrictStr], Field(description="The Apple App Store Key ID")] = None,
        app_store_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple App Store Key (p8) File")] = None,
        google_private_key_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="This is the private key file for your Google service account.")] = None,
        authorize_net_api_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Api Key")] = None,
        authorize_net_transaction_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Transaction Key")] = None,
        email_sender: Annotated[Optional[StrictStr], Field(description="Email Sender")] = None,
        smtp_user: Annotated[Optional[StrictStr], Field(description="SMTP User")] = None,
        smtp_host: Annotated[Optional[StrictStr], Field(description="SMTP Host")] = None,
        vatom_business_id: Annotated[Optional[StrictStr], Field(description="Vatom Business Id")] = None,
        vatom_rest_client_id: Annotated[Optional[StrictStr], Field(description="Vatom REST Client Id")] = None,
        vatom_rest_secret_key: Annotated[Optional[StrictStr], Field(description="Vatom Secret Key")] = None,
        twilio_account_sid: Annotated[Optional[StrictStr], Field(description="Twilio Account SID")] = None,
        twilio_auth_token: Annotated[Optional[StrictStr], Field(description="Twilio Auth Token")] = None,
        twilio_sender_phone_number: Annotated[Optional[StrictStr], Field(description="Twilio Sender Phone Number")] = None,
        open_ai_secret_key: Annotated[Optional[StrictStr], Field(description="OpenAI Secret API Key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Application

        Create an application record and one placement record for that application. You can create more placements for this application by using {@link createApplicationPlacement}.

        :param app_name: The name of the application (required)
        :type app_name: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param about: The description of the application
        :type about: str
        :param bundle_id: The application bundle identifier (format - com.company.appName)
        :type bundle_id: str
        :param app_icon_asset_id: The application icon asset id
        :type app_icon_asset_id: int
        :param app_logo_asset_id: The application logo asset id
        :type app_logo_asset_id: int
        :param facebook_app_id: The Facebook application id
        :type facebook_app_id: str
        :param facebook_app_secret: The Facebook application secret
        :type facebook_app_secret: str
        :param google_api_key: This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        :type google_api_key: str
        :param update_eula_date: Determines whether to update the EULA date
        :type update_eula_date: bool
        :param eula_version: The EULA version
        :type eula_version: str
        :param landing_page_url: The landing page URL
        :type landing_page_url: str
        :param show_in_activities: Determines whether to show the application in the activity feed
        :type show_in_activities: bool
        :param activity_description: The description of the application in the activity feed
        :type activity_description: str
        :param invite_welcome_text: The text to display on the invite page
        :type invite_welcome_text: str
        :param invite_page_url: The url to the application invite page
        :type invite_page_url: str
        :param url_scheme: The protocal the app uses to load the app via a browser
        :type url_scheme: str
        :param platforms: A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        :type platforms: str
        :param download_urls: Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        :type download_urls: str
        :param category_ids: List of categories to apply
        :type category_ids: str
        :param scoring_type: The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        :type scoring_type: str
        :param hint_cost: The cost of hints
        :type hint_cost: int
        :param max_score: The maximum score that will be possible
        :type max_score: int
        :param tickets_per_point: The point-to-ticket conversion ratio
        :type tickets_per_point: float
        :param has_game_data: Determines whether the application uses services to save custom game objects
        :type has_game_data: bool
        :param public_notifications: Public Notifications
        :type public_notifications: bool
        :param use_matching_algorithm: Use Matching Algorithm
        :type use_matching_algorithm: bool
        :param global_tickets: Determines whether earned tickets are applied across all applications
        :type global_tickets: bool
        :param build_version: The current build version of the application
        :type build_version: float
        :param api_version: The current API version the application uses
        :type api_version: float
        :param placement_name: The name of the placement
        :type placement_name: str
        :param placement_description: The description of the placement
        :type placement_description: str
        :param placement_size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        :type placement_size: str
        :param placement_height: The height of a custom ad size
        :type placement_height: int
        :param placement_width: The width of a custom ad size
        :type placement_width: int
        :param placement_refresh_interval: The refresh interval in seconds
        :type placement_refresh_interval: int
        :param create_object_store: Generate a custom object store to use
        :type create_object_store: bool
        :param public_content_approval: Determine whether or not public content requires admin approval before it becomes public
        :type public_content_approval: bool
        :param production_mode: Determines whether the application uses production or sandbox services
        :type production_mode: bool
        :param minimum_session_length: Minimum Session Length
        :type minimum_session_length: int
        :param session_gap_length: Session Gap Length
        :type session_gap_length: int
        :param local_ads_enabled: Local Ads Enabled
        :type local_ads_enabled: bool
        :param sqoot_api_key: Sqoot Api Key
        :type sqoot_api_key: str
        :param trilat_processing_type: Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        :type trilat_processing_type: str
        :param max_sample_size: Determines what the maximum sample size during trilateration
        :type max_sample_size: int
        :param min_rssi: Determines what the minimum acceptable RSSI value
        :type min_rssi: float
        :param modules: List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        :type modules: str
        :param authorized_count: How many servers the license will support
        :type authorized_count: int
        :param authorized_servers: The list of ip addresses of servers the license will support, leave null for any server
        :type authorized_servers: str
        :param default_timezone: Sets the default timezone for the app (used for leaderboards and other time specific content)
        :type default_timezone: str
        :param smtp_pass: SMTP Pass
        :type smtp_pass: str
        :param meta_data: The application meta data. Defined by the client
        :type meta_data: str
        :param placement_meta_data: The ad placement meta data. Defined by the client
        :type placement_meta_data: str
        :param ips_floor: Create floor tables for Ips
        :type ips_floor: bool
        :param enable_apns_badge: Enables setting the APNS badge value in the payload
        :type enable_apns_badge: bool
        :param include_in_report: Enables using the application in session reports
        :type include_in_report: bool
        :param default_app_filter_id: Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        :type default_app_filter_id: int
        :param enable_welcome_email: Enables whether the default welcome email will be sent for new app users
        :type enable_welcome_email: bool
        :param apple_app_id: The Apple Application ID
        :type apple_app_id: str
        :param apple_team_id: The Apple Team ID
        :type apple_team_id: str
        :param apple_auth_key_id: The Apple Auth Key ID
        :type apple_auth_key_id: str
        :param apple_auth_key: The Apple Auth Signin Key (p8) File
        :type apple_auth_key: bytearray
        :param apple_issuer_id: The Apple Issuer ID
        :type apple_issuer_id: str
        :param app_store_key_id: The Apple App Store Key ID
        :type app_store_key_id: str
        :param app_store_key: The Apple App Store Key (p8) File
        :type app_store_key: bytearray
        :param google_private_key_file: This is the private key file for your Google service account.
        :type google_private_key_file: bytearray
        :param authorize_net_api_key: Authorize Net Api Key
        :type authorize_net_api_key: str
        :param authorize_net_transaction_key: Authorize Net Transaction Key
        :type authorize_net_transaction_key: str
        :param email_sender: Email Sender
        :type email_sender: str
        :param smtp_user: SMTP User
        :type smtp_user: str
        :param smtp_host: SMTP Host
        :type smtp_host: str
        :param vatom_business_id: Vatom Business Id
        :type vatom_business_id: str
        :param vatom_rest_client_id: Vatom REST Client Id
        :type vatom_rest_client_id: str
        :param vatom_rest_secret_key: Vatom Secret Key
        :type vatom_rest_secret_key: str
        :param twilio_account_sid: Twilio Account SID
        :type twilio_account_sid: str
        :param twilio_auth_token: Twilio Auth Token
        :type twilio_auth_token: str
        :param twilio_sender_phone_number: Twilio Sender Phone Number
        :type twilio_sender_phone_number: str
        :param open_ai_secret_key: OpenAI Secret API Key
        :type open_ai_secret_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_serialize(
            app_name=app_name,
            device_id=device_id,
            account_id=account_id,
            about=about,
            bundle_id=bundle_id,
            app_icon_asset_id=app_icon_asset_id,
            app_logo_asset_id=app_logo_asset_id,
            facebook_app_id=facebook_app_id,
            facebook_app_secret=facebook_app_secret,
            google_api_key=google_api_key,
            update_eula_date=update_eula_date,
            eula_version=eula_version,
            landing_page_url=landing_page_url,
            show_in_activities=show_in_activities,
            activity_description=activity_description,
            invite_welcome_text=invite_welcome_text,
            invite_page_url=invite_page_url,
            url_scheme=url_scheme,
            platforms=platforms,
            download_urls=download_urls,
            category_ids=category_ids,
            scoring_type=scoring_type,
            hint_cost=hint_cost,
            max_score=max_score,
            tickets_per_point=tickets_per_point,
            has_game_data=has_game_data,
            public_notifications=public_notifications,
            use_matching_algorithm=use_matching_algorithm,
            global_tickets=global_tickets,
            build_version=build_version,
            api_version=api_version,
            placement_name=placement_name,
            placement_description=placement_description,
            placement_size=placement_size,
            placement_height=placement_height,
            placement_width=placement_width,
            placement_refresh_interval=placement_refresh_interval,
            create_object_store=create_object_store,
            public_content_approval=public_content_approval,
            production_mode=production_mode,
            minimum_session_length=minimum_session_length,
            session_gap_length=session_gap_length,
            local_ads_enabled=local_ads_enabled,
            sqoot_api_key=sqoot_api_key,
            trilat_processing_type=trilat_processing_type,
            max_sample_size=max_sample_size,
            min_rssi=min_rssi,
            modules=modules,
            authorized_count=authorized_count,
            authorized_servers=authorized_servers,
            default_timezone=default_timezone,
            smtp_pass=smtp_pass,
            meta_data=meta_data,
            placement_meta_data=placement_meta_data,
            ips_floor=ips_floor,
            enable_apns_badge=enable_apns_badge,
            include_in_report=include_in_report,
            default_app_filter_id=default_app_filter_id,
            enable_welcome_email=enable_welcome_email,
            apple_app_id=apple_app_id,
            apple_team_id=apple_team_id,
            apple_auth_key_id=apple_auth_key_id,
            apple_auth_key=apple_auth_key,
            apple_issuer_id=apple_issuer_id,
            app_store_key_id=app_store_key_id,
            app_store_key=app_store_key,
            google_private_key_file=google_private_key_file,
            authorize_net_api_key=authorize_net_api_key,
            authorize_net_transaction_key=authorize_net_transaction_key,
            email_sender=email_sender,
            smtp_user=smtp_user,
            smtp_host=smtp_host,
            vatom_business_id=vatom_business_id,
            vatom_rest_client_id=vatom_rest_client_id,
            vatom_rest_secret_key=vatom_rest_secret_key,
            twilio_account_sid=twilio_account_sid,
            twilio_auth_token=twilio_auth_token,
            twilio_sender_phone_number=twilio_sender_phone_number,
            open_ai_secret_key=open_ai_secret_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_application_serialize(
        self,
        app_name,
        device_id,
        account_id,
        about,
        bundle_id,
        app_icon_asset_id,
        app_logo_asset_id,
        facebook_app_id,
        facebook_app_secret,
        google_api_key,
        update_eula_date,
        eula_version,
        landing_page_url,
        show_in_activities,
        activity_description,
        invite_welcome_text,
        invite_page_url,
        url_scheme,
        platforms,
        download_urls,
        category_ids,
        scoring_type,
        hint_cost,
        max_score,
        tickets_per_point,
        has_game_data,
        public_notifications,
        use_matching_algorithm,
        global_tickets,
        build_version,
        api_version,
        placement_name,
        placement_description,
        placement_size,
        placement_height,
        placement_width,
        placement_refresh_interval,
        create_object_store,
        public_content_approval,
        production_mode,
        minimum_session_length,
        session_gap_length,
        local_ads_enabled,
        sqoot_api_key,
        trilat_processing_type,
        max_sample_size,
        min_rssi,
        modules,
        authorized_count,
        authorized_servers,
        default_timezone,
        smtp_pass,
        meta_data,
        placement_meta_data,
        ips_floor,
        enable_apns_badge,
        include_in_report,
        default_app_filter_id,
        enable_welcome_email,
        apple_app_id,
        apple_team_id,
        apple_auth_key_id,
        apple_auth_key,
        apple_issuer_id,
        app_store_key_id,
        app_store_key,
        google_private_key_file,
        authorize_net_api_key,
        authorize_net_transaction_key,
        email_sender,
        smtp_user,
        smtp_host,
        vatom_business_id,
        vatom_rest_client_id,
        vatom_rest_secret_key,
        twilio_account_sid,
        twilio_auth_token,
        twilio_sender_phone_number,
        open_ai_secret_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_name is not None:
            
            _query_params.append(('appName', app_name))
            
        if about is not None:
            
            _query_params.append(('about', about))
            
        if bundle_id is not None:
            
            _query_params.append(('bundleId', bundle_id))
            
        if app_icon_asset_id is not None:
            
            _query_params.append(('appIconAssetId', app_icon_asset_id))
            
        if app_logo_asset_id is not None:
            
            _query_params.append(('appLogoAssetId', app_logo_asset_id))
            
        if facebook_app_id is not None:
            
            _query_params.append(('facebookAppId', facebook_app_id))
            
        if facebook_app_secret is not None:
            
            _query_params.append(('facebookAppSecret', facebook_app_secret))
            
        if google_api_key is not None:
            
            _query_params.append(('googleApiKey', google_api_key))
            
        if update_eula_date is not None:
            
            _query_params.append(('updateEULADate', update_eula_date))
            
        if eula_version is not None:
            
            _query_params.append(('eulaVersion', eula_version))
            
        if landing_page_url is not None:
            
            _query_params.append(('landingPageUrl', landing_page_url))
            
        if show_in_activities is not None:
            
            _query_params.append(('showInActivities', show_in_activities))
            
        if activity_description is not None:
            
            _query_params.append(('activityDescription', activity_description))
            
        if invite_welcome_text is not None:
            
            _query_params.append(('inviteWelcomeText', invite_welcome_text))
            
        if invite_page_url is not None:
            
            _query_params.append(('invitePageUrl', invite_page_url))
            
        if url_scheme is not None:
            
            _query_params.append(('urlScheme', url_scheme))
            
        if platforms is not None:
            
            _query_params.append(('platforms', platforms))
            
        if download_urls is not None:
            
            _query_params.append(('downloadUrls', download_urls))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if scoring_type is not None:
            
            _query_params.append(('scoringType', scoring_type))
            
        if hint_cost is not None:
            
            _query_params.append(('hintCost', hint_cost))
            
        if max_score is not None:
            
            _query_params.append(('maxScore', max_score))
            
        if tickets_per_point is not None:
            
            _query_params.append(('ticketsPerPoint', tickets_per_point))
            
        if has_game_data is not None:
            
            _query_params.append(('hasGameData', has_game_data))
            
        if public_notifications is not None:
            
            _query_params.append(('publicNotifications', public_notifications))
            
        if use_matching_algorithm is not None:
            
            _query_params.append(('useMatchingAlgorithm', use_matching_algorithm))
            
        if global_tickets is not None:
            
            _query_params.append(('globalTickets', global_tickets))
            
        if build_version is not None:
            
            _query_params.append(('buildVersion', build_version))
            
        if api_version is not None:
            
            _query_params.append(('apiVersion', api_version))
            
        if placement_name is not None:
            
            _query_params.append(('placementName', placement_name))
            
        if placement_description is not None:
            
            _query_params.append(('placementDescription', placement_description))
            
        if placement_size is not None:
            
            _query_params.append(('placementSize', placement_size))
            
        if placement_height is not None:
            
            _query_params.append(('placementHeight', placement_height))
            
        if placement_width is not None:
            
            _query_params.append(('placementWidth', placement_width))
            
        if placement_refresh_interval is not None:
            
            _query_params.append(('placementRefreshInterval', placement_refresh_interval))
            
        if create_object_store is not None:
            
            _query_params.append(('createObjectStore', create_object_store))
            
        if public_content_approval is not None:
            
            _query_params.append(('publicContentApproval', public_content_approval))
            
        if production_mode is not None:
            
            _query_params.append(('productionMode', production_mode))
            
        if minimum_session_length is not None:
            
            _query_params.append(('minimumSessionLength', minimum_session_length))
            
        if session_gap_length is not None:
            
            _query_params.append(('sessionGapLength', session_gap_length))
            
        if local_ads_enabled is not None:
            
            _query_params.append(('localAdsEnabled', local_ads_enabled))
            
        if sqoot_api_key is not None:
            
            _query_params.append(('sqootApiKey', sqoot_api_key))
            
        if trilat_processing_type is not None:
            
            _query_params.append(('trilatProcessingType', trilat_processing_type))
            
        if max_sample_size is not None:
            
            _query_params.append(('maxSampleSize', max_sample_size))
            
        if min_rssi is not None:
            
            _query_params.append(('minRSSI', min_rssi))
            
        if modules is not None:
            
            _query_params.append(('modules', modules))
            
        if authorized_count is not None:
            
            _query_params.append(('authorizedCount', authorized_count))
            
        if authorized_servers is not None:
            
            _query_params.append(('authorizedServers', authorized_servers))
            
        if default_timezone is not None:
            
            _query_params.append(('defaultTimezone', default_timezone))
            
        if smtp_pass is not None:
            
            _query_params.append(('smtpPass', smtp_pass))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if placement_meta_data is not None:
            
            _query_params.append(('placementMetaData', placement_meta_data))
            
        if ips_floor is not None:
            
            _query_params.append(('ipsFloor', ips_floor))
            
        if enable_apns_badge is not None:
            
            _query_params.append(('enableAPNSBadge', enable_apns_badge))
            
        if include_in_report is not None:
            
            _query_params.append(('includeInReport', include_in_report))
            
        if default_app_filter_id is not None:
            
            _query_params.append(('defaultAppFilterId', default_app_filter_id))
            
        if enable_welcome_email is not None:
            
            _query_params.append(('enableWelcomeEmail', enable_welcome_email))
            
        if apple_app_id is not None:
            
            _query_params.append(('appleAppId', apple_app_id))
            
        if apple_team_id is not None:
            
            _query_params.append(('appleTeamId', apple_team_id))
            
        if apple_auth_key_id is not None:
            
            _query_params.append(('appleAuthKeyId', apple_auth_key_id))
            
        if apple_auth_key is not None:
            
            _query_params.append(('appleAuthKey', apple_auth_key))
            
        if apple_issuer_id is not None:
            
            _query_params.append(('appleIssuerId', apple_issuer_id))
            
        if app_store_key_id is not None:
            
            _query_params.append(('appStoreKeyId', app_store_key_id))
            
        if app_store_key is not None:
            
            _query_params.append(('appStoreKey', app_store_key))
            
        if google_private_key_file is not None:
            
            _query_params.append(('googlePrivateKeyFile', google_private_key_file))
            
        if authorize_net_api_key is not None:
            
            _query_params.append(('authorizeNetApiKey', authorize_net_api_key))
            
        if authorize_net_transaction_key is not None:
            
            _query_params.append(('authorizeNetTransactionKey', authorize_net_transaction_key))
            
        if email_sender is not None:
            
            _query_params.append(('emailSender', email_sender))
            
        if smtp_user is not None:
            
            _query_params.append(('smtpUser', smtp_user))
            
        if smtp_host is not None:
            
            _query_params.append(('smtpHost', smtp_host))
            
        if vatom_business_id is not None:
            
            _query_params.append(('vatomBusinessId', vatom_business_id))
            
        if vatom_rest_client_id is not None:
            
            _query_params.append(('vatomRestClientId', vatom_rest_client_id))
            
        if vatom_rest_secret_key is not None:
            
            _query_params.append(('vatomRestSecretKey', vatom_rest_secret_key))
            
        if twilio_account_sid is not None:
            
            _query_params.append(('twilioAccountSID', twilio_account_sid))
            
        if twilio_auth_token is not None:
            
            _query_params.append(('twilioAuthToken', twilio_auth_token))
            
        if twilio_sender_phone_number is not None:
            
            _query_params.append(('twilioSenderPhoneNumber', twilio_sender_phone_number))
            
        if open_ai_secret_key is not None:
            
            _query_params.append(('openAISecretKey', open_ai_secret_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_application_placement(
        self,
        app_key: Annotated[StrictStr, Field(description="The appKey of the application the ad placement is for")],
        size: Annotated[StrictStr, Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        default_image_id: Annotated[Optional[StrictInt], Field(description="Default Image Id")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlacementResponse:
        """Create Ad Placement

        Creates a new ad placement for an application.

        :param app_key: The appKey of the application the ad placement is for (required)
        :type app_key: str
        :param size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (required)
        :type size: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the placement
        :type name: str
        :param description: The description of the placement
        :type description: str
        :param height: The height of a custom ad size
        :type height: int
        :param width: The width of a custom ad size
        :type width: int
        :param refresh_interval: The refresh interval in seconds
        :type refresh_interval: int
        :param default_image_id: Default Image Id
        :type default_image_id: int
        :param active: Active
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_placement_serialize(
            app_key=app_key,
            size=size,
            device_id=device_id,
            account_id=account_id,
            name=name,
            description=description,
            height=height,
            width=width,
            refresh_interval=refresh_interval,
            default_image_id=default_image_id,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_application_placement_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The appKey of the application the ad placement is for")],
        size: Annotated[StrictStr, Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        default_image_id: Annotated[Optional[StrictInt], Field(description="Default Image Id")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlacementResponse]:
        """Create Ad Placement

        Creates a new ad placement for an application.

        :param app_key: The appKey of the application the ad placement is for (required)
        :type app_key: str
        :param size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (required)
        :type size: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the placement
        :type name: str
        :param description: The description of the placement
        :type description: str
        :param height: The height of a custom ad size
        :type height: int
        :param width: The width of a custom ad size
        :type width: int
        :param refresh_interval: The refresh interval in seconds
        :type refresh_interval: int
        :param default_image_id: Default Image Id
        :type default_image_id: int
        :param active: Active
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_placement_serialize(
            app_key=app_key,
            size=size,
            device_id=device_id,
            account_id=account_id,
            name=name,
            description=description,
            height=height,
            width=width,
            refresh_interval=refresh_interval,
            default_image_id=default_image_id,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_application_placement_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The appKey of the application the ad placement is for")],
        size: Annotated[StrictStr, Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        default_image_id: Annotated[Optional[StrictInt], Field(description="Default Image Id")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Ad Placement

        Creates a new ad placement for an application.

        :param app_key: The appKey of the application the ad placement is for (required)
        :type app_key: str
        :param size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (required)
        :type size: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the placement
        :type name: str
        :param description: The description of the placement
        :type description: str
        :param height: The height of a custom ad size
        :type height: int
        :param width: The width of a custom ad size
        :type width: int
        :param refresh_interval: The refresh interval in seconds
        :type refresh_interval: int
        :param default_image_id: Default Image Id
        :type default_image_id: int
        :param active: Active
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_placement_serialize(
            app_key=app_key,
            size=size,
            device_id=device_id,
            account_id=account_id,
            name=name,
            description=description,
            height=height,
            width=width,
            refresh_interval=refresh_interval,
            default_image_id=default_image_id,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_application_placement_serialize(
        self,
        app_key,
        size,
        device_id,
        account_id,
        name,
        description,
        height,
        width,
        refresh_interval,
        default_image_id,
        active,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if refresh_interval is not None:
            
            _query_params.append(('refreshInterval', refresh_interval))
            
        if default_image_id is not None:
            
            _query_params.append(('defaultImageId', default_image_id))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/placement/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_application(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the application.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The key of the application to be deleted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Application

        Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp

        :param account_id: The account used to perform the delete, must have rights to edit the application.
        :type account_id: int
        :param app_key: The key of the application to be deleted
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_serialize(
            account_id=account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_application_with_http_info(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the application.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The key of the application to be deleted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Application

        Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp

        :param account_id: The account used to perform the delete, must have rights to edit the application.
        :type account_id: int
        :param app_key: The key of the application to be deleted
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_serialize(
            account_id=account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_application_without_preload_content(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the application.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The key of the application to be deleted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Application

        Set the deleted timestamp to current time. This effectively deletes the application since all queries should ignore any records with a deleted timestamp

        :param account_id: The account used to perform the delete, must have rights to edit the application.
        :type account_id: int
        :param app_key: The key of the application to be deleted
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_serialize(
            account_id=account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_application_serialize(
        self,
        account_id,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_application_placement(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement to delete, the user must have rights to the application the ad placement is for")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlacementResponse:
        """Delete Ad Placement

        Deletes an ad placement for an application.

        :param placement_id: The id of the placement to delete, the user must have rights to the application the ad placement is for (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_application_placement_with_http_info(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement to delete, the user must have rights to the application the ad placement is for")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlacementResponse]:
        """Delete Ad Placement

        Deletes an ad placement for an application.

        :param placement_id: The id of the placement to delete, the user must have rights to the application the ad placement is for (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_application_placement_without_preload_content(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement to delete, the user must have rights to the application the ad placement is for")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Ad Placement

        Deletes an ad placement for an application.

        :param placement_id: The id of the placement to delete, the user must have rights to the application the ad placement is for (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_application_placement_serialize(
        self,
        placement_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if placement_id is not None:
            
            _query_params.append(('placementId', placement_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/placement/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_application(
        self,
        app_key: Annotated[Optional[StrictStr], Field(description="The key of the application")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="Application Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationResponse:
        """Get Application

        Get a specific application by appKey

        :param app_key: The key of the application
        :type app_key: str
        :param application_id: Application Id
        :type application_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_serialize(
            app_key=app_key,
            application_id=application_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_application_with_http_info(
        self,
        app_key: Annotated[Optional[StrictStr], Field(description="The key of the application")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="Application Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationResponse]:
        """Get Application

        Get a specific application by appKey

        :param app_key: The key of the application
        :type app_key: str
        :param application_id: Application Id
        :type application_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_serialize(
            app_key=app_key,
            application_id=application_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_application_without_preload_content(
        self,
        app_key: Annotated[Optional[StrictStr], Field(description="The key of the application")] = None,
        application_id: Annotated[Optional[StrictInt], Field(description="Application Id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Application

        Get a specific application by appKey

        :param app_key: The key of the application
        :type app_key: str
        :param application_id: Application Id
        :type application_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_serialize(
            app_key=app_key,
            application_id=application_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_application_serialize(
        self,
        app_key,
        application_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if application_id is not None:
            
            _query_params.append(('applicationId', application_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_application_placement(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlacementResponse:
        """Get Ad Placement

        Get details of an ad placement

        :param placement_id: The id of the placement (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_application_placement_with_http_info(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlacementResponse]:
        """Get Ad Placement

        Get details of an ad placement

        :param placement_id: The id of the placement (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_application_placement_without_preload_content(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ad Placement

        Get details of an ad placement

        :param placement_id: The id of the placement (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_application_placement_serialize(
        self,
        placement_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if placement_id is not None:
            
            _query_params.append(('placementId', placement_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/placement/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_application_versions(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Get API versions

        Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_versions_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_application_versions_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Get API versions

        Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_versions_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_application_versions_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get API versions

        Will return a comma separated list of numbers, newest first. For example: 3.0, 2.2, 2.1, 1.8

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_versions_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_application_versions_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/versions',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_unique_users_by_app(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key")],
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        since: Annotated[Optional[StrictInt], Field(description="Return accounts that have been active after this date (UNIX time-stamp in milliseconds)")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="the limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountListResponse:
        """Search Application Users

        Get a list of users per application

        :param app_key: The application key (required)
        :type app_key: str
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param since: Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
        :type since: int
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: the limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_unique_users_by_app_serialize(
            app_key=app_key,
            q=q,
            keyword=keyword,
            since=since,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_unique_users_by_app_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key")],
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        since: Annotated[Optional[StrictInt], Field(description="Return accounts that have been active after this date (UNIX time-stamp in milliseconds)")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="the limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountListResponse]:
        """Search Application Users

        Get a list of users per application

        :param app_key: The application key (required)
        :type app_key: str
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param since: Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
        :type since: int
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: the limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_unique_users_by_app_serialize(
            app_key=app_key,
            q=q,
            keyword=keyword,
            since=since,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_unique_users_by_app_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key")],
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        since: Annotated[Optional[StrictInt], Field(description="Return accounts that have been active after this date (UNIX time-stamp in milliseconds)")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="the limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Application Users

        Get a list of users per application

        :param app_key: The application key (required)
        :type app_key: str
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param since: Return accounts that have been active after this date (UNIX time-stamp in milliseconds)
        :type since: int
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: the limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_unique_users_by_app_serialize(
            app_key=app_key,
            q=q,
            keyword=keyword,
            since=since,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_unique_users_by_app_serialize(
        self,
        app_key,
        q,
        keyword,
        since,
        i,
        start,
        l,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if since is not None:
            
            _query_params.append(('since', since))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/users',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_applications(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the application owner/manager")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search for title, about, and description fields")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Deprecated, use deviceIds and deviceVersions")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids to filter the list by")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE")] = None,
        has_ads: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application supports ads or not. Ignore this parameter to return all results.")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application is available for public trigger notifications")] = None,
        filter_billable: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user has access to")] = None,
        filter_content_admin: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user is a content admin of")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="The limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated. If provided will ignore all other params.")] = None,
        has_object_store: Annotated[Optional[StrictBool], Field(description="Only include applications with a object store (default is false)")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicationShortResponse]:
        """List Applications

        List active applications matching the criteria (as a consumer)

        :param account_id: The account id of the application owner/manager
        :type account_id: int
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search for title, about, and description fields
        :type keyword: str
        :param platforms: Deprecated, use deviceIds and deviceVersions
        :type platforms: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
        :type device_versions: str
        :param category_ids: The list of category ids to filter the list by
        :type category_ids: str
        :param sort_field: The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
        :type sort_field: str
        :param has_ads: Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        :type has_ads: bool
        :param public_notifications: Filter results on whether the application is available for public trigger notifications
        :type public_notifications: bool
        :param filter_billable: Determines whether to only return applications that the user has access to
        :type filter_billable: bool
        :param filter_content_admin: Determines whether to only return applications that the user is a content admin of
        :type filter_content_admin: bool
        :param descending: The order to return the search results
        :type descending: bool
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: The limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param application_ids: The list of application ids, comma separated. If provided will ignore all other params.
        :type application_ids: str
        :param has_object_store: Only include applications with a object store (default is false)
        :type has_object_store: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_applications_serialize(
            account_id=account_id,
            q=q,
            keyword=keyword,
            platforms=platforms,
            device_ids=device_ids,
            device_versions=device_versions,
            category_ids=category_ids,
            sort_field=sort_field,
            has_ads=has_ads,
            public_notifications=public_notifications,
            filter_billable=filter_billable,
            filter_content_admin=filter_content_admin,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            application_ids=application_ids,
            has_object_store=has_object_store,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_applications_with_http_info(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the application owner/manager")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search for title, about, and description fields")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Deprecated, use deviceIds and deviceVersions")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids to filter the list by")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE")] = None,
        has_ads: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application supports ads or not. Ignore this parameter to return all results.")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application is available for public trigger notifications")] = None,
        filter_billable: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user has access to")] = None,
        filter_content_admin: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user is a content admin of")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="The limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated. If provided will ignore all other params.")] = None,
        has_object_store: Annotated[Optional[StrictBool], Field(description="Only include applications with a object store (default is false)")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApplicationShortResponse]]:
        """List Applications

        List active applications matching the criteria (as a consumer)

        :param account_id: The account id of the application owner/manager
        :type account_id: int
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search for title, about, and description fields
        :type keyword: str
        :param platforms: Deprecated, use deviceIds and deviceVersions
        :type platforms: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
        :type device_versions: str
        :param category_ids: The list of category ids to filter the list by
        :type category_ids: str
        :param sort_field: The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
        :type sort_field: str
        :param has_ads: Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        :type has_ads: bool
        :param public_notifications: Filter results on whether the application is available for public trigger notifications
        :type public_notifications: bool
        :param filter_billable: Determines whether to only return applications that the user has access to
        :type filter_billable: bool
        :param filter_content_admin: Determines whether to only return applications that the user is a content admin of
        :type filter_content_admin: bool
        :param descending: The order to return the search results
        :type descending: bool
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: The limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param application_ids: The list of application ids, comma separated. If provided will ignore all other params.
        :type application_ids: str
        :param has_object_store: Only include applications with a object store (default is false)
        :type has_object_store: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_applications_serialize(
            account_id=account_id,
            q=q,
            keyword=keyword,
            platforms=platforms,
            device_ids=device_ids,
            device_versions=device_versions,
            category_ids=category_ids,
            sort_field=sort_field,
            has_ads=has_ads,
            public_notifications=public_notifications,
            filter_billable=filter_billable,
            filter_content_admin=filter_content_admin,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            application_ids=application_ids,
            has_object_store=has_object_store,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_applications_without_preload_content(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the application owner/manager")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search for title, about, and description fields")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="Deprecated, use deviceIds and deviceVersions")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids to filter the list by")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE")] = None,
        has_ads: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application supports ads or not. Ignore this parameter to return all results.")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application is available for public trigger notifications")] = None,
        filter_billable: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user has access to")] = None,
        filter_content_admin: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user is a content admin of")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="The limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated. If provided will ignore all other params.")] = None,
        has_object_store: Annotated[Optional[StrictBool], Field(description="Only include applications with a object store (default is false)")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Applications

        List active applications matching the criteria (as a consumer)

        :param account_id: The account id of the application owner/manager
        :type account_id: int
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search for title, about, and description fields
        :type keyword: str
        :param platforms: Deprecated, use deviceIds and deviceVersions
        :type platforms: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retreived via /api/{version/audience/devices com.sirqul.geoapps.common.service.AudienceApi#getDevices getDevices (pass in deviceId values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned  with the provided devices list (see devices param for possible values),  comma separated; examples are: 2.3-X, 0-5.1.4, 4.3.1-6.1.4 where X  is no maximum and 0 is no minimum. 
        :type device_versions: str
        :param category_ids: The list of category ids to filter the list by
        :type category_ids: str
        :param sort_field: The column to sort the search on, possible values include: UPDATED (default), CREATED, TITLE
        :type sort_field: str
        :param has_ads: Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        :type has_ads: bool
        :param public_notifications: Filter results on whether the application is available for public trigger notifications
        :type public_notifications: bool
        :param filter_billable: Determines whether to only return applications that the user has access to
        :type filter_billable: bool
        :param filter_content_admin: Determines whether to only return applications that the user is a content admin of
        :type filter_content_admin: bool
        :param descending: The order to return the search results
        :type descending: bool
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: The limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param application_ids: The list of application ids, comma separated. If provided will ignore all other params.
        :type application_ids: str
        :param has_object_store: Only include applications with a object store (default is false)
        :type has_object_store: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_applications_serialize(
            account_id=account_id,
            q=q,
            keyword=keyword,
            platforms=platforms,
            device_ids=device_ids,
            device_versions=device_versions,
            category_ids=category_ids,
            sort_field=sort_field,
            has_ads=has_ads,
            public_notifications=public_notifications,
            filter_billable=filter_billable,
            filter_content_admin=filter_content_admin,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            application_ids=application_ids,
            has_object_store=has_object_store,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_applications_serialize(
        self,
        account_id,
        q,
        keyword,
        platforms,
        device_ids,
        device_versions,
        category_ids,
        sort_field,
        has_ads,
        public_notifications,
        filter_billable,
        filter_content_admin,
        descending,
        i,
        start,
        l,
        limit,
        application_ids,
        has_object_store,
        active_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if platforms is not None:
            
            _query_params.append(('platforms', platforms))
            
        if device_ids is not None:
            
            _query_params.append(('deviceIds', device_ids))
            
        if device_versions is not None:
            
            _query_params.append(('deviceVersions', device_versions))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if has_ads is not None:
            
            _query_params.append(('hasAds', has_ads))
            
        if public_notifications is not None:
            
            _query_params.append(('publicNotifications', public_notifications))
            
        if filter_billable is not None:
            
            _query_params.append(('filterBillable', filter_billable))
            
        if filter_content_admin is not None:
            
            _query_params.append(('filterContentAdmin', filter_content_admin))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if application_ids is not None:
            
            _query_params.append(('applicationIds', application_ids))
            
        if has_object_store is not None:
            
            _query_params.append(('hasObjectStore', has_object_store))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_application_placement(
        self,
        app_key: Annotated[StrictStr, Field(description="The key of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PlacementResponse]:
        """Search for Ad Placements

        Searches placements for an application.

        :param app_key: The key of the application (required)
        :type app_key: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param start: The start of the pagination
        :type start: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_placement_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PlacementResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_application_placement_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The key of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PlacementResponse]]:
        """Search for Ad Placements

        Searches placements for an application.

        :param app_key: The key of the application (required)
        :type app_key: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param start: The start of the pagination
        :type start: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_placement_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PlacementResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_application_placement_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The key of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Ad Placements

        Searches placements for an application.

        :param app_key: The key of the application (required)
        :type app_key: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param start: The start of the pagination
        :type start: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_placement_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PlacementResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_application_placement_serialize(
        self,
        app_key,
        device_id,
        account_id,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/placement/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_application_settings(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to view another person's account")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The string to search applications on")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit per result set for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationSettingsResponse:
        """Search for Application Settings

        Returns a list of applications that the user has logged into before, and returns specific settings for that application and user

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: The account id used to view another person's account
        :type connection_account_id: int
        :param keyword: The string to search applications on
        :type keyword: str
        :param sort_field: The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit per result set for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_settings_serialize(
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_application_settings_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to view another person's account")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The string to search applications on")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit per result set for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationSettingsResponse]:
        """Search for Application Settings

        Returns a list of applications that the user has logged into before, and returns specific settings for that application and user

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: The account id used to view another person's account
        :type connection_account_id: int
        :param keyword: The string to search applications on
        :type keyword: str
        :param sort_field: The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit per result set for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_settings_serialize(
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_application_settings_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="The account id used to view another person's account")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The string to search applications on")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit per result set for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Application Settings

        Returns a list of applications that the user has logged into before, and returns specific settings for that application and user

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: The account id used to view another person's account
        :type connection_account_id: int
        :param keyword: The string to search applications on
        :type keyword: str
        :param sort_field: The column to sort the search on. Possible values include: CREATED, UPDATED, APPLICATION_TITLE
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit per result set for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_settings_serialize(
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationSettingsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_application_settings_serialize(
        self,
        device_id,
        account_id,
        connection_account_id,
        keyword,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/settings/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_applications(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The location of the device")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The location of the device")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        q_search_fields: Annotated[Optional[StrictStr], Field(description="The columns to applied the keyword search to")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="the limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        has_ads: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application supports ads or not. Ignore this parameter to return all results.")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application is available for public trigger notifications")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicationResponse]:
        """Search Applications

        Search for applications matching the criteria that the logged in user has access to

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The location of the device
        :type latitude: float
        :param longitude: The location of the device
        :type longitude: float
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param q_search_fields: The columns to applied the keyword search to
        :type q_search_fields: str
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: the limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param has_ads: Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        :type has_ads: bool
        :param public_notifications: Filter results on whether the application is available for public trigger notifications
        :type public_notifications: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_applications_serialize(
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            q=q,
            keyword=keyword,
            q_search_fields=q_search_fields,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            has_ads=has_ads,
            public_notifications=public_notifications,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_applications_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The location of the device")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The location of the device")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        q_search_fields: Annotated[Optional[StrictStr], Field(description="The columns to applied the keyword search to")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="the limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        has_ads: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application supports ads or not. Ignore this parameter to return all results.")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application is available for public trigger notifications")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApplicationResponse]]:
        """Search Applications

        Search for applications matching the criteria that the logged in user has access to

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The location of the device
        :type latitude: float
        :param longitude: The location of the device
        :type longitude: float
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param q_search_fields: The columns to applied the keyword search to
        :type q_search_fields: str
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: the limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param has_ads: Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        :type has_ads: bool
        :param public_notifications: Filter results on whether the application is available for public trigger notifications
        :type public_notifications: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_applications_serialize(
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            q=q,
            keyword=keyword,
            q_search_fields=q_search_fields,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            has_ads=has_ads,
            public_notifications=public_notifications,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_applications_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The location of the device")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The location of the device")] = None,
        q: Annotated[Optional[StrictStr], Field(description="Q")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        q_search_fields: Annotated[Optional[StrictStr], Field(description="The columns to applied the keyword search to")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        i: Annotated[Optional[StrictInt], Field(description="the start of the index")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="the limit of the index")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        has_ads: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application supports ads or not. Ignore this parameter to return all results.")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Filter results on whether the application is available for public trigger notifications")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Return only active results")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Applications

        Search for applications matching the criteria that the logged in user has access to

        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: The location of the device
        :type latitude: float
        :param longitude: The location of the device
        :type longitude: float
        :param q: Q
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param q_search_fields: The columns to applied the keyword search to
        :type q_search_fields: str
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param i: the start of the index
        :type i: int
        :param start: The start of the pagination
        :type start: int
        :param l: the limit of the index
        :type l: int
        :param limit: The limit of the pagination
        :type limit: int
        :param has_ads: Filter results on whether the application supports ads or not. Ignore this parameter to return all results.
        :type has_ads: bool
        :param public_notifications: Filter results on whether the application is available for public trigger notifications
        :type public_notifications: bool
        :param active_only: Return only active results
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_applications_serialize(
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            q=q,
            keyword=keyword,
            q_search_fields=q_search_fields,
            sort_field=sort_field,
            descending=descending,
            i=i,
            start=start,
            l=l,
            limit=limit,
            has_ads=has_ads,
            public_notifications=public_notifications,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_applications_serialize(
        self,
        device_id,
        account_id,
        latitude,
        longitude,
        q,
        keyword,
        q_search_fields,
        sort_field,
        descending,
        i,
        start,
        l,
        limit,
        has_ads,
        public_notifications,
        active_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if q_search_fields is not None:
            
            _query_params.append(('qSearchFields', q_search_fields))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if has_ads is not None:
            
            _query_params.append(('hasAds', has_ads))
            
        if public_notifications is not None:
            
            _query_params.append(('publicNotifications', public_notifications))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/application/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_application(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key for updating an existing application")],
        app_name: Annotated[StrictStr, Field(description="The name of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        about: Annotated[Optional[StrictStr], Field(description="The description of the application")] = None,
        bundle_id: Annotated[Optional[StrictStr], Field(description="The application bundle identifier (format - com.company.appName)")] = None,
        app_icon_asset_id: Annotated[Optional[StrictInt], Field(description="The application icon asset id")] = None,
        app_logo_asset_id: Annotated[Optional[StrictInt], Field(description="The application logo asset id")] = None,
        facebook_app_id: Annotated[Optional[StrictStr], Field(description="The Facebook application id")] = None,
        facebook_app_secret: Annotated[Optional[StrictStr], Field(description="The Facebook application secret")] = None,
        google_api_key: Annotated[Optional[StrictStr], Field(description="This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging")] = None,
        update_eula_date: Annotated[Optional[StrictBool], Field(description="Determines whether to update the EULA date")] = None,
        eula_version: Annotated[Optional[StrictStr], Field(description="The EULA version")] = None,
        landing_page_url: Annotated[Optional[StrictStr], Field(description="The landing page URL")] = None,
        show_in_activities: Annotated[Optional[StrictBool], Field(description="Determines whether to show the application in the activity feed")] = None,
        activity_description: Annotated[Optional[StrictStr], Field(description="The description of the application in the activity feed")] = None,
        invite_welcome_text: Annotated[Optional[StrictStr], Field(description="The text to display on the invite page")] = None,
        invite_page_url: Annotated[Optional[StrictStr], Field(description="The url to the application invite page")] = None,
        url_scheme: Annotated[Optional[StrictStr], Field(description="The protocal the app uses to load the app via a browser")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ")] = None,
        download_urls: Annotated[Optional[StrictStr], Field(description="Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="List of categories to apply")] = None,
        scoring_type: Annotated[Optional[StrictStr], Field(description="The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT")] = None,
        hint_cost: Annotated[Optional[StrictInt], Field(description="The cost of hints")] = None,
        max_score: Annotated[Optional[StrictInt], Field(description="The maximum score that will be possible")] = None,
        tickets_per_point: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The point-to-ticket conversion ratio")] = None,
        has_game_data: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses services to save custom game objects")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Public Notifications")] = None,
        use_matching_algorithm: Annotated[Optional[StrictBool], Field(description="Use Matching Algorithm")] = None,
        global_tickets: Annotated[Optional[StrictBool], Field(description="Determines whether earned tickets are applied across all applications")] = None,
        build_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current build version of the application")] = None,
        api_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current API version the application uses")] = None,
        placement_name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        placement_description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        placement_size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)")] = None,
        placement_height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        placement_width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        placement_refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        create_object_store: Annotated[Optional[StrictBool], Field(description="Generate a custom object store to use")] = None,
        public_content_approval: Annotated[Optional[StrictBool], Field(description="Determine whether or not public content requires admin approval before it becomes public")] = None,
        production_mode: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses production or sandbox services")] = None,
        minimum_session_length: Annotated[Optional[StrictInt], Field(description="Minimum Session Length")] = None,
        session_gap_length: Annotated[Optional[StrictInt], Field(description="Session Gap Length")] = None,
        local_ads_enabled: Annotated[Optional[StrictBool], Field(description="Local Ads Enabled")] = None,
        sqoot_api_key: Annotated[Optional[StrictStr], Field(description="Sqoot Api Key")] = None,
        trilat_processing_type: Annotated[Optional[StrictStr], Field(description="Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT")] = None,
        max_sample_size: Annotated[Optional[StrictInt], Field(description="Determines what the maximum sample size during trilateration")] = None,
        min_rssi: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Determines what the minimum acceptable RSSI value")] = None,
        modules: Annotated[Optional[StrictStr], Field(description="List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL")] = None,
        authorized_count: Annotated[Optional[StrictInt], Field(description="How many servers the license will support")] = None,
        authorized_servers: Annotated[Optional[StrictStr], Field(description="The list of ip addresses of servers the license will support, leave null for any server")] = None,
        default_timezone: Annotated[Optional[StrictStr], Field(description="Sets the default timezone for the app (used for leaderboards and other time specific content)")] = None,
        smtp_pass: Annotated[Optional[StrictStr], Field(description="SMTP Pass")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="The application meta data. Defined by the client")] = None,
        placement_meta_data: Annotated[Optional[StrictStr], Field(description="The ad placement meta data. Defined by the client")] = None,
        ips_floor: Annotated[Optional[StrictBool], Field(description="Create floor tables for Ips")] = None,
        enable_apns_badge: Annotated[Optional[StrictBool], Field(description="Enables setting the APNS badge value in the payload")] = None,
        include_in_report: Annotated[Optional[StrictBool], Field(description="Enables using the application in session reports")] = None,
        default_app_filter_id: Annotated[Optional[StrictInt], Field(description="Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.")] = None,
        enable_welcome_email: Annotated[Optional[StrictBool], Field(description="Enables whether the default welcome email will be sent for new app users")] = None,
        apple_app_id: Annotated[Optional[StrictStr], Field(description="The Apple Application ID")] = None,
        apple_team_id: Annotated[Optional[StrictStr], Field(description="The Apple Team ID")] = None,
        apple_auth_key_id: Annotated[Optional[StrictStr], Field(description="The Apple Auth Key ID")] = None,
        apple_auth_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple Auth Signin Key (p8) File")] = None,
        apple_issuer_id: Annotated[Optional[StrictStr], Field(description="The Apple Issuer ID")] = None,
        app_store_key_id: Annotated[Optional[StrictStr], Field(description="The Apple App Store Key ID")] = None,
        app_store_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple App Store Key (p8) File")] = None,
        google_private_key_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="This is the private key file for your Google service account.")] = None,
        authorize_net_api_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Api Key")] = None,
        authorize_net_transaction_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Transaction Key")] = None,
        email_sender: Annotated[Optional[StrictStr], Field(description="Email Sender")] = None,
        smtp_user: Annotated[Optional[StrictStr], Field(description="SMTP User")] = None,
        smtp_host: Annotated[Optional[StrictStr], Field(description="SMTP Host")] = None,
        vatom_business_id: Annotated[Optional[StrictStr], Field(description="Vatom Business Id")] = None,
        vatom_rest_client_id: Annotated[Optional[StrictStr], Field(description="Vatom REST Client Id")] = None,
        vatom_rest_secret_key: Annotated[Optional[StrictStr], Field(description="Vatom Secret Key")] = None,
        twilio_account_sid: Annotated[Optional[StrictStr], Field(description="Twilio Account SID")] = None,
        twilio_auth_token: Annotated[Optional[StrictStr], Field(description="Twilio Auth Token")] = None,
        twilio_sender_phone_number: Annotated[Optional[StrictStr], Field(description="Twilio Sender Phone Number")] = None,
        open_ai_secret_key: Annotated[Optional[StrictStr], Field(description="OpenAI Secret API Key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationResponse:
        """Update Application

        Update an application record

        :param app_key: The application key for updating an existing application (required)
        :type app_key: str
        :param app_name: The name of the application (required)
        :type app_name: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param about: The description of the application
        :type about: str
        :param bundle_id: The application bundle identifier (format - com.company.appName)
        :type bundle_id: str
        :param app_icon_asset_id: The application icon asset id
        :type app_icon_asset_id: int
        :param app_logo_asset_id: The application logo asset id
        :type app_logo_asset_id: int
        :param facebook_app_id: The Facebook application id
        :type facebook_app_id: str
        :param facebook_app_secret: The Facebook application secret
        :type facebook_app_secret: str
        :param google_api_key: This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        :type google_api_key: str
        :param update_eula_date: Determines whether to update the EULA date
        :type update_eula_date: bool
        :param eula_version: The EULA version
        :type eula_version: str
        :param landing_page_url: The landing page URL
        :type landing_page_url: str
        :param show_in_activities: Determines whether to show the application in the activity feed
        :type show_in_activities: bool
        :param activity_description: The description of the application in the activity feed
        :type activity_description: str
        :param invite_welcome_text: The text to display on the invite page
        :type invite_welcome_text: str
        :param invite_page_url: The url to the application invite page
        :type invite_page_url: str
        :param url_scheme: The protocal the app uses to load the app via a browser
        :type url_scheme: str
        :param platforms: A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        :type platforms: str
        :param download_urls: Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        :type download_urls: str
        :param category_ids: List of categories to apply
        :type category_ids: str
        :param scoring_type: The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        :type scoring_type: str
        :param hint_cost: The cost of hints
        :type hint_cost: int
        :param max_score: The maximum score that will be possible
        :type max_score: int
        :param tickets_per_point: The point-to-ticket conversion ratio
        :type tickets_per_point: float
        :param has_game_data: Determines whether the application uses services to save custom game objects
        :type has_game_data: bool
        :param public_notifications: Public Notifications
        :type public_notifications: bool
        :param use_matching_algorithm: Use Matching Algorithm
        :type use_matching_algorithm: bool
        :param global_tickets: Determines whether earned tickets are applied across all applications
        :type global_tickets: bool
        :param build_version: The current build version of the application
        :type build_version: float
        :param api_version: The current API version the application uses
        :type api_version: float
        :param placement_name: The name of the placement
        :type placement_name: str
        :param placement_description: The description of the placement
        :type placement_description: str
        :param placement_size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        :type placement_size: str
        :param placement_height: The height of a custom ad size
        :type placement_height: int
        :param placement_width: The width of a custom ad size
        :type placement_width: int
        :param placement_refresh_interval: The refresh interval in seconds
        :type placement_refresh_interval: int
        :param create_object_store: Generate a custom object store to use
        :type create_object_store: bool
        :param public_content_approval: Determine whether or not public content requires admin approval before it becomes public
        :type public_content_approval: bool
        :param production_mode: Determines whether the application uses production or sandbox services
        :type production_mode: bool
        :param minimum_session_length: Minimum Session Length
        :type minimum_session_length: int
        :param session_gap_length: Session Gap Length
        :type session_gap_length: int
        :param local_ads_enabled: Local Ads Enabled
        :type local_ads_enabled: bool
        :param sqoot_api_key: Sqoot Api Key
        :type sqoot_api_key: str
        :param trilat_processing_type: Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        :type trilat_processing_type: str
        :param max_sample_size: Determines what the maximum sample size during trilateration
        :type max_sample_size: int
        :param min_rssi: Determines what the minimum acceptable RSSI value
        :type min_rssi: float
        :param modules: List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        :type modules: str
        :param authorized_count: How many servers the license will support
        :type authorized_count: int
        :param authorized_servers: The list of ip addresses of servers the license will support, leave null for any server
        :type authorized_servers: str
        :param default_timezone: Sets the default timezone for the app (used for leaderboards and other time specific content)
        :type default_timezone: str
        :param smtp_pass: SMTP Pass
        :type smtp_pass: str
        :param meta_data: The application meta data. Defined by the client
        :type meta_data: str
        :param placement_meta_data: The ad placement meta data. Defined by the client
        :type placement_meta_data: str
        :param ips_floor: Create floor tables for Ips
        :type ips_floor: bool
        :param enable_apns_badge: Enables setting the APNS badge value in the payload
        :type enable_apns_badge: bool
        :param include_in_report: Enables using the application in session reports
        :type include_in_report: bool
        :param default_app_filter_id: Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        :type default_app_filter_id: int
        :param enable_welcome_email: Enables whether the default welcome email will be sent for new app users
        :type enable_welcome_email: bool
        :param apple_app_id: The Apple Application ID
        :type apple_app_id: str
        :param apple_team_id: The Apple Team ID
        :type apple_team_id: str
        :param apple_auth_key_id: The Apple Auth Key ID
        :type apple_auth_key_id: str
        :param apple_auth_key: The Apple Auth Signin Key (p8) File
        :type apple_auth_key: bytearray
        :param apple_issuer_id: The Apple Issuer ID
        :type apple_issuer_id: str
        :param app_store_key_id: The Apple App Store Key ID
        :type app_store_key_id: str
        :param app_store_key: The Apple App Store Key (p8) File
        :type app_store_key: bytearray
        :param google_private_key_file: This is the private key file for your Google service account.
        :type google_private_key_file: bytearray
        :param authorize_net_api_key: Authorize Net Api Key
        :type authorize_net_api_key: str
        :param authorize_net_transaction_key: Authorize Net Transaction Key
        :type authorize_net_transaction_key: str
        :param email_sender: Email Sender
        :type email_sender: str
        :param smtp_user: SMTP User
        :type smtp_user: str
        :param smtp_host: SMTP Host
        :type smtp_host: str
        :param vatom_business_id: Vatom Business Id
        :type vatom_business_id: str
        :param vatom_rest_client_id: Vatom REST Client Id
        :type vatom_rest_client_id: str
        :param vatom_rest_secret_key: Vatom Secret Key
        :type vatom_rest_secret_key: str
        :param twilio_account_sid: Twilio Account SID
        :type twilio_account_sid: str
        :param twilio_auth_token: Twilio Auth Token
        :type twilio_auth_token: str
        :param twilio_sender_phone_number: Twilio Sender Phone Number
        :type twilio_sender_phone_number: str
        :param open_ai_secret_key: OpenAI Secret API Key
        :type open_ai_secret_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_serialize(
            app_key=app_key,
            app_name=app_name,
            device_id=device_id,
            account_id=account_id,
            about=about,
            bundle_id=bundle_id,
            app_icon_asset_id=app_icon_asset_id,
            app_logo_asset_id=app_logo_asset_id,
            facebook_app_id=facebook_app_id,
            facebook_app_secret=facebook_app_secret,
            google_api_key=google_api_key,
            update_eula_date=update_eula_date,
            eula_version=eula_version,
            landing_page_url=landing_page_url,
            show_in_activities=show_in_activities,
            activity_description=activity_description,
            invite_welcome_text=invite_welcome_text,
            invite_page_url=invite_page_url,
            url_scheme=url_scheme,
            platforms=platforms,
            download_urls=download_urls,
            category_ids=category_ids,
            scoring_type=scoring_type,
            hint_cost=hint_cost,
            max_score=max_score,
            tickets_per_point=tickets_per_point,
            has_game_data=has_game_data,
            public_notifications=public_notifications,
            use_matching_algorithm=use_matching_algorithm,
            global_tickets=global_tickets,
            build_version=build_version,
            api_version=api_version,
            placement_name=placement_name,
            placement_description=placement_description,
            placement_size=placement_size,
            placement_height=placement_height,
            placement_width=placement_width,
            placement_refresh_interval=placement_refresh_interval,
            create_object_store=create_object_store,
            public_content_approval=public_content_approval,
            production_mode=production_mode,
            minimum_session_length=minimum_session_length,
            session_gap_length=session_gap_length,
            local_ads_enabled=local_ads_enabled,
            sqoot_api_key=sqoot_api_key,
            trilat_processing_type=trilat_processing_type,
            max_sample_size=max_sample_size,
            min_rssi=min_rssi,
            modules=modules,
            authorized_count=authorized_count,
            authorized_servers=authorized_servers,
            default_timezone=default_timezone,
            smtp_pass=smtp_pass,
            meta_data=meta_data,
            placement_meta_data=placement_meta_data,
            ips_floor=ips_floor,
            enable_apns_badge=enable_apns_badge,
            include_in_report=include_in_report,
            default_app_filter_id=default_app_filter_id,
            enable_welcome_email=enable_welcome_email,
            apple_app_id=apple_app_id,
            apple_team_id=apple_team_id,
            apple_auth_key_id=apple_auth_key_id,
            apple_auth_key=apple_auth_key,
            apple_issuer_id=apple_issuer_id,
            app_store_key_id=app_store_key_id,
            app_store_key=app_store_key,
            google_private_key_file=google_private_key_file,
            authorize_net_api_key=authorize_net_api_key,
            authorize_net_transaction_key=authorize_net_transaction_key,
            email_sender=email_sender,
            smtp_user=smtp_user,
            smtp_host=smtp_host,
            vatom_business_id=vatom_business_id,
            vatom_rest_client_id=vatom_rest_client_id,
            vatom_rest_secret_key=vatom_rest_secret_key,
            twilio_account_sid=twilio_account_sid,
            twilio_auth_token=twilio_auth_token,
            twilio_sender_phone_number=twilio_sender_phone_number,
            open_ai_secret_key=open_ai_secret_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_application_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key for updating an existing application")],
        app_name: Annotated[StrictStr, Field(description="The name of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        about: Annotated[Optional[StrictStr], Field(description="The description of the application")] = None,
        bundle_id: Annotated[Optional[StrictStr], Field(description="The application bundle identifier (format - com.company.appName)")] = None,
        app_icon_asset_id: Annotated[Optional[StrictInt], Field(description="The application icon asset id")] = None,
        app_logo_asset_id: Annotated[Optional[StrictInt], Field(description="The application logo asset id")] = None,
        facebook_app_id: Annotated[Optional[StrictStr], Field(description="The Facebook application id")] = None,
        facebook_app_secret: Annotated[Optional[StrictStr], Field(description="The Facebook application secret")] = None,
        google_api_key: Annotated[Optional[StrictStr], Field(description="This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging")] = None,
        update_eula_date: Annotated[Optional[StrictBool], Field(description="Determines whether to update the EULA date")] = None,
        eula_version: Annotated[Optional[StrictStr], Field(description="The EULA version")] = None,
        landing_page_url: Annotated[Optional[StrictStr], Field(description="The landing page URL")] = None,
        show_in_activities: Annotated[Optional[StrictBool], Field(description="Determines whether to show the application in the activity feed")] = None,
        activity_description: Annotated[Optional[StrictStr], Field(description="The description of the application in the activity feed")] = None,
        invite_welcome_text: Annotated[Optional[StrictStr], Field(description="The text to display on the invite page")] = None,
        invite_page_url: Annotated[Optional[StrictStr], Field(description="The url to the application invite page")] = None,
        url_scheme: Annotated[Optional[StrictStr], Field(description="The protocal the app uses to load the app via a browser")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ")] = None,
        download_urls: Annotated[Optional[StrictStr], Field(description="Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="List of categories to apply")] = None,
        scoring_type: Annotated[Optional[StrictStr], Field(description="The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT")] = None,
        hint_cost: Annotated[Optional[StrictInt], Field(description="The cost of hints")] = None,
        max_score: Annotated[Optional[StrictInt], Field(description="The maximum score that will be possible")] = None,
        tickets_per_point: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The point-to-ticket conversion ratio")] = None,
        has_game_data: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses services to save custom game objects")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Public Notifications")] = None,
        use_matching_algorithm: Annotated[Optional[StrictBool], Field(description="Use Matching Algorithm")] = None,
        global_tickets: Annotated[Optional[StrictBool], Field(description="Determines whether earned tickets are applied across all applications")] = None,
        build_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current build version of the application")] = None,
        api_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current API version the application uses")] = None,
        placement_name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        placement_description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        placement_size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)")] = None,
        placement_height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        placement_width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        placement_refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        create_object_store: Annotated[Optional[StrictBool], Field(description="Generate a custom object store to use")] = None,
        public_content_approval: Annotated[Optional[StrictBool], Field(description="Determine whether or not public content requires admin approval before it becomes public")] = None,
        production_mode: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses production or sandbox services")] = None,
        minimum_session_length: Annotated[Optional[StrictInt], Field(description="Minimum Session Length")] = None,
        session_gap_length: Annotated[Optional[StrictInt], Field(description="Session Gap Length")] = None,
        local_ads_enabled: Annotated[Optional[StrictBool], Field(description="Local Ads Enabled")] = None,
        sqoot_api_key: Annotated[Optional[StrictStr], Field(description="Sqoot Api Key")] = None,
        trilat_processing_type: Annotated[Optional[StrictStr], Field(description="Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT")] = None,
        max_sample_size: Annotated[Optional[StrictInt], Field(description="Determines what the maximum sample size during trilateration")] = None,
        min_rssi: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Determines what the minimum acceptable RSSI value")] = None,
        modules: Annotated[Optional[StrictStr], Field(description="List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL")] = None,
        authorized_count: Annotated[Optional[StrictInt], Field(description="How many servers the license will support")] = None,
        authorized_servers: Annotated[Optional[StrictStr], Field(description="The list of ip addresses of servers the license will support, leave null for any server")] = None,
        default_timezone: Annotated[Optional[StrictStr], Field(description="Sets the default timezone for the app (used for leaderboards and other time specific content)")] = None,
        smtp_pass: Annotated[Optional[StrictStr], Field(description="SMTP Pass")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="The application meta data. Defined by the client")] = None,
        placement_meta_data: Annotated[Optional[StrictStr], Field(description="The ad placement meta data. Defined by the client")] = None,
        ips_floor: Annotated[Optional[StrictBool], Field(description="Create floor tables for Ips")] = None,
        enable_apns_badge: Annotated[Optional[StrictBool], Field(description="Enables setting the APNS badge value in the payload")] = None,
        include_in_report: Annotated[Optional[StrictBool], Field(description="Enables using the application in session reports")] = None,
        default_app_filter_id: Annotated[Optional[StrictInt], Field(description="Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.")] = None,
        enable_welcome_email: Annotated[Optional[StrictBool], Field(description="Enables whether the default welcome email will be sent for new app users")] = None,
        apple_app_id: Annotated[Optional[StrictStr], Field(description="The Apple Application ID")] = None,
        apple_team_id: Annotated[Optional[StrictStr], Field(description="The Apple Team ID")] = None,
        apple_auth_key_id: Annotated[Optional[StrictStr], Field(description="The Apple Auth Key ID")] = None,
        apple_auth_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple Auth Signin Key (p8) File")] = None,
        apple_issuer_id: Annotated[Optional[StrictStr], Field(description="The Apple Issuer ID")] = None,
        app_store_key_id: Annotated[Optional[StrictStr], Field(description="The Apple App Store Key ID")] = None,
        app_store_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple App Store Key (p8) File")] = None,
        google_private_key_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="This is the private key file for your Google service account.")] = None,
        authorize_net_api_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Api Key")] = None,
        authorize_net_transaction_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Transaction Key")] = None,
        email_sender: Annotated[Optional[StrictStr], Field(description="Email Sender")] = None,
        smtp_user: Annotated[Optional[StrictStr], Field(description="SMTP User")] = None,
        smtp_host: Annotated[Optional[StrictStr], Field(description="SMTP Host")] = None,
        vatom_business_id: Annotated[Optional[StrictStr], Field(description="Vatom Business Id")] = None,
        vatom_rest_client_id: Annotated[Optional[StrictStr], Field(description="Vatom REST Client Id")] = None,
        vatom_rest_secret_key: Annotated[Optional[StrictStr], Field(description="Vatom Secret Key")] = None,
        twilio_account_sid: Annotated[Optional[StrictStr], Field(description="Twilio Account SID")] = None,
        twilio_auth_token: Annotated[Optional[StrictStr], Field(description="Twilio Auth Token")] = None,
        twilio_sender_phone_number: Annotated[Optional[StrictStr], Field(description="Twilio Sender Phone Number")] = None,
        open_ai_secret_key: Annotated[Optional[StrictStr], Field(description="OpenAI Secret API Key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationResponse]:
        """Update Application

        Update an application record

        :param app_key: The application key for updating an existing application (required)
        :type app_key: str
        :param app_name: The name of the application (required)
        :type app_name: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param about: The description of the application
        :type about: str
        :param bundle_id: The application bundle identifier (format - com.company.appName)
        :type bundle_id: str
        :param app_icon_asset_id: The application icon asset id
        :type app_icon_asset_id: int
        :param app_logo_asset_id: The application logo asset id
        :type app_logo_asset_id: int
        :param facebook_app_id: The Facebook application id
        :type facebook_app_id: str
        :param facebook_app_secret: The Facebook application secret
        :type facebook_app_secret: str
        :param google_api_key: This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        :type google_api_key: str
        :param update_eula_date: Determines whether to update the EULA date
        :type update_eula_date: bool
        :param eula_version: The EULA version
        :type eula_version: str
        :param landing_page_url: The landing page URL
        :type landing_page_url: str
        :param show_in_activities: Determines whether to show the application in the activity feed
        :type show_in_activities: bool
        :param activity_description: The description of the application in the activity feed
        :type activity_description: str
        :param invite_welcome_text: The text to display on the invite page
        :type invite_welcome_text: str
        :param invite_page_url: The url to the application invite page
        :type invite_page_url: str
        :param url_scheme: The protocal the app uses to load the app via a browser
        :type url_scheme: str
        :param platforms: A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        :type platforms: str
        :param download_urls: Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        :type download_urls: str
        :param category_ids: List of categories to apply
        :type category_ids: str
        :param scoring_type: The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        :type scoring_type: str
        :param hint_cost: The cost of hints
        :type hint_cost: int
        :param max_score: The maximum score that will be possible
        :type max_score: int
        :param tickets_per_point: The point-to-ticket conversion ratio
        :type tickets_per_point: float
        :param has_game_data: Determines whether the application uses services to save custom game objects
        :type has_game_data: bool
        :param public_notifications: Public Notifications
        :type public_notifications: bool
        :param use_matching_algorithm: Use Matching Algorithm
        :type use_matching_algorithm: bool
        :param global_tickets: Determines whether earned tickets are applied across all applications
        :type global_tickets: bool
        :param build_version: The current build version of the application
        :type build_version: float
        :param api_version: The current API version the application uses
        :type api_version: float
        :param placement_name: The name of the placement
        :type placement_name: str
        :param placement_description: The description of the placement
        :type placement_description: str
        :param placement_size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        :type placement_size: str
        :param placement_height: The height of a custom ad size
        :type placement_height: int
        :param placement_width: The width of a custom ad size
        :type placement_width: int
        :param placement_refresh_interval: The refresh interval in seconds
        :type placement_refresh_interval: int
        :param create_object_store: Generate a custom object store to use
        :type create_object_store: bool
        :param public_content_approval: Determine whether or not public content requires admin approval before it becomes public
        :type public_content_approval: bool
        :param production_mode: Determines whether the application uses production or sandbox services
        :type production_mode: bool
        :param minimum_session_length: Minimum Session Length
        :type minimum_session_length: int
        :param session_gap_length: Session Gap Length
        :type session_gap_length: int
        :param local_ads_enabled: Local Ads Enabled
        :type local_ads_enabled: bool
        :param sqoot_api_key: Sqoot Api Key
        :type sqoot_api_key: str
        :param trilat_processing_type: Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        :type trilat_processing_type: str
        :param max_sample_size: Determines what the maximum sample size during trilateration
        :type max_sample_size: int
        :param min_rssi: Determines what the minimum acceptable RSSI value
        :type min_rssi: float
        :param modules: List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        :type modules: str
        :param authorized_count: How many servers the license will support
        :type authorized_count: int
        :param authorized_servers: The list of ip addresses of servers the license will support, leave null for any server
        :type authorized_servers: str
        :param default_timezone: Sets the default timezone for the app (used for leaderboards and other time specific content)
        :type default_timezone: str
        :param smtp_pass: SMTP Pass
        :type smtp_pass: str
        :param meta_data: The application meta data. Defined by the client
        :type meta_data: str
        :param placement_meta_data: The ad placement meta data. Defined by the client
        :type placement_meta_data: str
        :param ips_floor: Create floor tables for Ips
        :type ips_floor: bool
        :param enable_apns_badge: Enables setting the APNS badge value in the payload
        :type enable_apns_badge: bool
        :param include_in_report: Enables using the application in session reports
        :type include_in_report: bool
        :param default_app_filter_id: Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        :type default_app_filter_id: int
        :param enable_welcome_email: Enables whether the default welcome email will be sent for new app users
        :type enable_welcome_email: bool
        :param apple_app_id: The Apple Application ID
        :type apple_app_id: str
        :param apple_team_id: The Apple Team ID
        :type apple_team_id: str
        :param apple_auth_key_id: The Apple Auth Key ID
        :type apple_auth_key_id: str
        :param apple_auth_key: The Apple Auth Signin Key (p8) File
        :type apple_auth_key: bytearray
        :param apple_issuer_id: The Apple Issuer ID
        :type apple_issuer_id: str
        :param app_store_key_id: The Apple App Store Key ID
        :type app_store_key_id: str
        :param app_store_key: The Apple App Store Key (p8) File
        :type app_store_key: bytearray
        :param google_private_key_file: This is the private key file for your Google service account.
        :type google_private_key_file: bytearray
        :param authorize_net_api_key: Authorize Net Api Key
        :type authorize_net_api_key: str
        :param authorize_net_transaction_key: Authorize Net Transaction Key
        :type authorize_net_transaction_key: str
        :param email_sender: Email Sender
        :type email_sender: str
        :param smtp_user: SMTP User
        :type smtp_user: str
        :param smtp_host: SMTP Host
        :type smtp_host: str
        :param vatom_business_id: Vatom Business Id
        :type vatom_business_id: str
        :param vatom_rest_client_id: Vatom REST Client Id
        :type vatom_rest_client_id: str
        :param vatom_rest_secret_key: Vatom Secret Key
        :type vatom_rest_secret_key: str
        :param twilio_account_sid: Twilio Account SID
        :type twilio_account_sid: str
        :param twilio_auth_token: Twilio Auth Token
        :type twilio_auth_token: str
        :param twilio_sender_phone_number: Twilio Sender Phone Number
        :type twilio_sender_phone_number: str
        :param open_ai_secret_key: OpenAI Secret API Key
        :type open_ai_secret_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_serialize(
            app_key=app_key,
            app_name=app_name,
            device_id=device_id,
            account_id=account_id,
            about=about,
            bundle_id=bundle_id,
            app_icon_asset_id=app_icon_asset_id,
            app_logo_asset_id=app_logo_asset_id,
            facebook_app_id=facebook_app_id,
            facebook_app_secret=facebook_app_secret,
            google_api_key=google_api_key,
            update_eula_date=update_eula_date,
            eula_version=eula_version,
            landing_page_url=landing_page_url,
            show_in_activities=show_in_activities,
            activity_description=activity_description,
            invite_welcome_text=invite_welcome_text,
            invite_page_url=invite_page_url,
            url_scheme=url_scheme,
            platforms=platforms,
            download_urls=download_urls,
            category_ids=category_ids,
            scoring_type=scoring_type,
            hint_cost=hint_cost,
            max_score=max_score,
            tickets_per_point=tickets_per_point,
            has_game_data=has_game_data,
            public_notifications=public_notifications,
            use_matching_algorithm=use_matching_algorithm,
            global_tickets=global_tickets,
            build_version=build_version,
            api_version=api_version,
            placement_name=placement_name,
            placement_description=placement_description,
            placement_size=placement_size,
            placement_height=placement_height,
            placement_width=placement_width,
            placement_refresh_interval=placement_refresh_interval,
            create_object_store=create_object_store,
            public_content_approval=public_content_approval,
            production_mode=production_mode,
            minimum_session_length=minimum_session_length,
            session_gap_length=session_gap_length,
            local_ads_enabled=local_ads_enabled,
            sqoot_api_key=sqoot_api_key,
            trilat_processing_type=trilat_processing_type,
            max_sample_size=max_sample_size,
            min_rssi=min_rssi,
            modules=modules,
            authorized_count=authorized_count,
            authorized_servers=authorized_servers,
            default_timezone=default_timezone,
            smtp_pass=smtp_pass,
            meta_data=meta_data,
            placement_meta_data=placement_meta_data,
            ips_floor=ips_floor,
            enable_apns_badge=enable_apns_badge,
            include_in_report=include_in_report,
            default_app_filter_id=default_app_filter_id,
            enable_welcome_email=enable_welcome_email,
            apple_app_id=apple_app_id,
            apple_team_id=apple_team_id,
            apple_auth_key_id=apple_auth_key_id,
            apple_auth_key=apple_auth_key,
            apple_issuer_id=apple_issuer_id,
            app_store_key_id=app_store_key_id,
            app_store_key=app_store_key,
            google_private_key_file=google_private_key_file,
            authorize_net_api_key=authorize_net_api_key,
            authorize_net_transaction_key=authorize_net_transaction_key,
            email_sender=email_sender,
            smtp_user=smtp_user,
            smtp_host=smtp_host,
            vatom_business_id=vatom_business_id,
            vatom_rest_client_id=vatom_rest_client_id,
            vatom_rest_secret_key=vatom_rest_secret_key,
            twilio_account_sid=twilio_account_sid,
            twilio_auth_token=twilio_auth_token,
            twilio_sender_phone_number=twilio_sender_phone_number,
            open_ai_secret_key=open_ai_secret_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_application_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key for updating an existing application")],
        app_name: Annotated[StrictStr, Field(description="The name of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        about: Annotated[Optional[StrictStr], Field(description="The description of the application")] = None,
        bundle_id: Annotated[Optional[StrictStr], Field(description="The application bundle identifier (format - com.company.appName)")] = None,
        app_icon_asset_id: Annotated[Optional[StrictInt], Field(description="The application icon asset id")] = None,
        app_logo_asset_id: Annotated[Optional[StrictInt], Field(description="The application logo asset id")] = None,
        facebook_app_id: Annotated[Optional[StrictStr], Field(description="The Facebook application id")] = None,
        facebook_app_secret: Annotated[Optional[StrictStr], Field(description="The Facebook application secret")] = None,
        google_api_key: Annotated[Optional[StrictStr], Field(description="This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging")] = None,
        update_eula_date: Annotated[Optional[StrictBool], Field(description="Determines whether to update the EULA date")] = None,
        eula_version: Annotated[Optional[StrictStr], Field(description="The EULA version")] = None,
        landing_page_url: Annotated[Optional[StrictStr], Field(description="The landing page URL")] = None,
        show_in_activities: Annotated[Optional[StrictBool], Field(description="Determines whether to show the application in the activity feed")] = None,
        activity_description: Annotated[Optional[StrictStr], Field(description="The description of the application in the activity feed")] = None,
        invite_welcome_text: Annotated[Optional[StrictStr], Field(description="The text to display on the invite page")] = None,
        invite_page_url: Annotated[Optional[StrictStr], Field(description="The url to the application invite page")] = None,
        url_scheme: Annotated[Optional[StrictStr], Field(description="The protocal the app uses to load the app via a browser")] = None,
        platforms: Annotated[Optional[StrictStr], Field(description="A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` ")] = None,
        download_urls: Annotated[Optional[StrictStr], Field(description="Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  ")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="List of categories to apply")] = None,
        scoring_type: Annotated[Optional[StrictStr], Field(description="The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT")] = None,
        hint_cost: Annotated[Optional[StrictInt], Field(description="The cost of hints")] = None,
        max_score: Annotated[Optional[StrictInt], Field(description="The maximum score that will be possible")] = None,
        tickets_per_point: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The point-to-ticket conversion ratio")] = None,
        has_game_data: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses services to save custom game objects")] = None,
        public_notifications: Annotated[Optional[StrictBool], Field(description="Public Notifications")] = None,
        use_matching_algorithm: Annotated[Optional[StrictBool], Field(description="Use Matching Algorithm")] = None,
        global_tickets: Annotated[Optional[StrictBool], Field(description="Determines whether earned tickets are applied across all applications")] = None,
        build_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current build version of the application")] = None,
        api_version: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current API version the application uses")] = None,
        placement_name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        placement_description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        placement_size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)")] = None,
        placement_height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        placement_width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        placement_refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        create_object_store: Annotated[Optional[StrictBool], Field(description="Generate a custom object store to use")] = None,
        public_content_approval: Annotated[Optional[StrictBool], Field(description="Determine whether or not public content requires admin approval before it becomes public")] = None,
        production_mode: Annotated[Optional[StrictBool], Field(description="Determines whether the application uses production or sandbox services")] = None,
        minimum_session_length: Annotated[Optional[StrictInt], Field(description="Minimum Session Length")] = None,
        session_gap_length: Annotated[Optional[StrictInt], Field(description="Session Gap Length")] = None,
        local_ads_enabled: Annotated[Optional[StrictBool], Field(description="Local Ads Enabled")] = None,
        sqoot_api_key: Annotated[Optional[StrictStr], Field(description="Sqoot Api Key")] = None,
        trilat_processing_type: Annotated[Optional[StrictStr], Field(description="Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT")] = None,
        max_sample_size: Annotated[Optional[StrictInt], Field(description="Determines what the maximum sample size during trilateration")] = None,
        min_rssi: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Determines what the minimum acceptable RSSI value")] = None,
        modules: Annotated[Optional[StrictStr], Field(description="List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL")] = None,
        authorized_count: Annotated[Optional[StrictInt], Field(description="How many servers the license will support")] = None,
        authorized_servers: Annotated[Optional[StrictStr], Field(description="The list of ip addresses of servers the license will support, leave null for any server")] = None,
        default_timezone: Annotated[Optional[StrictStr], Field(description="Sets the default timezone for the app (used for leaderboards and other time specific content)")] = None,
        smtp_pass: Annotated[Optional[StrictStr], Field(description="SMTP Pass")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="The application meta data. Defined by the client")] = None,
        placement_meta_data: Annotated[Optional[StrictStr], Field(description="The ad placement meta data. Defined by the client")] = None,
        ips_floor: Annotated[Optional[StrictBool], Field(description="Create floor tables for Ips")] = None,
        enable_apns_badge: Annotated[Optional[StrictBool], Field(description="Enables setting the APNS badge value in the payload")] = None,
        include_in_report: Annotated[Optional[StrictBool], Field(description="Enables using the application in session reports")] = None,
        default_app_filter_id: Annotated[Optional[StrictInt], Field(description="Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.")] = None,
        enable_welcome_email: Annotated[Optional[StrictBool], Field(description="Enables whether the default welcome email will be sent for new app users")] = None,
        apple_app_id: Annotated[Optional[StrictStr], Field(description="The Apple Application ID")] = None,
        apple_team_id: Annotated[Optional[StrictStr], Field(description="The Apple Team ID")] = None,
        apple_auth_key_id: Annotated[Optional[StrictStr], Field(description="The Apple Auth Key ID")] = None,
        apple_auth_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple Auth Signin Key (p8) File")] = None,
        apple_issuer_id: Annotated[Optional[StrictStr], Field(description="The Apple Issuer ID")] = None,
        app_store_key_id: Annotated[Optional[StrictStr], Field(description="The Apple App Store Key ID")] = None,
        app_store_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The Apple App Store Key (p8) File")] = None,
        google_private_key_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="This is the private key file for your Google service account.")] = None,
        authorize_net_api_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Api Key")] = None,
        authorize_net_transaction_key: Annotated[Optional[StrictStr], Field(description="Authorize Net Transaction Key")] = None,
        email_sender: Annotated[Optional[StrictStr], Field(description="Email Sender")] = None,
        smtp_user: Annotated[Optional[StrictStr], Field(description="SMTP User")] = None,
        smtp_host: Annotated[Optional[StrictStr], Field(description="SMTP Host")] = None,
        vatom_business_id: Annotated[Optional[StrictStr], Field(description="Vatom Business Id")] = None,
        vatom_rest_client_id: Annotated[Optional[StrictStr], Field(description="Vatom REST Client Id")] = None,
        vatom_rest_secret_key: Annotated[Optional[StrictStr], Field(description="Vatom Secret Key")] = None,
        twilio_account_sid: Annotated[Optional[StrictStr], Field(description="Twilio Account SID")] = None,
        twilio_auth_token: Annotated[Optional[StrictStr], Field(description="Twilio Auth Token")] = None,
        twilio_sender_phone_number: Annotated[Optional[StrictStr], Field(description="Twilio Sender Phone Number")] = None,
        open_ai_secret_key: Annotated[Optional[StrictStr], Field(description="OpenAI Secret API Key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Application

        Update an application record

        :param app_key: The application key for updating an existing application (required)
        :type app_key: str
        :param app_name: The name of the application (required)
        :type app_name: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param about: The description of the application
        :type about: str
        :param bundle_id: The application bundle identifier (format - com.company.appName)
        :type bundle_id: str
        :param app_icon_asset_id: The application icon asset id
        :type app_icon_asset_id: int
        :param app_logo_asset_id: The application logo asset id
        :type app_logo_asset_id: int
        :param facebook_app_id: The Facebook application id
        :type facebook_app_id: str
        :param facebook_app_secret: The Facebook application secret
        :type facebook_app_secret: str
        :param google_api_key: This is the either the 'server key' or 'browser key' generated from google to enable Google Cloud Messaging
        :type google_api_key: str
        :param update_eula_date: Determines whether to update the EULA date
        :type update_eula_date: bool
        :param eula_version: The EULA version
        :type eula_version: str
        :param landing_page_url: The landing page URL
        :type landing_page_url: str
        :param show_in_activities: Determines whether to show the application in the activity feed
        :type show_in_activities: bool
        :param activity_description: The description of the application in the activity feed
        :type activity_description: str
        :param invite_welcome_text: The text to display on the invite page
        :type invite_welcome_text: str
        :param invite_page_url: The url to the application invite page
        :type invite_page_url: str
        :param url_scheme: The protocal the app uses to load the app via a browser
        :type url_scheme: str
        :param platforms: A json object with a list of supported platforms.  ```json {   \"platforms\": [     {       \"deviceId\": 1,       \"minimum\": 230,       \"maximum\": 421,       \"downloadUrl\": \"http://app.store.com/download\",       \"description\": \"description and version info\"     }   ] } ``` 
        :type platforms: str
        :param download_urls: Json formatted downloadUrls.  ```json {   \"ios\": \"the-url-to-app-store\",    \"android\": \"the-url-to-google-play\" } ```  
        :type download_urls: str
        :param category_ids: List of categories to apply
        :type category_ids: str
        :param scoring_type: The type of scoring this application will use {GAME_LEVEL, GAME_OBJECT
        :type scoring_type: str
        :param hint_cost: The cost of hints
        :type hint_cost: int
        :param max_score: The maximum score that will be possible
        :type max_score: int
        :param tickets_per_point: The point-to-ticket conversion ratio
        :type tickets_per_point: float
        :param has_game_data: Determines whether the application uses services to save custom game objects
        :type has_game_data: bool
        :param public_notifications: Public Notifications
        :type public_notifications: bool
        :param use_matching_algorithm: Use Matching Algorithm
        :type use_matching_algorithm: bool
        :param global_tickets: Determines whether earned tickets are applied across all applications
        :type global_tickets: bool
        :param build_version: The current build version of the application
        :type build_version: float
        :param api_version: The current API version the application uses
        :type api_version: float
        :param placement_name: The name of the placement
        :type placement_name: str
        :param placement_description: The description of the placement
        :type placement_description: str
        :param placement_size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM (this is required if a placements is to be created)
        :type placement_size: str
        :param placement_height: The height of a custom ad size
        :type placement_height: int
        :param placement_width: The width of a custom ad size
        :type placement_width: int
        :param placement_refresh_interval: The refresh interval in seconds
        :type placement_refresh_interval: int
        :param create_object_store: Generate a custom object store to use
        :type create_object_store: bool
        :param public_content_approval: Determine whether or not public content requires admin approval before it becomes public
        :type public_content_approval: bool
        :param production_mode: Determines whether the application uses production or sandbox services
        :type production_mode: bool
        :param minimum_session_length: Minimum Session Length
        :type minimum_session_length: int
        :param session_gap_length: Session Gap Length
        :type session_gap_length: int
        :param local_ads_enabled: Local Ads Enabled
        :type local_ads_enabled: bool
        :param sqoot_api_key: Sqoot Api Key
        :type sqoot_api_key: str
        :param trilat_processing_type: Determines how to process trilateration data. Possible values include: DEFAULT, FINGERPRINT
        :type trilat_processing_type: str
        :param max_sample_size: Determines what the maximum sample size during trilateration
        :type max_sample_size: int
        :param min_rssi: Determines what the minimum acceptable RSSI value
        :type min_rssi: float
        :param modules: List modules allowed to be served by the server, possible values include: COMMON, MEDIA, OFFER, GAME, SOCIAL, CONSUMER_WEBSITE, ALL
        :type modules: str
        :param authorized_count: How many servers the license will support
        :type authorized_count: int
        :param authorized_servers: The list of ip addresses of servers the license will support, leave null for any server
        :type authorized_servers: str
        :param default_timezone: Sets the default timezone for the app (used for leaderboards and other time specific content)
        :type default_timezone: str
        :param smtp_pass: SMTP Pass
        :type smtp_pass: str
        :param meta_data: The application meta data. Defined by the client
        :type meta_data: str
        :param placement_meta_data: The ad placement meta data. Defined by the client
        :type placement_meta_data: str
        :param ips_floor: Create floor tables for Ips
        :type ips_floor: bool
        :param enable_apns_badge: Enables setting the APNS badge value in the payload
        :type enable_apns_badge: bool
        :param include_in_report: Enables using the application in session reports
        :type include_in_report: bool
        :param default_app_filter_id: Sets the default filter to use (if none is passed in) for certain search APIs including Album Search.
        :type default_app_filter_id: int
        :param enable_welcome_email: Enables whether the default welcome email will be sent for new app users
        :type enable_welcome_email: bool
        :param apple_app_id: The Apple Application ID
        :type apple_app_id: str
        :param apple_team_id: The Apple Team ID
        :type apple_team_id: str
        :param apple_auth_key_id: The Apple Auth Key ID
        :type apple_auth_key_id: str
        :param apple_auth_key: The Apple Auth Signin Key (p8) File
        :type apple_auth_key: bytearray
        :param apple_issuer_id: The Apple Issuer ID
        :type apple_issuer_id: str
        :param app_store_key_id: The Apple App Store Key ID
        :type app_store_key_id: str
        :param app_store_key: The Apple App Store Key (p8) File
        :type app_store_key: bytearray
        :param google_private_key_file: This is the private key file for your Google service account.
        :type google_private_key_file: bytearray
        :param authorize_net_api_key: Authorize Net Api Key
        :type authorize_net_api_key: str
        :param authorize_net_transaction_key: Authorize Net Transaction Key
        :type authorize_net_transaction_key: str
        :param email_sender: Email Sender
        :type email_sender: str
        :param smtp_user: SMTP User
        :type smtp_user: str
        :param smtp_host: SMTP Host
        :type smtp_host: str
        :param vatom_business_id: Vatom Business Id
        :type vatom_business_id: str
        :param vatom_rest_client_id: Vatom REST Client Id
        :type vatom_rest_client_id: str
        :param vatom_rest_secret_key: Vatom Secret Key
        :type vatom_rest_secret_key: str
        :param twilio_account_sid: Twilio Account SID
        :type twilio_account_sid: str
        :param twilio_auth_token: Twilio Auth Token
        :type twilio_auth_token: str
        :param twilio_sender_phone_number: Twilio Sender Phone Number
        :type twilio_sender_phone_number: str
        :param open_ai_secret_key: OpenAI Secret API Key
        :type open_ai_secret_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_serialize(
            app_key=app_key,
            app_name=app_name,
            device_id=device_id,
            account_id=account_id,
            about=about,
            bundle_id=bundle_id,
            app_icon_asset_id=app_icon_asset_id,
            app_logo_asset_id=app_logo_asset_id,
            facebook_app_id=facebook_app_id,
            facebook_app_secret=facebook_app_secret,
            google_api_key=google_api_key,
            update_eula_date=update_eula_date,
            eula_version=eula_version,
            landing_page_url=landing_page_url,
            show_in_activities=show_in_activities,
            activity_description=activity_description,
            invite_welcome_text=invite_welcome_text,
            invite_page_url=invite_page_url,
            url_scheme=url_scheme,
            platforms=platforms,
            download_urls=download_urls,
            category_ids=category_ids,
            scoring_type=scoring_type,
            hint_cost=hint_cost,
            max_score=max_score,
            tickets_per_point=tickets_per_point,
            has_game_data=has_game_data,
            public_notifications=public_notifications,
            use_matching_algorithm=use_matching_algorithm,
            global_tickets=global_tickets,
            build_version=build_version,
            api_version=api_version,
            placement_name=placement_name,
            placement_description=placement_description,
            placement_size=placement_size,
            placement_height=placement_height,
            placement_width=placement_width,
            placement_refresh_interval=placement_refresh_interval,
            create_object_store=create_object_store,
            public_content_approval=public_content_approval,
            production_mode=production_mode,
            minimum_session_length=minimum_session_length,
            session_gap_length=session_gap_length,
            local_ads_enabled=local_ads_enabled,
            sqoot_api_key=sqoot_api_key,
            trilat_processing_type=trilat_processing_type,
            max_sample_size=max_sample_size,
            min_rssi=min_rssi,
            modules=modules,
            authorized_count=authorized_count,
            authorized_servers=authorized_servers,
            default_timezone=default_timezone,
            smtp_pass=smtp_pass,
            meta_data=meta_data,
            placement_meta_data=placement_meta_data,
            ips_floor=ips_floor,
            enable_apns_badge=enable_apns_badge,
            include_in_report=include_in_report,
            default_app_filter_id=default_app_filter_id,
            enable_welcome_email=enable_welcome_email,
            apple_app_id=apple_app_id,
            apple_team_id=apple_team_id,
            apple_auth_key_id=apple_auth_key_id,
            apple_auth_key=apple_auth_key,
            apple_issuer_id=apple_issuer_id,
            app_store_key_id=app_store_key_id,
            app_store_key=app_store_key,
            google_private_key_file=google_private_key_file,
            authorize_net_api_key=authorize_net_api_key,
            authorize_net_transaction_key=authorize_net_transaction_key,
            email_sender=email_sender,
            smtp_user=smtp_user,
            smtp_host=smtp_host,
            vatom_business_id=vatom_business_id,
            vatom_rest_client_id=vatom_rest_client_id,
            vatom_rest_secret_key=vatom_rest_secret_key,
            twilio_account_sid=twilio_account_sid,
            twilio_auth_token=twilio_auth_token,
            twilio_sender_phone_number=twilio_sender_phone_number,
            open_ai_secret_key=open_ai_secret_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_application_serialize(
        self,
        app_key,
        app_name,
        device_id,
        account_id,
        about,
        bundle_id,
        app_icon_asset_id,
        app_logo_asset_id,
        facebook_app_id,
        facebook_app_secret,
        google_api_key,
        update_eula_date,
        eula_version,
        landing_page_url,
        show_in_activities,
        activity_description,
        invite_welcome_text,
        invite_page_url,
        url_scheme,
        platforms,
        download_urls,
        category_ids,
        scoring_type,
        hint_cost,
        max_score,
        tickets_per_point,
        has_game_data,
        public_notifications,
        use_matching_algorithm,
        global_tickets,
        build_version,
        api_version,
        placement_name,
        placement_description,
        placement_size,
        placement_height,
        placement_width,
        placement_refresh_interval,
        create_object_store,
        public_content_approval,
        production_mode,
        minimum_session_length,
        session_gap_length,
        local_ads_enabled,
        sqoot_api_key,
        trilat_processing_type,
        max_sample_size,
        min_rssi,
        modules,
        authorized_count,
        authorized_servers,
        default_timezone,
        smtp_pass,
        meta_data,
        placement_meta_data,
        ips_floor,
        enable_apns_badge,
        include_in_report,
        default_app_filter_id,
        enable_welcome_email,
        apple_app_id,
        apple_team_id,
        apple_auth_key_id,
        apple_auth_key,
        apple_issuer_id,
        app_store_key_id,
        app_store_key,
        google_private_key_file,
        authorize_net_api_key,
        authorize_net_transaction_key,
        email_sender,
        smtp_user,
        smtp_host,
        vatom_business_id,
        vatom_rest_client_id,
        vatom_rest_secret_key,
        twilio_account_sid,
        twilio_auth_token,
        twilio_sender_phone_number,
        open_ai_secret_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if app_name is not None:
            
            _query_params.append(('appName', app_name))
            
        if about is not None:
            
            _query_params.append(('about', about))
            
        if bundle_id is not None:
            
            _query_params.append(('bundleId', bundle_id))
            
        if app_icon_asset_id is not None:
            
            _query_params.append(('appIconAssetId', app_icon_asset_id))
            
        if app_logo_asset_id is not None:
            
            _query_params.append(('appLogoAssetId', app_logo_asset_id))
            
        if facebook_app_id is not None:
            
            _query_params.append(('facebookAppId', facebook_app_id))
            
        if facebook_app_secret is not None:
            
            _query_params.append(('facebookAppSecret', facebook_app_secret))
            
        if google_api_key is not None:
            
            _query_params.append(('googleApiKey', google_api_key))
            
        if update_eula_date is not None:
            
            _query_params.append(('updateEULADate', update_eula_date))
            
        if eula_version is not None:
            
            _query_params.append(('eulaVersion', eula_version))
            
        if landing_page_url is not None:
            
            _query_params.append(('landingPageUrl', landing_page_url))
            
        if show_in_activities is not None:
            
            _query_params.append(('showInActivities', show_in_activities))
            
        if activity_description is not None:
            
            _query_params.append(('activityDescription', activity_description))
            
        if invite_welcome_text is not None:
            
            _query_params.append(('inviteWelcomeText', invite_welcome_text))
            
        if invite_page_url is not None:
            
            _query_params.append(('invitePageUrl', invite_page_url))
            
        if url_scheme is not None:
            
            _query_params.append(('urlScheme', url_scheme))
            
        if platforms is not None:
            
            _query_params.append(('platforms', platforms))
            
        if download_urls is not None:
            
            _query_params.append(('downloadUrls', download_urls))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if scoring_type is not None:
            
            _query_params.append(('scoringType', scoring_type))
            
        if hint_cost is not None:
            
            _query_params.append(('hintCost', hint_cost))
            
        if max_score is not None:
            
            _query_params.append(('maxScore', max_score))
            
        if tickets_per_point is not None:
            
            _query_params.append(('ticketsPerPoint', tickets_per_point))
            
        if has_game_data is not None:
            
            _query_params.append(('hasGameData', has_game_data))
            
        if public_notifications is not None:
            
            _query_params.append(('publicNotifications', public_notifications))
            
        if use_matching_algorithm is not None:
            
            _query_params.append(('useMatchingAlgorithm', use_matching_algorithm))
            
        if global_tickets is not None:
            
            _query_params.append(('globalTickets', global_tickets))
            
        if build_version is not None:
            
            _query_params.append(('buildVersion', build_version))
            
        if api_version is not None:
            
            _query_params.append(('apiVersion', api_version))
            
        if placement_name is not None:
            
            _query_params.append(('placementName', placement_name))
            
        if placement_description is not None:
            
            _query_params.append(('placementDescription', placement_description))
            
        if placement_size is not None:
            
            _query_params.append(('placementSize', placement_size))
            
        if placement_height is not None:
            
            _query_params.append(('placementHeight', placement_height))
            
        if placement_width is not None:
            
            _query_params.append(('placementWidth', placement_width))
            
        if placement_refresh_interval is not None:
            
            _query_params.append(('placementRefreshInterval', placement_refresh_interval))
            
        if create_object_store is not None:
            
            _query_params.append(('createObjectStore', create_object_store))
            
        if public_content_approval is not None:
            
            _query_params.append(('publicContentApproval', public_content_approval))
            
        if production_mode is not None:
            
            _query_params.append(('productionMode', production_mode))
            
        if minimum_session_length is not None:
            
            _query_params.append(('minimumSessionLength', minimum_session_length))
            
        if session_gap_length is not None:
            
            _query_params.append(('sessionGapLength', session_gap_length))
            
        if local_ads_enabled is not None:
            
            _query_params.append(('localAdsEnabled', local_ads_enabled))
            
        if sqoot_api_key is not None:
            
            _query_params.append(('sqootApiKey', sqoot_api_key))
            
        if trilat_processing_type is not None:
            
            _query_params.append(('trilatProcessingType', trilat_processing_type))
            
        if max_sample_size is not None:
            
            _query_params.append(('maxSampleSize', max_sample_size))
            
        if min_rssi is not None:
            
            _query_params.append(('minRSSI', min_rssi))
            
        if modules is not None:
            
            _query_params.append(('modules', modules))
            
        if authorized_count is not None:
            
            _query_params.append(('authorizedCount', authorized_count))
            
        if authorized_servers is not None:
            
            _query_params.append(('authorizedServers', authorized_servers))
            
        if default_timezone is not None:
            
            _query_params.append(('defaultTimezone', default_timezone))
            
        if smtp_pass is not None:
            
            _query_params.append(('smtpPass', smtp_pass))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if placement_meta_data is not None:
            
            _query_params.append(('placementMetaData', placement_meta_data))
            
        if ips_floor is not None:
            
            _query_params.append(('ipsFloor', ips_floor))
            
        if enable_apns_badge is not None:
            
            _query_params.append(('enableAPNSBadge', enable_apns_badge))
            
        if include_in_report is not None:
            
            _query_params.append(('includeInReport', include_in_report))
            
        if default_app_filter_id is not None:
            
            _query_params.append(('defaultAppFilterId', default_app_filter_id))
            
        if enable_welcome_email is not None:
            
            _query_params.append(('enableWelcomeEmail', enable_welcome_email))
            
        if apple_app_id is not None:
            
            _query_params.append(('appleAppId', apple_app_id))
            
        if apple_team_id is not None:
            
            _query_params.append(('appleTeamId', apple_team_id))
            
        if apple_auth_key_id is not None:
            
            _query_params.append(('appleAuthKeyId', apple_auth_key_id))
            
        if apple_auth_key is not None:
            
            _query_params.append(('appleAuthKey', apple_auth_key))
            
        if apple_issuer_id is not None:
            
            _query_params.append(('appleIssuerId', apple_issuer_id))
            
        if app_store_key_id is not None:
            
            _query_params.append(('appStoreKeyId', app_store_key_id))
            
        if app_store_key is not None:
            
            _query_params.append(('appStoreKey', app_store_key))
            
        if google_private_key_file is not None:
            
            _query_params.append(('googlePrivateKeyFile', google_private_key_file))
            
        if authorize_net_api_key is not None:
            
            _query_params.append(('authorizeNetApiKey', authorize_net_api_key))
            
        if authorize_net_transaction_key is not None:
            
            _query_params.append(('authorizeNetTransactionKey', authorize_net_transaction_key))
            
        if email_sender is not None:
            
            _query_params.append(('emailSender', email_sender))
            
        if smtp_user is not None:
            
            _query_params.append(('smtpUser', smtp_user))
            
        if smtp_host is not None:
            
            _query_params.append(('smtpHost', smtp_host))
            
        if vatom_business_id is not None:
            
            _query_params.append(('vatomBusinessId', vatom_business_id))
            
        if vatom_rest_client_id is not None:
            
            _query_params.append(('vatomRestClientId', vatom_rest_client_id))
            
        if vatom_rest_secret_key is not None:
            
            _query_params.append(('vatomRestSecretKey', vatom_rest_secret_key))
            
        if twilio_account_sid is not None:
            
            _query_params.append(('twilioAccountSID', twilio_account_sid))
            
        if twilio_auth_token is not None:
            
            _query_params.append(('twilioAuthToken', twilio_auth_token))
            
        if twilio_sender_phone_number is not None:
            
            _query_params.append(('twilioSenderPhoneNumber', twilio_sender_phone_number))
            
        if open_ai_secret_key is not None:
            
            _query_params.append(('openAISecretKey', open_ai_secret_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_application_active(
        self,
        account_id: Annotated[StrictInt, Field(description="The account used to perform the delete, must have rights to edit the application.")],
        app_key: Annotated[StrictStr, Field(description="The key of the application to be deleted")],
        active: Annotated[StrictBool, Field(description="If true then set to active, false otherwise")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Change Appliation Status

        Set the application's active flag to true/false. This effectively activates or deactivates the application.

        :param account_id: The account used to perform the delete, must have rights to edit the application. (required)
        :type account_id: int
        :param app_key: The key of the application to be deleted (required)
        :type app_key: str
        :param active: If true then set to active, false otherwise (required)
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_active_serialize(
            account_id=account_id,
            app_key=app_key,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_application_active_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account used to perform the delete, must have rights to edit the application.")],
        app_key: Annotated[StrictStr, Field(description="The key of the application to be deleted")],
        active: Annotated[StrictBool, Field(description="If true then set to active, false otherwise")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Change Appliation Status

        Set the application's active flag to true/false. This effectively activates or deactivates the application.

        :param account_id: The account used to perform the delete, must have rights to edit the application. (required)
        :type account_id: int
        :param app_key: The key of the application to be deleted (required)
        :type app_key: str
        :param active: If true then set to active, false otherwise (required)
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_active_serialize(
            account_id=account_id,
            app_key=app_key,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_application_active_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account used to perform the delete, must have rights to edit the application.")],
        app_key: Annotated[StrictStr, Field(description="The key of the application to be deleted")],
        active: Annotated[StrictBool, Field(description="If true then set to active, false otherwise")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Change Appliation Status

        Set the application's active flag to true/false. This effectively activates or deactivates the application.

        :param account_id: The account used to perform the delete, must have rights to edit the application. (required)
        :type account_id: int
        :param app_key: The key of the application to be deleted (required)
        :type app_key: str
        :param active: If true then set to active, false otherwise (required)
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_active_serialize(
            account_id=account_id,
            app_key=app_key,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_application_active_serialize(
        self,
        account_id,
        app_key,
        active,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/active',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_application_placement(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement to update, the user must have rights to the application the ad placement is for")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        default_image_id: Annotated[Optional[StrictInt], Field(description="Default Image Id")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PlacementResponse:
        """Update Ad Placement

        Updates an ad placement for an application.

        :param placement_id: The id of the placement to update, the user must have rights to the application the ad placement is for (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the placement
        :type name: str
        :param description: The description of the placement
        :type description: str
        :param size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
        :type size: str
        :param height: The height of a custom ad size
        :type height: int
        :param width: The width of a custom ad size
        :type width: int
        :param refresh_interval: The refresh interval in seconds
        :type refresh_interval: int
        :param default_image_id: Default Image Id
        :type default_image_id: int
        :param active: Active
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            description=description,
            size=size,
            height=height,
            width=width,
            refresh_interval=refresh_interval,
            default_image_id=default_image_id,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_application_placement_with_http_info(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement to update, the user must have rights to the application the ad placement is for")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        default_image_id: Annotated[Optional[StrictInt], Field(description="Default Image Id")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PlacementResponse]:
        """Update Ad Placement

        Updates an ad placement for an application.

        :param placement_id: The id of the placement to update, the user must have rights to the application the ad placement is for (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the placement
        :type name: str
        :param description: The description of the placement
        :type description: str
        :param size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
        :type size: str
        :param height: The height of a custom ad size
        :type height: int
        :param width: The width of a custom ad size
        :type width: int
        :param refresh_interval: The refresh interval in seconds
        :type refresh_interval: int
        :param default_image_id: Default Image Id
        :type default_image_id: int
        :param active: Active
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            description=description,
            size=size,
            height=height,
            width=width,
            refresh_interval=refresh_interval,
            default_image_id=default_image_id,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_application_placement_without_preload_content(
        self,
        placement_id: Annotated[StrictInt, Field(description="The id of the placement to update, the user must have rights to the application the ad placement is for")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the placement")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the placement")] = None,
        size: Annotated[Optional[StrictStr], Field(description="The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM")] = None,
        height: Annotated[Optional[StrictInt], Field(description="The height of a custom ad size")] = None,
        width: Annotated[Optional[StrictInt], Field(description="The width of a custom ad size")] = None,
        refresh_interval: Annotated[Optional[StrictInt], Field(description="The refresh interval in seconds")] = None,
        default_image_id: Annotated[Optional[StrictInt], Field(description="Default Image Id")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Ad Placement

        Updates an ad placement for an application.

        :param placement_id: The id of the placement to update, the user must have rights to the application the ad placement is for (required)
        :type placement_id: int
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the placement
        :type name: str
        :param description: The description of the placement
        :type description: str
        :param size: The ad placement size {BANNER, LEADERBOARD, SKYSCRAPER, INTERSTITIAL, CUSTOM
        :type size: str
        :param height: The height of a custom ad size
        :type height: int
        :param width: The width of a custom ad size
        :type width: int
        :param refresh_interval: The refresh interval in seconds
        :type refresh_interval: int
        :param default_image_id: Default Image Id
        :type default_image_id: int
        :param active: Active
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_placement_serialize(
            placement_id=placement_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            description=description,
            size=size,
            height=height,
            width=width,
            refresh_interval=refresh_interval,
            default_image_id=default_image_id,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PlacementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_application_placement_serialize(
        self,
        placement_id,
        device_id,
        account_id,
        name,
        description,
        size,
        height,
        width,
        refresh_interval,
        default_image_id,
        active,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if placement_id is not None:
            
            _query_params.append(('placementId', placement_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if size is not None:
            
            _query_params.append(('size', size))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if refresh_interval is not None:
            
            _query_params.append(('refreshInterval', refresh_interval))
            
        if default_image_id is not None:
            
            _query_params.append(('defaultImageId', default_image_id))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/placement/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def upload_application_certificate(
        self,
        app_key: Annotated[StrictStr, Field(description="The key of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="Device Id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the application.")] = None,
        certificate: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Certificate")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Application Certificate

        Uploads a certificate for an application that the user has access to.

        :param app_key: The key of the application (required)
        :type app_key: str
        :param device_id: Device Id
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the application.
        :type account_id: int
        :param certificate: Certificate
        :type certificate: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_application_certificate_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            certificate=certificate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def upload_application_certificate_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The key of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="Device Id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the application.")] = None,
        certificate: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Certificate")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Application Certificate

        Uploads a certificate for an application that the user has access to.

        :param app_key: The key of the application (required)
        :type app_key: str
        :param device_id: Device Id
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the application.
        :type account_id: int
        :param certificate: Certificate
        :type certificate: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_application_certificate_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            certificate=certificate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def upload_application_certificate_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The key of the application")],
        device_id: Annotated[Optional[StrictStr], Field(description="Device Id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the application.")] = None,
        certificate: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Certificate")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Application Certificate

        Uploads a certificate for an application that the user has access to.

        :param app_key: The key of the application (required)
        :type app_key: str
        :param device_id: Device Id
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the application.
        :type account_id: int
        :param certificate: Certificate
        :type certificate: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._upload_application_certificate_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            certificate=certificate,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _upload_application_certificate_serialize(
        self,
        app_key,
        device_id,
        account_id,
        certificate,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if certificate is not None:
            
            _query_params.append(('certificate', certificate))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/application/certificate/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


