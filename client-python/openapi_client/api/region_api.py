# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.region_response import RegionResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class RegionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_region(
        self,
        account_id: Annotated[StrictInt, Field(description="The id of the account sending the request")],
        region_class: Annotated[StrictStr, Field(description="RegionClass of this region")],
        short_name: Annotated[StrictStr, Field(description="Short name of the region. This is optimized for search")],
        full_name: Annotated[Optional[StrictStr], Field(description="Full name of the region")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are parents of this region")] = None,
        children_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are children of this region")] = None,
        postal_code_ids: Annotated[Optional[StrictStr], Field(description="Comma separated postal code ids the region will include")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="Sets of name,lat,long used to create new postal codes assigned to the region")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location that the region is being created for")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The Visibility of the region")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the region is assigned to")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the region is assigned to")] = None,
        start: Optional[StrictInt] = None,
        end: Optional[StrictInt] = None,
        polygon: Annotated[Optional[StrictStr], Field(description="the polygon generated for the region")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="the meta data associated with the region")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the region")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        root: Annotated[Optional[StrictBool], Field(description="If this is a root region or not. If true means this region has no parent regions")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active or inactive status of the region")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RegionResponse:
        """Create Region

        Create a region.

        :param account_id: The id of the account sending the request (required)
        :type account_id: int
        :param region_class: RegionClass of this region (required)
        :type region_class: str
        :param short_name: Short name of the region. This is optimized for search (required)
        :type short_name: str
        :param full_name: Full name of the region
        :type full_name: str
        :param parent_ids: Comma separated region ids that are parents of this region
        :type parent_ids: str
        :param children_ids: Comma separated region ids that are children of this region
        :type children_ids: str
        :param postal_code_ids: Comma separated postal code ids the region will include
        :type postal_code_ids: str
        :param locations: Sets of name,lat,long used to create new postal codes assigned to the region
        :type locations: str
        :param retailer_location_id: the id of the retailer location that the region is being created for
        :type retailer_location_id: int
        :param visibility: The Visibility of the region
        :type visibility: str
        :param category_ids: the categories that the region is assigned to
        :type category_ids: str
        :param filter_ids: the filters that the region is assigned to
        :type filter_ids: str
        :param start: 
        :type start: int
        :param end: 
        :type end: int
        :param polygon: the polygon generated for the region
        :type polygon: str
        :param meta_data: the meta data associated with the region
        :type meta_data: str
        :param latitude: the latitude of the region
        :type latitude: float
        :param longitude: the longitude of the region
        :type longitude: float
        :param version_code: the version code
        :type version_code: int
        :param root: If this is a root region or not. If true means this region has no parent regions
        :type root: bool
        :param active: Active or inactive status of the region
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_region_serialize(
            account_id=account_id,
            region_class=region_class,
            short_name=short_name,
            full_name=full_name,
            parent_ids=parent_ids,
            children_ids=children_ids,
            postal_code_ids=postal_code_ids,
            locations=locations,
            retailer_location_id=retailer_location_id,
            visibility=visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            end=end,
            polygon=polygon,
            meta_data=meta_data,
            latitude=latitude,
            longitude=longitude,
            version_code=version_code,
            root=root,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_region_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The id of the account sending the request")],
        region_class: Annotated[StrictStr, Field(description="RegionClass of this region")],
        short_name: Annotated[StrictStr, Field(description="Short name of the region. This is optimized for search")],
        full_name: Annotated[Optional[StrictStr], Field(description="Full name of the region")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are parents of this region")] = None,
        children_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are children of this region")] = None,
        postal_code_ids: Annotated[Optional[StrictStr], Field(description="Comma separated postal code ids the region will include")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="Sets of name,lat,long used to create new postal codes assigned to the region")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location that the region is being created for")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The Visibility of the region")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the region is assigned to")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the region is assigned to")] = None,
        start: Optional[StrictInt] = None,
        end: Optional[StrictInt] = None,
        polygon: Annotated[Optional[StrictStr], Field(description="the polygon generated for the region")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="the meta data associated with the region")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the region")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        root: Annotated[Optional[StrictBool], Field(description="If this is a root region or not. If true means this region has no parent regions")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active or inactive status of the region")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RegionResponse]:
        """Create Region

        Create a region.

        :param account_id: The id of the account sending the request (required)
        :type account_id: int
        :param region_class: RegionClass of this region (required)
        :type region_class: str
        :param short_name: Short name of the region. This is optimized for search (required)
        :type short_name: str
        :param full_name: Full name of the region
        :type full_name: str
        :param parent_ids: Comma separated region ids that are parents of this region
        :type parent_ids: str
        :param children_ids: Comma separated region ids that are children of this region
        :type children_ids: str
        :param postal_code_ids: Comma separated postal code ids the region will include
        :type postal_code_ids: str
        :param locations: Sets of name,lat,long used to create new postal codes assigned to the region
        :type locations: str
        :param retailer_location_id: the id of the retailer location that the region is being created for
        :type retailer_location_id: int
        :param visibility: The Visibility of the region
        :type visibility: str
        :param category_ids: the categories that the region is assigned to
        :type category_ids: str
        :param filter_ids: the filters that the region is assigned to
        :type filter_ids: str
        :param start: 
        :type start: int
        :param end: 
        :type end: int
        :param polygon: the polygon generated for the region
        :type polygon: str
        :param meta_data: the meta data associated with the region
        :type meta_data: str
        :param latitude: the latitude of the region
        :type latitude: float
        :param longitude: the longitude of the region
        :type longitude: float
        :param version_code: the version code
        :type version_code: int
        :param root: If this is a root region or not. If true means this region has no parent regions
        :type root: bool
        :param active: Active or inactive status of the region
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_region_serialize(
            account_id=account_id,
            region_class=region_class,
            short_name=short_name,
            full_name=full_name,
            parent_ids=parent_ids,
            children_ids=children_ids,
            postal_code_ids=postal_code_ids,
            locations=locations,
            retailer_location_id=retailer_location_id,
            visibility=visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            end=end,
            polygon=polygon,
            meta_data=meta_data,
            latitude=latitude,
            longitude=longitude,
            version_code=version_code,
            root=root,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_region_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The id of the account sending the request")],
        region_class: Annotated[StrictStr, Field(description="RegionClass of this region")],
        short_name: Annotated[StrictStr, Field(description="Short name of the region. This is optimized for search")],
        full_name: Annotated[Optional[StrictStr], Field(description="Full name of the region")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are parents of this region")] = None,
        children_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are children of this region")] = None,
        postal_code_ids: Annotated[Optional[StrictStr], Field(description="Comma separated postal code ids the region will include")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="Sets of name,lat,long used to create new postal codes assigned to the region")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location that the region is being created for")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The Visibility of the region")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the region is assigned to")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the region is assigned to")] = None,
        start: Optional[StrictInt] = None,
        end: Optional[StrictInt] = None,
        polygon: Annotated[Optional[StrictStr], Field(description="the polygon generated for the region")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="the meta data associated with the region")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the region")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        root: Annotated[Optional[StrictBool], Field(description="If this is a root region or not. If true means this region has no parent regions")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active or inactive status of the region")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Region

        Create a region.

        :param account_id: The id of the account sending the request (required)
        :type account_id: int
        :param region_class: RegionClass of this region (required)
        :type region_class: str
        :param short_name: Short name of the region. This is optimized for search (required)
        :type short_name: str
        :param full_name: Full name of the region
        :type full_name: str
        :param parent_ids: Comma separated region ids that are parents of this region
        :type parent_ids: str
        :param children_ids: Comma separated region ids that are children of this region
        :type children_ids: str
        :param postal_code_ids: Comma separated postal code ids the region will include
        :type postal_code_ids: str
        :param locations: Sets of name,lat,long used to create new postal codes assigned to the region
        :type locations: str
        :param retailer_location_id: the id of the retailer location that the region is being created for
        :type retailer_location_id: int
        :param visibility: The Visibility of the region
        :type visibility: str
        :param category_ids: the categories that the region is assigned to
        :type category_ids: str
        :param filter_ids: the filters that the region is assigned to
        :type filter_ids: str
        :param start: 
        :type start: int
        :param end: 
        :type end: int
        :param polygon: the polygon generated for the region
        :type polygon: str
        :param meta_data: the meta data associated with the region
        :type meta_data: str
        :param latitude: the latitude of the region
        :type latitude: float
        :param longitude: the longitude of the region
        :type longitude: float
        :param version_code: the version code
        :type version_code: int
        :param root: If this is a root region or not. If true means this region has no parent regions
        :type root: bool
        :param active: Active or inactive status of the region
        :type active: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_region_serialize(
            account_id=account_id,
            region_class=region_class,
            short_name=short_name,
            full_name=full_name,
            parent_ids=parent_ids,
            children_ids=children_ids,
            postal_code_ids=postal_code_ids,
            locations=locations,
            retailer_location_id=retailer_location_id,
            visibility=visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            end=end,
            polygon=polygon,
            meta_data=meta_data,
            latitude=latitude,
            longitude=longitude,
            version_code=version_code,
            root=root,
            active=active,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_region_serialize(
        self,
        account_id,
        region_class,
        short_name,
        full_name,
        parent_ids,
        children_ids,
        postal_code_ids,
        locations,
        retailer_location_id,
        visibility,
        category_ids,
        filter_ids,
        start,
        end,
        polygon,
        meta_data,
        latitude,
        longitude,
        version_code,
        root,
        active,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if region_class is not None:
            
            _query_params.append(('regionClass', region_class))
            
        if short_name is not None:
            
            _query_params.append(('shortName', short_name))
            
        if full_name is not None:
            
            _query_params.append(('fullName', full_name))
            
        if parent_ids is not None:
            
            _query_params.append(('parentIds', parent_ids))
            
        if children_ids is not None:
            
            _query_params.append(('childrenIds', children_ids))
            
        if postal_code_ids is not None:
            
            _query_params.append(('postalCodeIds', postal_code_ids))
            
        if locations is not None:
            
            _query_params.append(('locations', locations))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if end is not None:
            
            _query_params.append(('end', end))
            
        if polygon is not None:
            
            _query_params.append(('polygon', polygon))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if version_code is not None:
            
            _query_params.append(('versionCode', version_code))
            
        if root is not None:
            
            _query_params.append(('root', root))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/region/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_region(
        self,
        account_id: Annotated[StrictInt, Field(description="the id of the account logged in")],
        region_id: Annotated[StrictInt, Field(description="the id of the region")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RegionResponse:
        """Delete Region

        Delete a region.

        :param account_id: the id of the account logged in (required)
        :type account_id: int
        :param region_id: the id of the region (required)
        :type region_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_region_serialize(
            account_id=account_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_region_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="the id of the account logged in")],
        region_id: Annotated[StrictInt, Field(description="the id of the region")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RegionResponse]:
        """Delete Region

        Delete a region.

        :param account_id: the id of the account logged in (required)
        :type account_id: int
        :param region_id: the id of the region (required)
        :type region_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_region_serialize(
            account_id=account_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_region_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="the id of the account logged in")],
        region_id: Annotated[StrictInt, Field(description="the id of the region")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Region

        Delete a region.

        :param account_id: the id of the account logged in (required)
        :type account_id: int
        :param region_id: the id of the region (required)
        :type region_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_region_serialize(
            account_id=account_id,
            region_id=region_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_region_serialize(
        self,
        account_id,
        region_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if region_id is not None:
            
            _query_params.append(('regionId', region_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/region/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_region(
        self,
        region_id: Annotated[StrictInt, Field(description="the id of the region to get")],
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the logged in user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RegionResponse:
        """Get Region

        Get a region.

        :param region_id: the id of the region to get (required)
        :type region_id: int
        :param account_id: the id of the logged in user
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_region_serialize(
            region_id=region_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_region_with_http_info(
        self,
        region_id: Annotated[StrictInt, Field(description="the id of the region to get")],
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the logged in user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RegionResponse]:
        """Get Region

        Get a region.

        :param region_id: the id of the region to get (required)
        :type region_id: int
        :param account_id: the id of the logged in user
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_region_serialize(
            region_id=region_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_region_without_preload_content(
        self,
        region_id: Annotated[StrictInt, Field(description="the id of the region to get")],
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the logged in user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Region

        Get a region.

        :param region_id: the id of the region to get (required)
        :type region_id: int
        :param account_id: the id of the logged in user
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_region_serialize(
            region_id=region_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_region_serialize(
        self,
        region_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if region_id is not None:
            
            _query_params.append(('regionId', region_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/region/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_regions(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="the owner account id of the region to be created")] = None,
        query: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated - use \"keyword\"")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword to filter results on")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the search radius")] = None,
        region_class: Optional[StrictStr] = None,
        visibility: Optional[StrictStr] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines if the results get ordered in descending order")] = None,
        include_parent: Annotated[Optional[StrictBool], Field(description="include the parent region or not")] = None,
        include_children: Annotated[Optional[StrictBool], Field(description="include the chidren regions or not")] = None,
        include_postal_codes: Annotated[Optional[StrictBool], Field(description="include the postal codes associated with the region or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="search on the categories associated with the region")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="search on the filters associated with the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="filter by a specific version code")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="filter to show only active results")] = None,
        show_deleted: Annotated[Optional[StrictBool], Field(description="If showDeleted is true and activeOnly is false, will return regions that have been deleted")] = None,
        last_updated_since: Annotated[Optional[StrictInt], Field(description="only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RegionResponse]:
        """Search Regions

        Get the list of regions.

        :param account_id: the owner account id of the region to be created
        :type account_id: int
        :param query: This parameter is deprecated. deprecated - use \"keyword\"
        :type query: str
        :param keyword: the keyword to filter results on
        :type keyword: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param range: the search radius
        :type range: float
        :param region_class: 
        :type region_class: str
        :param visibility: 
        :type visibility: str
        :param search_mode: the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
        :type search_mode: str
        :param sort_field: the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
        :type sort_field: str
        :param descending: determines if the results get ordered in descending order
        :type descending: bool
        :param include_parent: include the parent region or not
        :type include_parent: bool
        :param include_children: include the chidren regions or not
        :type include_children: bool
        :param include_postal_codes: include the postal codes associated with the region or not
        :type include_postal_codes: bool
        :param category_ids: search on the categories associated with the region
        :type category_ids: str
        :param filter_ids: search on the filters associated with the region
        :type filter_ids: str
        :param version_code: filter by a specific version code
        :type version_code: int
        :param active_only: filter to show only active results
        :type active_only: bool
        :param show_deleted: If showDeleted is true and activeOnly is false, will return regions that have been deleted
        :type show_deleted: bool
        :param last_updated_since: only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
        :type last_updated_since: int
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_regions_serialize(
            account_id=account_id,
            query=query,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            range=range,
            region_class=region_class,
            visibility=visibility,
            search_mode=search_mode,
            sort_field=sort_field,
            descending=descending,
            include_parent=include_parent,
            include_children=include_children,
            include_postal_codes=include_postal_codes,
            category_ids=category_ids,
            filter_ids=filter_ids,
            version_code=version_code,
            active_only=active_only,
            show_deleted=show_deleted,
            last_updated_since=last_updated_since,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RegionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_regions_with_http_info(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="the owner account id of the region to be created")] = None,
        query: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated - use \"keyword\"")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword to filter results on")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the search radius")] = None,
        region_class: Optional[StrictStr] = None,
        visibility: Optional[StrictStr] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines if the results get ordered in descending order")] = None,
        include_parent: Annotated[Optional[StrictBool], Field(description="include the parent region or not")] = None,
        include_children: Annotated[Optional[StrictBool], Field(description="include the chidren regions or not")] = None,
        include_postal_codes: Annotated[Optional[StrictBool], Field(description="include the postal codes associated with the region or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="search on the categories associated with the region")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="search on the filters associated with the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="filter by a specific version code")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="filter to show only active results")] = None,
        show_deleted: Annotated[Optional[StrictBool], Field(description="If showDeleted is true and activeOnly is false, will return regions that have been deleted")] = None,
        last_updated_since: Annotated[Optional[StrictInt], Field(description="only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RegionResponse]]:
        """Search Regions

        Get the list of regions.

        :param account_id: the owner account id of the region to be created
        :type account_id: int
        :param query: This parameter is deprecated. deprecated - use \"keyword\"
        :type query: str
        :param keyword: the keyword to filter results on
        :type keyword: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param range: the search radius
        :type range: float
        :param region_class: 
        :type region_class: str
        :param visibility: 
        :type visibility: str
        :param search_mode: the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
        :type search_mode: str
        :param sort_field: the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
        :type sort_field: str
        :param descending: determines if the results get ordered in descending order
        :type descending: bool
        :param include_parent: include the parent region or not
        :type include_parent: bool
        :param include_children: include the chidren regions or not
        :type include_children: bool
        :param include_postal_codes: include the postal codes associated with the region or not
        :type include_postal_codes: bool
        :param category_ids: search on the categories associated with the region
        :type category_ids: str
        :param filter_ids: search on the filters associated with the region
        :type filter_ids: str
        :param version_code: filter by a specific version code
        :type version_code: int
        :param active_only: filter to show only active results
        :type active_only: bool
        :param show_deleted: If showDeleted is true and activeOnly is false, will return regions that have been deleted
        :type show_deleted: bool
        :param last_updated_since: only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
        :type last_updated_since: int
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_regions_serialize(
            account_id=account_id,
            query=query,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            range=range,
            region_class=region_class,
            visibility=visibility,
            search_mode=search_mode,
            sort_field=sort_field,
            descending=descending,
            include_parent=include_parent,
            include_children=include_children,
            include_postal_codes=include_postal_codes,
            category_ids=category_ids,
            filter_ids=filter_ids,
            version_code=version_code,
            active_only=active_only,
            show_deleted=show_deleted,
            last_updated_since=last_updated_since,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RegionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_regions_without_preload_content(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="the owner account id of the region to be created")] = None,
        query: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated - use \"keyword\"")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword to filter results on")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the search radius")] = None,
        region_class: Optional[StrictStr] = None,
        visibility: Optional[StrictStr] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines if the results get ordered in descending order")] = None,
        include_parent: Annotated[Optional[StrictBool], Field(description="include the parent region or not")] = None,
        include_children: Annotated[Optional[StrictBool], Field(description="include the chidren regions or not")] = None,
        include_postal_codes: Annotated[Optional[StrictBool], Field(description="include the postal codes associated with the region or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="search on the categories associated with the region")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="search on the filters associated with the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="filter by a specific version code")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="filter to show only active results")] = None,
        show_deleted: Annotated[Optional[StrictBool], Field(description="If showDeleted is true and activeOnly is false, will return regions that have been deleted")] = None,
        last_updated_since: Annotated[Optional[StrictInt], Field(description="only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Regions

        Get the list of regions.

        :param account_id: the owner account id of the region to be created
        :type account_id: int
        :param query: This parameter is deprecated. deprecated - use \"keyword\"
        :type query: str
        :param keyword: the keyword to filter results on
        :type keyword: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param range: the search radius
        :type range: float
        :param region_class: 
        :type region_class: str
        :param visibility: 
        :type visibility: str
        :param search_mode: the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
        :type search_mode: str
        :param sort_field: the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
        :type sort_field: str
        :param descending: determines if the results get ordered in descending order
        :type descending: bool
        :param include_parent: include the parent region or not
        :type include_parent: bool
        :param include_children: include the chidren regions or not
        :type include_children: bool
        :param include_postal_codes: include the postal codes associated with the region or not
        :type include_postal_codes: bool
        :param category_ids: search on the categories associated with the region
        :type category_ids: str
        :param filter_ids: search on the filters associated with the region
        :type filter_ids: str
        :param version_code: filter by a specific version code
        :type version_code: int
        :param active_only: filter to show only active results
        :type active_only: bool
        :param show_deleted: If showDeleted is true and activeOnly is false, will return regions that have been deleted
        :type show_deleted: bool
        :param last_updated_since: only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
        :type last_updated_since: int
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_regions_serialize(
            account_id=account_id,
            query=query,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            range=range,
            region_class=region_class,
            visibility=visibility,
            search_mode=search_mode,
            sort_field=sort_field,
            descending=descending,
            include_parent=include_parent,
            include_children=include_children,
            include_postal_codes=include_postal_codes,
            category_ids=category_ids,
            filter_ids=filter_ids,
            version_code=version_code,
            active_only=active_only,
            show_deleted=show_deleted,
            last_updated_since=last_updated_since,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RegionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_regions_serialize(
        self,
        account_id,
        query,
        keyword,
        latitude,
        longitude,
        range,
        region_class,
        visibility,
        search_mode,
        sort_field,
        descending,
        include_parent,
        include_children,
        include_postal_codes,
        category_ids,
        filter_ids,
        version_code,
        active_only,
        show_deleted,
        last_updated_since,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if range is not None:
            
            _query_params.append(('range', range))
            
        if region_class is not None:
            
            _query_params.append(('regionClass', region_class))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if search_mode is not None:
            
            _query_params.append(('searchMode', search_mode))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if include_parent is not None:
            
            _query_params.append(('includeParent', include_parent))
            
        if include_children is not None:
            
            _query_params.append(('includeChildren', include_children))
            
        if include_postal_codes is not None:
            
            _query_params.append(('includePostalCodes', include_postal_codes))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if version_code is not None:
            
            _query_params.append(('versionCode', version_code))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if show_deleted is not None:
            
            _query_params.append(('showDeleted', show_deleted))
            
        if last_updated_since is not None:
            
            _query_params.append(('lastUpdatedSince', last_updated_since))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/region/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_region(
        self,
        account_id: Annotated[StrictInt, Field(description="The id of the account sending the request")],
        region_id: Annotated[StrictInt, Field(description="The id of the region to be updated")],
        region_class: Annotated[Optional[StrictStr], Field(description="RegionClass of this region")] = None,
        short_name: Annotated[Optional[StrictStr], Field(description="Short name of the region. This is optimized for search")] = None,
        full_name: Annotated[Optional[StrictStr], Field(description="Full name of the region")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are parents of this region")] = None,
        children_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are children of this region")] = None,
        postal_code_ids: Annotated[Optional[StrictStr], Field(description="Comma separated postal code ids the region will include")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="Sets of name,lat,long used to create new postal codes assigned to the region")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the retailer location ID that the region is associated with")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The Visibility of the region")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the region is assigned to")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the region is assigned to")] = None,
        start: Optional[StrictInt] = None,
        end: Optional[StrictInt] = None,
        polygon: Annotated[Optional[StrictStr], Field(description="the polygon of the region")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the region")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the region")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        root: Annotated[Optional[StrictBool], Field(description="If this is a root region or not. If true means this region has no parent regions")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active or inactive status of the region")] = None,
        clear_lists: Annotated[Optional[StrictBool], Field(description="If true clear the children and postal code lists before add new ones, otherwise just append.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RegionResponse:
        """Update Region

        Update a region.

        :param account_id: The id of the account sending the request (required)
        :type account_id: int
        :param region_id: The id of the region to be updated (required)
        :type region_id: int
        :param region_class: RegionClass of this region
        :type region_class: str
        :param short_name: Short name of the region. This is optimized for search
        :type short_name: str
        :param full_name: Full name of the region
        :type full_name: str
        :param parent_ids: Comma separated region ids that are parents of this region
        :type parent_ids: str
        :param children_ids: Comma separated region ids that are children of this region
        :type children_ids: str
        :param postal_code_ids: Comma separated postal code ids the region will include
        :type postal_code_ids: str
        :param locations: Sets of name,lat,long used to create new postal codes assigned to the region
        :type locations: str
        :param retailer_location_id: the retailer location ID that the region is associated with
        :type retailer_location_id: int
        :param visibility: The Visibility of the region
        :type visibility: str
        :param category_ids: the categories that the region is assigned to
        :type category_ids: str
        :param filter_ids: the filters that the region is assigned to
        :type filter_ids: str
        :param start: 
        :type start: int
        :param end: 
        :type end: int
        :param polygon: the polygon of the region
        :type polygon: str
        :param meta_data: the meta data of the region
        :type meta_data: str
        :param latitude: the latitude of the region
        :type latitude: float
        :param longitude: the longitude of the region
        :type longitude: float
        :param version_code: the version code
        :type version_code: int
        :param root: If this is a root region or not. If true means this region has no parent regions
        :type root: bool
        :param active: Active or inactive status of the region
        :type active: bool
        :param clear_lists: If true clear the children and postal code lists before add new ones, otherwise just append.
        :type clear_lists: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_region_serialize(
            account_id=account_id,
            region_id=region_id,
            region_class=region_class,
            short_name=short_name,
            full_name=full_name,
            parent_ids=parent_ids,
            children_ids=children_ids,
            postal_code_ids=postal_code_ids,
            locations=locations,
            retailer_location_id=retailer_location_id,
            visibility=visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            end=end,
            polygon=polygon,
            meta_data=meta_data,
            latitude=latitude,
            longitude=longitude,
            version_code=version_code,
            root=root,
            active=active,
            clear_lists=clear_lists,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_region_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The id of the account sending the request")],
        region_id: Annotated[StrictInt, Field(description="The id of the region to be updated")],
        region_class: Annotated[Optional[StrictStr], Field(description="RegionClass of this region")] = None,
        short_name: Annotated[Optional[StrictStr], Field(description="Short name of the region. This is optimized for search")] = None,
        full_name: Annotated[Optional[StrictStr], Field(description="Full name of the region")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are parents of this region")] = None,
        children_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are children of this region")] = None,
        postal_code_ids: Annotated[Optional[StrictStr], Field(description="Comma separated postal code ids the region will include")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="Sets of name,lat,long used to create new postal codes assigned to the region")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the retailer location ID that the region is associated with")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The Visibility of the region")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the region is assigned to")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the region is assigned to")] = None,
        start: Optional[StrictInt] = None,
        end: Optional[StrictInt] = None,
        polygon: Annotated[Optional[StrictStr], Field(description="the polygon of the region")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the region")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the region")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        root: Annotated[Optional[StrictBool], Field(description="If this is a root region or not. If true means this region has no parent regions")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active or inactive status of the region")] = None,
        clear_lists: Annotated[Optional[StrictBool], Field(description="If true clear the children and postal code lists before add new ones, otherwise just append.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RegionResponse]:
        """Update Region

        Update a region.

        :param account_id: The id of the account sending the request (required)
        :type account_id: int
        :param region_id: The id of the region to be updated (required)
        :type region_id: int
        :param region_class: RegionClass of this region
        :type region_class: str
        :param short_name: Short name of the region. This is optimized for search
        :type short_name: str
        :param full_name: Full name of the region
        :type full_name: str
        :param parent_ids: Comma separated region ids that are parents of this region
        :type parent_ids: str
        :param children_ids: Comma separated region ids that are children of this region
        :type children_ids: str
        :param postal_code_ids: Comma separated postal code ids the region will include
        :type postal_code_ids: str
        :param locations: Sets of name,lat,long used to create new postal codes assigned to the region
        :type locations: str
        :param retailer_location_id: the retailer location ID that the region is associated with
        :type retailer_location_id: int
        :param visibility: The Visibility of the region
        :type visibility: str
        :param category_ids: the categories that the region is assigned to
        :type category_ids: str
        :param filter_ids: the filters that the region is assigned to
        :type filter_ids: str
        :param start: 
        :type start: int
        :param end: 
        :type end: int
        :param polygon: the polygon of the region
        :type polygon: str
        :param meta_data: the meta data of the region
        :type meta_data: str
        :param latitude: the latitude of the region
        :type latitude: float
        :param longitude: the longitude of the region
        :type longitude: float
        :param version_code: the version code
        :type version_code: int
        :param root: If this is a root region or not. If true means this region has no parent regions
        :type root: bool
        :param active: Active or inactive status of the region
        :type active: bool
        :param clear_lists: If true clear the children and postal code lists before add new ones, otherwise just append.
        :type clear_lists: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_region_serialize(
            account_id=account_id,
            region_id=region_id,
            region_class=region_class,
            short_name=short_name,
            full_name=full_name,
            parent_ids=parent_ids,
            children_ids=children_ids,
            postal_code_ids=postal_code_ids,
            locations=locations,
            retailer_location_id=retailer_location_id,
            visibility=visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            end=end,
            polygon=polygon,
            meta_data=meta_data,
            latitude=latitude,
            longitude=longitude,
            version_code=version_code,
            root=root,
            active=active,
            clear_lists=clear_lists,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_region_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The id of the account sending the request")],
        region_id: Annotated[StrictInt, Field(description="The id of the region to be updated")],
        region_class: Annotated[Optional[StrictStr], Field(description="RegionClass of this region")] = None,
        short_name: Annotated[Optional[StrictStr], Field(description="Short name of the region. This is optimized for search")] = None,
        full_name: Annotated[Optional[StrictStr], Field(description="Full name of the region")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are parents of this region")] = None,
        children_ids: Annotated[Optional[StrictStr], Field(description="Comma separated region ids that are children of this region")] = None,
        postal_code_ids: Annotated[Optional[StrictStr], Field(description="Comma separated postal code ids the region will include")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="Sets of name,lat,long used to create new postal codes assigned to the region")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the retailer location ID that the region is associated with")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="The Visibility of the region")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the region is assigned to")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the region is assigned to")] = None,
        start: Optional[StrictInt] = None,
        end: Optional[StrictInt] = None,
        polygon: Annotated[Optional[StrictStr], Field(description="the polygon of the region")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the region")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the region")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the region")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        root: Annotated[Optional[StrictBool], Field(description="If this is a root region or not. If true means this region has no parent regions")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Active or inactive status of the region")] = None,
        clear_lists: Annotated[Optional[StrictBool], Field(description="If true clear the children and postal code lists before add new ones, otherwise just append.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Region

        Update a region.

        :param account_id: The id of the account sending the request (required)
        :type account_id: int
        :param region_id: The id of the region to be updated (required)
        :type region_id: int
        :param region_class: RegionClass of this region
        :type region_class: str
        :param short_name: Short name of the region. This is optimized for search
        :type short_name: str
        :param full_name: Full name of the region
        :type full_name: str
        :param parent_ids: Comma separated region ids that are parents of this region
        :type parent_ids: str
        :param children_ids: Comma separated region ids that are children of this region
        :type children_ids: str
        :param postal_code_ids: Comma separated postal code ids the region will include
        :type postal_code_ids: str
        :param locations: Sets of name,lat,long used to create new postal codes assigned to the region
        :type locations: str
        :param retailer_location_id: the retailer location ID that the region is associated with
        :type retailer_location_id: int
        :param visibility: The Visibility of the region
        :type visibility: str
        :param category_ids: the categories that the region is assigned to
        :type category_ids: str
        :param filter_ids: the filters that the region is assigned to
        :type filter_ids: str
        :param start: 
        :type start: int
        :param end: 
        :type end: int
        :param polygon: the polygon of the region
        :type polygon: str
        :param meta_data: the meta data of the region
        :type meta_data: str
        :param latitude: the latitude of the region
        :type latitude: float
        :param longitude: the longitude of the region
        :type longitude: float
        :param version_code: the version code
        :type version_code: int
        :param root: If this is a root region or not. If true means this region has no parent regions
        :type root: bool
        :param active: Active or inactive status of the region
        :type active: bool
        :param clear_lists: If true clear the children and postal code lists before add new ones, otherwise just append.
        :type clear_lists: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_region_serialize(
            account_id=account_id,
            region_id=region_id,
            region_class=region_class,
            short_name=short_name,
            full_name=full_name,
            parent_ids=parent_ids,
            children_ids=children_ids,
            postal_code_ids=postal_code_ids,
            locations=locations,
            retailer_location_id=retailer_location_id,
            visibility=visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            end=end,
            polygon=polygon,
            meta_data=meta_data,
            latitude=latitude,
            longitude=longitude,
            version_code=version_code,
            root=root,
            active=active,
            clear_lists=clear_lists,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RegionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_region_serialize(
        self,
        account_id,
        region_id,
        region_class,
        short_name,
        full_name,
        parent_ids,
        children_ids,
        postal_code_ids,
        locations,
        retailer_location_id,
        visibility,
        category_ids,
        filter_ids,
        start,
        end,
        polygon,
        meta_data,
        latitude,
        longitude,
        version_code,
        root,
        active,
        clear_lists,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if region_id is not None:
            
            _query_params.append(('regionId', region_id))
            
        if region_class is not None:
            
            _query_params.append(('regionClass', region_class))
            
        if short_name is not None:
            
            _query_params.append(('shortName', short_name))
            
        if full_name is not None:
            
            _query_params.append(('fullName', full_name))
            
        if parent_ids is not None:
            
            _query_params.append(('parentIds', parent_ids))
            
        if children_ids is not None:
            
            _query_params.append(('childrenIds', children_ids))
            
        if postal_code_ids is not None:
            
            _query_params.append(('postalCodeIds', postal_code_ids))
            
        if locations is not None:
            
            _query_params.append(('locations', locations))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if end is not None:
            
            _query_params.append(('end', end))
            
        if polygon is not None:
            
            _query_params.append(('polygon', polygon))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if version_code is not None:
            
            _query_params.append(('versionCode', version_code))
            
        if root is not None:
            
            _query_params.append(('root', root))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if clear_lists is not None:
            
            _query_params.append(('clearLists', clear_lists))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/region/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


