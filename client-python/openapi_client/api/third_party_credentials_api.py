# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.profile_response import ProfileResponse
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.third_party_credential_response import ThirdPartyCredentialResponse
from openapi_client.models.third_party_network_response import ThirdPartyNetworkResponse
from openapi_client.models.third_party_network_short_response import ThirdPartyNetworkShortResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ThirdPartyCredentialsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_credential(
        self,
        third_party_id: Annotated[StrictStr, Field(description="the third party user account id")],
        third_party_token: Annotated[StrictStr, Field(description="the access token to authenticate with (ex: username or fb token or phone number)")],
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the unique id of the account that needs authenticating (optional for PHONE_V2)")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        session_id: Annotated[Optional[StrictStr], Field(description="the session id for the request")] = None,
        third_party_name: Annotated[Optional[StrictStr], Field(description="the third party user's display name")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="optional email address associated with the third party account")] = None,
        signin_only_mode: Annotated[Optional[StrictBool], Field(description="when true will error out if can't find any accounts matching (signin only)")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        third_party_refresh_token: Annotated[Optional[StrictStr], Field(description="optional refresh token for the third party")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="audience ids to add to the account")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="audience ids to remove from the account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Create Credential

        This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 

        :param third_party_id: the third party user account id (required)
        :type third_party_id: str
        :param third_party_token: the access token to authenticate with (ex: username or fb token or phone number) (required)
        :type third_party_token: str
        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param account_id: the unique id of the account that needs authenticating (optional for PHONE_V2)
        :type account_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param session_id: the session id for the request
        :type session_id: str
        :param third_party_name: the third party user's display name
        :type third_party_name: str
        :param email_address: optional email address associated with the third party account
        :type email_address: str
        :param signin_only_mode: when true will error out if can't find any accounts matching (signin only)
        :type signin_only_mode: bool
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param third_party_refresh_token: optional refresh token for the third party
        :type third_party_refresh_token: str
        :param audience_ids_to_add: audience ids to add to the account
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: audience ids to remove from the account
        :type audience_ids_to_remove: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_credential_serialize(
            third_party_id=third_party_id,
            third_party_token=third_party_token,
            network_uid=network_uid,
            app_key=app_key,
            account_id=account_id,
            device_id=device_id,
            session_id=session_id,
            third_party_name=third_party_name,
            email_address=email_address,
            signin_only_mode=signin_only_mode,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            third_party_refresh_token=third_party_refresh_token,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_credential_with_http_info(
        self,
        third_party_id: Annotated[StrictStr, Field(description="the third party user account id")],
        third_party_token: Annotated[StrictStr, Field(description="the access token to authenticate with (ex: username or fb token or phone number)")],
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the unique id of the account that needs authenticating (optional for PHONE_V2)")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        session_id: Annotated[Optional[StrictStr], Field(description="the session id for the request")] = None,
        third_party_name: Annotated[Optional[StrictStr], Field(description="the third party user's display name")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="optional email address associated with the third party account")] = None,
        signin_only_mode: Annotated[Optional[StrictBool], Field(description="when true will error out if can't find any accounts matching (signin only)")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        third_party_refresh_token: Annotated[Optional[StrictStr], Field(description="optional refresh token for the third party")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="audience ids to add to the account")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="audience ids to remove from the account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Create Credential

        This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 

        :param third_party_id: the third party user account id (required)
        :type third_party_id: str
        :param third_party_token: the access token to authenticate with (ex: username or fb token or phone number) (required)
        :type third_party_token: str
        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param account_id: the unique id of the account that needs authenticating (optional for PHONE_V2)
        :type account_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param session_id: the session id for the request
        :type session_id: str
        :param third_party_name: the third party user's display name
        :type third_party_name: str
        :param email_address: optional email address associated with the third party account
        :type email_address: str
        :param signin_only_mode: when true will error out if can't find any accounts matching (signin only)
        :type signin_only_mode: bool
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param third_party_refresh_token: optional refresh token for the third party
        :type third_party_refresh_token: str
        :param audience_ids_to_add: audience ids to add to the account
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: audience ids to remove from the account
        :type audience_ids_to_remove: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_credential_serialize(
            third_party_id=third_party_id,
            third_party_token=third_party_token,
            network_uid=network_uid,
            app_key=app_key,
            account_id=account_id,
            device_id=device_id,
            session_id=session_id,
            third_party_name=third_party_name,
            email_address=email_address,
            signin_only_mode=signin_only_mode,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            third_party_refresh_token=third_party_refresh_token,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_credential_without_preload_content(
        self,
        third_party_id: Annotated[StrictStr, Field(description="the third party user account id")],
        third_party_token: Annotated[StrictStr, Field(description="the access token to authenticate with (ex: username or fb token or phone number)")],
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the unique id of the account that needs authenticating (optional for PHONE_V2)")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        session_id: Annotated[Optional[StrictStr], Field(description="the session id for the request")] = None,
        third_party_name: Annotated[Optional[StrictStr], Field(description="the third party user's display name")] = None,
        email_address: Annotated[Optional[StrictStr], Field(description="optional email address associated with the third party account")] = None,
        signin_only_mode: Annotated[Optional[StrictBool], Field(description="when true will error out if can't find any accounts matching (signin only)")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        third_party_refresh_token: Annotated[Optional[StrictStr], Field(description="optional refresh token for the third party")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="audience ids to add to the account")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="audience ids to remove from the account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Credential

        This endpoint creates a third-party login for a Sirqul account. A third party login is a way for external systems (Third Party Networks) to link their own user accounts with a Sirqul account.   The thirdPartyId parameter is used to determine if the user already exists in Sirqul or not. This parameter needs to be unique for each user in the Third Party Network (identified by the networkUID parameter). Note that subsequent calls will update the user's third-party login credentials for the user with the same thirdPartyId and networkUID combination.    The thirdPartyToken parameter acts as a shared secret and used by client applications to log users into Sirqul without providing a Sirqul username and password. 

        :param third_party_id: the third party user account id (required)
        :type third_party_id: str
        :param third_party_token: the access token to authenticate with (ex: username or fb token or phone number) (required)
        :type third_party_token: str
        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param account_id: the unique id of the account that needs authenticating (optional for PHONE_V2)
        :type account_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param session_id: the session id for the request
        :type session_id: str
        :param third_party_name: the third party user's display name
        :type third_party_name: str
        :param email_address: optional email address associated with the third party account
        :type email_address: str
        :param signin_only_mode: when true will error out if can't find any accounts matching (signin only)
        :type signin_only_mode: bool
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param third_party_refresh_token: optional refresh token for the third party
        :type third_party_refresh_token: str
        :param audience_ids_to_add: audience ids to add to the account
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: audience ids to remove from the account
        :type audience_ids_to_remove: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_credential_serialize(
            third_party_id=third_party_id,
            third_party_token=third_party_token,
            network_uid=network_uid,
            app_key=app_key,
            account_id=account_id,
            device_id=device_id,
            session_id=session_id,
            third_party_name=third_party_name,
            email_address=email_address,
            signin_only_mode=signin_only_mode,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            third_party_refresh_token=third_party_refresh_token,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_credential_serialize(
        self,
        third_party_id,
        third_party_token,
        network_uid,
        app_key,
        account_id,
        device_id,
        session_id,
        third_party_name,
        email_address,
        signin_only_mode,
        response_filters,
        latitude,
        longitude,
        meta_data,
        third_party_refresh_token,
        audience_ids_to_add,
        audience_ids_to_remove,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if session_id is not None:
            
            _query_params.append(('sessionId', session_id))
            
        if third_party_id is not None:
            
            _query_params.append(('thirdPartyId', third_party_id))
            
        if third_party_name is not None:
            
            _query_params.append(('thirdPartyName', third_party_name))
            
        if third_party_token is not None:
            
            _query_params.append(('thirdPartyToken', third_party_token))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if email_address is not None:
            
            _query_params.append(('emailAddress', email_address))
            
        if signin_only_mode is not None:
            
            _query_params.append(('signinOnlyMode', signin_only_mode))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if third_party_refresh_token is not None:
            
            _query_params.append(('thirdPartyRefreshToken', third_party_refresh_token))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if audience_ids_to_remove is not None:
            
            _query_params.append(('audienceIdsToRemove', audience_ids_to_remove))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/credential/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_network(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        name: Annotated[StrictStr, Field(description="The name of the network")],
        enable_introspection: Annotated[StrictBool, Field(description="Whether the network uses introspection calls")],
        description: Annotated[Optional[StrictStr], Field(description="The description of the network")] = None,
        introspection_method: Annotated[Optional[StrictStr], Field(description="HTTP method to use for introspection calls (e.g., GET, POST)")] = None,
        introspection_url: Annotated[Optional[StrictStr], Field(description="The HTTP URL of the introspection call")] = None,
        introspection_params: Annotated[Optional[StrictStr], Field(description="The parameters of the introspection call")] = None,
        required_root_field: Annotated[Optional[StrictStr], Field(description="Required response params")] = None,
        enable_mfa: Annotated[Optional[StrictBool], Field(description="Whether this network uses MFA")] = None,
        size_mfa: Annotated[Optional[StrictInt], Field(description="Size of the MFA token")] = None,
        shelf_life_mfa: Annotated[Optional[StrictInt], Field(description="Shelf life (seconds) of the MFA token")] = None,
        oauth_token_url: Annotated[Optional[StrictStr], Field(description="OAuth token endpoint URL")] = None,
        oauth_private_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth private key file (multipart)")] = None,
        oauth_public_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth public key file (multipart)")] = None,
        oauth_client_id: Annotated[Optional[StrictStr], Field(description="OAuth client id")] = None,
        oauth_secret_key: Annotated[Optional[StrictStr], Field(description="OAuth secret key")] = None,
        body: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ThirdPartyNetworkResponse:
        """Create Network

        Creates a custom third party network.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param name: The name of the network (required)
        :type name: str
        :param enable_introspection: Whether the network uses introspection calls (required)
        :type enable_introspection: bool
        :param description: The description of the network
        :type description: str
        :param introspection_method: HTTP method to use for introspection calls (e.g., GET, POST)
        :type introspection_method: str
        :param introspection_url: The HTTP URL of the introspection call
        :type introspection_url: str
        :param introspection_params: The parameters of the introspection call
        :type introspection_params: str
        :param required_root_field: Required response params
        :type required_root_field: str
        :param enable_mfa: Whether this network uses MFA
        :type enable_mfa: bool
        :param size_mfa: Size of the MFA token
        :type size_mfa: int
        :param shelf_life_mfa: Shelf life (seconds) of the MFA token
        :type shelf_life_mfa: int
        :param oauth_token_url: OAuth token endpoint URL
        :type oauth_token_url: str
        :param oauth_private_key: OAuth private key file (multipart)
        :type oauth_private_key: bytearray
        :param oauth_public_key: OAuth public key file (multipart)
        :type oauth_public_key: bytearray
        :param oauth_client_id: OAuth client id
        :type oauth_client_id: str
        :param oauth_secret_key: OAuth secret key
        :type oauth_secret_key: str
        :param body:
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_serialize(
            account_id=account_id,
            name=name,
            enable_introspection=enable_introspection,
            description=description,
            introspection_method=introspection_method,
            introspection_url=introspection_url,
            introspection_params=introspection_params,
            required_root_field=required_root_field,
            enable_mfa=enable_mfa,
            size_mfa=size_mfa,
            shelf_life_mfa=shelf_life_mfa,
            oauth_token_url=oauth_token_url,
            oauth_private_key=oauth_private_key,
            oauth_public_key=oauth_public_key,
            oauth_client_id=oauth_client_id,
            oauth_secret_key=oauth_secret_key,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_network_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        name: Annotated[StrictStr, Field(description="The name of the network")],
        enable_introspection: Annotated[StrictBool, Field(description="Whether the network uses introspection calls")],
        description: Annotated[Optional[StrictStr], Field(description="The description of the network")] = None,
        introspection_method: Annotated[Optional[StrictStr], Field(description="HTTP method to use for introspection calls (e.g., GET, POST)")] = None,
        introspection_url: Annotated[Optional[StrictStr], Field(description="The HTTP URL of the introspection call")] = None,
        introspection_params: Annotated[Optional[StrictStr], Field(description="The parameters of the introspection call")] = None,
        required_root_field: Annotated[Optional[StrictStr], Field(description="Required response params")] = None,
        enable_mfa: Annotated[Optional[StrictBool], Field(description="Whether this network uses MFA")] = None,
        size_mfa: Annotated[Optional[StrictInt], Field(description="Size of the MFA token")] = None,
        shelf_life_mfa: Annotated[Optional[StrictInt], Field(description="Shelf life (seconds) of the MFA token")] = None,
        oauth_token_url: Annotated[Optional[StrictStr], Field(description="OAuth token endpoint URL")] = None,
        oauth_private_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth private key file (multipart)")] = None,
        oauth_public_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth public key file (multipart)")] = None,
        oauth_client_id: Annotated[Optional[StrictStr], Field(description="OAuth client id")] = None,
        oauth_secret_key: Annotated[Optional[StrictStr], Field(description="OAuth secret key")] = None,
        body: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ThirdPartyNetworkResponse]:
        """Create Network

        Creates a custom third party network.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param name: The name of the network (required)
        :type name: str
        :param enable_introspection: Whether the network uses introspection calls (required)
        :type enable_introspection: bool
        :param description: The description of the network
        :type description: str
        :param introspection_method: HTTP method to use for introspection calls (e.g., GET, POST)
        :type introspection_method: str
        :param introspection_url: The HTTP URL of the introspection call
        :type introspection_url: str
        :param introspection_params: The parameters of the introspection call
        :type introspection_params: str
        :param required_root_field: Required response params
        :type required_root_field: str
        :param enable_mfa: Whether this network uses MFA
        :type enable_mfa: bool
        :param size_mfa: Size of the MFA token
        :type size_mfa: int
        :param shelf_life_mfa: Shelf life (seconds) of the MFA token
        :type shelf_life_mfa: int
        :param oauth_token_url: OAuth token endpoint URL
        :type oauth_token_url: str
        :param oauth_private_key: OAuth private key file (multipart)
        :type oauth_private_key: bytearray
        :param oauth_public_key: OAuth public key file (multipart)
        :type oauth_public_key: bytearray
        :param oauth_client_id: OAuth client id
        :type oauth_client_id: str
        :param oauth_secret_key: OAuth secret key
        :type oauth_secret_key: str
        :param body:
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_serialize(
            account_id=account_id,
            name=name,
            enable_introspection=enable_introspection,
            description=description,
            introspection_method=introspection_method,
            introspection_url=introspection_url,
            introspection_params=introspection_params,
            required_root_field=required_root_field,
            enable_mfa=enable_mfa,
            size_mfa=size_mfa,
            shelf_life_mfa=shelf_life_mfa,
            oauth_token_url=oauth_token_url,
            oauth_private_key=oauth_private_key,
            oauth_public_key=oauth_public_key,
            oauth_client_id=oauth_client_id,
            oauth_secret_key=oauth_secret_key,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_network_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        name: Annotated[StrictStr, Field(description="The name of the network")],
        enable_introspection: Annotated[StrictBool, Field(description="Whether the network uses introspection calls")],
        description: Annotated[Optional[StrictStr], Field(description="The description of the network")] = None,
        introspection_method: Annotated[Optional[StrictStr], Field(description="HTTP method to use for introspection calls (e.g., GET, POST)")] = None,
        introspection_url: Annotated[Optional[StrictStr], Field(description="The HTTP URL of the introspection call")] = None,
        introspection_params: Annotated[Optional[StrictStr], Field(description="The parameters of the introspection call")] = None,
        required_root_field: Annotated[Optional[StrictStr], Field(description="Required response params")] = None,
        enable_mfa: Annotated[Optional[StrictBool], Field(description="Whether this network uses MFA")] = None,
        size_mfa: Annotated[Optional[StrictInt], Field(description="Size of the MFA token")] = None,
        shelf_life_mfa: Annotated[Optional[StrictInt], Field(description="Shelf life (seconds) of the MFA token")] = None,
        oauth_token_url: Annotated[Optional[StrictStr], Field(description="OAuth token endpoint URL")] = None,
        oauth_private_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth private key file (multipart)")] = None,
        oauth_public_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth public key file (multipart)")] = None,
        oauth_client_id: Annotated[Optional[StrictStr], Field(description="OAuth client id")] = None,
        oauth_secret_key: Annotated[Optional[StrictStr], Field(description="OAuth secret key")] = None,
        body: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Network

        Creates a custom third party network.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param name: The name of the network (required)
        :type name: str
        :param enable_introspection: Whether the network uses introspection calls (required)
        :type enable_introspection: bool
        :param description: The description of the network
        :type description: str
        :param introspection_method: HTTP method to use for introspection calls (e.g., GET, POST)
        :type introspection_method: str
        :param introspection_url: The HTTP URL of the introspection call
        :type introspection_url: str
        :param introspection_params: The parameters of the introspection call
        :type introspection_params: str
        :param required_root_field: Required response params
        :type required_root_field: str
        :param enable_mfa: Whether this network uses MFA
        :type enable_mfa: bool
        :param size_mfa: Size of the MFA token
        :type size_mfa: int
        :param shelf_life_mfa: Shelf life (seconds) of the MFA token
        :type shelf_life_mfa: int
        :param oauth_token_url: OAuth token endpoint URL
        :type oauth_token_url: str
        :param oauth_private_key: OAuth private key file (multipart)
        :type oauth_private_key: bytearray
        :param oauth_public_key: OAuth public key file (multipart)
        :type oauth_public_key: bytearray
        :param oauth_client_id: OAuth client id
        :type oauth_client_id: str
        :param oauth_secret_key: OAuth secret key
        :type oauth_secret_key: str
        :param body:
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_network_serialize(
            account_id=account_id,
            name=name,
            enable_introspection=enable_introspection,
            description=description,
            introspection_method=introspection_method,
            introspection_url=introspection_url,
            introspection_params=introspection_params,
            required_root_field=required_root_field,
            enable_mfa=enable_mfa,
            size_mfa=size_mfa,
            shelf_life_mfa=shelf_life_mfa,
            oauth_token_url=oauth_token_url,
            oauth_private_key=oauth_private_key,
            oauth_public_key=oauth_public_key,
            oauth_client_id=oauth_client_id,
            oauth_secret_key=oauth_secret_key,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_network_serialize(
        self,
        account_id,
        name,
        enable_introspection,
        description,
        introspection_method,
        introspection_url,
        introspection_params,
        required_root_field,
        enable_mfa,
        size_mfa,
        shelf_life_mfa,
        oauth_token_url,
        oauth_private_key,
        oauth_public_key,
        oauth_client_id,
        oauth_secret_key,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if enable_introspection is not None:
            
            _query_params.append(('enableIntrospection', enable_introspection))
            
        if introspection_method is not None:
            
            _query_params.append(('introspectionMethod', introspection_method))
            
        if introspection_url is not None:
            
            _query_params.append(('introspectionURL', introspection_url))
            
        if introspection_params is not None:
            
            _query_params.append(('introspectionParams', introspection_params))
            
        if required_root_field is not None:
            
            _query_params.append(('requiredRootField', required_root_field))
            
        if enable_mfa is not None:
            
            _query_params.append(('enableMFA', enable_mfa))
            
        if size_mfa is not None:
            
            _query_params.append(('sizeMFA', size_mfa))
            
        if shelf_life_mfa is not None:
            
            _query_params.append(('shelfLifeMFA', shelf_life_mfa))
            
        if oauth_token_url is not None:
            
            _query_params.append(('oauthTokenURL', oauth_token_url))
            
        if oauth_private_key is not None:
            
            _query_params.append(('oauthPrivateKey', oauth_private_key))
            
        if oauth_public_key is not None:
            
            _query_params.append(('oauthPublicKey', oauth_public_key))
            
        if oauth_client_id is not None:
            
            _query_params.append(('oauthClientId', oauth_client_id))
            
        if oauth_secret_key is not None:
            
            _query_params.append(('oauthSecretKey', oauth_secret_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/network/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_credential(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        network_uid: Annotated[StrictStr, Field(description="The third party network identifier")],
        third_party_id: Annotated[StrictStr, Field(description="The third party user id")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Credential

        Delete a third party network on a Sirqul account.

        :param account_id: The account id of the user (required)
        :type account_id: int
        :param network_uid: The third party network identifier (required)
        :type network_uid: str
        :param third_party_id: The third party user id (required)
        :type third_party_id: str
        :param app_key: the application key (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_credential_serialize(
            account_id=account_id,
            network_uid=network_uid,
            third_party_id=third_party_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_credential_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        network_uid: Annotated[StrictStr, Field(description="The third party network identifier")],
        third_party_id: Annotated[StrictStr, Field(description="The third party user id")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Credential

        Delete a third party network on a Sirqul account.

        :param account_id: The account id of the user (required)
        :type account_id: int
        :param network_uid: The third party network identifier (required)
        :type network_uid: str
        :param third_party_id: The third party user id (required)
        :type third_party_id: str
        :param app_key: the application key (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_credential_serialize(
            account_id=account_id,
            network_uid=network_uid,
            third_party_id=third_party_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_credential_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        network_uid: Annotated[StrictStr, Field(description="The third party network identifier")],
        third_party_id: Annotated[StrictStr, Field(description="The third party user id")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Credential

        Delete a third party network on a Sirqul account.

        :param account_id: The account id of the user (required)
        :type account_id: int
        :param network_uid: The third party network identifier (required)
        :type network_uid: str
        :param third_party_id: The third party user id (required)
        :type third_party_id: str
        :param app_key: the application key (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_credential_serialize(
            account_id=account_id,
            network_uid=network_uid,
            third_party_id=third_party_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_credential_serialize(
        self,
        account_id,
        network_uid,
        third_party_id,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if third_party_id is not None:
            
            _query_params.append(('thirdPartyId', third_party_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/credential/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_network(
        self,
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Network

        Marks a custom third party network as deleted. Only the network owners and managers have access to this.

        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_network_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Network

        Marks a custom third party network as deleted. Only the network owners and managers have access to this.

        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_network_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Network

        Marks a custom third party network as deleted. Only the network owners and managers have access to this.

        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_network_serialize(
        self,
        account_id,
        network_uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/network/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_credential(
        self,
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the unique account id of a specific account that will be bound to the third-party credentials")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        session_id: Annotated[Optional[StrictStr], Field(description="the session id for the request")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="the third-party credentials id from the response of the credential/create step")] = None,
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with")] = None,
        third_party_secret: Annotated[Optional[StrictStr], Field(description="the secret code to authenticate with (used for MFA)")] = None,
        create_new_account: Annotated[Optional[StrictBool], Field(description="flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="audience ids to add to the account")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="audience ids to remove from the account")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="account id of the referrer (inviter-invitee relationship)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Get Credential

        Gets the account information given a third party token.

        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param account_id: the unique account id of a specific account that will be bound to the third-party credentials
        :type account_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param session_id: the session id for the request
        :type session_id: str
        :param third_party_credential_id: the third-party credentials id from the response of the credential/create step
        :type third_party_credential_id: int
        :param third_party_token: the access token to authenticate with
        :type third_party_token: str
        :param third_party_secret: the secret code to authenticate with (used for MFA)
        :type third_party_secret: str
        :param create_new_account: flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
        :type create_new_account: bool
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param audience_ids_to_add: audience ids to add to the account
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: audience ids to remove from the account
        :type audience_ids_to_remove: str
        :param referral_account_id: account id of the referrer (inviter-invitee relationship)
        :type referral_account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_credential_serialize(
            network_uid=network_uid,
            app_key=app_key,
            account_id=account_id,
            device_id=device_id,
            session_id=session_id,
            third_party_credential_id=third_party_credential_id,
            third_party_token=third_party_token,
            third_party_secret=third_party_secret,
            create_new_account=create_new_account,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            referral_account_id=referral_account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_credential_with_http_info(
        self,
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the unique account id of a specific account that will be bound to the third-party credentials")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        session_id: Annotated[Optional[StrictStr], Field(description="the session id for the request")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="the third-party credentials id from the response of the credential/create step")] = None,
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with")] = None,
        third_party_secret: Annotated[Optional[StrictStr], Field(description="the secret code to authenticate with (used for MFA)")] = None,
        create_new_account: Annotated[Optional[StrictBool], Field(description="flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="audience ids to add to the account")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="audience ids to remove from the account")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="account id of the referrer (inviter-invitee relationship)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Get Credential

        Gets the account information given a third party token.

        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param account_id: the unique account id of a specific account that will be bound to the third-party credentials
        :type account_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param session_id: the session id for the request
        :type session_id: str
        :param third_party_credential_id: the third-party credentials id from the response of the credential/create step
        :type third_party_credential_id: int
        :param third_party_token: the access token to authenticate with
        :type third_party_token: str
        :param third_party_secret: the secret code to authenticate with (used for MFA)
        :type third_party_secret: str
        :param create_new_account: flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
        :type create_new_account: bool
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param audience_ids_to_add: audience ids to add to the account
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: audience ids to remove from the account
        :type audience_ids_to_remove: str
        :param referral_account_id: account id of the referrer (inviter-invitee relationship)
        :type referral_account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_credential_serialize(
            network_uid=network_uid,
            app_key=app_key,
            account_id=account_id,
            device_id=device_id,
            session_id=session_id,
            third_party_credential_id=third_party_credential_id,
            third_party_token=third_party_token,
            third_party_secret=third_party_secret,
            create_new_account=create_new_account,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            referral_account_id=referral_account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_credential_without_preload_content(
        self,
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the unique account id of a specific account that will be bound to the third-party credentials")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        session_id: Annotated[Optional[StrictStr], Field(description="the session id for the request")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="the third-party credentials id from the response of the credential/create step")] = None,
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with")] = None,
        third_party_secret: Annotated[Optional[StrictStr], Field(description="the secret code to authenticate with (used for MFA)")] = None,
        create_new_account: Annotated[Optional[StrictBool], Field(description="flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the user")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="audience ids to add to the account")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="audience ids to remove from the account")] = None,
        referral_account_id: Annotated[Optional[StrictInt], Field(description="account id of the referrer (inviter-invitee relationship)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Credential

        Gets the account information given a third party token.

        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param account_id: the unique account id of a specific account that will be bound to the third-party credentials
        :type account_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param session_id: the session id for the request
        :type session_id: str
        :param third_party_credential_id: the third-party credentials id from the response of the credential/create step
        :type third_party_credential_id: int
        :param third_party_token: the access token to authenticate with
        :type third_party_token: str
        :param third_party_secret: the secret code to authenticate with (used for MFA)
        :type third_party_secret: str
        :param create_new_account: flag to force creation of a new account when no accountId is passed and user chooses not to use listed accounts
        :type create_new_account: bool
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param latitude: the latitude of the user
        :type latitude: float
        :param longitude: the longitude of the user
        :type longitude: float
        :param audience_ids_to_add: audience ids to add to the account
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: audience ids to remove from the account
        :type audience_ids_to_remove: str
        :param referral_account_id: account id of the referrer (inviter-invitee relationship)
        :type referral_account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_credential_serialize(
            network_uid=network_uid,
            app_key=app_key,
            account_id=account_id,
            device_id=device_id,
            session_id=session_id,
            third_party_credential_id=third_party_credential_id,
            third_party_token=third_party_token,
            third_party_secret=third_party_secret,
            create_new_account=create_new_account,
            response_filters=response_filters,
            latitude=latitude,
            longitude=longitude,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            referral_account_id=referral_account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_credential_serialize(
        self,
        network_uid,
        app_key,
        account_id,
        device_id,
        session_id,
        third_party_credential_id,
        third_party_token,
        third_party_secret,
        create_new_account,
        response_filters,
        latitude,
        longitude,
        audience_ids_to_add,
        audience_ids_to_remove,
        referral_account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if session_id is not None:
            
            _query_params.append(('sessionId', session_id))
            
        if third_party_credential_id is not None:
            
            _query_params.append(('thirdPartyCredentialId', third_party_credential_id))
            
        if third_party_token is not None:
            
            _query_params.append(('thirdPartyToken', third_party_token))
            
        if third_party_secret is not None:
            
            _query_params.append(('thirdPartySecret', third_party_secret))
            
        if create_new_account is not None:
            
            _query_params.append(('createNewAccount', create_new_account))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if audience_ids_to_remove is not None:
            
            _query_params.append(('audienceIdsToRemove', audience_ids_to_remove))
            
        if referral_account_id is not None:
            
            _query_params.append(('referralAccountId', referral_account_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/credential/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_network(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ThirdPartyNetworkResponse:
        """Get Network

        Get the details of a third party network. Only the network owners and managers have access to this.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_network_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ThirdPartyNetworkResponse]:
        """Get Network

        Get the details of a third party network. Only the network owners and managers have access to this.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_network_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Network

        Get the details of a third party network. Only the network owners and managers have access to this.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_network_serialize(
        self,
        account_id,
        network_uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/thirdparty/network/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_credentials(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search on the third party name and network string")] = None,
        network_uid: Annotated[Optional[StrictStr], Field(description="The network UID to filter results with")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ThirdPartyCredentialResponse]:
        """Search Credentials

        Search on a user's linked third party networks.

        :param account_id: The account id of the user (required)
        :type account_id: int
        :param keyword: The keyword used to search on the third party name and network string
        :type keyword: str
        :param network_uid: The network UID to filter results with
        :type network_uid: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The start of the pagination
        :type start: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_credentials_serialize(
            account_id=account_id,
            keyword=keyword,
            network_uid=network_uid,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ThirdPartyCredentialResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_credentials_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search on the third party name and network string")] = None,
        network_uid: Annotated[Optional[StrictStr], Field(description="The network UID to filter results with")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ThirdPartyCredentialResponse]]:
        """Search Credentials

        Search on a user's linked third party networks.

        :param account_id: The account id of the user (required)
        :type account_id: int
        :param keyword: The keyword used to search on the third party name and network string
        :type keyword: str
        :param network_uid: The network UID to filter results with
        :type network_uid: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The start of the pagination
        :type start: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_credentials_serialize(
            account_id=account_id,
            keyword=keyword,
            network_uid=network_uid,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ThirdPartyCredentialResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_credentials_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search on the third party name and network string")] = None,
        network_uid: Annotated[Optional[StrictStr], Field(description="The network UID to filter results with")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Credentials

        Search on a user's linked third party networks.

        :param account_id: The account id of the user (required)
        :type account_id: int
        :param keyword: The keyword used to search on the third party name and network string
        :type keyword: str
        :param network_uid: The network UID to filter results with
        :type network_uid: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The start of the pagination
        :type start: int
        :param limit: The limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_credentials_serialize(
            account_id=account_id,
            keyword=keyword,
            network_uid=network_uid,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ThirdPartyCredentialResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_credentials_serialize(
        self,
        account_id,
        keyword,
        network_uid,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/thirdparty/credential/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_networks(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search on the network name and description fields")] = None,
        filter_billable: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user has access to")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ThirdPartyNetworkShortResponse]:
        """Search Networks

        Search on supported third party networks and custom networks from external users.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param sort_field: The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The start of the pagination (required)
        :type start: int
        :param limit: The limit of the pagination (required)
        :type limit: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param keyword: The keyword used to search on the network name and description fields
        :type keyword: str
        :param filter_billable: Determines whether to only return applications that the user has access to
        :type filter_billable: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_networks_serialize(
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            keyword=keyword,
            filter_billable=filter_billable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ThirdPartyNetworkShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_networks_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search on the network name and description fields")] = None,
        filter_billable: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user has access to")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ThirdPartyNetworkShortResponse]]:
        """Search Networks

        Search on supported third party networks and custom networks from external users.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param sort_field: The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The start of the pagination (required)
        :type start: int
        :param limit: The limit of the pagination (required)
        :type limit: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param keyword: The keyword used to search on the network name and description fields
        :type keyword: str
        :param filter_billable: Determines whether to only return applications that the user has access to
        :type filter_billable: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_networks_serialize(
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            keyword=keyword,
            filter_billable=filter_billable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ThirdPartyNetworkShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_networks_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search on the network name and description fields")] = None,
        filter_billable: Annotated[Optional[StrictBool], Field(description="Determines whether to only return applications that the user has access to")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Networks

        Search on supported third party networks and custom networks from external users.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param sort_field: The column to sort the search on, possible values include: UPDATED (default), CREATED, NAME (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The start of the pagination (required)
        :type start: int
        :param limit: The limit of the pagination (required)
        :type limit: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param keyword: The keyword used to search on the network name and description fields
        :type keyword: str
        :param filter_billable: Determines whether to only return applications that the user has access to
        :type filter_billable: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_networks_serialize(
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            keyword=keyword,
            filter_billable=filter_billable,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ThirdPartyNetworkShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_networks_serialize(
        self,
        account_id,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        keyword,
        filter_billable,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if filter_billable is not None:
            
            _query_params.append(('filterBillable', filter_billable))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/thirdparty/network/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def send_mfa_challenge(
        self,
        network_uid: Annotated[StrictStr, Field(description="the third party network provider that has MFA enabled")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="optional id of the existing third party credential")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Send MFA Challenge

        Sends an MFA challenge (SMS or Email) for networks with MFA enabled.

        :param network_uid: the third party network provider that has MFA enabled (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param third_party_token: the access token to authenticate with
        :type third_party_token: str
        :param third_party_credential_id: optional id of the existing third party credential
        :type third_party_credential_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_mfa_challenge_serialize(
            network_uid=network_uid,
            app_key=app_key,
            third_party_token=third_party_token,
            third_party_credential_id=third_party_credential_id,
            device_id=device_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def send_mfa_challenge_with_http_info(
        self,
        network_uid: Annotated[StrictStr, Field(description="the third party network provider that has MFA enabled")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="optional id of the existing third party credential")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Send MFA Challenge

        Sends an MFA challenge (SMS or Email) for networks with MFA enabled.

        :param network_uid: the third party network provider that has MFA enabled (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param third_party_token: the access token to authenticate with
        :type third_party_token: str
        :param third_party_credential_id: optional id of the existing third party credential
        :type third_party_credential_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_mfa_challenge_serialize(
            network_uid=network_uid,
            app_key=app_key,
            third_party_token=third_party_token,
            third_party_credential_id=third_party_credential_id,
            device_id=device_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def send_mfa_challenge_without_preload_content(
        self,
        network_uid: Annotated[StrictStr, Field(description="the third party network provider that has MFA enabled")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with")] = None,
        third_party_credential_id: Annotated[Optional[StrictInt], Field(description="optional id of the existing third party credential")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send MFA Challenge

        Sends an MFA challenge (SMS or Email) for networks with MFA enabled.

        :param network_uid: the third party network provider that has MFA enabled (required)
        :type network_uid: str
        :param app_key: the application key (required)
        :type app_key: str
        :param third_party_token: the access token to authenticate with
        :type third_party_token: str
        :param third_party_credential_id: optional id of the existing third party credential
        :type third_party_credential_id: int
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_mfa_challenge_serialize(
            network_uid=network_uid,
            app_key=app_key,
            third_party_token=third_party_token,
            third_party_credential_id=third_party_credential_id,
            device_id=device_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_mfa_challenge_serialize(
        self,
        network_uid,
        app_key,
        third_party_token,
        third_party_credential_id,
        device_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if third_party_token is not None:
            
            _query_params.append(('thirdPartyToken', third_party_token))
            
        if third_party_credential_id is not None:
            
            _query_params.append(('thirdPartyCredentialId', third_party_credential_id))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/credential/mfa/send',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_credential(
        self,
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        third_party_id: Annotated[StrictStr, Field(description="the third party user account id")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        third_party_name: Annotated[Optional[StrictStr], Field(description="the third party user name")] = None,
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with (ex: username or fb token)")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        third_party_refresh_token: Annotated[Optional[StrictStr], Field(description="optional refresh token for the third party")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Update Credential

        Updates a third-party login for an account.

        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param third_party_id: the third party user account id (required)
        :type third_party_id: str
        :param app_key: the application key (required)
        :type app_key: str
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param third_party_name: the third party user name
        :type third_party_name: str
        :param third_party_token: the access token to authenticate with (ex: username or fb token)
        :type third_party_token: str
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param third_party_refresh_token: optional refresh token for the third party
        :type third_party_refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_credential_serialize(
            network_uid=network_uid,
            third_party_id=third_party_id,
            app_key=app_key,
            device_id=device_id,
            third_party_name=third_party_name,
            third_party_token=third_party_token,
            response_filters=response_filters,
            meta_data=meta_data,
            third_party_refresh_token=third_party_refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_credential_with_http_info(
        self,
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        third_party_id: Annotated[StrictStr, Field(description="the third party user account id")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        third_party_name: Annotated[Optional[StrictStr], Field(description="the third party user name")] = None,
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with (ex: username or fb token)")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        third_party_refresh_token: Annotated[Optional[StrictStr], Field(description="optional refresh token for the third party")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Update Credential

        Updates a third-party login for an account.

        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param third_party_id: the third party user account id (required)
        :type third_party_id: str
        :param app_key: the application key (required)
        :type app_key: str
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param third_party_name: the third party user name
        :type third_party_name: str
        :param third_party_token: the access token to authenticate with (ex: username or fb token)
        :type third_party_token: str
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param third_party_refresh_token: optional refresh token for the third party
        :type third_party_refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_credential_serialize(
            network_uid=network_uid,
            third_party_id=third_party_id,
            app_key=app_key,
            device_id=device_id,
            third_party_name=third_party_name,
            third_party_token=third_party_token,
            response_filters=response_filters,
            meta_data=meta_data,
            third_party_refresh_token=third_party_refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_credential_without_preload_content(
        self,
        network_uid: Annotated[StrictStr, Field(description="the access provider to authenticate against")],
        third_party_id: Annotated[StrictStr, Field(description="the third party user account id")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request")] = None,
        third_party_name: Annotated[Optional[StrictStr], Field(description="the third party user name")] = None,
        third_party_token: Annotated[Optional[StrictStr], Field(description="the access token to authenticate with (ex: username or fb token)")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="this determines how much of the profile should be returned, see ProfileFilters")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        third_party_refresh_token: Annotated[Optional[StrictStr], Field(description="optional refresh token for the third party")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Credential

        Updates a third-party login for an account.

        :param network_uid: the access provider to authenticate against (required)
        :type network_uid: str
        :param third_party_id: the third party user account id (required)
        :type third_party_id: str
        :param app_key: the application key (required)
        :type app_key: str
        :param device_id: the unique id of the device making the request
        :type device_id: str
        :param third_party_name: the third party user name
        :type third_party_name: str
        :param third_party_token: the access token to authenticate with (ex: username or fb token)
        :type third_party_token: str
        :param response_filters: this determines how much of the profile should be returned, see ProfileFilters
        :type response_filters: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param third_party_refresh_token: optional refresh token for the third party
        :type third_party_refresh_token: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_credential_serialize(
            network_uid=network_uid,
            third_party_id=third_party_id,
            app_key=app_key,
            device_id=device_id,
            third_party_name=third_party_name,
            third_party_token=third_party_token,
            response_filters=response_filters,
            meta_data=meta_data,
            third_party_refresh_token=third_party_refresh_token,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_credential_serialize(
        self,
        network_uid,
        third_party_id,
        app_key,
        device_id,
        third_party_name,
        third_party_token,
        response_filters,
        meta_data,
        third_party_refresh_token,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if third_party_id is not None:
            
            _query_params.append(('thirdPartyId', third_party_id))
            
        if third_party_name is not None:
            
            _query_params.append(('thirdPartyName', third_party_name))
            
        if third_party_token is not None:
            
            _query_params.append(('thirdPartyToken', third_party_token))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if third_party_refresh_token is not None:
            
            _query_params.append(('thirdPartyRefreshToken', third_party_refresh_token))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/credential/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_network(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the network")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the network")] = None,
        enable_introspection: Annotated[Optional[StrictBool], Field(description="Whether the network uses introspection calls")] = None,
        introspection_method: Annotated[Optional[StrictStr], Field(description="HTTP method to use for introspection calls (e.g., GET, POST)")] = None,
        introspection_url: Annotated[Optional[StrictStr], Field(description="The HTTP URL of the introspection call")] = None,
        introspection_params: Annotated[Optional[StrictStr], Field(description="The parameters of the introspection call")] = None,
        required_root_field: Annotated[Optional[StrictStr], Field(description="Required response params")] = None,
        enable_mfa: Annotated[Optional[StrictBool], Field(description="Whether this network uses MFA")] = None,
        size_mfa: Annotated[Optional[StrictInt], Field(description="Size of the MFA token")] = None,
        shelf_life_mfa: Annotated[Optional[StrictInt], Field(description="Shelf life (seconds) of the MFA token")] = None,
        oauth_token_url: Annotated[Optional[StrictStr], Field(description="OAuth token endpoint URL")] = None,
        oauth_private_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth private key file (multipart)")] = None,
        oauth_public_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth public key file (multipart)")] = None,
        oauth_client_id: Annotated[Optional[StrictStr], Field(description="OAuth client id")] = None,
        oauth_secret_key: Annotated[Optional[StrictStr], Field(description="OAuth secret key")] = None,
        body: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ThirdPartyNetworkResponse:
        """Update Network

        Updates a custom third party network. Only the network owners and managers have access to this.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param name: The name of the network
        :type name: str
        :param description: The description of the network
        :type description: str
        :param enable_introspection: Whether the network uses introspection calls
        :type enable_introspection: bool
        :param introspection_method: HTTP method to use for introspection calls (e.g., GET, POST)
        :type introspection_method: str
        :param introspection_url: The HTTP URL of the introspection call
        :type introspection_url: str
        :param introspection_params: The parameters of the introspection call
        :type introspection_params: str
        :param required_root_field: Required response params
        :type required_root_field: str
        :param enable_mfa: Whether this network uses MFA
        :type enable_mfa: bool
        :param size_mfa: Size of the MFA token
        :type size_mfa: int
        :param shelf_life_mfa: Shelf life (seconds) of the MFA token
        :type shelf_life_mfa: int
        :param oauth_token_url: OAuth token endpoint URL
        :type oauth_token_url: str
        :param oauth_private_key: OAuth private key file (multipart)
        :type oauth_private_key: bytearray
        :param oauth_public_key: OAuth public key file (multipart)
        :type oauth_public_key: bytearray
        :param oauth_client_id: OAuth client id
        :type oauth_client_id: str
        :param oauth_secret_key: OAuth secret key
        :type oauth_secret_key: str
        :param body:
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            name=name,
            description=description,
            enable_introspection=enable_introspection,
            introspection_method=introspection_method,
            introspection_url=introspection_url,
            introspection_params=introspection_params,
            required_root_field=required_root_field,
            enable_mfa=enable_mfa,
            size_mfa=size_mfa,
            shelf_life_mfa=shelf_life_mfa,
            oauth_token_url=oauth_token_url,
            oauth_private_key=oauth_private_key,
            oauth_public_key=oauth_public_key,
            oauth_client_id=oauth_client_id,
            oauth_secret_key=oauth_secret_key,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_network_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the network")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the network")] = None,
        enable_introspection: Annotated[Optional[StrictBool], Field(description="Whether the network uses introspection calls")] = None,
        introspection_method: Annotated[Optional[StrictStr], Field(description="HTTP method to use for introspection calls (e.g., GET, POST)")] = None,
        introspection_url: Annotated[Optional[StrictStr], Field(description="The HTTP URL of the introspection call")] = None,
        introspection_params: Annotated[Optional[StrictStr], Field(description="The parameters of the introspection call")] = None,
        required_root_field: Annotated[Optional[StrictStr], Field(description="Required response params")] = None,
        enable_mfa: Annotated[Optional[StrictBool], Field(description="Whether this network uses MFA")] = None,
        size_mfa: Annotated[Optional[StrictInt], Field(description="Size of the MFA token")] = None,
        shelf_life_mfa: Annotated[Optional[StrictInt], Field(description="Shelf life (seconds) of the MFA token")] = None,
        oauth_token_url: Annotated[Optional[StrictStr], Field(description="OAuth token endpoint URL")] = None,
        oauth_private_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth private key file (multipart)")] = None,
        oauth_public_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth public key file (multipart)")] = None,
        oauth_client_id: Annotated[Optional[StrictStr], Field(description="OAuth client id")] = None,
        oauth_secret_key: Annotated[Optional[StrictStr], Field(description="OAuth secret key")] = None,
        body: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ThirdPartyNetworkResponse]:
        """Update Network

        Updates a custom third party network. Only the network owners and managers have access to this.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param name: The name of the network
        :type name: str
        :param description: The description of the network
        :type description: str
        :param enable_introspection: Whether the network uses introspection calls
        :type enable_introspection: bool
        :param introspection_method: HTTP method to use for introspection calls (e.g., GET, POST)
        :type introspection_method: str
        :param introspection_url: The HTTP URL of the introspection call
        :type introspection_url: str
        :param introspection_params: The parameters of the introspection call
        :type introspection_params: str
        :param required_root_field: Required response params
        :type required_root_field: str
        :param enable_mfa: Whether this network uses MFA
        :type enable_mfa: bool
        :param size_mfa: Size of the MFA token
        :type size_mfa: int
        :param shelf_life_mfa: Shelf life (seconds) of the MFA token
        :type shelf_life_mfa: int
        :param oauth_token_url: OAuth token endpoint URL
        :type oauth_token_url: str
        :param oauth_private_key: OAuth private key file (multipart)
        :type oauth_private_key: bytearray
        :param oauth_public_key: OAuth public key file (multipart)
        :type oauth_public_key: bytearray
        :param oauth_client_id: OAuth client id
        :type oauth_client_id: str
        :param oauth_secret_key: OAuth secret key
        :type oauth_secret_key: str
        :param body:
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            name=name,
            description=description,
            enable_introspection=enable_introspection,
            introspection_method=introspection_method,
            introspection_url=introspection_url,
            introspection_params=introspection_params,
            required_root_field=required_root_field,
            enable_mfa=enable_mfa,
            size_mfa=size_mfa,
            shelf_life_mfa=shelf_life_mfa,
            oauth_token_url=oauth_token_url,
            oauth_private_key=oauth_private_key,
            oauth_public_key=oauth_public_key,
            oauth_client_id=oauth_client_id,
            oauth_secret_key=oauth_secret_key,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_network_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account id making the request")],
        network_uid: Annotated[StrictStr, Field(description="The unique identifier for the third party network defined by Sirqul")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the network")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the network")] = None,
        enable_introspection: Annotated[Optional[StrictBool], Field(description="Whether the network uses introspection calls")] = None,
        introspection_method: Annotated[Optional[StrictStr], Field(description="HTTP method to use for introspection calls (e.g., GET, POST)")] = None,
        introspection_url: Annotated[Optional[StrictStr], Field(description="The HTTP URL of the introspection call")] = None,
        introspection_params: Annotated[Optional[StrictStr], Field(description="The parameters of the introspection call")] = None,
        required_root_field: Annotated[Optional[StrictStr], Field(description="Required response params")] = None,
        enable_mfa: Annotated[Optional[StrictBool], Field(description="Whether this network uses MFA")] = None,
        size_mfa: Annotated[Optional[StrictInt], Field(description="Size of the MFA token")] = None,
        shelf_life_mfa: Annotated[Optional[StrictInt], Field(description="Shelf life (seconds) of the MFA token")] = None,
        oauth_token_url: Annotated[Optional[StrictStr], Field(description="OAuth token endpoint URL")] = None,
        oauth_private_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth private key file (multipart)")] = None,
        oauth_public_key: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="OAuth public key file (multipart)")] = None,
        oauth_client_id: Annotated[Optional[StrictStr], Field(description="OAuth client id")] = None,
        oauth_secret_key: Annotated[Optional[StrictStr], Field(description="OAuth secret key")] = None,
        body: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Network

        Updates a custom third party network. Only the network owners and managers have access to this.

        :param account_id: The account id making the request (required)
        :type account_id: int
        :param network_uid: The unique identifier for the third party network defined by Sirqul (required)
        :type network_uid: str
        :param name: The name of the network
        :type name: str
        :param description: The description of the network
        :type description: str
        :param enable_introspection: Whether the network uses introspection calls
        :type enable_introspection: bool
        :param introspection_method: HTTP method to use for introspection calls (e.g., GET, POST)
        :type introspection_method: str
        :param introspection_url: The HTTP URL of the introspection call
        :type introspection_url: str
        :param introspection_params: The parameters of the introspection call
        :type introspection_params: str
        :param required_root_field: Required response params
        :type required_root_field: str
        :param enable_mfa: Whether this network uses MFA
        :type enable_mfa: bool
        :param size_mfa: Size of the MFA token
        :type size_mfa: int
        :param shelf_life_mfa: Shelf life (seconds) of the MFA token
        :type shelf_life_mfa: int
        :param oauth_token_url: OAuth token endpoint URL
        :type oauth_token_url: str
        :param oauth_private_key: OAuth private key file (multipart)
        :type oauth_private_key: bytearray
        :param oauth_public_key: OAuth public key file (multipart)
        :type oauth_public_key: bytearray
        :param oauth_client_id: OAuth client id
        :type oauth_client_id: str
        :param oauth_secret_key: OAuth secret key
        :type oauth_secret_key: str
        :param body:
        :type body: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_network_serialize(
            account_id=account_id,
            network_uid=network_uid,
            name=name,
            description=description,
            enable_introspection=enable_introspection,
            introspection_method=introspection_method,
            introspection_url=introspection_url,
            introspection_params=introspection_params,
            required_root_field=required_root_field,
            enable_mfa=enable_mfa,
            size_mfa=size_mfa,
            shelf_life_mfa=shelf_life_mfa,
            oauth_token_url=oauth_token_url,
            oauth_private_key=oauth_private_key,
            oauth_public_key=oauth_public_key,
            oauth_client_id=oauth_client_id,
            oauth_secret_key=oauth_secret_key,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ThirdPartyNetworkResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_network_serialize(
        self,
        account_id,
        network_uid,
        name,
        description,
        enable_introspection,
        introspection_method,
        introspection_url,
        introspection_params,
        required_root_field,
        enable_mfa,
        size_mfa,
        shelf_life_mfa,
        oauth_token_url,
        oauth_private_key,
        oauth_public_key,
        oauth_client_id,
        oauth_secret_key,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if network_uid is not None:
            
            _query_params.append(('networkUID', network_uid))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if enable_introspection is not None:
            
            _query_params.append(('enableIntrospection', enable_introspection))
            
        if introspection_method is not None:
            
            _query_params.append(('introspectionMethod', introspection_method))
            
        if introspection_url is not None:
            
            _query_params.append(('introspectionURL', introspection_url))
            
        if introspection_params is not None:
            
            _query_params.append(('introspectionParams', introspection_params))
            
        if required_root_field is not None:
            
            _query_params.append(('requiredRootField', required_root_field))
            
        if enable_mfa is not None:
            
            _query_params.append(('enableMFA', enable_mfa))
            
        if size_mfa is not None:
            
            _query_params.append(('sizeMFA', size_mfa))
            
        if shelf_life_mfa is not None:
            
            _query_params.append(('shelfLifeMFA', shelf_life_mfa))
            
        if oauth_token_url is not None:
            
            _query_params.append(('oauthTokenURL', oauth_token_url))
            
        if oauth_private_key is not None:
            
            _query_params.append(('oauthPrivateKey', oauth_private_key))
            
        if oauth_public_key is not None:
            
            _query_params.append(('oauthPublicKey', oauth_public_key))
            
        if oauth_client_id is not None:
            
            _query_params.append(('oauthClientId', oauth_client_id))
            
        if oauth_secret_key is not None:
            
            _query_params.append(('oauthSecretKey', oauth_secret_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/thirdparty/network/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


