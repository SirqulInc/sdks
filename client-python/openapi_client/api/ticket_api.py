# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.count_response import CountResponse
from openapi_client.models.profile_response import ProfileResponse
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.ticket_list_response import TicketListResponse
from openapi_client.models.ticket_offer_response import TicketOfferResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TicketApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_ticket_count(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account that owns the tickets")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="this is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the applicationkey")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the type of ticket")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CountResponse:
        """Get Ticket Count

        Gets the ticket count.

        :param device_id: the id of the device that owns the tickets
        :type device_id: str
        :param account_id: the id of the account that owns the tickets
        :type account_id: int
        :param game_type: this is deprecated.
        :type game_type: str
        :param app_key: the applicationkey
        :type app_key: str
        :param ticket_type: the type of ticket
        :type ticket_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticket_count_serialize(
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            ticket_type=ticket_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CountResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticket_count_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account that owns the tickets")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="this is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the applicationkey")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the type of ticket")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CountResponse]:
        """Get Ticket Count

        Gets the ticket count.

        :param device_id: the id of the device that owns the tickets
        :type device_id: str
        :param account_id: the id of the account that owns the tickets
        :type account_id: int
        :param game_type: this is deprecated.
        :type game_type: str
        :param app_key: the applicationkey
        :type app_key: str
        :param ticket_type: the type of ticket
        :type ticket_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticket_count_serialize(
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            ticket_type=ticket_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CountResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticket_count_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account that owns the tickets")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="this is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the applicationkey")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the type of ticket")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ticket Count

        Gets the ticket count.

        :param device_id: the id of the device that owns the tickets
        :type device_id: str
        :param account_id: the id of the account that owns the tickets
        :type account_id: int
        :param game_type: this is deprecated.
        :type game_type: str
        :param app_key: the applicationkey
        :type app_key: str
        :param ticket_type: the type of ticket
        :type ticket_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticket_count_serialize(
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            ticket_type=ticket_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CountResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticket_count_serialize(
        self,
        device_id,
        account_id,
        game_type,
        app_key,
        ticket_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if ticket_type is not None:
            
            _query_params.append(('ticketType', ticket_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ticket/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_ticket_list(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account that owns the tickets")] = None,
        ticket_object_type: Annotated[Optional[StrictStr], Field(description="comma separated list of TicketObjectType")] = None,
        action_type: Annotated[Optional[StrictStr], Field(description="comma separated list of TicketActionType")] = None,
        ticket_ids: Annotated[Optional[StrictStr], Field(description="the ids of the tickets to get")] = None,
        object_ids: Annotated[Optional[StrictStr], Field(description="the ids of the objects to get")] = None,
        receipt_tokens: Optional[StrictStr] = None,
        game_type: Optional[StrictStr] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TicketListResponse:
        """Get Ticket List

        Gets the list of tickets.

        :param device_id: the id of the device that owns the tickets
        :type device_id: str
        :param account_id: the id of the account that owns the tickets
        :type account_id: int
        :param ticket_object_type: comma separated list of TicketObjectType
        :type ticket_object_type: str
        :param action_type: comma separated list of TicketActionType
        :type action_type: str
        :param ticket_ids: the ids of the tickets to get
        :type ticket_ids: str
        :param object_ids: the ids of the objects to get
        :type object_ids: str
        :param receipt_tokens: 
        :type receipt_tokens: str
        :param game_type: 
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticket_list_serialize(
            device_id=device_id,
            account_id=account_id,
            ticket_object_type=ticket_object_type,
            action_type=action_type,
            ticket_ids=ticket_ids,
            object_ids=object_ids,
            receipt_tokens=receipt_tokens,
            game_type=game_type,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TicketListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_ticket_list_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account that owns the tickets")] = None,
        ticket_object_type: Annotated[Optional[StrictStr], Field(description="comma separated list of TicketObjectType")] = None,
        action_type: Annotated[Optional[StrictStr], Field(description="comma separated list of TicketActionType")] = None,
        ticket_ids: Annotated[Optional[StrictStr], Field(description="the ids of the tickets to get")] = None,
        object_ids: Annotated[Optional[StrictStr], Field(description="the ids of the objects to get")] = None,
        receipt_tokens: Optional[StrictStr] = None,
        game_type: Optional[StrictStr] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TicketListResponse]:
        """Get Ticket List

        Gets the list of tickets.

        :param device_id: the id of the device that owns the tickets
        :type device_id: str
        :param account_id: the id of the account that owns the tickets
        :type account_id: int
        :param ticket_object_type: comma separated list of TicketObjectType
        :type ticket_object_type: str
        :param action_type: comma separated list of TicketActionType
        :type action_type: str
        :param ticket_ids: the ids of the tickets to get
        :type ticket_ids: str
        :param object_ids: the ids of the objects to get
        :type object_ids: str
        :param receipt_tokens: 
        :type receipt_tokens: str
        :param game_type: 
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticket_list_serialize(
            device_id=device_id,
            account_id=account_id,
            ticket_object_type=ticket_object_type,
            action_type=action_type,
            ticket_ids=ticket_ids,
            object_ids=object_ids,
            receipt_tokens=receipt_tokens,
            game_type=game_type,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TicketListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_ticket_list_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account that owns the tickets")] = None,
        ticket_object_type: Annotated[Optional[StrictStr], Field(description="comma separated list of TicketObjectType")] = None,
        action_type: Annotated[Optional[StrictStr], Field(description="comma separated list of TicketActionType")] = None,
        ticket_ids: Annotated[Optional[StrictStr], Field(description="the ids of the tickets to get")] = None,
        object_ids: Annotated[Optional[StrictStr], Field(description="the ids of the objects to get")] = None,
        receipt_tokens: Optional[StrictStr] = None,
        game_type: Optional[StrictStr] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ticket List

        Gets the list of tickets.

        :param device_id: the id of the device that owns the tickets
        :type device_id: str
        :param account_id: the id of the account that owns the tickets
        :type account_id: int
        :param ticket_object_type: comma separated list of TicketObjectType
        :type ticket_object_type: str
        :param action_type: comma separated list of TicketActionType
        :type action_type: str
        :param ticket_ids: the ids of the tickets to get
        :type ticket_ids: str
        :param object_ids: the ids of the objects to get
        :type object_ids: str
        :param receipt_tokens: 
        :type receipt_tokens: str
        :param game_type: 
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_ticket_list_serialize(
            device_id=device_id,
            account_id=account_id,
            ticket_object_type=ticket_object_type,
            action_type=action_type,
            ticket_ids=ticket_ids,
            object_ids=object_ids,
            receipt_tokens=receipt_tokens,
            game_type=game_type,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TicketListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_ticket_list_serialize(
        self,
        device_id,
        account_id,
        ticket_object_type,
        action_type,
        ticket_ids,
        object_ids,
        receipt_tokens,
        game_type,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if ticket_object_type is not None:
            
            _query_params.append(('ticketObjectType', ticket_object_type))
            
        if action_type is not None:
            
            _query_params.append(('actionType', action_type))
            
        if ticket_ids is not None:
            
            _query_params.append(('ticketIds', ticket_ids))
            
        if object_ids is not None:
            
            _query_params.append(('objectIds', object_ids))
            
        if receipt_tokens is not None:
            
            _query_params.append(('receiptTokens', receipt_tokens))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ticket/getList',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def gift_purchase(
        self,
        receiver_account_id: Annotated[StrictInt, Field(description="the id of the account receiving the tickets")],
        ticket_id: Annotated[StrictInt, Field(description="the id of the tickets")],
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the gift owner")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the id of the asset")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="a message that can be written to go along with the gift")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="the type of game associated with the tickets")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Gift Tickets

        Gift tickets to another user.

        :param receiver_account_id: the id of the account receiving the tickets (required)
        :type receiver_account_id: int
        :param ticket_id: the id of the tickets (required)
        :type ticket_id: int
        :param device_id: the id of the device
        :type device_id: str
        :param account_id: the id of the gift owner
        :type account_id: int
        :param asset_id: the id of the asset
        :type asset_id: int
        :param custom_message: a message that can be written to go along with the gift
        :type custom_message: str
        :param game_type: the type of game associated with the tickets
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gift_purchase_serialize(
            receiver_account_id=receiver_account_id,
            ticket_id=ticket_id,
            device_id=device_id,
            account_id=account_id,
            asset_id=asset_id,
            custom_message=custom_message,
            game_type=game_type,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def gift_purchase_with_http_info(
        self,
        receiver_account_id: Annotated[StrictInt, Field(description="the id of the account receiving the tickets")],
        ticket_id: Annotated[StrictInt, Field(description="the id of the tickets")],
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the gift owner")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the id of the asset")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="a message that can be written to go along with the gift")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="the type of game associated with the tickets")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Gift Tickets

        Gift tickets to another user.

        :param receiver_account_id: the id of the account receiving the tickets (required)
        :type receiver_account_id: int
        :param ticket_id: the id of the tickets (required)
        :type ticket_id: int
        :param device_id: the id of the device
        :type device_id: str
        :param account_id: the id of the gift owner
        :type account_id: int
        :param asset_id: the id of the asset
        :type asset_id: int
        :param custom_message: a message that can be written to go along with the gift
        :type custom_message: str
        :param game_type: the type of game associated with the tickets
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gift_purchase_serialize(
            receiver_account_id=receiver_account_id,
            ticket_id=ticket_id,
            device_id=device_id,
            account_id=account_id,
            asset_id=asset_id,
            custom_message=custom_message,
            game_type=game_type,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def gift_purchase_without_preload_content(
        self,
        receiver_account_id: Annotated[StrictInt, Field(description="the id of the account receiving the tickets")],
        ticket_id: Annotated[StrictInt, Field(description="the id of the tickets")],
        device_id: Annotated[Optional[StrictStr], Field(description="the id of the device")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the gift owner")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the id of the asset")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="a message that can be written to go along with the gift")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="the type of game associated with the tickets")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gift Tickets

        Gift tickets to another user.

        :param receiver_account_id: the id of the account receiving the tickets (required)
        :type receiver_account_id: int
        :param ticket_id: the id of the tickets (required)
        :type ticket_id: int
        :param device_id: the id of the device
        :type device_id: str
        :param account_id: the id of the gift owner
        :type account_id: int
        :param asset_id: the id of the asset
        :type asset_id: int
        :param custom_message: a message that can be written to go along with the gift
        :type custom_message: str
        :param game_type: the type of game associated with the tickets
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._gift_purchase_serialize(
            receiver_account_id=receiver_account_id,
            ticket_id=ticket_id,
            device_id=device_id,
            account_id=account_id,
            asset_id=asset_id,
            custom_message=custom_message,
            game_type=game_type,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _gift_purchase_serialize(
        self,
        receiver_account_id,
        ticket_id,
        device_id,
        account_id,
        asset_id,
        custom_message,
        game_type,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if receiver_account_id is not None:
            
            _query_params.append(('receiverAccountId', receiver_account_id))
            
        if ticket_id is not None:
            
            _query_params.append(('ticketId', ticket_id))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if custom_message is not None:
            
            _query_params.append(('customMessage', custom_message))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/purchase/gift',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_ticket(
        self,
        action_type: Annotated[StrictStr, Field(description="the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER")],
        ticket_object_type: Annotated[StrictStr, Field(description="the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM")],
        return_nulls: Annotated[Optional[StrictBool], Field(description="whether to return nulls or not")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id that owns the tickets")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        object_id: Annotated[Optional[StrictInt], Field(description="the ID of the item being purchased")] = None,
        purchase_code: Annotated[Optional[StrictStr], Field(description="a unique string identifier defined by the application owner or Executive")] = None,
        receipt_token: Annotated[Optional[StrictStr], Field(description="a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)")] = None,
        receipt_data: Annotated[Optional[StrictStr], Field(description="the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="the count of tickets")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the ticket type")] = None,
        purchase_provider: Annotated[Optional[StrictStr], Field(description="the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }")] = None,
        return_profile_response: Annotated[Optional[StrictBool], Field(description="returns a ProfileResponse if true, otherwise will return an AppResponse")] = None,
        include_profile_response: Annotated[Optional[StrictBool], Field(description="if returnProfileResponse is false, will return an AppResponse with profile data if true")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="the application version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Save Ticket

        Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.

        :param action_type: the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER (required)
        :type action_type: str
        :param ticket_object_type: the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM (required)
        :type ticket_object_type: str
        :param return_nulls: whether to return nulls or not
        :type return_nulls: bool
        :param device_id: the device id that owns the tickets
        :type device_id: str
        :param account_id: the account id that owns the tickets
        :type account_id: int
        :param game_type: This parameter is deprecated. deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param object_id: the ID of the item being purchased
        :type object_id: int
        :param purchase_code: a unique string identifier defined by the application owner or Executive
        :type purchase_code: str
        :param receipt_token: a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        :type receipt_token: str
        :param receipt_data: the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
        :type receipt_data: str
        :param count: the count of tickets
        :type count: int
        :param ticket_type: the ticket type
        :type ticket_type: str
        :param purchase_provider: the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        :type purchase_provider: str
        :param purchase_type: a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        :type purchase_type: str
        :param return_profile_response: returns a ProfileResponse if true, otherwise will return an AppResponse
        :type return_profile_response: bool
        :param include_profile_response: if returnProfileResponse is false, will return an AppResponse with profile data if true
        :type include_profile_response: bool
        :param app_version: the application version
        :type app_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_ticket_serialize(
            action_type=action_type,
            ticket_object_type=ticket_object_type,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            object_id=object_id,
            purchase_code=purchase_code,
            receipt_token=receipt_token,
            receipt_data=receipt_data,
            count=count,
            ticket_type=ticket_type,
            purchase_provider=purchase_provider,
            purchase_type=purchase_type,
            return_profile_response=return_profile_response,
            include_profile_response=include_profile_response,
            app_version=app_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_ticket_with_http_info(
        self,
        action_type: Annotated[StrictStr, Field(description="the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER")],
        ticket_object_type: Annotated[StrictStr, Field(description="the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM")],
        return_nulls: Annotated[Optional[StrictBool], Field(description="whether to return nulls or not")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id that owns the tickets")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        object_id: Annotated[Optional[StrictInt], Field(description="the ID of the item being purchased")] = None,
        purchase_code: Annotated[Optional[StrictStr], Field(description="a unique string identifier defined by the application owner or Executive")] = None,
        receipt_token: Annotated[Optional[StrictStr], Field(description="a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)")] = None,
        receipt_data: Annotated[Optional[StrictStr], Field(description="the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="the count of tickets")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the ticket type")] = None,
        purchase_provider: Annotated[Optional[StrictStr], Field(description="the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }")] = None,
        return_profile_response: Annotated[Optional[StrictBool], Field(description="returns a ProfileResponse if true, otherwise will return an AppResponse")] = None,
        include_profile_response: Annotated[Optional[StrictBool], Field(description="if returnProfileResponse is false, will return an AppResponse with profile data if true")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="the application version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Save Ticket

        Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.

        :param action_type: the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER (required)
        :type action_type: str
        :param ticket_object_type: the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM (required)
        :type ticket_object_type: str
        :param return_nulls: whether to return nulls or not
        :type return_nulls: bool
        :param device_id: the device id that owns the tickets
        :type device_id: str
        :param account_id: the account id that owns the tickets
        :type account_id: int
        :param game_type: This parameter is deprecated. deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param object_id: the ID of the item being purchased
        :type object_id: int
        :param purchase_code: a unique string identifier defined by the application owner or Executive
        :type purchase_code: str
        :param receipt_token: a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        :type receipt_token: str
        :param receipt_data: the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
        :type receipt_data: str
        :param count: the count of tickets
        :type count: int
        :param ticket_type: the ticket type
        :type ticket_type: str
        :param purchase_provider: the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        :type purchase_provider: str
        :param purchase_type: a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        :type purchase_type: str
        :param return_profile_response: returns a ProfileResponse if true, otherwise will return an AppResponse
        :type return_profile_response: bool
        :param include_profile_response: if returnProfileResponse is false, will return an AppResponse with profile data if true
        :type include_profile_response: bool
        :param app_version: the application version
        :type app_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_ticket_serialize(
            action_type=action_type,
            ticket_object_type=ticket_object_type,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            object_id=object_id,
            purchase_code=purchase_code,
            receipt_token=receipt_token,
            receipt_data=receipt_data,
            count=count,
            ticket_type=ticket_type,
            purchase_provider=purchase_provider,
            purchase_type=purchase_type,
            return_profile_response=return_profile_response,
            include_profile_response=include_profile_response,
            app_version=app_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_ticket_without_preload_content(
        self,
        action_type: Annotated[StrictStr, Field(description="the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER")],
        ticket_object_type: Annotated[StrictStr, Field(description="the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM")],
        return_nulls: Annotated[Optional[StrictBool], Field(description="whether to return nulls or not")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id that owns the tickets")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id that owns the tickets")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        object_id: Annotated[Optional[StrictInt], Field(description="the ID of the item being purchased")] = None,
        purchase_code: Annotated[Optional[StrictStr], Field(description="a unique string identifier defined by the application owner or Executive")] = None,
        receipt_token: Annotated[Optional[StrictStr], Field(description="a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)")] = None,
        receipt_data: Annotated[Optional[StrictStr], Field(description="the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.")] = None,
        count: Annotated[Optional[StrictInt], Field(description="the count of tickets")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the ticket type")] = None,
        purchase_provider: Annotated[Optional[StrictStr], Field(description="the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }")] = None,
        return_profile_response: Annotated[Optional[StrictBool], Field(description="returns a ProfileResponse if true, otherwise will return an AppResponse")] = None,
        include_profile_response: Annotated[Optional[StrictBool], Field(description="if returnProfileResponse is false, will return an AppResponse with profile data if true")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="the application version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save Ticket

        Allow user to acquire a purchase item and generate a ticket record. Used to redeem tickets or add tickets to the system.

        :param action_type: the action being performed, values: COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER (required)
        :type action_type: str
        :param ticket_object_type: the type of object being purchased, values: GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM (required)
        :type ticket_object_type: str
        :param return_nulls: whether to return nulls or not
        :type return_nulls: bool
        :param device_id: the device id that owns the tickets
        :type device_id: str
        :param account_id: the account id that owns the tickets
        :type account_id: int
        :param game_type: This parameter is deprecated. deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param object_id: the ID of the item being purchased
        :type object_id: int
        :param purchase_code: a unique string identifier defined by the application owner or Executive
        :type purchase_code: str
        :param receipt_token: a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        :type receipt_token: str
        :param receipt_data: the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in string format.
        :type receipt_data: str
        :param count: the count of tickets
        :type count: int
        :param ticket_type: the ticket type
        :type ticket_type: str
        :param purchase_provider: the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        :type purchase_provider: str
        :param purchase_type: a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        :type purchase_type: str
        :param return_profile_response: returns a ProfileResponse if true, otherwise will return an AppResponse
        :type return_profile_response: bool
        :param include_profile_response: if returnProfileResponse is false, will return an AppResponse with profile data if true
        :type include_profile_response: bool
        :param app_version: the application version
        :type app_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_ticket_serialize(
            action_type=action_type,
            ticket_object_type=ticket_object_type,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            object_id=object_id,
            purchase_code=purchase_code,
            receipt_token=receipt_token,
            receipt_data=receipt_data,
            count=count,
            ticket_type=ticket_type,
            purchase_provider=purchase_provider,
            purchase_type=purchase_type,
            return_profile_response=return_profile_response,
            include_profile_response=include_profile_response,
            app_version=app_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_ticket_serialize(
        self,
        action_type,
        ticket_object_type,
        return_nulls,
        device_id,
        account_id,
        game_type,
        app_key,
        object_id,
        purchase_code,
        receipt_token,
        receipt_data,
        count,
        ticket_type,
        purchase_provider,
        purchase_type,
        return_profile_response,
        include_profile_response,
        app_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if action_type is not None:
            
            _query_params.append(('actionType', action_type))
            
        if ticket_object_type is not None:
            
            _query_params.append(('ticketObjectType', ticket_object_type))
            
        if object_id is not None:
            
            _query_params.append(('objectId', object_id))
            
        if purchase_code is not None:
            
            _query_params.append(('purchaseCode', purchase_code))
            
        if receipt_token is not None:
            
            _query_params.append(('receiptToken', receipt_token))
            
        if receipt_data is not None:
            
            _query_params.append(('receiptData', receipt_data))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if ticket_type is not None:
            
            _query_params.append(('ticketType', ticket_type))
            
        if purchase_provider is not None:
            
            _query_params.append(('purchaseProvider', purchase_provider))
            
        if purchase_type is not None:
            
            _query_params.append(('purchaseType', purchase_type))
            
        if return_profile_response is not None:
            
            _query_params.append(('returnProfileResponse', return_profile_response))
            
        if include_profile_response is not None:
            
            _query_params.append(('includeProfileResponse', include_profile_response))
            
        if app_version is not None:
            
            _query_params.append(('appVersion', app_version))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ticket/save',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_ticket_via_file_upload(
        self,
        action_type: Annotated[StrictStr, Field(description="the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }")],
        ticket_object_type: Annotated[StrictStr, Field(description="the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}")],
        receipt_data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.")],
        return_nulls: Annotated[Optional[StrictBool], Field(description="whether to return nulls or not")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        object_id: Annotated[Optional[StrictInt], Field(description="the ID of the item being purchased")] = None,
        purchase_code: Annotated[Optional[StrictStr], Field(description="a unique string identifier defined by the application owner or Executive")] = None,
        receipt_token: Annotated[Optional[StrictStr], Field(description="a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)")] = None,
        count: Annotated[Optional[StrictInt], Field(description="the count of tickets")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the ticket type")] = None,
        purchase_provider: Annotated[Optional[StrictStr], Field(description="the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }")] = None,
        return_profile_response: Annotated[Optional[StrictBool], Field(description="returns a ProfileResponse if true, otherwise will return an AppResponse")] = None,
        include_profile_response: Annotated[Optional[StrictBool], Field(description="if returnProfileResponse is false, will return an AppResponse with profile data if true")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="the application version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ProfileResponse:
        """Save Ticket with Reciept

        Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post

        :param action_type: the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER } (required)
        :type action_type: str
        :param ticket_object_type: the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM} (required)
        :type ticket_object_type: str
        :param receipt_data: the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format. (required)
        :type receipt_data: bytearray
        :param return_nulls: whether to return nulls or not
        :type return_nulls: bool
        :param device_id: the device id
        :type device_id: str
        :param account_id: the account id
        :type account_id: int
        :param game_type: This parameter is deprecated. deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param object_id: the ID of the item being purchased
        :type object_id: int
        :param purchase_code: a unique string identifier defined by the application owner or Executive
        :type purchase_code: str
        :param receipt_token: a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        :type receipt_token: str
        :param count: the count of tickets
        :type count: int
        :param ticket_type: the ticket type
        :type ticket_type: str
        :param purchase_provider: the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        :type purchase_provider: str
        :param purchase_type: a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        :type purchase_type: str
        :param return_profile_response: returns a ProfileResponse if true, otherwise will return an AppResponse
        :type return_profile_response: bool
        :param include_profile_response: if returnProfileResponse is false, will return an AppResponse with profile data if true
        :type include_profile_response: bool
        :param app_version: the application version
        :type app_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_ticket_via_file_upload_serialize(
            action_type=action_type,
            ticket_object_type=ticket_object_type,
            receipt_data=receipt_data,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            object_id=object_id,
            purchase_code=purchase_code,
            receipt_token=receipt_token,
            count=count,
            ticket_type=ticket_type,
            purchase_provider=purchase_provider,
            purchase_type=purchase_type,
            return_profile_response=return_profile_response,
            include_profile_response=include_profile_response,
            app_version=app_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_ticket_via_file_upload_with_http_info(
        self,
        action_type: Annotated[StrictStr, Field(description="the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }")],
        ticket_object_type: Annotated[StrictStr, Field(description="the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}")],
        receipt_data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.")],
        return_nulls: Annotated[Optional[StrictBool], Field(description="whether to return nulls or not")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        object_id: Annotated[Optional[StrictInt], Field(description="the ID of the item being purchased")] = None,
        purchase_code: Annotated[Optional[StrictStr], Field(description="a unique string identifier defined by the application owner or Executive")] = None,
        receipt_token: Annotated[Optional[StrictStr], Field(description="a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)")] = None,
        count: Annotated[Optional[StrictInt], Field(description="the count of tickets")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the ticket type")] = None,
        purchase_provider: Annotated[Optional[StrictStr], Field(description="the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }")] = None,
        return_profile_response: Annotated[Optional[StrictBool], Field(description="returns a ProfileResponse if true, otherwise will return an AppResponse")] = None,
        include_profile_response: Annotated[Optional[StrictBool], Field(description="if returnProfileResponse is false, will return an AppResponse with profile data if true")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="the application version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ProfileResponse]:
        """Save Ticket with Reciept

        Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post

        :param action_type: the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER } (required)
        :type action_type: str
        :param ticket_object_type: the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM} (required)
        :type ticket_object_type: str
        :param receipt_data: the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format. (required)
        :type receipt_data: bytearray
        :param return_nulls: whether to return nulls or not
        :type return_nulls: bool
        :param device_id: the device id
        :type device_id: str
        :param account_id: the account id
        :type account_id: int
        :param game_type: This parameter is deprecated. deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param object_id: the ID of the item being purchased
        :type object_id: int
        :param purchase_code: a unique string identifier defined by the application owner or Executive
        :type purchase_code: str
        :param receipt_token: a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        :type receipt_token: str
        :param count: the count of tickets
        :type count: int
        :param ticket_type: the ticket type
        :type ticket_type: str
        :param purchase_provider: the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        :type purchase_provider: str
        :param purchase_type: a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        :type purchase_type: str
        :param return_profile_response: returns a ProfileResponse if true, otherwise will return an AppResponse
        :type return_profile_response: bool
        :param include_profile_response: if returnProfileResponse is false, will return an AppResponse with profile data if true
        :type include_profile_response: bool
        :param app_version: the application version
        :type app_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_ticket_via_file_upload_serialize(
            action_type=action_type,
            ticket_object_type=ticket_object_type,
            receipt_data=receipt_data,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            object_id=object_id,
            purchase_code=purchase_code,
            receipt_token=receipt_token,
            count=count,
            ticket_type=ticket_type,
            purchase_provider=purchase_provider,
            purchase_type=purchase_type,
            return_profile_response=return_profile_response,
            include_profile_response=include_profile_response,
            app_version=app_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_ticket_via_file_upload_without_preload_content(
        self,
        action_type: Annotated[StrictStr, Field(description="the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER }")],
        ticket_object_type: Annotated[StrictStr, Field(description="the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM}")],
        receipt_data: Annotated[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]], Field(description="the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format.")],
        return_nulls: Annotated[Optional[StrictBool], Field(description="whether to return nulls or not")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        object_id: Annotated[Optional[StrictInt], Field(description="the ID of the item being purchased")] = None,
        purchase_code: Annotated[Optional[StrictStr], Field(description="a unique string identifier defined by the application owner or Executive")] = None,
        receipt_token: Annotated[Optional[StrictStr], Field(description="a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)")] = None,
        count: Annotated[Optional[StrictInt], Field(description="the count of tickets")] = None,
        ticket_type: Annotated[Optional[StrictStr], Field(description="the ticket type")] = None,
        purchase_provider: Annotated[Optional[StrictStr], Field(description="the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}")] = None,
        purchase_type: Annotated[Optional[StrictStr], Field(description="a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }")] = None,
        return_profile_response: Annotated[Optional[StrictBool], Field(description="returns a ProfileResponse if true, otherwise will return an AppResponse")] = None,
        include_profile_response: Annotated[Optional[StrictBool], Field(description="if returnProfileResponse is false, will return an AppResponse with profile data if true")] = None,
        app_version: Annotated[Optional[StrictStr], Field(description="the application version")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Save Ticket with Reciept

        Similar to the Save Ticket endpoint but allows the receiptData to be in binary format. This must be a multi-part post

        :param action_type: the action being performed { COMPLETED, // ADD TICKETS FOR COMPLETING A MISSION, CHALLENGE, GAME, PACK, LEVEL, LEVEL OBJECT REDEEMED, // REMOVE TICKETS FOR BUYING PACKS, HINTS, AND PEN TOOLS OPTIONS, ETC USERS_PLAYED, // ADD TICKETS FOR LEVELS PLAYED BY OTHER USERS TOURNAMENT_OWNER, // ADD TICKETS FOR TOURNAMENTS BY OTHER USERS PURCHASED, // ADD TICKET VIA IN APP PURCHASING SUMATION, // SUMATION OF TICKETS EARNED FROM CHILDREN GIFTED, // TRANSFERING OF PURCHASE ITEMS TO OTHER PEOPLE REFUNDED // FOR REFUNDING TICKETS BACK TO THE USER } (required)
        :type action_type: str
        :param ticket_object_type: the type of object being purchased {GAME_OBJECT, GAME_LEVEL, PACK, GAME, MISSION, PROFILE, APPLICATION, TICKETS, ASSET, CUSTOM} (required)
        :type ticket_object_type: str
        :param receipt_data: the receipt/transaction data for validating a purchase via iTunes/Gooogle/etc. This should be in binary format. (required)
        :type receipt_data: bytearray
        :param return_nulls: whether to return nulls or not
        :type return_nulls: bool
        :param device_id: the device id
        :type device_id: str
        :param account_id: the account id
        :type account_id: int
        :param game_type: This parameter is deprecated. deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param object_id: the ID of the item being purchased
        :type object_id: int
        :param purchase_code: a unique string identifier defined by the application owner or Executive
        :type purchase_code: str
        :param receipt_token: a unique transaction identifier from the purchase provider (i.e. the transaction ID from iTunes, Google Play, etc)
        :type receipt_token: str
        :param count: the count of tickets
        :type count: int
        :param ticket_type: the ticket type
        :type ticket_type: str
        :param purchase_provider: the provider for making the purchase {ITUNES, ITUNES_SANDBOX, GOOGLE}
        :type purchase_provider: str
        :param purchase_type: a comma separated list of purchase types { SIRQUL, // purchasing from the sirqul store using tickets IOS, // purchasing from the itunes store for iPhone, iPod, iPod Touch GOOGLE, // purchasing from the google android store AMAZON, // purchasing from the amazon android store MAC, // purchasing from the itunes store for OSX WP8, // purhasing from the windows phone 8 store FREE }
        :type purchase_type: str
        :param return_profile_response: returns a ProfileResponse if true, otherwise will return an AppResponse
        :type return_profile_response: bool
        :param include_profile_response: if returnProfileResponse is false, will return an AppResponse with profile data if true
        :type include_profile_response: bool
        :param app_version: the application version
        :type app_version: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_ticket_via_file_upload_serialize(
            action_type=action_type,
            ticket_object_type=ticket_object_type,
            receipt_data=receipt_data,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            object_id=object_id,
            purchase_code=purchase_code,
            receipt_token=receipt_token,
            count=count,
            ticket_type=ticket_type,
            purchase_provider=purchase_provider,
            purchase_type=purchase_type,
            return_profile_response=return_profile_response,
            include_profile_response=include_profile_response,
            app_version=app_version,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ProfileResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_ticket_via_file_upload_serialize(
        self,
        action_type,
        ticket_object_type,
        receipt_data,
        return_nulls,
        device_id,
        account_id,
        game_type,
        app_key,
        object_id,
        purchase_code,
        receipt_token,
        count,
        ticket_type,
        purchase_provider,
        purchase_type,
        return_profile_response,
        include_profile_response,
        app_version,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if action_type is not None:
            
            _query_params.append(('actionType', action_type))
            
        if ticket_object_type is not None:
            
            _query_params.append(('ticketObjectType', ticket_object_type))
            
        if object_id is not None:
            
            _query_params.append(('objectId', object_id))
            
        if purchase_code is not None:
            
            _query_params.append(('purchaseCode', purchase_code))
            
        if receipt_token is not None:
            
            _query_params.append(('receiptToken', receipt_token))
            
        if receipt_data is not None:
            
            _query_params.append(('receiptData', receipt_data))
            
        if count is not None:
            
            _query_params.append(('count', count))
            
        if ticket_type is not None:
            
            _query_params.append(('ticketType', ticket_type))
            
        if purchase_provider is not None:
            
            _query_params.append(('purchaseProvider', purchase_provider))
            
        if purchase_type is not None:
            
            _query_params.append(('purchaseType', purchase_type))
            
        if return_profile_response is not None:
            
            _query_params.append(('returnProfileResponse', return_profile_response))
            
        if include_profile_response is not None:
            
            _query_params.append(('includeProfileResponse', include_profile_response))
            
        if app_version is not None:
            
            _query_params.append(('appVersion', app_version))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/ticket/save/fileUpload',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def ticket_offers(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TicketOfferResponse:
        """Get Ticket Offers

        Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ticket_offers_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TicketOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def ticket_offers_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TicketOfferResponse]:
        """Get Ticket Offers

        Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ticket_offers_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TicketOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def ticket_offers_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Ticket Offers

        Get a list offers for tickets owned by sirqul.  Purchasing these will add the number of tickets to the account specified by the offer.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._ticket_offers_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TicketOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _ticket_offers_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/ticket/ticketoffers',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


