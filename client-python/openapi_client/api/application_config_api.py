# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.application_config_response import ApplicationConfigResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ApplicationConfigApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_application_config(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        app_key: Annotated[StrictStr, Field(description="The application key that the newly created applicationConfig will be associated to")],
        config_version: Annotated[StrictStr, Field(description="The application configuration, has to be unique within the application")],
        asset_id: Annotated[StrictInt, Field(description="The json assetId that stores the configuration detail.")],
        retailer_id: Annotated[Optional[StrictInt], Field(description="The retailer id for retailer specific configurations")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="The retailer location id for retailer location specific configurations")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The device udid for device specific configurations")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationConfigResponse:
        """Create AppConfig

        Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param app_key: The application key that the newly created applicationConfig will be associated to (required)
        :type app_key: str
        :param config_version: The application configuration, has to be unique within the application (required)
        :type config_version: str
        :param asset_id: The json assetId that stores the configuration detail. (required)
        :type asset_id: int
        :param retailer_id: The retailer id for retailer specific configurations
        :type retailer_id: int
        :param retailer_location_id: The retailer location id for retailer location specific configurations
        :type retailer_location_id: int
        :param udid: The device udid for device specific configurations
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_config_serialize(
            account_id=account_id,
            app_key=app_key,
            config_version=config_version,
            asset_id=asset_id,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_application_config_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        app_key: Annotated[StrictStr, Field(description="The application key that the newly created applicationConfig will be associated to")],
        config_version: Annotated[StrictStr, Field(description="The application configuration, has to be unique within the application")],
        asset_id: Annotated[StrictInt, Field(description="The json assetId that stores the configuration detail.")],
        retailer_id: Annotated[Optional[StrictInt], Field(description="The retailer id for retailer specific configurations")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="The retailer location id for retailer location specific configurations")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The device udid for device specific configurations")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationConfigResponse]:
        """Create AppConfig

        Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param app_key: The application key that the newly created applicationConfig will be associated to (required)
        :type app_key: str
        :param config_version: The application configuration, has to be unique within the application (required)
        :type config_version: str
        :param asset_id: The json assetId that stores the configuration detail. (required)
        :type asset_id: int
        :param retailer_id: The retailer id for retailer specific configurations
        :type retailer_id: int
        :param retailer_location_id: The retailer location id for retailer location specific configurations
        :type retailer_location_id: int
        :param udid: The device udid for device specific configurations
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_config_serialize(
            account_id=account_id,
            app_key=app_key,
            config_version=config_version,
            asset_id=asset_id,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_application_config_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        app_key: Annotated[StrictStr, Field(description="The application key that the newly created applicationConfig will be associated to")],
        config_version: Annotated[StrictStr, Field(description="The application configuration, has to be unique within the application")],
        asset_id: Annotated[StrictInt, Field(description="The json assetId that stores the configuration detail.")],
        retailer_id: Annotated[Optional[StrictInt], Field(description="The retailer id for retailer specific configurations")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="The retailer location id for retailer location specific configurations")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The device udid for device specific configurations")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create AppConfig

        Creates a new application configuration. If the configVersion provided already exists for the given app, an invalid response is returned and the application configuration won't be created.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param app_key: The application key that the newly created applicationConfig will be associated to (required)
        :type app_key: str
        :param config_version: The application configuration, has to be unique within the application (required)
        :type config_version: str
        :param asset_id: The json assetId that stores the configuration detail. (required)
        :type asset_id: int
        :param retailer_id: The retailer id for retailer specific configurations
        :type retailer_id: int
        :param retailer_location_id: The retailer location id for retailer location specific configurations
        :type retailer_location_id: int
        :param udid: The device udid for device specific configurations
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_application_config_serialize(
            account_id=account_id,
            app_key=app_key,
            config_version=config_version,
            asset_id=asset_id,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_application_config_serialize(
        self,
        account_id,
        app_key,
        config_version,
        asset_id,
        retailer_id,
        retailer_location_id,
        udid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if config_version is not None:
            
            _query_params.append(('configVersion', config_version))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/appconfig/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_application_config(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete AppConfig

        Mark the application configuration for deletion.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration to delete (required)
        :type config_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_application_config_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete AppConfig

        Mark the application configuration for deletion.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration to delete (required)
        :type config_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_application_config_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete AppConfig

        Mark the application configuration for deletion.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration to delete (required)
        :type config_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_application_config_serialize(
        self,
        account_id,
        config_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if config_id is not None:
            
            _query_params.append(('configId', config_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/appconfig/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_application_config(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationConfigResponse:
        """Get AppConfig

        Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration (required)
        :type config_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_application_config_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationConfigResponse]:
        """Get AppConfig

        Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration (required)
        :type config_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_application_config_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get AppConfig

        Gets the appConfig data by the given configId. If appConfig cannot be found, it returns an invalid response.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration (required)
        :type config_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_application_config_serialize(
        self,
        account_id,
        config_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if config_id is not None:
            
            _query_params.append(('configId', config_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/appconfig/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_application_config_by_config_version(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key")],
        config_version: Annotated[StrictStr, Field(description="The version of the application configuration")],
        retailer_id: Annotated[Optional[StrictInt], Field(description="Only returns the config that matches the given retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Only returns the config that matches the given retailer location")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="Only returns only returns the config that matches the given device udid")] = None,
        allow_older_versions: Annotated[Optional[StrictBool], Field(description="Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationConfigResponse:
        """Get AppConfig by Version

        Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 

        :param app_key: The application key (required)
        :type app_key: str
        :param config_version: The version of the application configuration (required)
        :type config_version: str
        :param retailer_id: Only returns the config that matches the given retailer
        :type retailer_id: int
        :param retailer_location_id: Only returns the config that matches the given retailer location
        :type retailer_location_id: int
        :param udid: Only returns only returns the config that matches the given device udid
        :type udid: str
        :param allow_older_versions: Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
        :type allow_older_versions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_config_by_config_version_serialize(
            app_key=app_key,
            config_version=config_version,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            allow_older_versions=allow_older_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_application_config_by_config_version_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key")],
        config_version: Annotated[StrictStr, Field(description="The version of the application configuration")],
        retailer_id: Annotated[Optional[StrictInt], Field(description="Only returns the config that matches the given retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Only returns the config that matches the given retailer location")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="Only returns only returns the config that matches the given device udid")] = None,
        allow_older_versions: Annotated[Optional[StrictBool], Field(description="Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationConfigResponse]:
        """Get AppConfig by Version

        Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 

        :param app_key: The application key (required)
        :type app_key: str
        :param config_version: The version of the application configuration (required)
        :type config_version: str
        :param retailer_id: Only returns the config that matches the given retailer
        :type retailer_id: int
        :param retailer_location_id: Only returns the config that matches the given retailer location
        :type retailer_location_id: int
        :param udid: Only returns only returns the config that matches the given device udid
        :type udid: str
        :param allow_older_versions: Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
        :type allow_older_versions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_config_by_config_version_serialize(
            app_key=app_key,
            config_version=config_version,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            allow_older_versions=allow_older_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_application_config_by_config_version_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application key")],
        config_version: Annotated[StrictStr, Field(description="The version of the application configuration")],
        retailer_id: Annotated[Optional[StrictInt], Field(description="Only returns the config that matches the given retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Only returns the config that matches the given retailer location")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="Only returns only returns the config that matches the given device udid")] = None,
        allow_older_versions: Annotated[Optional[StrictBool], Field(description="Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get AppConfig by Version

        Gets the appConfig data by the given appKey and app configVersion number.If the appKey is is invalid or appConfig is not found, it returns an invalid response. 

        :param app_key: The application key (required)
        :type app_key: str
        :param config_version: The version of the application configuration (required)
        :type config_version: str
        :param retailer_id: Only returns the config that matches the given retailer
        :type retailer_id: int
        :param retailer_location_id: Only returns the config that matches the given retailer location
        :type retailer_location_id: int
        :param udid: Only returns only returns the config that matches the given device udid
        :type udid: str
        :param allow_older_versions: Determines whether to return older config versions if the exact version is not found. If this happens, will try to return the latest version.
        :type allow_older_versions: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_application_config_by_config_version_serialize(
            app_key=app_key,
            config_version=config_version,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            allow_older_versions=allow_older_versions,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_application_config_by_config_version_serialize(
        self,
        app_key,
        config_version,
        retailer_id,
        retailer_location_id,
        udid,
        allow_older_versions,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if config_version is not None:
            
            _query_params.append(('configVersion', config_version))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        if allow_older_versions is not None:
            
            _query_params.append(('allowOlderVersions', allow_older_versions))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/appconfig/getbyversion',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_application_config(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Only returns the configs that matches the given retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Only returns the configs that matches the given retailer location")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="Only returns only returns the configs that matches the given device udid")] = None,
        config_version: Annotated[Optional[StrictStr], Field(description="Config Version")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX ")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the results are in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination (There is a hard limit of 100)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ApplicationConfigResponse]:
        """Search AppConfigs

        Gets all versions of application configurations in a particular app by the given appKey.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param app_key: The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
        :type app_key: str
        :param retailer_id: Only returns the configs that matches the given retailer
        :type retailer_id: int
        :param retailer_location_id: Only returns the configs that matches the given retailer location
        :type retailer_location_id: int
        :param udid: Only returns only returns the configs that matches the given device udid
        :type udid: str
        :param config_version: Config Version
        :type config_version: str
        :param sort_field: Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
        :type sort_field: str
        :param descending: Determines whether the results are in descending or ascending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination (There is a hard limit of 100)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_config_serialize(
            account_id=account_id,
            app_key=app_key,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            config_version=config_version,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationConfigResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_application_config_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Only returns the configs that matches the given retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Only returns the configs that matches the given retailer location")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="Only returns only returns the configs that matches the given device udid")] = None,
        config_version: Annotated[Optional[StrictStr], Field(description="Config Version")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX ")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the results are in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination (There is a hard limit of 100)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ApplicationConfigResponse]]:
        """Search AppConfigs

        Gets all versions of application configurations in a particular app by the given appKey.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param app_key: The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
        :type app_key: str
        :param retailer_id: Only returns the configs that matches the given retailer
        :type retailer_id: int
        :param retailer_location_id: Only returns the configs that matches the given retailer location
        :type retailer_location_id: int
        :param udid: Only returns only returns the configs that matches the given device udid
        :type udid: str
        :param config_version: Config Version
        :type config_version: str
        :param sort_field: Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
        :type sort_field: str
        :param descending: Determines whether the results are in descending or ascending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination (There is a hard limit of 100)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_config_serialize(
            account_id=account_id,
            app_key=app_key,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            config_version=config_version,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationConfigResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_application_config_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Only returns the configs that matches the given retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Only returns the configs that matches the given retailer location")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="Only returns only returns the configs that matches the given device udid")] = None,
        config_version: Annotated[Optional[StrictStr], Field(description="Config Version")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX ")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the results are in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination (There is a hard limit of 100)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search AppConfigs

        Gets all versions of application configurations in a particular app by the given appKey.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param app_key: The application key to filter results by application Leaving this empty will return all application configurations for all applications (executive user only)
        :type app_key: str
        :param retailer_id: Only returns the configs that matches the given retailer
        :type retailer_id: int
        :param retailer_location_id: Only returns the configs that matches the given retailer location
        :type retailer_location_id: int
        :param udid: Only returns only returns the configs that matches the given device udid
        :type udid: str
        :param config_version: Config Version
        :type config_version: str
        :param sort_field: Orders the results by: CREATED, UPDATED, ACTIVE, APPLICATION_ID,  APPLICATION_KEY, APPLICATION_NAME, RETAILER_NAME, RETAILER_ID, RETAILER_LOCATION_NAME,  RETAILER_LOCATION_ID, OFFER_TITLE, OFFER_ID, OFFER_LOCATION_ID, CONFIG_VERSION_MINOR,  CONFIG_VERSION_MAJOR, CONFIG_VERSION_INDEX 
        :type sort_field: str
        :param descending: Determines whether the results are in descending or ascending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination (There is a hard limit of 100)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_application_config_serialize(
            account_id=account_id,
            app_key=app_key,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            config_version=config_version,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ApplicationConfigResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_application_config_serialize(
        self,
        account_id,
        app_key,
        retailer_id,
        retailer_location_id,
        udid,
        config_version,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        if config_version is not None:
            
            _query_params.append(('configVersion', config_version))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/appconfig/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_application_config(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration to update")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key that the updated applicationConfig will be associated to")] = None,
        config_version: Annotated[Optional[StrictStr], Field(description="The application configuration, has to be unique within the application")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The json assetId that stores the configuration detail.")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="The retailer id for retailer specific configurations")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="The retailer location id for retailer location specific configurations")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The device udid for device specific configurations")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApplicationConfigResponse:
        """Update AppConfig

        pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration to update (required)
        :type config_id: int
        :param app_key: The application key that the updated applicationConfig will be associated to
        :type app_key: str
        :param config_version: The application configuration, has to be unique within the application
        :type config_version: str
        :param asset_id: The json assetId that stores the configuration detail.
        :type asset_id: int
        :param retailer_id: The retailer id for retailer specific configurations
        :type retailer_id: int
        :param retailer_location_id: The retailer location id for retailer location specific configurations
        :type retailer_location_id: int
        :param udid: The device udid for device specific configurations
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            app_key=app_key,
            config_version=config_version,
            asset_id=asset_id,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_application_config_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration to update")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key that the updated applicationConfig will be associated to")] = None,
        config_version: Annotated[Optional[StrictStr], Field(description="The application configuration, has to be unique within the application")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The json assetId that stores the configuration detail.")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="The retailer id for retailer specific configurations")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="The retailer location id for retailer location specific configurations")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The device udid for device specific configurations")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ApplicationConfigResponse]:
        """Update AppConfig

        pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration to update (required)
        :type config_id: int
        :param app_key: The application key that the updated applicationConfig will be associated to
        :type app_key: str
        :param config_version: The application configuration, has to be unique within the application
        :type config_version: str
        :param asset_id: The json assetId that stores the configuration detail.
        :type asset_id: int
        :param retailer_id: The retailer id for retailer specific configurations
        :type retailer_id: int
        :param retailer_location_id: The retailer location id for retailer location specific configurations
        :type retailer_location_id: int
        :param udid: The device udid for device specific configurations
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            app_key=app_key,
            config_version=config_version,
            asset_id=asset_id,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_application_config_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account ID of the user")],
        config_id: Annotated[StrictInt, Field(description="The config ID of the application configuration to update")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key that the updated applicationConfig will be associated to")] = None,
        config_version: Annotated[Optional[StrictStr], Field(description="The application configuration, has to be unique within the application")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The json assetId that stores the configuration detail.")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="The retailer id for retailer specific configurations")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="The retailer location id for retailer location specific configurations")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The device udid for device specific configurations")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update AppConfig

        pdates an existing application configuration. If the configVersion provided already exists for the given app the application configuration won't be updated.

        :param account_id: The account ID of the user (required)
        :type account_id: int
        :param config_id: The config ID of the application configuration to update (required)
        :type config_id: int
        :param app_key: The application key that the updated applicationConfig will be associated to
        :type app_key: str
        :param config_version: The application configuration, has to be unique within the application
        :type config_version: str
        :param asset_id: The json assetId that stores the configuration detail.
        :type asset_id: int
        :param retailer_id: The retailer id for retailer specific configurations
        :type retailer_id: int
        :param retailer_location_id: The retailer location id for retailer location specific configurations
        :type retailer_location_id: int
        :param udid: The device udid for device specific configurations
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_application_config_serialize(
            account_id=account_id,
            config_id=config_id,
            app_key=app_key,
            config_version=config_version,
            asset_id=asset_id,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ApplicationConfigResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_application_config_serialize(
        self,
        account_id,
        config_id,
        app_key,
        config_version,
        asset_id,
        retailer_id,
        retailer_location_id,
        udid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if config_id is not None:
            
            _query_params.append(('configId', config_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if config_version is not None:
            
            _query_params.append(('configVersion', config_version))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/appconfig/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


