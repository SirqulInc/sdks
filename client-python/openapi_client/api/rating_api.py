# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.rating_index_response import RatingIndexResponse
from openapi_client.models.rating_response import RatingResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class RatingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_rating(
        self,
        ratable_type: Annotated[StrictStr, Field(description="The ratable object type {RETAILER_LOCATION}")],
        ratable_id: Annotated[StrictInt, Field(description="The id of the ratable object")],
        rating_value: Annotated[StrictInt, Field(description="The integer value of 0-100")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        category_id: Optional[StrictInt] = None,
        display: Annotated[Optional[StrictStr], Field(description="A subject title for the user rating (limited to 255 characters)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the rating")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RatingResponse:
        """Create Rating

        This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.

        :param ratable_type: The ratable object type {RETAILER_LOCATION} (required)
        :type ratable_type: str
        :param ratable_id: The id of the ratable object (required)
        :type ratable_id: int
        :param rating_value: The integer value of 0-100 (required)
        :type rating_value: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param category_id: 
        :type category_id: int
        :param display: A subject title for the user rating (limited to 255 characters)
        :type display: str
        :param description: The description of the rating
        :type description: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_rating_serialize(
            ratable_type=ratable_type,
            ratable_id=ratable_id,
            rating_value=rating_value,
            device_id=device_id,
            account_id=account_id,
            category_id=category_id,
            display=display,
            description=description,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RatingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_rating_with_http_info(
        self,
        ratable_type: Annotated[StrictStr, Field(description="The ratable object type {RETAILER_LOCATION}")],
        ratable_id: Annotated[StrictInt, Field(description="The id of the ratable object")],
        rating_value: Annotated[StrictInt, Field(description="The integer value of 0-100")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        category_id: Optional[StrictInt] = None,
        display: Annotated[Optional[StrictStr], Field(description="A subject title for the user rating (limited to 255 characters)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the rating")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RatingResponse]:
        """Create Rating

        This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.

        :param ratable_type: The ratable object type {RETAILER_LOCATION} (required)
        :type ratable_type: str
        :param ratable_id: The id of the ratable object (required)
        :type ratable_id: int
        :param rating_value: The integer value of 0-100 (required)
        :type rating_value: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param category_id: 
        :type category_id: int
        :param display: A subject title for the user rating (limited to 255 characters)
        :type display: str
        :param description: The description of the rating
        :type description: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_rating_serialize(
            ratable_type=ratable_type,
            ratable_id=ratable_id,
            rating_value=rating_value,
            device_id=device_id,
            account_id=account_id,
            category_id=category_id,
            display=display,
            description=description,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RatingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_rating_without_preload_content(
        self,
        ratable_type: Annotated[StrictStr, Field(description="The ratable object type {RETAILER_LOCATION}")],
        ratable_id: Annotated[StrictInt, Field(description="The id of the ratable object")],
        rating_value: Annotated[StrictInt, Field(description="The integer value of 0-100")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        category_id: Optional[StrictInt] = None,
        display: Annotated[Optional[StrictStr], Field(description="A subject title for the user rating (limited to 255 characters)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the rating")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Rating

        This is used to leave rating on a ratable object (i.e. retailer locations). Each user can only rate on a ratable object once per category. If a user rates on the same object and category, the previous rating will be overwritten. Leaving a rating on a ratable object will be visible to everyone who has access to view the object.

        :param ratable_type: The ratable object type {RETAILER_LOCATION} (required)
        :type ratable_type: str
        :param ratable_id: The id of the ratable object (required)
        :type ratable_id: int
        :param rating_value: The integer value of 0-100 (required)
        :type rating_value: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param category_id: 
        :type category_id: int
        :param display: A subject title for the user rating (limited to 255 characters)
        :type display: str
        :param description: The description of the rating
        :type description: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_rating_serialize(
            ratable_type=ratable_type,
            ratable_id=ratable_id,
            rating_value=rating_value,
            device_id=device_id,
            account_id=account_id,
            category_id=category_id,
            display=display,
            description=description,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RatingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_rating_serialize(
        self,
        ratable_type,
        ratable_id,
        rating_value,
        device_id,
        account_id,
        category_id,
        display,
        description,
        location_description,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if ratable_type is not None:
            
            _query_params.append(('ratableType', ratable_type))
            
        if ratable_id is not None:
            
            _query_params.append(('ratableId', ratable_id))
            
        if rating_value is not None:
            
            _query_params.append(('ratingValue', rating_value))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if display is not None:
            
            _query_params.append(('display', display))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/rating/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_rating(
        self,
        rating_id: Annotated[StrictInt, Field(description="The ID of the rating to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Rating

        Sets a rating as deleted.

        :param rating_id: The ID of the rating to delete (required)
        :type rating_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_rating_serialize(
            rating_id=rating_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_rating_with_http_info(
        self,
        rating_id: Annotated[StrictInt, Field(description="The ID of the rating to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Rating

        Sets a rating as deleted.

        :param rating_id: The ID of the rating to delete (required)
        :type rating_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_rating_serialize(
            rating_id=rating_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_rating_without_preload_content(
        self,
        rating_id: Annotated[StrictInt, Field(description="The ID of the rating to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Rating

        Sets a rating as deleted.

        :param rating_id: The ID of the rating to delete (required)
        :type rating_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_rating_serialize(
            rating_id=rating_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_rating_serialize(
        self,
        rating_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if rating_id is not None:
            
            _query_params.append(('ratingId', rating_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/rating/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_location_rating_indexes(
        self,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="The type of location to filter the results by")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The search radius in kilometers to filter results")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        return_overall_rating: Annotated[Optional[StrictBool], Field(description="Determines whether to return the overall rating record instead")] = None,
        distance_unit: Optional[StrictStr] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="whether to return the retailer or not")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="whether to return the assets or not")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="whether to return the offers or not")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="whether to return the categories or not")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="whether to return the filters or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RatingIndexResponse]:
        """Search Location Rating Indexes

        Search for retailer locations by averages near you.

        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param location_type: The type of location to filter the results by
        :type location_type: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param search_range: The search radius in kilometers to filter results
        :type search_range: float
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param return_overall_rating: Determines whether to return the overall rating record instead
        :type return_overall_rating: bool
        :param distance_unit: 
        :type distance_unit: str
        :param return_retailer: whether to return the retailer or not
        :type return_retailer: bool
        :param return_assets: whether to return the assets or not
        :type return_assets: bool
        :param return_offers: whether to return the offers or not
        :type return_offers: bool
        :param return_categories: whether to return the categories or not
        :type return_categories: bool
        :param return_filters: whether to return the filters or not
        :type return_filters: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_location_rating_indexes_serialize(
            category_ids=category_ids,
            keyword=keyword,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            search_range=search_range,
            latitude=latitude,
            longitude=longitude,
            return_overall_rating=return_overall_rating,
            distance_unit=distance_unit,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingIndexResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_location_rating_indexes_with_http_info(
        self,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="The type of location to filter the results by")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The search radius in kilometers to filter results")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        return_overall_rating: Annotated[Optional[StrictBool], Field(description="Determines whether to return the overall rating record instead")] = None,
        distance_unit: Optional[StrictStr] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="whether to return the retailer or not")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="whether to return the assets or not")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="whether to return the offers or not")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="whether to return the categories or not")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="whether to return the filters or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RatingIndexResponse]]:
        """Search Location Rating Indexes

        Search for retailer locations by averages near you.

        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param location_type: The type of location to filter the results by
        :type location_type: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param search_range: The search radius in kilometers to filter results
        :type search_range: float
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param return_overall_rating: Determines whether to return the overall rating record instead
        :type return_overall_rating: bool
        :param distance_unit: 
        :type distance_unit: str
        :param return_retailer: whether to return the retailer or not
        :type return_retailer: bool
        :param return_assets: whether to return the assets or not
        :type return_assets: bool
        :param return_offers: whether to return the offers or not
        :type return_offers: bool
        :param return_categories: whether to return the categories or not
        :type return_categories: bool
        :param return_filters: whether to return the filters or not
        :type return_filters: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_location_rating_indexes_serialize(
            category_ids=category_ids,
            keyword=keyword,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            search_range=search_range,
            latitude=latitude,
            longitude=longitude,
            return_overall_rating=return_overall_rating,
            distance_unit=distance_unit,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingIndexResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_location_rating_indexes_without_preload_content(
        self,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        location_type: Annotated[Optional[StrictStr], Field(description="The type of location to filter the results by")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The search radius in kilometers to filter results")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        return_overall_rating: Annotated[Optional[StrictBool], Field(description="Determines whether to return the overall rating record instead")] = None,
        distance_unit: Optional[StrictStr] = None,
        return_retailer: Annotated[Optional[StrictBool], Field(description="whether to return the retailer or not")] = None,
        return_assets: Annotated[Optional[StrictBool], Field(description="whether to return the assets or not")] = None,
        return_offers: Annotated[Optional[StrictBool], Field(description="whether to return the offers or not")] = None,
        return_categories: Annotated[Optional[StrictBool], Field(description="whether to return the categories or not")] = None,
        return_filters: Annotated[Optional[StrictBool], Field(description="whether to return the filters or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Location Rating Indexes

        Search for retailer locations by averages near you.

        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param location_type: The type of location to filter the results by
        :type location_type: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param search_range: The search radius in kilometers to filter results
        :type search_range: float
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param return_overall_rating: Determines whether to return the overall rating record instead
        :type return_overall_rating: bool
        :param distance_unit: 
        :type distance_unit: str
        :param return_retailer: whether to return the retailer or not
        :type return_retailer: bool
        :param return_assets: whether to return the assets or not
        :type return_assets: bool
        :param return_offers: whether to return the offers or not
        :type return_offers: bool
        :param return_categories: whether to return the categories or not
        :type return_categories: bool
        :param return_filters: whether to return the filters or not
        :type return_filters: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_location_rating_indexes_serialize(
            category_ids=category_ids,
            keyword=keyword,
            location_type=location_type,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            search_range=search_range,
            latitude=latitude,
            longitude=longitude,
            return_overall_rating=return_overall_rating,
            distance_unit=distance_unit,
            return_retailer=return_retailer,
            return_assets=return_assets,
            return_offers=return_offers,
            return_categories=return_categories,
            return_filters=return_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingIndexResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_location_rating_indexes_serialize(
        self,
        category_ids,
        keyword,
        location_type,
        sort_field,
        descending,
        start,
        limit,
        search_range,
        latitude,
        longitude,
        return_overall_rating,
        distance_unit,
        return_retailer,
        return_assets,
        return_offers,
        return_categories,
        return_filters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if location_type is not None:
            
            _query_params.append(('locationType', location_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if return_overall_rating is not None:
            
            _query_params.append(('returnOverallRating', return_overall_rating))
            
        if distance_unit is not None:
            
            _query_params.append(('distanceUnit', distance_unit))
            
        if return_retailer is not None:
            
            _query_params.append(('returnRetailer', return_retailer))
            
        if return_assets is not None:
            
            _query_params.append(('returnAssets', return_assets))
            
        if return_offers is not None:
            
            _query_params.append(('returnOffers', return_offers))
            
        if return_categories is not None:
            
            _query_params.append(('returnCategories', return_categories))
            
        if return_filters is not None:
            
            _query_params.append(('returnFilters', return_filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/location/rating/index/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_rating_indexes(
        self,
        ratable_type: Annotated[StrictStr, Field(description="Filter results by a ratable type {RETAILER_LOCATION}")],
        ratable_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of ratable ids to filter the resuts by")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        secondary_type: Optional[StrictStr] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        return_ratable: Annotated[Optional[StrictBool], Field(description="Determines whether to return the ratable object in the response")] = None,
        return_overall_rating: Annotated[Optional[StrictBool], Field(description="Determines whether to return the overall rating record instead")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RatingIndexResponse]:
        """Search Rating Indexes

        Search for ratable items by averages.

        :param ratable_type: Filter results by a ratable type {RETAILER_LOCATION} (required)
        :type ratable_type: str
        :param ratable_ids: Comma separated list of ratable ids to filter the resuts by
        :type ratable_ids: str
        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param secondary_type: 
        :type secondary_type: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param latitude: 
        :type latitude: float
        :param longitude: 
        :type longitude: float
        :param return_ratable: Determines whether to return the ratable object in the response
        :type return_ratable: bool
        :param return_overall_rating: Determines whether to return the overall rating record instead
        :type return_overall_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_rating_indexes_serialize(
            ratable_type=ratable_type,
            ratable_ids=ratable_ids,
            category_ids=category_ids,
            secondary_type=secondary_type,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            return_ratable=return_ratable,
            return_overall_rating=return_overall_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingIndexResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_rating_indexes_with_http_info(
        self,
        ratable_type: Annotated[StrictStr, Field(description="Filter results by a ratable type {RETAILER_LOCATION}")],
        ratable_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of ratable ids to filter the resuts by")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        secondary_type: Optional[StrictStr] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        return_ratable: Annotated[Optional[StrictBool], Field(description="Determines whether to return the ratable object in the response")] = None,
        return_overall_rating: Annotated[Optional[StrictBool], Field(description="Determines whether to return the overall rating record instead")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RatingIndexResponse]]:
        """Search Rating Indexes

        Search for ratable items by averages.

        :param ratable_type: Filter results by a ratable type {RETAILER_LOCATION} (required)
        :type ratable_type: str
        :param ratable_ids: Comma separated list of ratable ids to filter the resuts by
        :type ratable_ids: str
        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param secondary_type: 
        :type secondary_type: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param latitude: 
        :type latitude: float
        :param longitude: 
        :type longitude: float
        :param return_ratable: Determines whether to return the ratable object in the response
        :type return_ratable: bool
        :param return_overall_rating: Determines whether to return the overall rating record instead
        :type return_overall_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_rating_indexes_serialize(
            ratable_type=ratable_type,
            ratable_ids=ratable_ids,
            category_ids=category_ids,
            secondary_type=secondary_type,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            return_ratable=return_ratable,
            return_overall_rating=return_overall_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingIndexResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_rating_indexes_without_preload_content(
        self,
        ratable_type: Annotated[StrictStr, Field(description="Filter results by a ratable type {RETAILER_LOCATION}")],
        ratable_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of ratable ids to filter the resuts by")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        secondary_type: Optional[StrictStr] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        latitude: Optional[Union[StrictFloat, StrictInt]] = None,
        longitude: Optional[Union[StrictFloat, StrictInt]] = None,
        return_ratable: Annotated[Optional[StrictBool], Field(description="Determines whether to return the ratable object in the response")] = None,
        return_overall_rating: Annotated[Optional[StrictBool], Field(description="Determines whether to return the overall rating record instead")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Rating Indexes

        Search for ratable items by averages.

        :param ratable_type: Filter results by a ratable type {RETAILER_LOCATION} (required)
        :type ratable_type: str
        :param ratable_ids: Comma separated list of ratable ids to filter the resuts by
        :type ratable_ids: str
        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param secondary_type: 
        :type secondary_type: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, COUNT, SUMMATION, AVERAGE, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param latitude: 
        :type latitude: float
        :param longitude: 
        :type longitude: float
        :param return_ratable: Determines whether to return the ratable object in the response
        :type return_ratable: bool
        :param return_overall_rating: Determines whether to return the overall rating record instead
        :type return_overall_rating: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_rating_indexes_serialize(
            ratable_type=ratable_type,
            ratable_ids=ratable_ids,
            category_ids=category_ids,
            secondary_type=secondary_type,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            return_ratable=return_ratable,
            return_overall_rating=return_overall_rating,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingIndexResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_rating_indexes_serialize(
        self,
        ratable_type,
        ratable_ids,
        category_ids,
        secondary_type,
        keyword,
        sort_field,
        descending,
        start,
        limit,
        latitude,
        longitude,
        return_ratable,
        return_overall_rating,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if ratable_type is not None:
            
            _query_params.append(('ratableType', ratable_type))
            
        if ratable_ids is not None:
            
            _query_params.append(('ratableIds', ratable_ids))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if secondary_type is not None:
            
            _query_params.append(('secondaryType', secondary_type))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if return_ratable is not None:
            
            _query_params.append(('returnRatable', return_ratable))
            
        if return_overall_rating is not None:
            
            _query_params.append(('returnOverallRating', return_overall_rating))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/rating/index/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_ratings(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        filter_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a particular account")] = None,
        ratable_type: Annotated[Optional[StrictStr], Field(description="The ratable object type {RETAILER_LOCATION}")] = None,
        ratable_id: Annotated[Optional[StrictInt], Field(description="The id of the ratable object")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RatingResponse]:
        """Search Ratings

        Search for ratings on a ratable object.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param filter_account_id: Filter results for a particular account
        :type filter_account_id: int
        :param ratable_type: The ratable object type {RETAILER_LOCATION}
        :type ratable_type: str
        :param ratable_id: The id of the ratable object
        :type ratable_id: int
        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_ratings_serialize(
            device_id=device_id,
            account_id=account_id,
            filter_account_id=filter_account_id,
            ratable_type=ratable_type,
            ratable_id=ratable_id,
            category_ids=category_ids,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_ratings_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        filter_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a particular account")] = None,
        ratable_type: Annotated[Optional[StrictStr], Field(description="The ratable object type {RETAILER_LOCATION}")] = None,
        ratable_id: Annotated[Optional[StrictInt], Field(description="The id of the ratable object")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RatingResponse]]:
        """Search Ratings

        Search for ratings on a ratable object.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param filter_account_id: Filter results for a particular account
        :type filter_account_id: int
        :param ratable_type: The ratable object type {RETAILER_LOCATION}
        :type ratable_type: str
        :param ratable_id: The id of the ratable object
        :type ratable_id: int
        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_ratings_serialize(
            device_id=device_id,
            account_id=account_id,
            filter_account_id=filter_account_id,
            ratable_type=ratable_type,
            ratable_id=ratable_id,
            category_ids=category_ids,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_ratings_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        filter_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a particular account")] = None,
        ratable_type: Annotated[Optional[StrictStr], Field(description="The ratable object type {RETAILER_LOCATION}")] = None,
        ratable_id: Annotated[Optional[StrictInt], Field(description="The id of the ratable object")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids to filter the results by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Ratings

        Search for ratings on a ratable object.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param filter_account_id: Filter results for a particular account
        :type filter_account_id: int
        :param ratable_type: The ratable object type {RETAILER_LOCATION}
        :type ratable_type: str
        :param ratable_id: The id of the ratable object
        :type ratable_id: int
        :param category_ids: Comma separated list of category ids to filter the results by
        :type category_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param sort_field: The column to sort the search on {ID, CREATED, UPDATED, ACTIVE, OWNER_DISPLAY, RATABLE_TYPE, RATABLE_ID, RATABLE_DISPLAY, CATEGORY_ID, CATEGORY_NAME, CATEGORY_SHORT_NAME, CATEGORY_DISPLAY, VALUE}
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_ratings_serialize(
            device_id=device_id,
            account_id=account_id,
            filter_account_id=filter_account_id,
            ratable_type=ratable_type,
            ratable_id=ratable_id,
            category_ids=category_ids,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RatingResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_ratings_serialize(
        self,
        device_id,
        account_id,
        filter_account_id,
        ratable_type,
        ratable_id,
        category_ids,
        keyword,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if filter_account_id is not None:
            
            _query_params.append(('filterAccountId', filter_account_id))
            
        if ratable_type is not None:
            
            _query_params.append(('ratableType', ratable_type))
            
        if ratable_id is not None:
            
            _query_params.append(('ratableId', ratable_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/rating/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_rating(
        self,
        rating_id: Annotated[StrictInt, Field(description="The id of the rating (Note: this is not the ratable object id)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        rating_value: Annotated[Optional[StrictInt], Field(description="The rating value to update")] = None,
        category_id: Optional[StrictInt] = None,
        display: Annotated[Optional[StrictStr], Field(description="A subject title for the user rating (limited to 255 characters)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the rating")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RatingResponse:
        """Update Rating

        Update an existing rating. Only the creator of the rating have permission to update.

        :param rating_id: The id of the rating (Note: this is not the ratable object id) (required)
        :type rating_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param rating_value: The rating value to update
        :type rating_value: int
        :param category_id: 
        :type category_id: int
        :param display: A subject title for the user rating (limited to 255 characters)
        :type display: str
        :param description: The description of the rating
        :type description: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_rating_serialize(
            rating_id=rating_id,
            device_id=device_id,
            account_id=account_id,
            rating_value=rating_value,
            category_id=category_id,
            display=display,
            description=description,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RatingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_rating_with_http_info(
        self,
        rating_id: Annotated[StrictInt, Field(description="The id of the rating (Note: this is not the ratable object id)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        rating_value: Annotated[Optional[StrictInt], Field(description="The rating value to update")] = None,
        category_id: Optional[StrictInt] = None,
        display: Annotated[Optional[StrictStr], Field(description="A subject title for the user rating (limited to 255 characters)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the rating")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RatingResponse]:
        """Update Rating

        Update an existing rating. Only the creator of the rating have permission to update.

        :param rating_id: The id of the rating (Note: this is not the ratable object id) (required)
        :type rating_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param rating_value: The rating value to update
        :type rating_value: int
        :param category_id: 
        :type category_id: int
        :param display: A subject title for the user rating (limited to 255 characters)
        :type display: str
        :param description: The description of the rating
        :type description: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_rating_serialize(
            rating_id=rating_id,
            device_id=device_id,
            account_id=account_id,
            rating_value=rating_value,
            category_id=category_id,
            display=display,
            description=description,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RatingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_rating_without_preload_content(
        self,
        rating_id: Annotated[StrictInt, Field(description="The id of the rating (Note: this is not the ratable object id)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        rating_value: Annotated[Optional[StrictInt], Field(description="The rating value to update")] = None,
        category_id: Optional[StrictInt] = None,
        display: Annotated[Optional[StrictStr], Field(description="A subject title for the user rating (limited to 255 characters)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the rating")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Rating

        Update an existing rating. Only the creator of the rating have permission to update.

        :param rating_id: The id of the rating (Note: this is not the ratable object id) (required)
        :type rating_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param rating_value: The rating value to update
        :type rating_value: int
        :param category_id: 
        :type category_id: int
        :param display: A subject title for the user rating (limited to 255 characters)
        :type display: str
        :param description: The description of the rating
        :type description: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_rating_serialize(
            rating_id=rating_id,
            device_id=device_id,
            account_id=account_id,
            rating_value=rating_value,
            category_id=category_id,
            display=display,
            description=description,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RatingResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_rating_serialize(
        self,
        rating_id,
        device_id,
        account_id,
        rating_value,
        category_id,
        display,
        description,
        location_description,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if rating_id is not None:
            
            _query_params.append(('ratingId', rating_id))
            
        if rating_value is not None:
            
            _query_params.append(('ratingValue', rating_value))
            
        if category_id is not None:
            
            _query_params.append(('categoryId', category_id))
            
        if display is not None:
            
            _query_params.append(('display', display))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/rating/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


