# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.account_login_response import AccountLoginResponse
from openapi_client.models.retailer_full_response import RetailerFullResponse
from openapi_client.models.retailer_response import RetailerResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class RetailerApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_retailer(
        self,
        version: Union[StrictFloat, StrictInt],
        name: Annotated[StrictStr, Field(description="The name of the retailer")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer")] = None,
        facebook_url: Annotated[Optional[StrictStr], Field(description="The facebook URL of the retailer")] = None,
        twitter_url: Annotated[Optional[StrictStr], Field(description="The twitter URL of the retailer")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailers by categories")] = None,
        category_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs to add to the retailer")] = None,
        category_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs to remove from the retailer")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailers")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="External custom search keywords")] = None,
        retailer_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        visibility: Optional[StrictStr] = None,
        create_default_location: Annotated[Optional[StrictBool], Field(description="Determines whether to create a default location using the retailer information")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerFullResponse:
        """Create Retailer

        Create a retailer record. A billable entity must be created first before a retailer record can be made.

        :param version: (required)
        :type version: float
        :param name: The name of the retailer (required)
        :type name: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address: The street address of the retailer
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer
        :type city: str
        :param state: The state of the retailer
        :type state: str
        :param postal_code: The postal code of the retailer
        :type postal_code: str
        :param country: the country of the retailer
        :type country: str
        :param business_phone: The business phone number of the retailer
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer
        :type business_phone_ext: str
        :param website: The website of the retailer
        :type website: str
        :param email: The email of the retailer
        :type email: str
        :param facebook_url: The facebook URL of the retailer
        :type facebook_url: str
        :param twitter_url: The twitter URL of the retailer
        :type twitter_url: str
        :param logo: The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailers by categories
        :type category_ids: str
        :param category_ids_to_add: Comma separated list of category IDs to add to the retailer
        :type category_ids_to_add: str
        :param category_ids_to_remove: Comma separated list of category IDs to remove from the retailer
        :type category_ids_to_remove: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailers
        :type filter_ids: str
        :param latitude: the latitude of the retailer
        :type latitude: float
        :param longitude: the longitude of the retailer
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param search_tags: External custom search keywords
        :type search_tags: str
        :param retailer_type: External custom type identifier
        :type retailer_type: str
        :param visibility: 
        :type visibility: str
        :param create_default_location: Determines whether to create a default location using the retailer information
        :type create_default_location: bool
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_serialize(
            version=version,
            name=name,
            device_id=device_id,
            account_id=account_id,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            facebook_url=facebook_url,
            twitter_url=twitter_url,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            category_ids_to_add=category_ids_to_add,
            category_ids_to_remove=category_ids_to_remove,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            search_tags=search_tags,
            retailer_type=retailer_type,
            visibility=visibility,
            create_default_location=create_default_location,
            response_format=response_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_retailer_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        name: Annotated[StrictStr, Field(description="The name of the retailer")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer")] = None,
        facebook_url: Annotated[Optional[StrictStr], Field(description="The facebook URL of the retailer")] = None,
        twitter_url: Annotated[Optional[StrictStr], Field(description="The twitter URL of the retailer")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailers by categories")] = None,
        category_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs to add to the retailer")] = None,
        category_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs to remove from the retailer")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailers")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="External custom search keywords")] = None,
        retailer_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        visibility: Optional[StrictStr] = None,
        create_default_location: Annotated[Optional[StrictBool], Field(description="Determines whether to create a default location using the retailer information")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerFullResponse]:
        """Create Retailer

        Create a retailer record. A billable entity must be created first before a retailer record can be made.

        :param version: (required)
        :type version: float
        :param name: The name of the retailer (required)
        :type name: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address: The street address of the retailer
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer
        :type city: str
        :param state: The state of the retailer
        :type state: str
        :param postal_code: The postal code of the retailer
        :type postal_code: str
        :param country: the country of the retailer
        :type country: str
        :param business_phone: The business phone number of the retailer
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer
        :type business_phone_ext: str
        :param website: The website of the retailer
        :type website: str
        :param email: The email of the retailer
        :type email: str
        :param facebook_url: The facebook URL of the retailer
        :type facebook_url: str
        :param twitter_url: The twitter URL of the retailer
        :type twitter_url: str
        :param logo: The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailers by categories
        :type category_ids: str
        :param category_ids_to_add: Comma separated list of category IDs to add to the retailer
        :type category_ids_to_add: str
        :param category_ids_to_remove: Comma separated list of category IDs to remove from the retailer
        :type category_ids_to_remove: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailers
        :type filter_ids: str
        :param latitude: the latitude of the retailer
        :type latitude: float
        :param longitude: the longitude of the retailer
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param search_tags: External custom search keywords
        :type search_tags: str
        :param retailer_type: External custom type identifier
        :type retailer_type: str
        :param visibility: 
        :type visibility: str
        :param create_default_location: Determines whether to create a default location using the retailer information
        :type create_default_location: bool
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_serialize(
            version=version,
            name=name,
            device_id=device_id,
            account_id=account_id,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            facebook_url=facebook_url,
            twitter_url=twitter_url,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            category_ids_to_add=category_ids_to_add,
            category_ids_to_remove=category_ids_to_remove,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            search_tags=search_tags,
            retailer_type=retailer_type,
            visibility=visibility,
            create_default_location=create_default_location,
            response_format=response_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_retailer_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        name: Annotated[StrictStr, Field(description="The name of the retailer")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone number of the retailer")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer")] = None,
        facebook_url: Annotated[Optional[StrictStr], Field(description="The facebook URL of the retailer")] = None,
        twitter_url: Annotated[Optional[StrictStr], Field(description="The twitter URL of the retailer")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailers by categories")] = None,
        category_ids_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs to add to the retailer")] = None,
        category_ids_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs to remove from the retailer")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailers")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="External custom search keywords")] = None,
        retailer_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        visibility: Optional[StrictStr] = None,
        create_default_location: Annotated[Optional[StrictBool], Field(description="Determines whether to create a default location using the retailer information")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Retailer

        Create a retailer record. A billable entity must be created first before a retailer record can be made.

        :param version: (required)
        :type version: float
        :param name: The name of the retailer (required)
        :type name: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param street_address: The street address of the retailer
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer
        :type city: str
        :param state: The state of the retailer
        :type state: str
        :param postal_code: The postal code of the retailer
        :type postal_code: str
        :param country: the country of the retailer
        :type country: str
        :param business_phone: The business phone number of the retailer
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer
        :type business_phone_ext: str
        :param website: The website of the retailer
        :type website: str
        :param email: The email of the retailer
        :type email: str
        :param facebook_url: The facebook URL of the retailer
        :type facebook_url: str
        :param twitter_url: The twitter URL of the retailer
        :type twitter_url: str
        :param logo: The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailers by categories
        :type category_ids: str
        :param category_ids_to_add: Comma separated list of category IDs to add to the retailer
        :type category_ids_to_add: str
        :param category_ids_to_remove: Comma separated list of category IDs to remove from the retailer
        :type category_ids_to_remove: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailers
        :type filter_ids: str
        :param latitude: the latitude of the retailer
        :type latitude: float
        :param longitude: the longitude of the retailer
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param search_tags: External custom search keywords
        :type search_tags: str
        :param retailer_type: External custom type identifier
        :type retailer_type: str
        :param visibility: 
        :type visibility: str
        :param create_default_location: Determines whether to create a default location using the retailer information
        :type create_default_location: bool
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_retailer_serialize(
            version=version,
            name=name,
            device_id=device_id,
            account_id=account_id,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            facebook_url=facebook_url,
            twitter_url=twitter_url,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            category_ids_to_add=category_ids_to_add,
            category_ids_to_remove=category_ids_to_remove,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            search_tags=search_tags,
            retailer_type=retailer_type,
            visibility=visibility,
            create_default_location=create_default_location,
            response_format=response_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_retailer_serialize(
        self,
        version,
        name,
        device_id,
        account_id,
        street_address,
        street_address2,
        city,
        state,
        postal_code,
        country,
        business_phone,
        business_phone_ext,
        website,
        email,
        facebook_url,
        twitter_url,
        logo,
        logo_asset_id,
        picture1,
        picture1_asset_id,
        picture2,
        picture2_asset_id,
        category_ids,
        category_ids_to_add,
        category_ids_to_remove,
        filter_ids,
        latitude,
        longitude,
        meta_data,
        search_tags,
        retailer_type,
        visibility,
        create_default_location,
        response_format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if business_phone_ext is not None:
            
            _query_params.append(('businessPhoneExt', business_phone_ext))
            
        if website is not None:
            
            _query_params.append(('website', website))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if facebook_url is not None:
            
            _query_params.append(('facebookUrl', facebook_url))
            
        if twitter_url is not None:
            
            _query_params.append(('twitterUrl', twitter_url))
            
        if logo is not None:
            
            _query_params.append(('logo', logo))
            
        if logo_asset_id is not None:
            
            _query_params.append(('logoAssetId', logo_asset_id))
            
        if picture1 is not None:
            
            _query_params.append(('picture1', picture1))
            
        if picture1_asset_id is not None:
            
            _query_params.append(('picture1AssetId', picture1_asset_id))
            
        if picture2 is not None:
            
            _query_params.append(('picture2', picture2))
            
        if picture2_asset_id is not None:
            
            _query_params.append(('picture2AssetId', picture2_asset_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if category_ids_to_add is not None:
            
            _query_params.append(('categoryIdsToAdd', category_ids_to_add))
            
        if category_ids_to_remove is not None:
            
            _query_params.append(('categoryIdsToRemove', category_ids_to_remove))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if retailer_type is not None:
            
            _query_params.append(('retailerType', retailer_type))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if create_default_location is not None:
            
            _query_params.append(('createDefaultLocation', create_default_location))
            
        if response_format is not None:
            
            _query_params.append(('responseFormat', response_format))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_retailer(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the retailer.")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="The ID of the retailer to be deleted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Retailer

        Set the deleted timestamp to current time.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the retailer.
        :type account_id: int
        :param retailer_id: The ID of the retailer to be deleted
        :type retailer_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_retailer_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            retailer_id=retailer_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_retailer_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the retailer.")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="The ID of the retailer to be deleted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Retailer

        Set the deleted timestamp to current time.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the retailer.
        :type account_id: int
        :param retailer_id: The ID of the retailer to be deleted
        :type retailer_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_retailer_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            retailer_id=retailer_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_retailer_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the retailer.")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="The ID of the retailer to be deleted")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Retailer

        Set the deleted timestamp to current time.

        :param version: (required)
        :type version: float
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the retailer.
        :type account_id: int
        :param retailer_id: The ID of the retailer to be deleted
        :type retailer_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_retailer_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            retailer_id=retailer_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_retailer_serialize(
        self,
        version,
        device_id,
        account_id,
        retailer_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_retailer(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="the ID of the retailer")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        include_counts: Annotated[Optional[StrictBool], Field(description="Determines whether to include counts in the response (default true)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerFullResponse:
        """Get Retailer

        Gets a retailer. Only the owner and the employees of a retailer have access to view its information.

        :param version: (required)
        :type version: float
        :param retailer_id: the ID of the retailer (required)
        :type retailer_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param include_counts: Determines whether to include counts in the response (default true)
        :type include_counts: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_serialize(
            version=version,
            retailer_id=retailer_id,
            device_id=device_id,
            account_id=account_id,
            include_counts=include_counts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_retailer_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="the ID of the retailer")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        include_counts: Annotated[Optional[StrictBool], Field(description="Determines whether to include counts in the response (default true)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerFullResponse]:
        """Get Retailer

        Gets a retailer. Only the owner and the employees of a retailer have access to view its information.

        :param version: (required)
        :type version: float
        :param retailer_id: the ID of the retailer (required)
        :type retailer_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param include_counts: Determines whether to include counts in the response (default true)
        :type include_counts: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_serialize(
            version=version,
            retailer_id=retailer_id,
            device_id=device_id,
            account_id=account_id,
            include_counts=include_counts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_retailer_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="the ID of the retailer")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        include_counts: Annotated[Optional[StrictBool], Field(description="Determines whether to include counts in the response (default true)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Retailer

        Gets a retailer. Only the owner and the employees of a retailer have access to view its information.

        :param version: (required)
        :type version: float
        :param retailer_id: the ID of the retailer (required)
        :type retailer_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param include_counts: Determines whether to include counts in the response (default true)
        :type include_counts: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailer_serialize(
            version=version,
            retailer_id=retailer_id,
            device_id=device_id,
            account_id=account_id,
            include_counts=include_counts,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_retailer_serialize(
        self,
        version,
        retailer_id,
        device_id,
        account_id,
        include_counts,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if include_counts is not None:
            
            _query_params.append(('includeCounts', include_counts))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/retailer/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_retailers(
        self,
        version: Union[StrictFloat, StrictInt],
        visibility: StrictStr,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The record to begin the return set on")],
        limit: Annotated[StrictInt, Field(description="The number of records to return")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the retailer is associated with")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the retailer is associated with")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[RetailerResponse]:
        """Search Retailers

        earches on retailers that the account has access to.

        :param version: (required)
        :type version: float
        :param visibility:  (required)
        :type visibility: str
        :param sort_field: The column to sort the search on (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The record to begin the return set on (required)
        :type start: int
        :param limit: The number of records to return (required)
        :type limit: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param category_ids: the categories that the retailer is associated with
        :type category_ids: str
        :param filter_ids: the filters that the retailer is associated with
        :type filter_ids: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailers_serialize(
            version=version,
            visibility=visibility,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            category_ids=category_ids,
            filter_ids=filter_ids,
            i=i,
            l=l,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_retailers_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        visibility: StrictStr,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The record to begin the return set on")],
        limit: Annotated[StrictInt, Field(description="The number of records to return")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the retailer is associated with")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the retailer is associated with")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[RetailerResponse]]:
        """Search Retailers

        earches on retailers that the account has access to.

        :param version: (required)
        :type version: float
        :param visibility:  (required)
        :type visibility: str
        :param sort_field: The column to sort the search on (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The record to begin the return set on (required)
        :type start: int
        :param limit: The number of records to return (required)
        :type limit: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param category_ids: the categories that the retailer is associated with
        :type category_ids: str
        :param filter_ids: the filters that the retailer is associated with
        :type filter_ids: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailers_serialize(
            version=version,
            visibility=visibility,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            category_ids=category_ids,
            filter_ids=filter_ids,
            i=i,
            l=l,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_retailers_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        visibility: StrictStr,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The record to begin the return set on")],
        limit: Annotated[StrictInt, Field(description="The number of records to return")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="the categories that the retailer is associated with")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="the filters that the retailer is associated with")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Retailers

        earches on retailers that the account has access to.

        :param version: (required)
        :type version: float
        :param visibility:  (required)
        :type visibility: str
        :param sort_field: The column to sort the search on (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The record to begin the return set on (required)
        :type start: int
        :param limit: The number of records to return (required)
        :type limit: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param category_ids: the categories that the retailer is associated with
        :type category_ids: str
        :param filter_ids: the filters that the retailer is associated with
        :type filter_ids: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_retailers_serialize(
            version=version,
            visibility=visibility,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            category_ids=category_ids,
            filter_ids=filter_ids,
            i=i,
            l=l,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[RetailerResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_retailers_serialize(
        self,
        version,
        visibility,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        device_id,
        account_id,
        q,
        keyword,
        category_ids,
        filter_ids,
        i,
        l,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/retailer/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def retailer_login_check(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="the user's email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="the password")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (optional)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AccountLoginResponse:
        """Login Retailer

        Retailer login check.

        :param version: (required)
        :type version: float
        :param username: the user's email address they used to sign-up (required)
        :type username: str
        :param password: the password (required)
        :type password: str
        :param device_id: the device id (optional)
        :type device_id: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retailer_login_check_serialize(
            version=version,
            username=username,
            password=password,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def retailer_login_check_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="the user's email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="the password")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (optional)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AccountLoginResponse]:
        """Login Retailer

        Retailer login check.

        :param version: (required)
        :type version: float
        :param username: the user's email address they used to sign-up (required)
        :type username: str
        :param password: the password (required)
        :type password: str
        :param device_id: the device id (optional)
        :type device_id: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retailer_login_check_serialize(
            version=version,
            username=username,
            password=password,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def retailer_login_check_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        username: Annotated[StrictStr, Field(description="the user's email address they used to sign-up")],
        password: Annotated[StrictStr, Field(description="the password")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (optional)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Login Retailer

        Retailer login check.

        :param version: (required)
        :type version: float
        :param username: the user's email address they used to sign-up (required)
        :type username: str
        :param password: the password (required)
        :type password: str
        :param device_id: the device id (optional)
        :type device_id: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param app_key: the application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._retailer_login_check_serialize(
            version=version,
            username=username,
            password=password,
            device_id=device_id,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AccountLoginResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _retailer_login_check_serialize(
        self,
        version,
        username,
        password,
        device_id,
        latitude,
        longitude,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if username is not None:
            
            _query_params.append(('username', username))
            
        if password is not None:
            
            _query_params.append(('password', password))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/login',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_retailer(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="The ID of the retailer to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the retailer")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone of the retailer")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer")] = None,
        facebook_url: Annotated[Optional[StrictStr], Field(description="The facebook URL of the retailer")] = None,
        twitter_url: Annotated[Optional[StrictStr], Field(description="The twitter URL of the retailer")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailers by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailers")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="External custom search keywords")] = None,
        retailer_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        visibility: Optional[StrictStr] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the retailer is active or inactive (hidden from consumers)")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerFullResponse:
        """Update Retailer

        Update a retailer record. Only the owner and the employees of the retailer have access to update its information.

        :param version: (required)
        :type version: float
        :param retailer_id: The ID of the retailer to update (required)
        :type retailer_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the retailer
        :type name: str
        :param street_address: The street address of the retailer
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer
        :type city: str
        :param state: The state of the retailer
        :type state: str
        :param postal_code: The postal code of the retailer
        :type postal_code: str
        :param country: the country of the retailer
        :type country: str
        :param business_phone: The business phone of the retailer
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer
        :type business_phone_ext: str
        :param website: The website of the retailer
        :type website: str
        :param email: The email of the retailer
        :type email: str
        :param facebook_url: The facebook URL of the retailer
        :type facebook_url: str
        :param twitter_url: The twitter URL of the retailer
        :type twitter_url: str
        :param logo: The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailers by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailers
        :type filter_ids: str
        :param latitude: the latitude of the retailer
        :type latitude: float
        :param longitude: the longitude of the retailer
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param search_tags: External custom search keywords
        :type search_tags: str
        :param retailer_type: External custom type identifier
        :type retailer_type: str
        :param visibility: 
        :type visibility: str
        :param active: Sets whether the retailer is active or inactive (hidden from consumers)
        :type active: bool
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_retailer_serialize(
            version=version,
            retailer_id=retailer_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            facebook_url=facebook_url,
            twitter_url=twitter_url,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            search_tags=search_tags,
            retailer_type=retailer_type,
            visibility=visibility,
            active=active,
            response_format=response_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_retailer_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="The ID of the retailer to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the retailer")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone of the retailer")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer")] = None,
        facebook_url: Annotated[Optional[StrictStr], Field(description="The facebook URL of the retailer")] = None,
        twitter_url: Annotated[Optional[StrictStr], Field(description="The twitter URL of the retailer")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailers by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailers")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="External custom search keywords")] = None,
        retailer_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        visibility: Optional[StrictStr] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the retailer is active or inactive (hidden from consumers)")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerFullResponse]:
        """Update Retailer

        Update a retailer record. Only the owner and the employees of the retailer have access to update its information.

        :param version: (required)
        :type version: float
        :param retailer_id: The ID of the retailer to update (required)
        :type retailer_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the retailer
        :type name: str
        :param street_address: The street address of the retailer
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer
        :type city: str
        :param state: The state of the retailer
        :type state: str
        :param postal_code: The postal code of the retailer
        :type postal_code: str
        :param country: the country of the retailer
        :type country: str
        :param business_phone: The business phone of the retailer
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer
        :type business_phone_ext: str
        :param website: The website of the retailer
        :type website: str
        :param email: The email of the retailer
        :type email: str
        :param facebook_url: The facebook URL of the retailer
        :type facebook_url: str
        :param twitter_url: The twitter URL of the retailer
        :type twitter_url: str
        :param logo: The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailers by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailers
        :type filter_ids: str
        :param latitude: the latitude of the retailer
        :type latitude: float
        :param longitude: the longitude of the retailer
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param search_tags: External custom search keywords
        :type search_tags: str
        :param retailer_type: External custom type identifier
        :type retailer_type: str
        :param visibility: 
        :type visibility: str
        :param active: Sets whether the retailer is active or inactive (hidden from consumers)
        :type active: bool
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_retailer_serialize(
            version=version,
            retailer_id=retailer_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            facebook_url=facebook_url,
            twitter_url=twitter_url,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            search_tags=search_tags,
            retailer_type=retailer_type,
            visibility=visibility,
            active=active,
            response_format=response_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_retailer_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        retailer_id: Annotated[StrictInt, Field(description="The ID of the retailer to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the retailer")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the retailer")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the retailer")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of the retailer")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the retailer")] = None,
        country: Annotated[Optional[StrictStr], Field(description="the country of the retailer")] = None,
        business_phone: Annotated[Optional[StrictStr], Field(description="The business phone of the retailer")] = None,
        business_phone_ext: Annotated[Optional[StrictStr], Field(description="The business phone extension of the retailer")] = None,
        website: Annotated[Optional[StrictStr], Field(description="The website of the retailer")] = None,
        email: Annotated[Optional[StrictStr], Field(description="The email of the retailer")] = None,
        facebook_url: Annotated[Optional[StrictStr], Field(description="The facebook URL of the retailer")] = None,
        twitter_url: Annotated[Optional[StrictStr], Field(description="The twitter URL of the retailer")] = None,
        logo: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)")] = None,
        logo_asset_id: Annotated[Optional[StrictInt], Field(description="The retailer logo asset id")] = None,
        picture1: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)")] = None,
        picture1_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        picture2: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)")] = None,
        picture2_asset_id: Annotated[Optional[StrictInt], Field(description="An asset id")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category IDs used to filter retailers by categories")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter IDs used to filter retailers")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the retailer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the retailer")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="External custom search keywords")] = None,
        retailer_type: Annotated[Optional[StrictStr], Field(description="External custom type identifier")] = None,
        visibility: Optional[StrictStr] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the retailer is active or inactive (hidden from consumers)")] = None,
        response_format: Annotated[Optional[StrictStr], Field(description="The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Retailer

        Update a retailer record. Only the owner and the employees of the retailer have access to update its information.

        :param version: (required)
        :type version: float
        :param retailer_id: The ID of the retailer to update (required)
        :type retailer_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: The name of the retailer
        :type name: str
        :param street_address: The street address of the retailer
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the retailer
        :type city: str
        :param state: The state of the retailer
        :type state: str
        :param postal_code: The postal code of the retailer
        :type postal_code: str
        :param country: the country of the retailer
        :type country: str
        :param business_phone: The business phone of the retailer
        :type business_phone: str
        :param business_phone_ext: The business phone extension of the retailer
        :type business_phone_ext: str
        :param website: The website of the retailer
        :type website: str
        :param email: The email of the retailer
        :type email: str
        :param facebook_url: The facebook URL of the retailer
        :type facebook_url: str
        :param twitter_url: The twitter URL of the retailer
        :type twitter_url: str
        :param logo: The retailer logo sent as a multipart binary file (you can optionally use logoAssetId if the asset has already been uploaded before)
        :type logo: bytearray
        :param logo_asset_id: The retailer logo asset id
        :type logo_asset_id: int
        :param picture1: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture1AssetId if the asset has already been uploaded before)
        :type picture1: bytearray
        :param picture1_asset_id: An asset id
        :type picture1_asset_id: int
        :param picture2: Optional store-front pictures or product pictures or etc. A multipart binary file (you can optionally use picture2AssetId if the asset has already been uploaded before)
        :type picture2: bytearray
        :param picture2_asset_id: An asset id
        :type picture2_asset_id: int
        :param category_ids: Comma separated list of category IDs used to filter retailers by categories
        :type category_ids: str
        :param filter_ids: Comma separated list of filter IDs used to filter retailers
        :type filter_ids: str
        :param latitude: the latitude of the retailer
        :type latitude: float
        :param longitude: the longitude of the retailer
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param search_tags: External custom search keywords
        :type search_tags: str
        :param retailer_type: External custom type identifier
        :type retailer_type: str
        :param visibility: 
        :type visibility: str
        :param active: Sets whether the retailer is active or inactive (hidden from consumers)
        :type active: bool
        :param response_format: The format of the returned response {JSON // default , HTML // for Dojo support when uploading assets}
        :type response_format: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_retailer_serialize(
            version=version,
            retailer_id=retailer_id,
            device_id=device_id,
            account_id=account_id,
            name=name,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            country=country,
            business_phone=business_phone,
            business_phone_ext=business_phone_ext,
            website=website,
            email=email,
            facebook_url=facebook_url,
            twitter_url=twitter_url,
            logo=logo,
            logo_asset_id=logo_asset_id,
            picture1=picture1,
            picture1_asset_id=picture1_asset_id,
            picture2=picture2,
            picture2_asset_id=picture2_asset_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            search_tags=search_tags,
            retailer_type=retailer_type,
            visibility=visibility,
            active=active,
            response_format=response_format,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_retailer_serialize(
        self,
        version,
        retailer_id,
        device_id,
        account_id,
        name,
        street_address,
        street_address2,
        city,
        state,
        postal_code,
        country,
        business_phone,
        business_phone_ext,
        website,
        email,
        facebook_url,
        twitter_url,
        logo,
        logo_asset_id,
        picture1,
        picture1_asset_id,
        picture2,
        picture2_asset_id,
        category_ids,
        filter_ids,
        latitude,
        longitude,
        meta_data,
        search_tags,
        retailer_type,
        visibility,
        active,
        response_format,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if country is not None:
            
            _query_params.append(('country', country))
            
        if business_phone is not None:
            
            _query_params.append(('businessPhone', business_phone))
            
        if business_phone_ext is not None:
            
            _query_params.append(('businessPhoneExt', business_phone_ext))
            
        if website is not None:
            
            _query_params.append(('website', website))
            
        if email is not None:
            
            _query_params.append(('email', email))
            
        if facebook_url is not None:
            
            _query_params.append(('facebookUrl', facebook_url))
            
        if twitter_url is not None:
            
            _query_params.append(('twitterUrl', twitter_url))
            
        if logo is not None:
            
            _query_params.append(('logo', logo))
            
        if logo_asset_id is not None:
            
            _query_params.append(('logoAssetId', logo_asset_id))
            
        if picture1 is not None:
            
            _query_params.append(('picture1', picture1))
            
        if picture1_asset_id is not None:
            
            _query_params.append(('picture1AssetId', picture1_asset_id))
            
        if picture2 is not None:
            
            _query_params.append(('picture2', picture2))
            
        if picture2_asset_id is not None:
            
            _query_params.append(('picture2AssetId', picture2_asset_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if retailer_type is not None:
            
            _query_params.append(('retailerType', retailer_type))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if response_format is not None:
            
            _query_params.append(('responseFormat', response_format))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/retailer/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


