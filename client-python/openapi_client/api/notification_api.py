# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.blocked_notification_response import BlockedNotificationResponse
from openapi_client.models.notification_message_list_response import NotificationMessageListResponse
from openapi_client.models.notification_recipient_response import NotificationRecipientResponse
from openapi_client.models.notification_recipient_response_list_response import NotificationRecipientResponseListResponse
from openapi_client.models.notification_template_response import NotificationTemplateResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class NotificationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_notification_template(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        conduit: Annotated[StrictStr, Field(description="Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")],
        title: Annotated[StrictStr, Field(description="title of the notification template")],
        body: Annotated[StrictStr, Field(description="body of the notification template")],
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application.")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Filter results by event.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="tags associated with the note template")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationTemplateResponse:
        """Create Notification Template

        Create a notification template. Developers will only be able to create notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param conduit: Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (required)
        :type conduit: str
        :param title: title of the notification template (required)
        :type title: str
        :param body: body of the notification template (required)
        :type body: str
        :param app_key: Filter results by application.
        :type app_key: str
        :param event: Filter results by event.
        :type event: str
        :param tags: tags associated with the note template
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_notification_template_serialize(
            version=version,
            account_id=account_id,
            conduit=conduit,
            title=title,
            body=body,
            app_key=app_key,
            event=event,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_notification_template_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        conduit: Annotated[StrictStr, Field(description="Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")],
        title: Annotated[StrictStr, Field(description="title of the notification template")],
        body: Annotated[StrictStr, Field(description="body of the notification template")],
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application.")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Filter results by event.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="tags associated with the note template")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationTemplateResponse]:
        """Create Notification Template

        Create a notification template. Developers will only be able to create notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param conduit: Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (required)
        :type conduit: str
        :param title: title of the notification template (required)
        :type title: str
        :param body: body of the notification template (required)
        :type body: str
        :param app_key: Filter results by application.
        :type app_key: str
        :param event: Filter results by event.
        :type event: str
        :param tags: tags associated with the note template
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_notification_template_serialize(
            version=version,
            account_id=account_id,
            conduit=conduit,
            title=title,
            body=body,
            app_key=app_key,
            event=event,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_notification_template_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        conduit: Annotated[StrictStr, Field(description="Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")],
        title: Annotated[StrictStr, Field(description="title of the notification template")],
        body: Annotated[StrictStr, Field(description="body of the notification template")],
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application.")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Filter results by event.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="tags associated with the note template")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Notification Template

        Create a notification template. Developers will only be able to create notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param conduit: Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION. (required)
        :type conduit: str
        :param title: title of the notification template (required)
        :type title: str
        :param body: body of the notification template (required)
        :type body: str
        :param app_key: Filter results by application.
        :type app_key: str
        :param event: Filter results by event.
        :type event: str
        :param tags: tags associated with the note template
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_notification_template_serialize(
            version=version,
            account_id=account_id,
            conduit=conduit,
            title=title,
            body=body,
            app_key=app_key,
            event=event,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_notification_template_serialize(
        self,
        version,
        account_id,
        conduit,
        title,
        body,
        app_key,
        event,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if conduit is not None:
            
            _query_params.append(('conduit', conduit))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if body is not None:
            
            _query_params.append(('body', body))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/template/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_or_update_blocked_notifications(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        data: Annotated[StrictStr, Field(description="batch data payload (application specific)")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BlockedNotificationResponse:
        """Create or update blocked notification settings

        Create or update blocked notification settings

        :param version: (required)
        :type version: float
        :param app_key: The application key (required)
        :type app_key: str
        :param data: batch data payload (application specific) (required)
        :type data: str
        :param account_id: the account id of the user
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_blocked_notifications_serialize(
            version=version,
            app_key=app_key,
            data=data,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockedNotificationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_or_update_blocked_notifications_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        data: Annotated[StrictStr, Field(description="batch data payload (application specific)")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BlockedNotificationResponse]:
        """Create or update blocked notification settings

        Create or update blocked notification settings

        :param version: (required)
        :type version: float
        :param app_key: The application key (required)
        :type app_key: str
        :param data: batch data payload (application specific) (required)
        :type data: str
        :param account_id: the account id of the user
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_blocked_notifications_serialize(
            version=version,
            app_key=app_key,
            data=data,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockedNotificationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_or_update_blocked_notifications_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        data: Annotated[StrictStr, Field(description="batch data payload (application specific)")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or update blocked notification settings

        Create or update blocked notification settings

        :param version: (required)
        :type version: float
        :param app_key: The application key (required)
        :type app_key: str
        :param data: batch data payload (application specific) (required)
        :type data: str
        :param account_id: the account id of the user
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_blocked_notifications_serialize(
            version=version,
            app_key=app_key,
            data=data,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockedNotificationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_or_update_blocked_notifications_serialize(
        self,
        version,
        app_key,
        data,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if data is not None:
            
            _query_params.append(('data', data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/blocked/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_notification_template(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        notification_template_id: Annotated[StrictInt, Field(description="the id of the notification template to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationTemplateResponse:
        """Delete Notification Template

        Deletes a notification template. Developers will only be able to delete notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param notification_template_id: the id of the notification template to delete (required)
        :type notification_template_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_notification_template_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        notification_template_id: Annotated[StrictInt, Field(description="the id of the notification template to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationTemplateResponse]:
        """Delete Notification Template

        Deletes a notification template. Developers will only be able to delete notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param notification_template_id: the id of the notification template to delete (required)
        :type notification_template_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_notification_template_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        notification_template_id: Annotated[StrictInt, Field(description="the id of the notification template to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Notification Template

        Deletes a notification template. Developers will only be able to delete notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param notification_template_id: the id of the notification template to delete (required)
        :type notification_template_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_notification_template_serialize(
        self,
        version,
        account_id,
        notification_template_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if notification_template_id is not None:
            
            _query_params.append(('notificationTemplateId', notification_template_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/template/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_notification_template(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the account")],
        notification_template_id: Annotated[StrictInt, Field(description="the id of the notification template to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationTemplateResponse:
        """Get Notification Template

        Get the details of a notification template. Developers will only be able to see notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: the id of the account (required)
        :type account_id: int
        :param notification_template_id: the id of the notification template to get (required)
        :type notification_template_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_notification_template_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the account")],
        notification_template_id: Annotated[StrictInt, Field(description="the id of the notification template to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationTemplateResponse]:
        """Get Notification Template

        Get the details of a notification template. Developers will only be able to see notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: the id of the account (required)
        :type account_id: int
        :param notification_template_id: the id of the notification template to get (required)
        :type notification_template_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_notification_template_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the account")],
        notification_template_id: Annotated[StrictInt, Field(description="the id of the notification template to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Notification Template

        Get the details of a notification template. Developers will only be able to see notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: the id of the account (required)
        :type account_id: int
        :param notification_template_id: the id of the notification template to get (required)
        :type notification_template_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_notification_template_serialize(
        self,
        version,
        account_id,
        notification_template_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if notification_template_id is not None:
            
            _query_params.append(('notificationTemplateId', notification_template_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/template/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_notifications(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the account id used to view another person's notifications")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter messages by application")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of content ids to search notifications on")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="comma separated list of content types to search notifications on")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of parent ids to search notifications on")] = None,
        parent_types: Annotated[Optional[StrictStr], Field(description="comma separated list of parent types to search notifications on")] = None,
        action_category: Annotated[Optional[StrictStr], Field(description="Action category used to filter notifications")] = None,
        conduits: Annotated[Optional[StrictStr], Field(description="comma separated list of conduits to search notifications on")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search notifications via keyword")] = None,
        return_read_messages: Annotated[Optional[StrictBool], Field(description="if set to true, will return notifications that have been marked as read")] = None,
        mark_as_read: Annotated[Optional[StrictBool], Field(description="if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent")] = None,
        from_date: Annotated[Optional[StrictInt], Field(description="filter notifications from this date")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        return_sent: Annotated[Optional[StrictBool], Field(description="whether to include notifications sent by the requester in the response")] = None,
        ignore_flagged: Annotated[Optional[StrictBool], Field(description="whether to ignore flagged notifications")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationMessageListResponse:
        """Get Notifications

        Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: the account id used to view another person's notifications
        :type connection_account_id: int
        :param app_key: the application key to filter messages by application
        :type app_key: str
        :param event_type: comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
        :type event_type: str
        :param content_ids: comma separated list of content ids to search notifications on
        :type content_ids: str
        :param content_types: comma separated list of content types to search notifications on
        :type content_types: str
        :param parent_ids: comma separated list of parent ids to search notifications on
        :type parent_ids: str
        :param parent_types: comma separated list of parent types to search notifications on
        :type parent_types: str
        :param action_category: Action category used to filter notifications
        :type action_category: str
        :param conduits: comma separated list of conduits to search notifications on
        :type conduits: str
        :param keyword: search notifications via keyword
        :type keyword: str
        :param return_read_messages: if set to true, will return notifications that have been marked as read
        :type return_read_messages: bool
        :param mark_as_read: if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
        :type mark_as_read: bool
        :param from_date: filter notifications from this date
        :type from_date: int
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param return_sent: whether to include notifications sent by the requester in the response
        :type return_sent: bool
        :param ignore_flagged: whether to ignore flagged notifications
        :type ignore_flagged: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_notifications_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            event_type=event_type,
            content_ids=content_ids,
            content_types=content_types,
            parent_ids=parent_ids,
            parent_types=parent_types,
            action_category=action_category,
            conduits=conduits,
            keyword=keyword,
            return_read_messages=return_read_messages,
            mark_as_read=mark_as_read,
            from_date=from_date,
            latitude=latitude,
            longitude=longitude,
            return_sent=return_sent,
            ignore_flagged=ignore_flagged,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationMessageListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_notifications_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the account id used to view another person's notifications")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter messages by application")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of content ids to search notifications on")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="comma separated list of content types to search notifications on")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of parent ids to search notifications on")] = None,
        parent_types: Annotated[Optional[StrictStr], Field(description="comma separated list of parent types to search notifications on")] = None,
        action_category: Annotated[Optional[StrictStr], Field(description="Action category used to filter notifications")] = None,
        conduits: Annotated[Optional[StrictStr], Field(description="comma separated list of conduits to search notifications on")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search notifications via keyword")] = None,
        return_read_messages: Annotated[Optional[StrictBool], Field(description="if set to true, will return notifications that have been marked as read")] = None,
        mark_as_read: Annotated[Optional[StrictBool], Field(description="if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent")] = None,
        from_date: Annotated[Optional[StrictInt], Field(description="filter notifications from this date")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        return_sent: Annotated[Optional[StrictBool], Field(description="whether to include notifications sent by the requester in the response")] = None,
        ignore_flagged: Annotated[Optional[StrictBool], Field(description="whether to ignore flagged notifications")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationMessageListResponse]:
        """Get Notifications

        Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: the account id used to view another person's notifications
        :type connection_account_id: int
        :param app_key: the application key to filter messages by application
        :type app_key: str
        :param event_type: comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
        :type event_type: str
        :param content_ids: comma separated list of content ids to search notifications on
        :type content_ids: str
        :param content_types: comma separated list of content types to search notifications on
        :type content_types: str
        :param parent_ids: comma separated list of parent ids to search notifications on
        :type parent_ids: str
        :param parent_types: comma separated list of parent types to search notifications on
        :type parent_types: str
        :param action_category: Action category used to filter notifications
        :type action_category: str
        :param conduits: comma separated list of conduits to search notifications on
        :type conduits: str
        :param keyword: search notifications via keyword
        :type keyword: str
        :param return_read_messages: if set to true, will return notifications that have been marked as read
        :type return_read_messages: bool
        :param mark_as_read: if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
        :type mark_as_read: bool
        :param from_date: filter notifications from this date
        :type from_date: int
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param return_sent: whether to include notifications sent by the requester in the response
        :type return_sent: bool
        :param ignore_flagged: whether to ignore flagged notifications
        :type ignore_flagged: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_notifications_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            event_type=event_type,
            content_ids=content_ids,
            content_types=content_types,
            parent_ids=parent_ids,
            parent_types=parent_types,
            action_category=action_category,
            conduits=conduits,
            keyword=keyword,
            return_read_messages=return_read_messages,
            mark_as_read=mark_as_read,
            from_date=from_date,
            latitude=latitude,
            longitude=longitude,
            return_sent=return_sent,
            ignore_flagged=ignore_flagged,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationMessageListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_notifications_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the account id used to view another person's notifications")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter messages by application")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of content ids to search notifications on")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="comma separated list of content types to search notifications on")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of parent ids to search notifications on")] = None,
        parent_types: Annotated[Optional[StrictStr], Field(description="comma separated list of parent types to search notifications on")] = None,
        action_category: Annotated[Optional[StrictStr], Field(description="Action category used to filter notifications")] = None,
        conduits: Annotated[Optional[StrictStr], Field(description="comma separated list of conduits to search notifications on")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search notifications via keyword")] = None,
        return_read_messages: Annotated[Optional[StrictBool], Field(description="if set to true, will return notifications that have been marked as read")] = None,
        mark_as_read: Annotated[Optional[StrictBool], Field(description="if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent")] = None,
        from_date: Annotated[Optional[StrictInt], Field(description="filter notifications from this date")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        return_sent: Annotated[Optional[StrictBool], Field(description="whether to include notifications sent by the requester in the response")] = None,
        ignore_flagged: Annotated[Optional[StrictBool], Field(description="whether to ignore flagged notifications")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Notifications

        Get a list of notifications for a user. If the \"markAsRead\" parameter is set to true, the returned notifications will be marked as \"read\" after the response has been sent. By default, read messages will not be returned, so to see read messages, set \"returnReadMessages\" to true.

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: the account id used to view another person's notifications
        :type connection_account_id: int
        :param app_key: the application key to filter messages by application
        :type app_key: str
        :param event_type: comma separated list of EVENTS. Filters search results to only include these events. Don't include this parameter or pass in an empty string to return all event types.
        :type event_type: str
        :param content_ids: comma separated list of content ids to search notifications on
        :type content_ids: str
        :param content_types: comma separated list of content types to search notifications on
        :type content_types: str
        :param parent_ids: comma separated list of parent ids to search notifications on
        :type parent_ids: str
        :param parent_types: comma separated list of parent types to search notifications on
        :type parent_types: str
        :param action_category: Action category used to filter notifications
        :type action_category: str
        :param conduits: comma separated list of conduits to search notifications on
        :type conduits: str
        :param keyword: search notifications via keyword
        :type keyword: str
        :param return_read_messages: if set to true, will return notifications that have been marked as read
        :type return_read_messages: bool
        :param mark_as_read: if set to true, the returned notifications will be marked as \\\"read\\\" after the response has been sent
        :type mark_as_read: bool
        :param from_date: filter notifications from this date
        :type from_date: int
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param return_sent: whether to include notifications sent by the requester in the response
        :type return_sent: bool
        :param ignore_flagged: whether to ignore flagged notifications
        :type ignore_flagged: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_notifications_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            event_type=event_type,
            content_ids=content_ids,
            content_types=content_types,
            parent_ids=parent_ids,
            parent_types=parent_types,
            action_category=action_category,
            conduits=conduits,
            keyword=keyword,
            return_read_messages=return_read_messages,
            mark_as_read=mark_as_read,
            from_date=from_date,
            latitude=latitude,
            longitude=longitude,
            return_sent=return_sent,
            ignore_flagged=ignore_flagged,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationMessageListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_notifications_serialize(
        self,
        version,
        device_id,
        account_id,
        connection_account_id,
        app_key,
        event_type,
        content_ids,
        content_types,
        parent_ids,
        parent_types,
        action_category,
        conduits,
        keyword,
        return_read_messages,
        mark_as_read,
        from_date,
        latitude,
        longitude,
        return_sent,
        ignore_flagged,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if content_ids is not None:
            
            _query_params.append(('contentIds', content_ids))
            
        if content_types is not None:
            
            _query_params.append(('contentTypes', content_types))
            
        if parent_ids is not None:
            
            _query_params.append(('parentIds', parent_ids))
            
        if parent_types is not None:
            
            _query_params.append(('parentTypes', parent_types))
            
        if action_category is not None:
            
            _query_params.append(('actionCategory', action_category))
            
        if conduits is not None:
            
            _query_params.append(('conduits', conduits))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if return_read_messages is not None:
            
            _query_params.append(('returnReadMessages', return_read_messages))
            
        if mark_as_read is not None:
            
            _query_params.append(('markAsRead', mark_as_read))
            
        if from_date is not None:
            
            _query_params.append(('fromDate', from_date))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if return_sent is not None:
            
            _query_params.append(('returnSent', return_sent))
            
        if ignore_flagged is not None:
            
            _query_params.append(('ignoreFlagged', ignore_flagged))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def register_notification_token(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="A token that is generated by the device to sign requests for the notification service providers")],
        push_type: Annotated[StrictStr, Field(description="The type of push notification. Possible values include: APNS, GCM")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        environment: Annotated[Optional[StrictStr], Field(description="Determines if the token is a DEVELOPMENT or PRODUCTION token")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated (use appKey instead)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the token is active or not (non-active tokens are not used)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Register Notification Token

        Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.

        :param version: (required)
        :type version: float
        :param token: A token that is generated by the device to sign requests for the notification service providers (required)
        :type token: str
        :param push_type: The type of push notification. Possible values include: APNS, GCM (required)
        :type push_type: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param environment: Determines if the token is a DEVELOPMENT or PRODUCTION token
        :type environment: str
        :param app_key: The application key
        :type app_key: str
        :param game_type: This parameter is deprecated (use appKey instead)
        :type game_type: str
        :param active: Sets whether the token is active or not (non-active tokens are not used)
        :type active: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_notification_token_serialize(
            version=version,
            token=token,
            push_type=push_type,
            device_id=device_id,
            account_id=account_id,
            environment=environment,
            app_key=app_key,
            game_type=game_type,
            active=active,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def register_notification_token_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="A token that is generated by the device to sign requests for the notification service providers")],
        push_type: Annotated[StrictStr, Field(description="The type of push notification. Possible values include: APNS, GCM")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        environment: Annotated[Optional[StrictStr], Field(description="Determines if the token is a DEVELOPMENT or PRODUCTION token")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated (use appKey instead)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the token is active or not (non-active tokens are not used)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Register Notification Token

        Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.

        :param version: (required)
        :type version: float
        :param token: A token that is generated by the device to sign requests for the notification service providers (required)
        :type token: str
        :param push_type: The type of push notification. Possible values include: APNS, GCM (required)
        :type push_type: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param environment: Determines if the token is a DEVELOPMENT or PRODUCTION token
        :type environment: str
        :param app_key: The application key
        :type app_key: str
        :param game_type: This parameter is deprecated (use appKey instead)
        :type game_type: str
        :param active: Sets whether the token is active or not (non-active tokens are not used)
        :type active: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_notification_token_serialize(
            version=version,
            token=token,
            push_type=push_type,
            device_id=device_id,
            account_id=account_id,
            environment=environment,
            app_key=app_key,
            game_type=game_type,
            active=active,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def register_notification_token_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        token: Annotated[StrictStr, Field(description="A token that is generated by the device to sign requests for the notification service providers")],
        push_type: Annotated[StrictStr, Field(description="The type of push notification. Possible values include: APNS, GCM")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        environment: Annotated[Optional[StrictStr], Field(description="Determines if the token is a DEVELOPMENT or PRODUCTION token")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated (use appKey instead)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the token is active or not (non-active tokens are not used)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Register Notification Token

        Register a token to send application dependent notifications like Google Cloud Messaging, or Apple Push Notifications.

        :param version: (required)
        :type version: float
        :param token: A token that is generated by the device to sign requests for the notification service providers (required)
        :type token: str
        :param push_type: The type of push notification. Possible values include: APNS, GCM (required)
        :type push_type: str
        :param device_id: The unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param environment: Determines if the token is a DEVELOPMENT or PRODUCTION token
        :type environment: str
        :param app_key: The application key
        :type app_key: str
        :param game_type: This parameter is deprecated (use appKey instead)
        :type game_type: str
        :param active: Sets whether the token is active or not (non-active tokens are not used)
        :type active: bool
        :param latitude: Latitude used to update the user's current location
        :type latitude: float
        :param longitude: Longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._register_notification_token_serialize(
            version=version,
            token=token,
            push_type=push_type,
            device_id=device_id,
            account_id=account_id,
            environment=environment,
            app_key=app_key,
            game_type=game_type,
            active=active,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _register_notification_token_serialize(
        self,
        version,
        token,
        push_type,
        device_id,
        account_id,
        environment,
        app_key,
        game_type,
        active,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        if push_type is not None:
            
            _query_params.append(('pushType', push_type))
            
        if environment is not None:
            
            _query_params.append(('environment', environment))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/token',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_blocked_notifications(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="search tags to filter results")] = None,
        events: Annotated[Optional[StrictStr], Field(description="events to filter by (comma separated)")] = None,
        conduits: Annotated[Optional[StrictStr], Field(description="conduits to filter by (comma separated)")] = None,
        custom_types: Annotated[Optional[StrictStr], Field(description="custom types to filter by (comma separated)")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="content types to filter by (comma separated)")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="content ids to filter by (comma separated)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="sort field for results")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="whether to sort descending")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> BlockedNotificationResponse:
        """Search on the user's blocked notification settings

        Search on the user's blocked notification settings

        :param version: (required)
        :type version: float
        :param app_key: The application key (required)
        :type app_key: str
        :param account_id: the account id of the user
        :type account_id: int
        :param search_tags: search tags to filter results
        :type search_tags: str
        :param events: events to filter by (comma separated)
        :type events: str
        :param conduits: conduits to filter by (comma separated)
        :type conduits: str
        :param custom_types: custom types to filter by (comma separated)
        :type custom_types: str
        :param content_types: content types to filter by (comma separated)
        :type content_types: str
        :param content_ids: content ids to filter by (comma separated)
        :type content_ids: str
        :param sort_field: sort field for results
        :type sort_field: str
        :param descending: whether to sort descending
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_blocked_notifications_serialize(
            version=version,
            app_key=app_key,
            account_id=account_id,
            search_tags=search_tags,
            events=events,
            conduits=conduits,
            custom_types=custom_types,
            content_types=content_types,
            content_ids=content_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockedNotificationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_blocked_notifications_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="search tags to filter results")] = None,
        events: Annotated[Optional[StrictStr], Field(description="events to filter by (comma separated)")] = None,
        conduits: Annotated[Optional[StrictStr], Field(description="conduits to filter by (comma separated)")] = None,
        custom_types: Annotated[Optional[StrictStr], Field(description="custom types to filter by (comma separated)")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="content types to filter by (comma separated)")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="content ids to filter by (comma separated)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="sort field for results")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="whether to sort descending")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[BlockedNotificationResponse]:
        """Search on the user's blocked notification settings

        Search on the user's blocked notification settings

        :param version: (required)
        :type version: float
        :param app_key: The application key (required)
        :type app_key: str
        :param account_id: the account id of the user
        :type account_id: int
        :param search_tags: search tags to filter results
        :type search_tags: str
        :param events: events to filter by (comma separated)
        :type events: str
        :param conduits: conduits to filter by (comma separated)
        :type conduits: str
        :param custom_types: custom types to filter by (comma separated)
        :type custom_types: str
        :param content_types: content types to filter by (comma separated)
        :type content_types: str
        :param content_ids: content ids to filter by (comma separated)
        :type content_ids: str
        :param sort_field: sort field for results
        :type sort_field: str
        :param descending: whether to sort descending
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_blocked_notifications_serialize(
            version=version,
            app_key=app_key,
            account_id=account_id,
            search_tags=search_tags,
            events=events,
            conduits=conduits,
            custom_types=custom_types,
            content_types=content_types,
            content_ids=content_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockedNotificationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_blocked_notifications_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="search tags to filter results")] = None,
        events: Annotated[Optional[StrictStr], Field(description="events to filter by (comma separated)")] = None,
        conduits: Annotated[Optional[StrictStr], Field(description="conduits to filter by (comma separated)")] = None,
        custom_types: Annotated[Optional[StrictStr], Field(description="custom types to filter by (comma separated)")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="content types to filter by (comma separated)")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="content ids to filter by (comma separated)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="sort field for results")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="whether to sort descending")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search on the user's blocked notification settings

        Search on the user's blocked notification settings

        :param version: (required)
        :type version: float
        :param app_key: The application key (required)
        :type app_key: str
        :param account_id: the account id of the user
        :type account_id: int
        :param search_tags: search tags to filter results
        :type search_tags: str
        :param events: events to filter by (comma separated)
        :type events: str
        :param conduits: conduits to filter by (comma separated)
        :type conduits: str
        :param custom_types: custom types to filter by (comma separated)
        :type custom_types: str
        :param content_types: content types to filter by (comma separated)
        :type content_types: str
        :param content_ids: content ids to filter by (comma separated)
        :type content_ids: str
        :param sort_field: sort field for results
        :type sort_field: str
        :param descending: whether to sort descending
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_blocked_notifications_serialize(
            version=version,
            app_key=app_key,
            account_id=account_id,
            search_tags=search_tags,
            events=events,
            conduits=conduits,
            custom_types=custom_types,
            content_types=content_types,
            content_ids=content_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "BlockedNotificationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_blocked_notifications_serialize(
        self,
        version,
        app_key,
        account_id,
        search_tags,
        events,
        conduits,
        custom_types,
        content_types,
        content_ids,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if events is not None:
            
            _query_params.append(('events', events))
            
        if conduits is not None:
            
            _query_params.append(('conduits', conduits))
            
        if custom_types is not None:
            
            _query_params.append(('customTypes', custom_types))
            
        if content_types is not None:
            
            _query_params.append(('contentTypes', content_types))
            
        if content_ids is not None:
            
            _query_params.append(('contentIds', content_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/blocked/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_notification_template(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        sort_field: Annotated[StrictStr, Field(description="Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.")],
        descending: Annotated[StrictBool, Field(description="Specified whether the results are returned in descending or ascending order.")],
        start: Annotated[StrictInt, Field(description="The start of the pagination.")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination.")],
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application.")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Filter results by event.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        global_only: Annotated[Optional[StrictBool], Field(description="Returns only templates that have been reserved for system use on all applications (only for admin accounts).")] = None,
        reserved_only: Annotated[Optional[StrictBool], Field(description="Returns only templates that use reserved events.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Filter results by keyword on the title, tags.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationTemplateResponse:
        """Search Notification Templates

        Search for notification templates on owned applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param sort_field: Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false. (required)
        :type sort_field: str
        :param descending: Specified whether the results are returned in descending or ascending order. (required)
        :type descending: bool
        :param start: The start of the pagination. (required)
        :type start: int
        :param limit: The limit of the pagination. (required)
        :type limit: int
        :param app_key: Filter results by application.
        :type app_key: str
        :param event: Filter results by event.
        :type event: str
        :param conduit: Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param global_only: Returns only templates that have been reserved for system use on all applications (only for admin accounts).
        :type global_only: bool
        :param reserved_only: Returns only templates that use reserved events.
        :type reserved_only: bool
        :param keyword: Filter results by keyword on the title, tags.
        :type keyword: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_notification_template_serialize(
            version=version,
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            app_key=app_key,
            event=event,
            conduit=conduit,
            global_only=global_only,
            reserved_only=reserved_only,
            keyword=keyword,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_notification_template_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        sort_field: Annotated[StrictStr, Field(description="Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.")],
        descending: Annotated[StrictBool, Field(description="Specified whether the results are returned in descending or ascending order.")],
        start: Annotated[StrictInt, Field(description="The start of the pagination.")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination.")],
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application.")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Filter results by event.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        global_only: Annotated[Optional[StrictBool], Field(description="Returns only templates that have been reserved for system use on all applications (only for admin accounts).")] = None,
        reserved_only: Annotated[Optional[StrictBool], Field(description="Returns only templates that use reserved events.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Filter results by keyword on the title, tags.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationTemplateResponse]:
        """Search Notification Templates

        Search for notification templates on owned applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param sort_field: Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false. (required)
        :type sort_field: str
        :param descending: Specified whether the results are returned in descending or ascending order. (required)
        :type descending: bool
        :param start: The start of the pagination. (required)
        :type start: int
        :param limit: The limit of the pagination. (required)
        :type limit: int
        :param app_key: Filter results by application.
        :type app_key: str
        :param event: Filter results by event.
        :type event: str
        :param conduit: Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param global_only: Returns only templates that have been reserved for system use on all applications (only for admin accounts).
        :type global_only: bool
        :param reserved_only: Returns only templates that use reserved events.
        :type reserved_only: bool
        :param keyword: Filter results by keyword on the title, tags.
        :type keyword: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_notification_template_serialize(
            version=version,
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            app_key=app_key,
            event=event,
            conduit=conduit,
            global_only=global_only,
            reserved_only=reserved_only,
            keyword=keyword,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_notification_template_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        sort_field: Annotated[StrictStr, Field(description="Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false.")],
        descending: Annotated[StrictBool, Field(description="Specified whether the results are returned in descending or ascending order.")],
        start: Annotated[StrictInt, Field(description="The start of the pagination.")],
        limit: Annotated[StrictInt, Field(description="The limit of the pagination.")],
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application.")] = None,
        event: Annotated[Optional[StrictStr], Field(description="Filter results by event.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        global_only: Annotated[Optional[StrictBool], Field(description="Returns only templates that have been reserved for system use on all applications (only for admin accounts).")] = None,
        reserved_only: Annotated[Optional[StrictBool], Field(description="Returns only templates that use reserved events.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Filter results by keyword on the title, tags.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Notification Templates

        Search for notification templates on owned applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param sort_field: Specifies how results are ordered.ID - order results by the notificationTemplateId CREATED - order results by the created date UPDATED - order results by the updated date TITLE - order results by title EVENT - order results by event CONDUIT - order results by conduit APP_NAME - order results by the application name ('global' templates will not have an application and will be returned last if 'descending' is set to false. (required)
        :type sort_field: str
        :param descending: Specified whether the results are returned in descending or ascending order. (required)
        :type descending: bool
        :param start: The start of the pagination. (required)
        :type start: int
        :param limit: The limit of the pagination. (required)
        :type limit: int
        :param app_key: Filter results by application.
        :type app_key: str
        :param event: Filter results by event.
        :type event: str
        :param conduit: Filter results by notification type: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param global_only: Returns only templates that have been reserved for system use on all applications (only for admin accounts).
        :type global_only: bool
        :param reserved_only: Returns only templates that use reserved events.
        :type reserved_only: bool
        :param keyword: Filter results by keyword on the title, tags.
        :type keyword: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_notification_template_serialize(
            version=version,
            account_id=account_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            app_key=app_key,
            event=event,
            conduit=conduit,
            global_only=global_only,
            reserved_only=reserved_only,
            keyword=keyword,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_notification_template_serialize(
        self,
        version,
        account_id,
        sort_field,
        descending,
        start,
        limit,
        app_key,
        event,
        conduit,
        global_only,
        reserved_only,
        keyword,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if event is not None:
            
            _query_params.append(('event', event))
            
        if conduit is not None:
            
            _query_params.append(('conduit', conduit))
            
        if global_only is not None:
            
            _query_params.append(('globalOnly', global_only))
            
        if reserved_only is not None:
            
            _query_params.append(('reservedOnly', reserved_only))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/template/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_recipients(
        self,
        version: Union[StrictFloat, StrictInt],
        sort_field: Annotated[StrictStr, Field(description="The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}")],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="filters results by application. If this is empty, will return all recipients for all applications that the user has access to.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search by keyword on user's display name and email")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. filter results by audience")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="filter results by audiences (comma separated list of audience ids)")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="filter results by connection groups (comma separated list of connection group ids)")] = None,
        recipient_account_ids: Annotated[Optional[StrictStr], Field(description="filter results by accounts (comma separated list of account ids)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination (hard limit of 1000)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[NotificationRecipientResponse]:
        """Search for Recipients

        Search for application users to send notifications.

        :param version: (required)
        :type version: float
        :param sort_field: The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME} (required)
        :type sort_field: str
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        :type app_key: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param keyword: search by keyword on user's display name and email
        :type keyword: str
        :param audience_id: This parameter is deprecated. filter results by audience
        :type audience_id: int
        :param audience_ids: filter results by audiences (comma separated list of audience ids)
        :type audience_ids: str
        :param connection_group_ids: filter results by connection groups (comma separated list of connection group ids)
        :type connection_group_ids: str
        :param recipient_account_ids: filter results by accounts (comma separated list of account ids)
        :type recipient_account_ids: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination (hard limit of 1000)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_recipients_serialize(
            version=version,
            sort_field=sort_field,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            conduit=conduit,
            keyword=keyword,
            audience_id=audience_id,
            audience_ids=audience_ids,
            connection_group_ids=connection_group_ids,
            recipient_account_ids=recipient_account_ids,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NotificationRecipientResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_recipients_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        sort_field: Annotated[StrictStr, Field(description="The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}")],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="filters results by application. If this is empty, will return all recipients for all applications that the user has access to.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search by keyword on user's display name and email")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. filter results by audience")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="filter results by audiences (comma separated list of audience ids)")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="filter results by connection groups (comma separated list of connection group ids)")] = None,
        recipient_account_ids: Annotated[Optional[StrictStr], Field(description="filter results by accounts (comma separated list of account ids)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination (hard limit of 1000)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[NotificationRecipientResponse]]:
        """Search for Recipients

        Search for application users to send notifications.

        :param version: (required)
        :type version: float
        :param sort_field: The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME} (required)
        :type sort_field: str
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        :type app_key: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param keyword: search by keyword on user's display name and email
        :type keyword: str
        :param audience_id: This parameter is deprecated. filter results by audience
        :type audience_id: int
        :param audience_ids: filter results by audiences (comma separated list of audience ids)
        :type audience_ids: str
        :param connection_group_ids: filter results by connection groups (comma separated list of connection group ids)
        :type connection_group_ids: str
        :param recipient_account_ids: filter results by accounts (comma separated list of account ids)
        :type recipient_account_ids: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination (hard limit of 1000)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_recipients_serialize(
            version=version,
            sort_field=sort_field,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            conduit=conduit,
            keyword=keyword,
            audience_id=audience_id,
            audience_ids=audience_ids,
            connection_group_ids=connection_group_ids,
            recipient_account_ids=recipient_account_ids,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NotificationRecipientResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_recipients_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        sort_field: Annotated[StrictStr, Field(description="The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME}")],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="filters results by application. If this is empty, will return all recipients for all applications that the user has access to.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search by keyword on user's display name and email")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. filter results by audience")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="filter results by audiences (comma separated list of audience ids)")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="filter results by connection groups (comma separated list of connection group ids)")] = None,
        recipient_account_ids: Annotated[Optional[StrictStr], Field(description="filter results by accounts (comma separated list of account ids)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination (hard limit of 1000)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Recipients

        Search for application users to send notifications.

        :param version: (required)
        :type version: float
        :param sort_field: The field to sort by. Possible values include: {ACCOUNT_DISPLAY, CREATED, UPDATED, ACTIVE, DELETED, LAST_LOGGED_IN, CONTACT_EMAIL, RETAILER_LOCATION_NAME, RETAILER_NAME, APPLICATION_NAME} (required)
        :type sort_field: str
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        :type app_key: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param keyword: search by keyword on user's display name and email
        :type keyword: str
        :param audience_id: This parameter is deprecated. filter results by audience
        :type audience_id: int
        :param audience_ids: filter results by audiences (comma separated list of audience ids)
        :type audience_ids: str
        :param connection_group_ids: filter results by connection groups (comma separated list of connection group ids)
        :type connection_group_ids: str
        :param recipient_account_ids: filter results by accounts (comma separated list of account ids)
        :type recipient_account_ids: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination (hard limit of 1000)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_recipients_serialize(
            version=version,
            sort_field=sort_field,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            conduit=conduit,
            keyword=keyword,
            audience_id=audience_id,
            audience_ids=audience_ids,
            connection_group_ids=connection_group_ids,
            recipient_account_ids=recipient_account_ids,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NotificationRecipientResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_recipients_serialize(
        self,
        version,
        sort_field,
        device_id,
        account_id,
        app_key,
        conduit,
        keyword,
        audience_id,
        audience_ids,
        connection_group_ids,
        recipient_account_ids,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if conduit is not None:
            
            _query_params.append(('conduit', conduit))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if connection_group_ids is not None:
            
            _query_params.append(('connectionGroupIds', connection_group_ids))
            
        if recipient_account_ids is not None:
            
            _query_params.append(('recipientAccountIds', recipient_account_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/recipient/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_recipients_count(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="filters results by application. If this is empty, will return all recipients for all applications that the user has access to.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search by keyword on user's display name and email")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. filter results by audience")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="filter results by audiences (comma separated list of audience ids)")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="filter results by connection groups (comma separated list of connection group ids)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by (see API docs for allowed values).")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationRecipientResponseListResponse:
        """Search for Recipients (Counts/Grouped)

        Search for application users to send notifications (count/grouped variant).

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        :type app_key: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param keyword: search by keyword on user's display name and email
        :type keyword: str
        :param audience_id: This parameter is deprecated. filter results by audience
        :type audience_id: int
        :param audience_ids: filter results by audiences (comma separated list of audience ids)
        :type audience_ids: str
        :param connection_group_ids: filter results by connection groups (comma separated list of connection group ids)
        :type connection_group_ids: str
        :param sort_field: The field to sort by (see API docs for allowed values).
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_recipients_count_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            conduit=conduit,
            keyword=keyword,
            audience_id=audience_id,
            audience_ids=audience_ids,
            connection_group_ids=connection_group_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationRecipientResponseListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_recipients_count_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="filters results by application. If this is empty, will return all recipients for all applications that the user has access to.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search by keyword on user's display name and email")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. filter results by audience")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="filter results by audiences (comma separated list of audience ids)")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="filter results by connection groups (comma separated list of connection group ids)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by (see API docs for allowed values).")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationRecipientResponseListResponse]:
        """Search for Recipients (Counts/Grouped)

        Search for application users to send notifications (count/grouped variant).

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        :type app_key: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param keyword: search by keyword on user's display name and email
        :type keyword: str
        :param audience_id: This parameter is deprecated. filter results by audience
        :type audience_id: int
        :param audience_ids: filter results by audiences (comma separated list of audience ids)
        :type audience_ids: str
        :param connection_group_ids: filter results by connection groups (comma separated list of connection group ids)
        :type connection_group_ids: str
        :param sort_field: The field to sort by (see API docs for allowed values).
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_recipients_count_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            conduit=conduit,
            keyword=keyword,
            audience_id=audience_id,
            audience_ids=audience_ids,
            connection_group_ids=connection_group_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationRecipientResponseListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_recipients_count_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="filters results by application. If this is empty, will return all recipients for all applications that the user has access to.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="search by keyword on user's display name and email")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. filter results by audience")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="filter results by audiences (comma separated list of audience ids)")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="filter results by connection groups (comma separated list of connection group ids)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by (see API docs for allowed values).")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="start of the pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="limit of the pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search for Recipients (Counts/Grouped)

        Search for application users to send notifications (count/grouped variant).

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: filters results by application. If this is empty, will return all recipients for all applications that the user has access to.
        :type app_key: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param keyword: search by keyword on user's display name and email
        :type keyword: str
        :param audience_id: This parameter is deprecated. filter results by audience
        :type audience_id: int
        :param audience_ids: filter results by audiences (comma separated list of audience ids)
        :type audience_ids: str
        :param connection_group_ids: filter results by connection groups (comma separated list of connection group ids)
        :type connection_group_ids: str
        :param sort_field: The field to sort by (see API docs for allowed values).
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: start of the pagination
        :type start: int
        :param limit: limit of the pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_recipients_count_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            conduit=conduit,
            keyword=keyword,
            audience_id=audience_id,
            audience_ids=audience_ids,
            connection_group_ids=connection_group_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationRecipientResponseListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_recipients_count_serialize(
        self,
        version,
        device_id,
        account_id,
        app_key,
        conduit,
        keyword,
        audience_id,
        audience_ids,
        connection_group_ids,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if conduit is not None:
            
            _query_params.append(('conduit', conduit))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if connection_group_ids is not None:
            
            _query_params.append(('connectionGroupIds', connection_group_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/recipient/search/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def send_batch_notifications(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the application owner/manager")],
        app_key: Annotated[StrictStr, Field(description="The application key for updating an existing application")],
        custom_message: Annotated[StrictStr, Field(description="Message string that will be displayed in on the notification")],
        conduit: Annotated[Optional[StrictStr], Field(description="The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Send Batch Notifications

        Send notifications to all users of an application. Only someone with permissions to the application can do this.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the application owner/manager (required)
        :type account_id: int
        :param app_key: The application key for updating an existing application (required)
        :type app_key: str
        :param custom_message: Message string that will be displayed in on the notification (required)
        :type custom_message: str
        :param conduit: The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param content_id: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_id: int
        :param content_name: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_name: str
        :param content_type: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_type: str
        :param parent_id: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_id: int
        :param parent_type: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_batch_notifications_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            custom_message=custom_message,
            conduit=conduit,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def send_batch_notifications_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the application owner/manager")],
        app_key: Annotated[StrictStr, Field(description="The application key for updating an existing application")],
        custom_message: Annotated[StrictStr, Field(description="Message string that will be displayed in on the notification")],
        conduit: Annotated[Optional[StrictStr], Field(description="The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Send Batch Notifications

        Send notifications to all users of an application. Only someone with permissions to the application can do this.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the application owner/manager (required)
        :type account_id: int
        :param app_key: The application key for updating an existing application (required)
        :type app_key: str
        :param custom_message: Message string that will be displayed in on the notification (required)
        :type custom_message: str
        :param conduit: The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param content_id: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_id: int
        :param content_name: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_name: str
        :param content_type: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_type: str
        :param parent_id: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_id: int
        :param parent_type: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_batch_notifications_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            custom_message=custom_message,
            conduit=conduit,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def send_batch_notifications_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the application owner/manager")],
        app_key: Annotated[StrictStr, Field(description="The application key for updating an existing application")],
        custom_message: Annotated[StrictStr, Field(description="Message string that will be displayed in on the notification")],
        conduit: Annotated[Optional[StrictStr], Field(description="The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="Default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Batch Notifications

        Send notifications to all users of an application. Only someone with permissions to the application can do this.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the application owner/manager (required)
        :type account_id: int
        :param app_key: The application key for updating an existing application (required)
        :type app_key: str
        :param custom_message: Message string that will be displayed in on the notification (required)
        :type custom_message: str
        :param conduit: The type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param content_id: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_id: int
        :param content_name: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_name: str
        :param content_type: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_type: str
        :param parent_id: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_id: int
        :param parent_type: Default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_batch_notifications_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            custom_message=custom_message,
            conduit=conduit,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_batch_notifications_serialize(
        self,
        version,
        account_id,
        app_key,
        custom_message,
        conduit,
        content_id,
        content_name,
        content_type,
        parent_id,
        parent_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if conduit is not None:
            
            _query_params.append(('conduit', conduit))
            
        if custom_message is not None:
            
            _query_params.append(('customMessage', custom_message))
            
        if content_id is not None:
            
            _query_params.append(('contentId', content_id))
            
        if content_name is not None:
            
            _query_params.append(('contentName', content_name))
            
        if content_type is not None:
            
            _query_params.append(('contentType', content_type))
            
        if parent_id is not None:
            
            _query_params.append(('parentId', parent_id))
            
        if parent_type is not None:
            
            _query_params.append(('parentType', parent_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def send_custom_notifications(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        receiver_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of account IDs that will receive the notification")] = None,
        include_friend_group: Annotated[Optional[StrictBool], Field(description="determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        action_category: Optional[StrictStr] = None,
        subject: Annotated[Optional[StrictStr], Field(description="the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="message string that will be displayed in on the notification")] = None,
        friend_only_apns: Annotated[Optional[StrictBool], Field(description="only sends APNS to people who are friends of the user (still saves the notification message for feed polling)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Send Custom Notifications

        Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param receiver_account_ids: comma separated list of account IDs that will receive the notification
        :type receiver_account_ids: str
        :param include_friend_group: determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
        :type include_friend_group: bool
        :param app_key: the application key
        :type app_key: str
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param content_id: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_id: int
        :param content_name: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_name: str
        :param content_type: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_type: str
        :param parent_id: default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_id: int
        :param parent_type: default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_type: str
        :param action_category: 
        :type action_category: str
        :param subject: the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
        :type subject: str
        :param custom_message: message string that will be displayed in on the notification
        :type custom_message: str
        :param friend_only_apns: only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
        :type friend_only_apns: bool
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_custom_notifications_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            receiver_account_ids=receiver_account_ids,
            include_friend_group=include_friend_group,
            app_key=app_key,
            game_type=game_type,
            conduit=conduit,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            action_category=action_category,
            subject=subject,
            custom_message=custom_message,
            friend_only_apns=friend_only_apns,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def send_custom_notifications_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        receiver_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of account IDs that will receive the notification")] = None,
        include_friend_group: Annotated[Optional[StrictBool], Field(description="determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        action_category: Optional[StrictStr] = None,
        subject: Annotated[Optional[StrictStr], Field(description="the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="message string that will be displayed in on the notification")] = None,
        friend_only_apns: Annotated[Optional[StrictBool], Field(description="only sends APNS to people who are friends of the user (still saves the notification message for feed polling)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Send Custom Notifications

        Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param receiver_account_ids: comma separated list of account IDs that will receive the notification
        :type receiver_account_ids: str
        :param include_friend_group: determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
        :type include_friend_group: bool
        :param app_key: the application key
        :type app_key: str
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param content_id: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_id: int
        :param content_name: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_name: str
        :param content_type: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_type: str
        :param parent_id: default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_id: int
        :param parent_type: default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_type: str
        :param action_category: 
        :type action_category: str
        :param subject: the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
        :type subject: str
        :param custom_message: message string that will be displayed in on the notification
        :type custom_message: str
        :param friend_only_apns: only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
        :type friend_only_apns: bool
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_custom_notifications_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            receiver_account_ids=receiver_account_ids,
            include_friend_group=include_friend_group,
            app_key=app_key,
            game_type=game_type,
            conduit=conduit,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            action_category=action_category,
            subject=subject,
            custom_message=custom_message,
            friend_only_apns=friend_only_apns,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def send_custom_notifications_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the unique id of the device making the request (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        receiver_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of account IDs that will receive the notification")] = None,
        include_friend_group: Annotated[Optional[StrictBool], Field(description="determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        conduit: Annotated[Optional[StrictStr], Field(description="the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="default notification pay-load field (usage is dependent on the app and the type of event)")] = None,
        action_category: Optional[StrictStr] = None,
        subject: Annotated[Optional[StrictStr], Field(description="the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)")] = None,
        custom_message: Annotated[Optional[StrictStr], Field(description="message string that will be displayed in on the notification")] = None,
        friend_only_apns: Annotated[Optional[StrictBool], Field(description="only sends APNS to people who are friends of the user (still saves the notification message for feed polling)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Custom Notifications

        Send your own custom notification to a user. NOTE: the EventType of these notifications will be CUSTOM. Notifications sent to yourself will currently be ignored.

        :param version: (required)
        :type version: float
        :param device_id: the unique id of the device making the request (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param receiver_account_ids: comma separated list of account IDs that will receive the notification
        :type receiver_account_ids: str
        :param include_friend_group: determines whether to send to all of the user's friends, this flag must be true or receiverAccountIds must not be empty
        :type include_friend_group: bool
        :param app_key: the application key
        :type app_key: str
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param conduit: the type of notification to send: EMAIL, SMS, PUSH, MOBILE_NOTIFICATION.
        :type conduit: str
        :param content_id: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_id: int
        :param content_name: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_name: str
        :param content_type: default notification pay-load field (usage is dependent on the app and the type of event)
        :type content_type: str
        :param parent_id: default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_id: int
        :param parent_type: default notification pay-load field (usage is dependent on the app and the type of event)
        :type parent_type: str
        :param action_category: 
        :type action_category: str
        :param subject: the subject line of an email #@param customPayload custom json definition of notification pay-load (usage is dependent on the app and the type of event)
        :type subject: str
        :param custom_message: message string that will be displayed in on the notification
        :type custom_message: str
        :param friend_only_apns: only sends APNS to people who are friends of the user (still saves the notification message for feed polling)
        :type friend_only_apns: bool
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_custom_notifications_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            receiver_account_ids=receiver_account_ids,
            include_friend_group=include_friend_group,
            app_key=app_key,
            game_type=game_type,
            conduit=conduit,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            action_category=action_category,
            subject=subject,
            custom_message=custom_message,
            friend_only_apns=friend_only_apns,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_custom_notifications_serialize(
        self,
        version,
        device_id,
        account_id,
        receiver_account_ids,
        include_friend_group,
        app_key,
        game_type,
        conduit,
        content_id,
        content_name,
        content_type,
        parent_id,
        parent_type,
        action_category,
        subject,
        custom_message,
        friend_only_apns,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if receiver_account_ids is not None:
            
            _query_params.append(('receiverAccountIds', receiver_account_ids))
            
        if include_friend_group is not None:
            
            _query_params.append(('includeFriendGroup', include_friend_group))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if conduit is not None:
            
            _query_params.append(('conduit', conduit))
            
        if content_id is not None:
            
            _query_params.append(('contentId', content_id))
            
        if content_name is not None:
            
            _query_params.append(('contentName', content_name))
            
        if content_type is not None:
            
            _query_params.append(('contentType', content_type))
            
        if parent_id is not None:
            
            _query_params.append(('parentId', parent_id))
            
        if parent_type is not None:
            
            _query_params.append(('parentType', parent_type))
            
        if action_category is not None:
            
            _query_params.append(('actionCategory', action_category))
            
        if subject is not None:
            
            _query_params.append(('subject', subject))
            
        if custom_message is not None:
            
            _query_params.append(('customMessage', custom_message))
            
        if friend_only_apns is not None:
            
            _query_params.append(('friendOnlyAPNS', friend_only_apns))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/custom',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_notification_template(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        notification_template_id: Annotated[StrictInt, Field(description="The notification template ID to update.")],
        title: Annotated[Optional[StrictStr], Field(description="The title of the message (this would become the subject title for emails). There is a 191 character limit.")] = None,
        body: Annotated[Optional[StrictStr], Field(description="The body of the message.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="The search tags on the template used during search queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NotificationTemplateResponse:
        """Update Notification Template

        Update a notification template. Developers will only be able to update notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param notification_template_id: The notification template ID to update. (required)
        :type notification_template_id: int
        :param title: The title of the message (this would become the subject title for emails). There is a 191 character limit.
        :type title: str
        :param body: The body of the message.
        :type body: str
        :param tags: The search tags on the template used during search queries.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            title=title,
            body=body,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_notification_template_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        notification_template_id: Annotated[StrictInt, Field(description="The notification template ID to update.")],
        title: Annotated[Optional[StrictStr], Field(description="The title of the message (this would become the subject title for emails). There is a 191 character limit.")] = None,
        body: Annotated[Optional[StrictStr], Field(description="The body of the message.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="The search tags on the template used during search queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NotificationTemplateResponse]:
        """Update Notification Template

        Update a notification template. Developers will only be able to update notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param notification_template_id: The notification template ID to update. (required)
        :type notification_template_id: int
        :param title: The title of the message (this would become the subject title for emails). There is a 191 character limit.
        :type title: str
        :param body: The body of the message.
        :type body: str
        :param tags: The search tags on the template used during search queries.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            title=title,
            body=body,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_notification_template_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account ID of the user.")],
        notification_template_id: Annotated[StrictInt, Field(description="The notification template ID to update.")],
        title: Annotated[Optional[StrictStr], Field(description="The title of the message (this would become the subject title for emails). There is a 191 character limit.")] = None,
        body: Annotated[Optional[StrictStr], Field(description="The body of the message.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="The search tags on the template used during search queries.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Notification Template

        Update a notification template. Developers will only be able to update notification templates for their own applications.

        :param version: (required)
        :type version: float
        :param account_id: The account ID of the user. (required)
        :type account_id: int
        :param notification_template_id: The notification template ID to update. (required)
        :type notification_template_id: int
        :param title: The title of the message (this would become the subject title for emails). There is a 191 character limit.
        :type title: str
        :param body: The body of the message.
        :type body: str
        :param tags: The search tags on the template used during search queries.
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_notification_template_serialize(
            version=version,
            account_id=account_id,
            notification_template_id=notification_template_id,
            title=title,
            body=body,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NotificationTemplateResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_notification_template_serialize(
        self,
        version,
        account_id,
        notification_template_id,
        title,
        body,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if notification_template_id is not None:
            
            _query_params.append(('notificationTemplateId', notification_template_id))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if body is not None:
            
            _query_params.append(('body', body))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/template/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


