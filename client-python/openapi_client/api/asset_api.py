# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.asset_full_response import AssetFullResponse
from openapi_client.models.asset_response import AssetResponse
from openapi_client.models.asset_short_response import AssetShortResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AssetApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def asset_download(
        self,
        version: Union[StrictFloat, StrictInt],
        filename: Annotated[str, Field(strict=True, description="the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Download Asset

        Downloads an asset from the server for assets that have been uploaded to the server.

        :param version: (required)
        :type version: float
        :param filename: the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId} (required)
        :type filename: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asset_download_serialize(
            version=version,
            filename=filename,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asset_download_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        filename: Annotated[str, Field(strict=True, description="the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Download Asset

        Downloads an asset from the server for assets that have been uploaded to the server.

        :param version: (required)
        :type version: float
        :param filename: the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId} (required)
        :type filename: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asset_download_serialize(
            version=version,
            filename=filename,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asset_download_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        filename: Annotated[str, Field(strict=True, description="the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId}")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Download Asset

        Downloads an asset from the server for assets that have been uploaded to the server.

        :param version: (required)
        :type version: float
        :param filename: the filename in the following formats: {assetId}-{suffix}.{extension} | {assetId}.{extension} | {assetId} (required)
        :type filename: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asset_download_serialize(
            version=version,
            filename=filename,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asset_download_serialize(
        self,
        version,
        filename,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        if filename is not None:
            _path_params['filename'] = filename
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/asset/download/{filename}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def asset_morph(
        self,
        version: Union[StrictFloat, StrictInt],
        offer_id: Annotated[StrictInt, Field(description="offer id used for inserting offer text/flavor")],
        ad_size: Annotated[StrictStr, Field(description="the ad size used for selecting a format for the creative image")],
        creative_id: Annotated[Optional[StrictInt], Field(description="used for inserting the newly created image into")] = None,
        width: Annotated[Optional[StrictInt], Field(description="total width of the creative image")] = None,
        height: Annotated[Optional[StrictInt], Field(description="total height of the creative image")] = None,
        background_size: Annotated[Optional[StrictStr], Field(description="the size of the background")] = None,
        template: Annotated[Optional[StrictStr], Field(description="the template to use")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AssetShortResponse:
        """Convert Offer to Creative

        Converts an offer image + text into a creative image.

        :param version: (required)
        :type version: float
        :param offer_id: offer id used for inserting offer text/flavor (required)
        :type offer_id: int
        :param ad_size: the ad size used for selecting a format for the creative image (required)
        :type ad_size: str
        :param creative_id: used for inserting the newly created image into
        :type creative_id: int
        :param width: total width of the creative image
        :type width: int
        :param height: total height of the creative image
        :type height: int
        :param background_size: the size of the background
        :type background_size: str
        :param template: the template to use
        :type template: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asset_morph_serialize(
            version=version,
            offer_id=offer_id,
            ad_size=ad_size,
            creative_id=creative_id,
            width=width,
            height=height,
            background_size=background_size,
            template=template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def asset_morph_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        offer_id: Annotated[StrictInt, Field(description="offer id used for inserting offer text/flavor")],
        ad_size: Annotated[StrictStr, Field(description="the ad size used for selecting a format for the creative image")],
        creative_id: Annotated[Optional[StrictInt], Field(description="used for inserting the newly created image into")] = None,
        width: Annotated[Optional[StrictInt], Field(description="total width of the creative image")] = None,
        height: Annotated[Optional[StrictInt], Field(description="total height of the creative image")] = None,
        background_size: Annotated[Optional[StrictStr], Field(description="the size of the background")] = None,
        template: Annotated[Optional[StrictStr], Field(description="the template to use")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AssetShortResponse]:
        """Convert Offer to Creative

        Converts an offer image + text into a creative image.

        :param version: (required)
        :type version: float
        :param offer_id: offer id used for inserting offer text/flavor (required)
        :type offer_id: int
        :param ad_size: the ad size used for selecting a format for the creative image (required)
        :type ad_size: str
        :param creative_id: used for inserting the newly created image into
        :type creative_id: int
        :param width: total width of the creative image
        :type width: int
        :param height: total height of the creative image
        :type height: int
        :param background_size: the size of the background
        :type background_size: str
        :param template: the template to use
        :type template: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asset_morph_serialize(
            version=version,
            offer_id=offer_id,
            ad_size=ad_size,
            creative_id=creative_id,
            width=width,
            height=height,
            background_size=background_size,
            template=template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def asset_morph_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        offer_id: Annotated[StrictInt, Field(description="offer id used for inserting offer text/flavor")],
        ad_size: Annotated[StrictStr, Field(description="the ad size used for selecting a format for the creative image")],
        creative_id: Annotated[Optional[StrictInt], Field(description="used for inserting the newly created image into")] = None,
        width: Annotated[Optional[StrictInt], Field(description="total width of the creative image")] = None,
        height: Annotated[Optional[StrictInt], Field(description="total height of the creative image")] = None,
        background_size: Annotated[Optional[StrictStr], Field(description="the size of the background")] = None,
        template: Annotated[Optional[StrictStr], Field(description="the template to use")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Convert Offer to Creative

        Converts an offer image + text into a creative image.

        :param version: (required)
        :type version: float
        :param offer_id: offer id used for inserting offer text/flavor (required)
        :type offer_id: int
        :param ad_size: the ad size used for selecting a format for the creative image (required)
        :type ad_size: str
        :param creative_id: used for inserting the newly created image into
        :type creative_id: int
        :param width: total width of the creative image
        :type width: int
        :param height: total height of the creative image
        :type height: int
        :param background_size: the size of the background
        :type background_size: str
        :param template: the template to use
        :type template: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._asset_morph_serialize(
            version=version,
            offer_id=offer_id,
            ad_size=ad_size,
            creative_id=creative_id,
            width=width,
            height=height,
            background_size=background_size,
            template=template,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _asset_morph_serialize(
        self,
        version,
        offer_id,
        ad_size,
        creative_id,
        width,
        height,
        background_size,
        template,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if creative_id is not None:
            
            _query_params.append(('creativeId', creative_id))
            
        if ad_size is not None:
            
            _query_params.append(('adSize', ad_size))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if background_size is not None:
            
            _query_params.append(('backgroundSize', background_size))
            
        if template is not None:
            
            _query_params.append(('template', template))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/asset/morph',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_asset(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="to return nulls")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="Deprecated: use collections via the collection endpoints.")] = None,
        add_to_default_album: Annotated[Optional[StrictStr], Field(description="Whether to add to a default album")] = None,
        add_to_media_library: Annotated[Optional[StrictBool], Field(description="Whether to add to the media library")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="the version name")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        caption: Annotated[Optional[StrictStr], Field(description="the caption (optional)")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="the asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="approval status for the asset")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="account id assigned to the asset")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the mimetype, etc")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (optional)")] = None,
        media_string: Annotated[Optional[StrictStr], Field(description="the media content as a string (optional)")] = None,
        media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for mediaString (optional)")] = None,
        media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for mediaString (optional)")] = None,
        media_height: Annotated[Optional[StrictInt], Field(description="the media height (optional)")] = None,
        media_width: Annotated[Optional[StrictInt], Field(description="the media width (optional)")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)")] = None,
        attached_media_string: Annotated[Optional[StrictStr], Field(description="attached media content as a string (optional)")] = None,
        attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for attachedMediaString (optional)")] = None,
        attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for attachedMediaString (optional)")] = None,
        attached_media_height: Annotated[Optional[StrictInt], Field(description="the attached media height (optional)")] = None,
        attached_media_width: Annotated[Optional[StrictInt], Field(description="the attached media width (optional)")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description (optional)")] = None,
        app: Annotated[Optional[StrictStr], Field(description="Deprecated: app parameter")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="the search tags")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude (optional)")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude (optional)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AssetResponse:
        """Create Asset

        Uploads an asset to server and returns an asset id which can be used to assign to various objects.

        :param version: (required)
        :type version: float
        :param return_nulls: to return nulls
        :type return_nulls: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the album the asset will be added to (optional)
        :type album_id: int
        :param collection_id: Deprecated: use collections via the collection endpoints.
        :type collection_id: int
        :param add_to_default_album: Whether to add to a default album
        :type add_to_default_album: str
        :param add_to_media_library: Whether to add to the media library
        :type add_to_media_library: bool
        :param version_code: the version code
        :type version_code: int
        :param version_name: the version name
        :type version_name: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param caption: the caption (optional)
        :type caption: str
        :param asset_type: the asset type
        :type asset_type: str
        :param approval_status: approval status for the asset
        :type approval_status: str
        :param assigned_account_id: account id assigned to the asset
        :type assigned_account_id: int
        :param media: a MultipartFile containing the mimetype, etc
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (optional)
        :type media_url: str
        :param media_string: the media content as a string (optional)
        :type media_string: str
        :param media_string_file_name: file name for mediaString (optional)
        :type media_string_file_name: str
        :param media_string_content_type: content type for mediaString (optional)
        :type media_string_content_type: str
        :param media_height: the media height (optional)
        :type media_height: int
        :param media_width: the media width (optional)
        :type media_width: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        :type attached_media_url: str
        :param attached_media_string: attached media content as a string (optional)
        :type attached_media_string: str
        :param attached_media_string_file_name: file name for attachedMediaString (optional)
        :type attached_media_string_file_name: str
        :param attached_media_string_content_type: content type for attachedMediaString (optional)
        :type attached_media_string_content_type: str
        :param attached_media_height: the attached media height (optional)
        :type attached_media_height: int
        :param attached_media_width: the attached media width (optional)
        :type attached_media_width: int
        :param location_description: the location description (optional)
        :type location_description: str
        :param app: Deprecated: app parameter
        :type app: str
        :param app_key: the application key
        :type app_key: str
        :param search_tags: the search tags
        :type search_tags: str
        :param latitude: the latitude (optional)
        :type latitude: float
        :param longitude: the longitude (optional)
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_asset_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            collection_id=collection_id,
            add_to_default_album=add_to_default_album,
            add_to_media_library=add_to_media_library,
            version_code=version_code,
            version_name=version_name,
            meta_data=meta_data,
            caption=caption,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            media=media,
            media_url=media_url,
            media_string=media_string,
            media_string_file_name=media_string_file_name,
            media_string_content_type=media_string_content_type,
            media_height=media_height,
            media_width=media_width,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            attached_media_string=attached_media_string,
            attached_media_string_file_name=attached_media_string_file_name,
            attached_media_string_content_type=attached_media_string_content_type,
            attached_media_height=attached_media_height,
            attached_media_width=attached_media_width,
            location_description=location_description,
            app=app,
            app_key=app_key,
            search_tags=search_tags,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_asset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="to return nulls")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="Deprecated: use collections via the collection endpoints.")] = None,
        add_to_default_album: Annotated[Optional[StrictStr], Field(description="Whether to add to a default album")] = None,
        add_to_media_library: Annotated[Optional[StrictBool], Field(description="Whether to add to the media library")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="the version name")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        caption: Annotated[Optional[StrictStr], Field(description="the caption (optional)")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="the asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="approval status for the asset")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="account id assigned to the asset")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the mimetype, etc")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (optional)")] = None,
        media_string: Annotated[Optional[StrictStr], Field(description="the media content as a string (optional)")] = None,
        media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for mediaString (optional)")] = None,
        media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for mediaString (optional)")] = None,
        media_height: Annotated[Optional[StrictInt], Field(description="the media height (optional)")] = None,
        media_width: Annotated[Optional[StrictInt], Field(description="the media width (optional)")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)")] = None,
        attached_media_string: Annotated[Optional[StrictStr], Field(description="attached media content as a string (optional)")] = None,
        attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for attachedMediaString (optional)")] = None,
        attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for attachedMediaString (optional)")] = None,
        attached_media_height: Annotated[Optional[StrictInt], Field(description="the attached media height (optional)")] = None,
        attached_media_width: Annotated[Optional[StrictInt], Field(description="the attached media width (optional)")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description (optional)")] = None,
        app: Annotated[Optional[StrictStr], Field(description="Deprecated: app parameter")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="the search tags")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude (optional)")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude (optional)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AssetResponse]:
        """Create Asset

        Uploads an asset to server and returns an asset id which can be used to assign to various objects.

        :param version: (required)
        :type version: float
        :param return_nulls: to return nulls
        :type return_nulls: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the album the asset will be added to (optional)
        :type album_id: int
        :param collection_id: Deprecated: use collections via the collection endpoints.
        :type collection_id: int
        :param add_to_default_album: Whether to add to a default album
        :type add_to_default_album: str
        :param add_to_media_library: Whether to add to the media library
        :type add_to_media_library: bool
        :param version_code: the version code
        :type version_code: int
        :param version_name: the version name
        :type version_name: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param caption: the caption (optional)
        :type caption: str
        :param asset_type: the asset type
        :type asset_type: str
        :param approval_status: approval status for the asset
        :type approval_status: str
        :param assigned_account_id: account id assigned to the asset
        :type assigned_account_id: int
        :param media: a MultipartFile containing the mimetype, etc
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (optional)
        :type media_url: str
        :param media_string: the media content as a string (optional)
        :type media_string: str
        :param media_string_file_name: file name for mediaString (optional)
        :type media_string_file_name: str
        :param media_string_content_type: content type for mediaString (optional)
        :type media_string_content_type: str
        :param media_height: the media height (optional)
        :type media_height: int
        :param media_width: the media width (optional)
        :type media_width: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        :type attached_media_url: str
        :param attached_media_string: attached media content as a string (optional)
        :type attached_media_string: str
        :param attached_media_string_file_name: file name for attachedMediaString (optional)
        :type attached_media_string_file_name: str
        :param attached_media_string_content_type: content type for attachedMediaString (optional)
        :type attached_media_string_content_type: str
        :param attached_media_height: the attached media height (optional)
        :type attached_media_height: int
        :param attached_media_width: the attached media width (optional)
        :type attached_media_width: int
        :param location_description: the location description (optional)
        :type location_description: str
        :param app: Deprecated: app parameter
        :type app: str
        :param app_key: the application key
        :type app_key: str
        :param search_tags: the search tags
        :type search_tags: str
        :param latitude: the latitude (optional)
        :type latitude: float
        :param longitude: the longitude (optional)
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_asset_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            collection_id=collection_id,
            add_to_default_album=add_to_default_album,
            add_to_media_library=add_to_media_library,
            version_code=version_code,
            version_name=version_name,
            meta_data=meta_data,
            caption=caption,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            media=media,
            media_url=media_url,
            media_string=media_string,
            media_string_file_name=media_string_file_name,
            media_string_content_type=media_string_content_type,
            media_height=media_height,
            media_width=media_width,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            attached_media_string=attached_media_string,
            attached_media_string_file_name=attached_media_string_file_name,
            attached_media_string_content_type=attached_media_string_content_type,
            attached_media_height=attached_media_height,
            attached_media_width=attached_media_width,
            location_description=location_description,
            app=app,
            app_key=app_key,
            search_tags=search_tags,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_asset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[Optional[StrictBool], Field(description="to return nulls")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="Deprecated: use collections via the collection endpoints.")] = None,
        add_to_default_album: Annotated[Optional[StrictStr], Field(description="Whether to add to a default album")] = None,
        add_to_media_library: Annotated[Optional[StrictBool], Field(description="Whether to add to the media library")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="the version name")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        caption: Annotated[Optional[StrictStr], Field(description="the caption (optional)")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="the asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="approval status for the asset")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="account id assigned to the asset")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the mimetype, etc")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (optional)")] = None,
        media_string: Annotated[Optional[StrictStr], Field(description="the media content as a string (optional)")] = None,
        media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for mediaString (optional)")] = None,
        media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for mediaString (optional)")] = None,
        media_height: Annotated[Optional[StrictInt], Field(description="the media height (optional)")] = None,
        media_width: Annotated[Optional[StrictInt], Field(description="the media width (optional)")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)")] = None,
        attached_media_string: Annotated[Optional[StrictStr], Field(description="attached media content as a string (optional)")] = None,
        attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for attachedMediaString (optional)")] = None,
        attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for attachedMediaString (optional)")] = None,
        attached_media_height: Annotated[Optional[StrictInt], Field(description="the attached media height (optional)")] = None,
        attached_media_width: Annotated[Optional[StrictInt], Field(description="the attached media width (optional)")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description (optional)")] = None,
        app: Annotated[Optional[StrictStr], Field(description="Deprecated: app parameter")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="the search tags")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude (optional)")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude (optional)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Asset

        Uploads an asset to server and returns an asset id which can be used to assign to various objects.

        :param version: (required)
        :type version: float
        :param return_nulls: to return nulls
        :type return_nulls: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the album the asset will be added to (optional)
        :type album_id: int
        :param collection_id: Deprecated: use collections via the collection endpoints.
        :type collection_id: int
        :param add_to_default_album: Whether to add to a default album
        :type add_to_default_album: str
        :param add_to_media_library: Whether to add to the media library
        :type add_to_media_library: bool
        :param version_code: the version code
        :type version_code: int
        :param version_name: the version name
        :type version_name: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param caption: the caption (optional)
        :type caption: str
        :param asset_type: the asset type
        :type asset_type: str
        :param approval_status: approval status for the asset
        :type approval_status: str
        :param assigned_account_id: account id assigned to the asset
        :type assigned_account_id: int
        :param media: a MultipartFile containing the mimetype, etc
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (optional)
        :type media_url: str
        :param media_string: the media content as a string (optional)
        :type media_string: str
        :param media_string_file_name: file name for mediaString (optional)
        :type media_string_file_name: str
        :param media_string_content_type: content type for mediaString (optional)
        :type media_string_content_type: str
        :param media_height: the media height (optional)
        :type media_height: int
        :param media_width: the media width (optional)
        :type media_width: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        :type attached_media_url: str
        :param attached_media_string: attached media content as a string (optional)
        :type attached_media_string: str
        :param attached_media_string_file_name: file name for attachedMediaString (optional)
        :type attached_media_string_file_name: str
        :param attached_media_string_content_type: content type for attachedMediaString (optional)
        :type attached_media_string_content_type: str
        :param attached_media_height: the attached media height (optional)
        :type attached_media_height: int
        :param attached_media_width: the attached media width (optional)
        :type attached_media_width: int
        :param location_description: the location description (optional)
        :type location_description: str
        :param app: Deprecated: app parameter
        :type app: str
        :param app_key: the application key
        :type app_key: str
        :param search_tags: the search tags
        :type search_tags: str
        :param latitude: the latitude (optional)
        :type latitude: float
        :param longitude: the longitude (optional)
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_asset_serialize(
            version=version,
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            collection_id=collection_id,
            add_to_default_album=add_to_default_album,
            add_to_media_library=add_to_media_library,
            version_code=version_code,
            version_name=version_name,
            meta_data=meta_data,
            caption=caption,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            media=media,
            media_url=media_url,
            media_string=media_string,
            media_string_file_name=media_string_file_name,
            media_string_content_type=media_string_content_type,
            media_height=media_height,
            media_width=media_width,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            attached_media_string=attached_media_string,
            attached_media_string_file_name=attached_media_string_file_name,
            attached_media_string_content_type=attached_media_string_content_type,
            attached_media_height=attached_media_height,
            attached_media_width=attached_media_width,
            location_description=location_description,
            app=app,
            app_key=app_key,
            search_tags=search_tags,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_asset_serialize(
        self,
        version,
        return_nulls,
        device_id,
        account_id,
        album_id,
        collection_id,
        add_to_default_album,
        add_to_media_library,
        version_code,
        version_name,
        meta_data,
        caption,
        asset_type,
        approval_status,
        assigned_account_id,
        media,
        media_url,
        media_string,
        media_string_file_name,
        media_string_content_type,
        media_height,
        media_width,
        attached_media,
        attached_media_url,
        attached_media_string,
        attached_media_string_file_name,
        attached_media_string_content_type,
        attached_media_height,
        attached_media_width,
        location_description,
        app,
        app_key,
        search_tags,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if collection_id is not None:
            
            _query_params.append(('collectionId', collection_id))
            
        if add_to_default_album is not None:
            
            _query_params.append(('addToDefaultAlbum', add_to_default_album))
            
        if add_to_media_library is not None:
            
            _query_params.append(('addToMediaLibrary', add_to_media_library))
            
        if version_code is not None:
            
            _query_params.append(('versionCode', version_code))
            
        if version_name is not None:
            
            _query_params.append(('versionName', version_name))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if caption is not None:
            
            _query_params.append(('caption', caption))
            
        if asset_type is not None:
            
            _query_params.append(('assetType', asset_type))
            
        if approval_status is not None:
            
            _query_params.append(('approvalStatus', approval_status))
            
        if assigned_account_id is not None:
            
            _query_params.append(('assignedAccountId', assigned_account_id))
            
        if media is not None:
            
            _query_params.append(('media', media))
            
        if media_url is not None:
            
            _query_params.append(('mediaUrl', media_url))
            
        if media_string is not None:
            
            _query_params.append(('mediaString', media_string))
            
        if media_string_file_name is not None:
            
            _query_params.append(('mediaStringFileName', media_string_file_name))
            
        if media_string_content_type is not None:
            
            _query_params.append(('mediaStringContentType', media_string_content_type))
            
        if media_height is not None:
            
            _query_params.append(('mediaHeight', media_height))
            
        if media_width is not None:
            
            _query_params.append(('mediaWidth', media_width))
            
        if attached_media is not None:
            
            _query_params.append(('attachedMedia', attached_media))
            
        if attached_media_url is not None:
            
            _query_params.append(('attachedMediaUrl', attached_media_url))
            
        if attached_media_string is not None:
            
            _query_params.append(('attachedMediaString', attached_media_string))
            
        if attached_media_string_file_name is not None:
            
            _query_params.append(('attachedMediaStringFileName', attached_media_string_file_name))
            
        if attached_media_string_content_type is not None:
            
            _query_params.append(('attachedMediaStringContentType', attached_media_string_content_type))
            
        if attached_media_height is not None:
            
            _query_params.append(('attachedMediaHeight', attached_media_height))
            
        if attached_media_width is not None:
            
            _query_params.append(('attachedMediaWidth', attached_media_width))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if app is not None:
            
            _query_params.append(('app', app))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/asset/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_asset(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictStr, Field(description="the id of the asset to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Asset

        Delete an asset.

        :param version: (required)
        :type version: float
        :param asset_id: the id of the asset to delete (required)
        :type asset_id: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_asset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictStr, Field(description="the id of the asset to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Asset

        Delete an asset.

        :param version: (required)
        :type version: float
        :param asset_id: the id of the asset to delete (required)
        :type asset_id: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_asset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictStr, Field(description="the id of the asset to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Asset

        Delete an asset.

        :param version: (required)
        :type version: float
        :param asset_id: the id of the asset to delete (required)
        :type asset_id: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_asset_serialize(
        self,
        version,
        asset_id,
        device_id,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/asset/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_asset(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictInt, Field(description="the asset ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        note_descending: Annotated[Optional[StrictBool], Field(description="determines whether the notes on the asset are in descending order")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AssetFullResponse:
        """Get Asset

        Gets the full asset response including attached likes and notes.

        :param version: (required)
        :type version: float
        :param asset_id: the asset ID (required)
        :type asset_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param note_descending: determines whether the notes on the asset are in descending order
        :type note_descending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            note_descending=note_descending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_asset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictInt, Field(description="the asset ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        note_descending: Annotated[Optional[StrictBool], Field(description="determines whether the notes on the asset are in descending order")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AssetFullResponse]:
        """Get Asset

        Gets the full asset response including attached likes and notes.

        :param version: (required)
        :type version: float
        :param asset_id: the asset ID (required)
        :type asset_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param note_descending: determines whether the notes on the asset are in descending order
        :type note_descending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            note_descending=note_descending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_asset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictInt, Field(description="the asset ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        note_descending: Annotated[Optional[StrictBool], Field(description="determines whether the notes on the asset are in descending order")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Asset

        Gets the full asset response including attached likes and notes.

        :param version: (required)
        :type version: float
        :param asset_id: the asset ID (required)
        :type asset_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param note_descending: determines whether the notes on the asset are in descending order
        :type note_descending: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            note_descending=note_descending,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AssetFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_asset_serialize(
        self,
        version,
        asset_id,
        device_id,
        account_id,
        note_descending,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if note_descending is not None:
            
            _query_params.append(('noteDescending', note_descending))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/asset/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_asset(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictStr, Field(description="the id of the asset to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the album id to remove the asset from")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="the collection id to remove the asset from")] = None,
        remove_from_default_albums: Annotated[Optional[StrictBool], Field(description="remove from the user's profile album")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Remove Asset from Collection

        Remove assets from collections

        :param version: (required)
        :type version: float
        :param asset_id: the id of the asset to remove (required)
        :type asset_id: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the album id to remove the asset from
        :type album_id: int
        :param collection_id: the collection id to remove the asset from
        :type collection_id: int
        :param remove_from_default_albums: remove from the user's profile album
        :type remove_from_default_albums: bool
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            collection_id=collection_id,
            remove_from_default_albums=remove_from_default_albums,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_asset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictStr, Field(description="the id of the asset to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the album id to remove the asset from")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="the collection id to remove the asset from")] = None,
        remove_from_default_albums: Annotated[Optional[StrictBool], Field(description="remove from the user's profile album")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Remove Asset from Collection

        Remove assets from collections

        :param version: (required)
        :type version: float
        :param asset_id: the id of the asset to remove (required)
        :type asset_id: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the album id to remove the asset from
        :type album_id: int
        :param collection_id: the collection id to remove the asset from
        :type collection_id: int
        :param remove_from_default_albums: remove from the user's profile album
        :type remove_from_default_albums: bool
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            collection_id=collection_id,
            remove_from_default_albums=remove_from_default_albums,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_asset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictStr, Field(description="the id of the asset to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the album id to remove the asset from")] = None,
        collection_id: Annotated[Optional[StrictInt], Field(description="the collection id to remove the asset from")] = None,
        remove_from_default_albums: Annotated[Optional[StrictBool], Field(description="remove from the user's profile album")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the user's current location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove Asset from Collection

        Remove assets from collections

        :param version: (required)
        :type version: float
        :param asset_id: the id of the asset to remove (required)
        :type asset_id: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the album id to remove the asset from
        :type album_id: int
        :param collection_id: the collection id to remove the asset from
        :type collection_id: int
        :param remove_from_default_albums: remove from the user's profile album
        :type remove_from_default_albums: bool
        :param latitude: latitude used to update the user's current location
        :type latitude: float
        :param longitude: longitude used to update the user's current location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            collection_id=collection_id,
            remove_from_default_albums=remove_from_default_albums,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_asset_serialize(
        self,
        version,
        asset_id,
        device_id,
        account_id,
        album_id,
        collection_id,
        remove_from_default_albums,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if collection_id is not None:
            
            _query_params.append(('collectionId', collection_id))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if remove_from_default_albums is not None:
            
            _query_params.append(('removeFromDefaultAlbums', remove_from_default_albums))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/asset/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_assets(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of album ids to search on")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of asset ids to search on")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter results by application.")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT")] = None,
        mime_type: Annotated[Optional[StrictStr], Field(description="filter results by mime type")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="filter results by version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="filter results by version name")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by. See AssetApiMap")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sorted list is in descending or ascending order")] = None,
        search_media_library: Annotated[Optional[StrictBool], Field(description="determines whether to search on the media library album")] = None,
        filter_by_billable: Annotated[Optional[StrictBool], Field(description="filter results by billable entity")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="if only searching for active assets")] = None,
        return_app: Annotated[Optional[StrictBool], Field(description="determines whether to include the application response as part of the asset response")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination (there is a hard limit of 200)")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="search mode for index (SearchIndexMode)")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="filter by asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="filter by approval status")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="filter results by an assigned account id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AssetResponse]:
        """Search Assets

        Searches for assets

        :param version: (required)
        :type version: float
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_ids: comma separated list of album ids to search on
        :type album_ids: str
        :param asset_ids: comma separated list of asset ids to search on
        :type asset_ids: str
        :param app_key: the application key to filter results by application.
        :type app_key: str
        :param media_type: filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
        :type media_type: str
        :param mime_type: filter results by mime type
        :type mime_type: str
        :param keyword: keyword search string
        :type keyword: str
        :param version_code: filter results by version code
        :type version_code: int
        :param version_name: filter results by version name
        :type version_name: str
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param sort_field: the field to sort by. See AssetApiMap
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param search_media_library: determines whether to search on the media library album
        :type search_media_library: bool
        :param filter_by_billable: filter results by billable entity
        :type filter_by_billable: bool
        :param active_only: if only searching for active assets
        :type active_only: bool
        :param return_app: determines whether to include the application response as part of the asset response
        :type return_app: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination (there is a hard limit of 200)
        :type limit: int
        :param search_mode: search mode for index (SearchIndexMode)
        :type search_mode: str
        :param asset_type: filter by asset type
        :type asset_type: str
        :param approval_status: filter by approval status
        :type approval_status: str
        :param assigned_account_id: filter results by an assigned account id
        :type assigned_account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_assets_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            album_ids=album_ids,
            asset_ids=asset_ids,
            app_key=app_key,
            media_type=media_type,
            mime_type=mime_type,
            keyword=keyword,
            version_code=version_code,
            version_name=version_name,
            updated_since=updated_since,
            updated_before=updated_before,
            sort_field=sort_field,
            descending=descending,
            search_media_library=search_media_library,
            filter_by_billable=filter_by_billable,
            active_only=active_only,
            return_app=return_app,
            start=start,
            limit=limit,
            search_mode=search_mode,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AssetResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_assets_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of album ids to search on")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of asset ids to search on")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter results by application.")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT")] = None,
        mime_type: Annotated[Optional[StrictStr], Field(description="filter results by mime type")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="filter results by version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="filter results by version name")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by. See AssetApiMap")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sorted list is in descending or ascending order")] = None,
        search_media_library: Annotated[Optional[StrictBool], Field(description="determines whether to search on the media library album")] = None,
        filter_by_billable: Annotated[Optional[StrictBool], Field(description="filter results by billable entity")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="if only searching for active assets")] = None,
        return_app: Annotated[Optional[StrictBool], Field(description="determines whether to include the application response as part of the asset response")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination (there is a hard limit of 200)")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="search mode for index (SearchIndexMode)")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="filter by asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="filter by approval status")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="filter results by an assigned account id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AssetResponse]]:
        """Search Assets

        Searches for assets

        :param version: (required)
        :type version: float
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_ids: comma separated list of album ids to search on
        :type album_ids: str
        :param asset_ids: comma separated list of asset ids to search on
        :type asset_ids: str
        :param app_key: the application key to filter results by application.
        :type app_key: str
        :param media_type: filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
        :type media_type: str
        :param mime_type: filter results by mime type
        :type mime_type: str
        :param keyword: keyword search string
        :type keyword: str
        :param version_code: filter results by version code
        :type version_code: int
        :param version_name: filter results by version name
        :type version_name: str
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param sort_field: the field to sort by. See AssetApiMap
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param search_media_library: determines whether to search on the media library album
        :type search_media_library: bool
        :param filter_by_billable: filter results by billable entity
        :type filter_by_billable: bool
        :param active_only: if only searching for active assets
        :type active_only: bool
        :param return_app: determines whether to include the application response as part of the asset response
        :type return_app: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination (there is a hard limit of 200)
        :type limit: int
        :param search_mode: search mode for index (SearchIndexMode)
        :type search_mode: str
        :param asset_type: filter by asset type
        :type asset_type: str
        :param approval_status: filter by approval status
        :type approval_status: str
        :param assigned_account_id: filter results by an assigned account id
        :type assigned_account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_assets_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            album_ids=album_ids,
            asset_ids=asset_ids,
            app_key=app_key,
            media_type=media_type,
            mime_type=mime_type,
            keyword=keyword,
            version_code=version_code,
            version_name=version_name,
            updated_since=updated_since,
            updated_before=updated_before,
            sort_field=sort_field,
            descending=descending,
            search_media_library=search_media_library,
            filter_by_billable=filter_by_billable,
            active_only=active_only,
            return_app=return_app,
            start=start,
            limit=limit,
            search_mode=search_mode,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AssetResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_assets_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of album ids to search on")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of asset ids to search on")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter results by application.")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT")] = None,
        mime_type: Annotated[Optional[StrictStr], Field(description="filter results by mime type")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="filter results by version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="filter results by version name")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by. See AssetApiMap")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sorted list is in descending or ascending order")] = None,
        search_media_library: Annotated[Optional[StrictBool], Field(description="determines whether to search on the media library album")] = None,
        filter_by_billable: Annotated[Optional[StrictBool], Field(description="filter results by billable entity")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="if only searching for active assets")] = None,
        return_app: Annotated[Optional[StrictBool], Field(description="determines whether to include the application response as part of the asset response")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination (there is a hard limit of 200)")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="search mode for index (SearchIndexMode)")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="filter by asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="filter by approval status")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="filter results by an assigned account id")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Assets

        Searches for assets

        :param version: (required)
        :type version: float
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_ids: comma separated list of album ids to search on
        :type album_ids: str
        :param asset_ids: comma separated list of asset ids to search on
        :type asset_ids: str
        :param app_key: the application key to filter results by application.
        :type app_key: str
        :param media_type: filter results by media type. Possible values include: APPLICATION, IMAGE, AUDIO, VIDEO, MULTIPART, TEXT
        :type media_type: str
        :param mime_type: filter results by mime type
        :type mime_type: str
        :param keyword: keyword search string
        :type keyword: str
        :param version_code: filter results by version code
        :type version_code: int
        :param version_name: filter results by version name
        :type version_name: str
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param sort_field: the field to sort by. See AssetApiMap
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param search_media_library: determines whether to search on the media library album
        :type search_media_library: bool
        :param filter_by_billable: filter results by billable entity
        :type filter_by_billable: bool
        :param active_only: if only searching for active assets
        :type active_only: bool
        :param return_app: determines whether to include the application response as part of the asset response
        :type return_app: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination (there is a hard limit of 200)
        :type limit: int
        :param search_mode: search mode for index (SearchIndexMode)
        :type search_mode: str
        :param asset_type: filter by asset type
        :type asset_type: str
        :param approval_status: filter by approval status
        :type approval_status: str
        :param assigned_account_id: filter results by an assigned account id
        :type assigned_account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_assets_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            album_ids=album_ids,
            asset_ids=asset_ids,
            app_key=app_key,
            media_type=media_type,
            mime_type=mime_type,
            keyword=keyword,
            version_code=version_code,
            version_name=version_name,
            updated_since=updated_since,
            updated_before=updated_before,
            sort_field=sort_field,
            descending=descending,
            search_media_library=search_media_library,
            filter_by_billable=filter_by_billable,
            active_only=active_only,
            return_app=return_app,
            start=start,
            limit=limit,
            search_mode=search_mode,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AssetResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_assets_serialize(
        self,
        version,
        device_id,
        account_id,
        album_ids,
        asset_ids,
        app_key,
        media_type,
        mime_type,
        keyword,
        version_code,
        version_name,
        updated_since,
        updated_before,
        sort_field,
        descending,
        search_media_library,
        filter_by_billable,
        active_only,
        return_app,
        start,
        limit,
        search_mode,
        asset_type,
        approval_status,
        assigned_account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_ids is not None:
            
            _query_params.append(('albumIds', album_ids))
            
        if asset_ids is not None:
            
            _query_params.append(('assetIds', asset_ids))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if media_type is not None:
            
            _query_params.append(('mediaType', media_type))
            
        if mime_type is not None:
            
            _query_params.append(('mimeType', mime_type))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if version_code is not None:
            
            _query_params.append(('versionCode', version_code))
            
        if version_name is not None:
            
            _query_params.append(('versionName', version_name))
            
        if updated_since is not None:
            
            _query_params.append(('updatedSince', updated_since))
            
        if updated_before is not None:
            
            _query_params.append(('updatedBefore', updated_before))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if search_media_library is not None:
            
            _query_params.append(('searchMediaLibrary', search_media_library))
            
        if filter_by_billable is not None:
            
            _query_params.append(('filterByBillable', filter_by_billable))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if return_app is not None:
            
            _query_params.append(('returnApp', return_app))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if search_mode is not None:
            
            _query_params.append(('searchMode', search_mode))
            
        if asset_type is not None:
            
            _query_params.append(('assetType', asset_type))
            
        if approval_status is not None:
            
            _query_params.append(('approvalStatus', approval_status))
            
        if assigned_account_id is not None:
            
            _query_params.append(('assignedAccountId', assigned_account_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/asset/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_asset(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictInt, Field(description="the ID of the asset to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the ID of the album to check user permissions")] = None,
        attached_asset_id: Annotated[Optional[StrictInt], Field(description="the ID of the attached asset")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="the version name")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        caption: Annotated[Optional[StrictStr], Field(description="the caption")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="the asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="approval status for the asset")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="account id assigned to the asset")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the mimetype, etc")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (optional)")] = None,
        media_string: Annotated[Optional[StrictStr], Field(description="the media content as a string (optional)")] = None,
        media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for mediaString (optional)")] = None,
        media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for mediaString (optional)")] = None,
        media_height: Annotated[Optional[StrictInt], Field(description="the media height (optional)")] = None,
        media_width: Annotated[Optional[StrictInt], Field(description="the media width (optional)")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)")] = None,
        attached_media_string: Annotated[Optional[StrictStr], Field(description="attached media content as a string (optional)")] = None,
        attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for attachedMediaString (optional)")] = None,
        attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for attachedMediaString (optional)")] = None,
        attached_media_height: Annotated[Optional[StrictInt], Field(description="the attached media height (optional)")] = None,
        attached_media_width: Annotated[Optional[StrictInt], Field(description="the attached media width (optional)")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the asset's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the asset's location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Asset

        Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.

        :param version: (required)
        :type version: float
        :param asset_id: the ID of the asset to update (required)
        :type asset_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the ID of the album to check user permissions
        :type album_id: int
        :param attached_asset_id: the ID of the attached asset
        :type attached_asset_id: int
        :param version_code: the version code
        :type version_code: int
        :param version_name: the version name
        :type version_name: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param caption: the caption
        :type caption: str
        :param asset_type: the asset type
        :type asset_type: str
        :param approval_status: approval status for the asset
        :type approval_status: str
        :param assigned_account_id: account id assigned to the asset
        :type assigned_account_id: int
        :param media: a MultipartFile containing the mimetype, etc
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (optional)
        :type media_url: str
        :param media_string: the media content as a string (optional)
        :type media_string: str
        :param media_string_file_name: file name for mediaString (optional)
        :type media_string_file_name: str
        :param media_string_content_type: content type for mediaString (optional)
        :type media_string_content_type: str
        :param media_height: the media height (optional)
        :type media_height: int
        :param media_width: the media width (optional)
        :type media_width: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        :type attached_media_url: str
        :param attached_media_string: attached media content as a string (optional)
        :type attached_media_string: str
        :param attached_media_string_file_name: file name for attachedMediaString (optional)
        :type attached_media_string_file_name: str
        :param attached_media_string_content_type: content type for attachedMediaString (optional)
        :type attached_media_string_content_type: str
        :param attached_media_height: the attached media height (optional)
        :type attached_media_height: int
        :param attached_media_width: the attached media width (optional)
        :type attached_media_width: int
        :param location_description: the location description
        :type location_description: str
        :param search_tags: search tags
        :type search_tags: str
        :param app_key: the application key
        :type app_key: str
        :param latitude: latitude used to update the asset's location
        :type latitude: float
        :param longitude: longitude used to update the asset's location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            attached_asset_id=attached_asset_id,
            version_code=version_code,
            version_name=version_name,
            meta_data=meta_data,
            caption=caption,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            media=media,
            media_url=media_url,
            media_string=media_string,
            media_string_file_name=media_string_file_name,
            media_string_content_type=media_string_content_type,
            media_height=media_height,
            media_width=media_width,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            attached_media_string=attached_media_string,
            attached_media_string_file_name=attached_media_string_file_name,
            attached_media_string_content_type=attached_media_string_content_type,
            attached_media_height=attached_media_height,
            attached_media_width=attached_media_width,
            location_description=location_description,
            search_tags=search_tags,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_asset_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictInt, Field(description="the ID of the asset to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the ID of the album to check user permissions")] = None,
        attached_asset_id: Annotated[Optional[StrictInt], Field(description="the ID of the attached asset")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="the version name")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        caption: Annotated[Optional[StrictStr], Field(description="the caption")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="the asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="approval status for the asset")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="account id assigned to the asset")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the mimetype, etc")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (optional)")] = None,
        media_string: Annotated[Optional[StrictStr], Field(description="the media content as a string (optional)")] = None,
        media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for mediaString (optional)")] = None,
        media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for mediaString (optional)")] = None,
        media_height: Annotated[Optional[StrictInt], Field(description="the media height (optional)")] = None,
        media_width: Annotated[Optional[StrictInt], Field(description="the media width (optional)")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)")] = None,
        attached_media_string: Annotated[Optional[StrictStr], Field(description="attached media content as a string (optional)")] = None,
        attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for attachedMediaString (optional)")] = None,
        attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for attachedMediaString (optional)")] = None,
        attached_media_height: Annotated[Optional[StrictInt], Field(description="the attached media height (optional)")] = None,
        attached_media_width: Annotated[Optional[StrictInt], Field(description="the attached media width (optional)")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the asset's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the asset's location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Asset

        Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.

        :param version: (required)
        :type version: float
        :param asset_id: the ID of the asset to update (required)
        :type asset_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the ID of the album to check user permissions
        :type album_id: int
        :param attached_asset_id: the ID of the attached asset
        :type attached_asset_id: int
        :param version_code: the version code
        :type version_code: int
        :param version_name: the version name
        :type version_name: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param caption: the caption
        :type caption: str
        :param asset_type: the asset type
        :type asset_type: str
        :param approval_status: approval status for the asset
        :type approval_status: str
        :param assigned_account_id: account id assigned to the asset
        :type assigned_account_id: int
        :param media: a MultipartFile containing the mimetype, etc
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (optional)
        :type media_url: str
        :param media_string: the media content as a string (optional)
        :type media_string: str
        :param media_string_file_name: file name for mediaString (optional)
        :type media_string_file_name: str
        :param media_string_content_type: content type for mediaString (optional)
        :type media_string_content_type: str
        :param media_height: the media height (optional)
        :type media_height: int
        :param media_width: the media width (optional)
        :type media_width: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        :type attached_media_url: str
        :param attached_media_string: attached media content as a string (optional)
        :type attached_media_string: str
        :param attached_media_string_file_name: file name for attachedMediaString (optional)
        :type attached_media_string_file_name: str
        :param attached_media_string_content_type: content type for attachedMediaString (optional)
        :type attached_media_string_content_type: str
        :param attached_media_height: the attached media height (optional)
        :type attached_media_height: int
        :param attached_media_width: the attached media width (optional)
        :type attached_media_width: int
        :param location_description: the location description
        :type location_description: str
        :param search_tags: search tags
        :type search_tags: str
        :param app_key: the application key
        :type app_key: str
        :param latitude: latitude used to update the asset's location
        :type latitude: float
        :param longitude: longitude used to update the asset's location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            attached_asset_id=attached_asset_id,
            version_code=version_code,
            version_name=version_name,
            meta_data=meta_data,
            caption=caption,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            media=media,
            media_url=media_url,
            media_string=media_string,
            media_string_file_name=media_string_file_name,
            media_string_content_type=media_string_content_type,
            media_height=media_height,
            media_width=media_width,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            attached_media_string=attached_media_string,
            attached_media_string_file_name=attached_media_string_file_name,
            attached_media_string_content_type=attached_media_string_content_type,
            attached_media_height=attached_media_height,
            attached_media_width=attached_media_width,
            location_description=location_description,
            search_tags=search_tags,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_asset_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        asset_id: Annotated[StrictInt, Field(description="the ID of the asset to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        album_id: Annotated[Optional[StrictInt], Field(description="the ID of the album to check user permissions")] = None,
        attached_asset_id: Annotated[Optional[StrictInt], Field(description="the ID of the attached asset")] = None,
        version_code: Annotated[Optional[StrictInt], Field(description="the version code")] = None,
        version_name: Annotated[Optional[StrictStr], Field(description="the version name")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        caption: Annotated[Optional[StrictStr], Field(description="the caption")] = None,
        asset_type: Annotated[Optional[StrictStr], Field(description="the asset type")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="approval status for the asset")] = None,
        assigned_account_id: Annotated[Optional[StrictInt], Field(description="account id assigned to the asset")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the mimetype, etc")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (optional)")] = None,
        media_string: Annotated[Optional[StrictStr], Field(description="the media content as a string (optional)")] = None,
        media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for mediaString (optional)")] = None,
        media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for mediaString (optional)")] = None,
        media_height: Annotated[Optional[StrictInt], Field(description="the media height (optional)")] = None,
        media_width: Annotated[Optional[StrictInt], Field(description="the media width (optional)")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)")] = None,
        attached_media_string: Annotated[Optional[StrictStr], Field(description="attached media content as a string (optional)")] = None,
        attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="file name for attachedMediaString (optional)")] = None,
        attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="content type for attachedMediaString (optional)")] = None,
        attached_media_height: Annotated[Optional[StrictInt], Field(description="the attached media height (optional)")] = None,
        attached_media_width: Annotated[Optional[StrictInt], Field(description="the attached media width (optional)")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the asset's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the asset's location")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Asset

        Updates an asset's meta data. If an album reference is passed in, the participants with write permissions are allowed to edit the asset. Otherwise, only the asset up-loader has permission to edit the data.

        :param version: (required)
        :type version: float
        :param asset_id: the ID of the asset to update (required)
        :type asset_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param album_id: the ID of the album to check user permissions
        :type album_id: int
        :param attached_asset_id: the ID of the attached asset
        :type attached_asset_id: int
        :param version_code: the version code
        :type version_code: int
        :param version_name: the version name
        :type version_name: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param caption: the caption
        :type caption: str
        :param asset_type: the asset type
        :type asset_type: str
        :param approval_status: approval status for the asset
        :type approval_status: str
        :param assigned_account_id: account id assigned to the asset
        :type assigned_account_id: int
        :param media: a MultipartFile containing the mimetype, etc
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (optional)
        :type media_url: str
        :param media_string: the media content as a string (optional)
        :type media_string: str
        :param media_string_file_name: file name for mediaString (optional)
        :type media_string_file_name: str
        :param media_string_content_type: content type for mediaString (optional)
        :type media_string_content_type: str
        :param media_height: the media height (optional)
        :type media_height: int
        :param media_width: the media width (optional)
        :type media_width: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references (optional). Example: to upload a video the \"media\" file should contain a screen capture and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (optional)
        :type attached_media_url: str
        :param attached_media_string: attached media content as a string (optional)
        :type attached_media_string: str
        :param attached_media_string_file_name: file name for attachedMediaString (optional)
        :type attached_media_string_file_name: str
        :param attached_media_string_content_type: content type for attachedMediaString (optional)
        :type attached_media_string_content_type: str
        :param attached_media_height: the attached media height (optional)
        :type attached_media_height: int
        :param attached_media_width: the attached media width (optional)
        :type attached_media_width: int
        :param location_description: the location description
        :type location_description: str
        :param search_tags: search tags
        :type search_tags: str
        :param app_key: the application key
        :type app_key: str
        :param latitude: latitude used to update the asset's location
        :type latitude: float
        :param longitude: longitude used to update the asset's location
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_asset_serialize(
            version=version,
            asset_id=asset_id,
            device_id=device_id,
            account_id=account_id,
            album_id=album_id,
            attached_asset_id=attached_asset_id,
            version_code=version_code,
            version_name=version_name,
            meta_data=meta_data,
            caption=caption,
            asset_type=asset_type,
            approval_status=approval_status,
            assigned_account_id=assigned_account_id,
            media=media,
            media_url=media_url,
            media_string=media_string,
            media_string_file_name=media_string_file_name,
            media_string_content_type=media_string_content_type,
            media_height=media_height,
            media_width=media_width,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            attached_media_string=attached_media_string,
            attached_media_string_file_name=attached_media_string_file_name,
            attached_media_string_content_type=attached_media_string_content_type,
            attached_media_height=attached_media_height,
            attached_media_width=attached_media_width,
            location_description=location_description,
            search_tags=search_tags,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_asset_serialize(
        self,
        version,
        asset_id,
        device_id,
        account_id,
        album_id,
        attached_asset_id,
        version_code,
        version_name,
        meta_data,
        caption,
        asset_type,
        approval_status,
        assigned_account_id,
        media,
        media_url,
        media_string,
        media_string_file_name,
        media_string_content_type,
        media_height,
        media_width,
        attached_media,
        attached_media_url,
        attached_media_string,
        attached_media_string_file_name,
        attached_media_string_content_type,
        attached_media_height,
        attached_media_width,
        location_description,
        search_tags,
        app_key,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if attached_asset_id is not None:
            
            _query_params.append(('attachedAssetId', attached_asset_id))
            
        if version_code is not None:
            
            _query_params.append(('versionCode', version_code))
            
        if version_name is not None:
            
            _query_params.append(('versionName', version_name))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if caption is not None:
            
            _query_params.append(('caption', caption))
            
        if asset_type is not None:
            
            _query_params.append(('assetType', asset_type))
            
        if approval_status is not None:
            
            _query_params.append(('approvalStatus', approval_status))
            
        if assigned_account_id is not None:
            
            _query_params.append(('assignedAccountId', assigned_account_id))
            
        if media is not None:
            
            _query_params.append(('media', media))
            
        if media_url is not None:
            
            _query_params.append(('mediaUrl', media_url))
            
        if media_string is not None:
            
            _query_params.append(('mediaString', media_string))
            
        if media_string_file_name is not None:
            
            _query_params.append(('mediaStringFileName', media_string_file_name))
            
        if media_string_content_type is not None:
            
            _query_params.append(('mediaStringContentType', media_string_content_type))
            
        if media_height is not None:
            
            _query_params.append(('mediaHeight', media_height))
            
        if media_width is not None:
            
            _query_params.append(('mediaWidth', media_width))
            
        if attached_media is not None:
            
            _query_params.append(('attachedMedia', attached_media))
            
        if attached_media_url is not None:
            
            _query_params.append(('attachedMediaUrl', attached_media_url))
            
        if attached_media_string is not None:
            
            _query_params.append(('attachedMediaString', attached_media_string))
            
        if attached_media_string_file_name is not None:
            
            _query_params.append(('attachedMediaStringFileName', attached_media_string_file_name))
            
        if attached_media_string_content_type is not None:
            
            _query_params.append(('attachedMediaStringContentType', attached_media_string_content_type))
            
        if attached_media_height is not None:
            
            _query_params.append(('attachedMediaHeight', attached_media_height))
            
        if attached_media_width is not None:
            
            _query_params.append(('attachedMediaWidth', attached_media_width))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/asset/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


