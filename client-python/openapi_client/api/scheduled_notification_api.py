# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.scheduled_notification_full_response import ScheduledNotificationFullResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ScheduledNotificationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_scheduled_notification(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[StrictStr, Field(description="The name of the scheduled notification")],
        type: Annotated[StrictStr, Field(description="The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages")],
        message: Annotated[StrictStr, Field(description="The message to send")],
        content_id: Annotated[Optional[StrictInt], Field(description="The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="The connection accounts to use to generate the list of recipients (comma separated list of user account ids)")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. The audience used to generate the list of recipients")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences used to generate the list of recipients (comma separated list of audience IDs)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="The album ids to associate with the scheduled notification (comma separated list of album IDs)")] = None,
        report_id: Annotated[Optional[StrictInt], Field(description="The report used to generate the the list of recipients")] = None,
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters to supply to the report used to generate the the list of recipients")] = None,
        endpoint_url: Annotated[Optional[StrictStr], Field(description="The URL for making an HTTP call")] = None,
        payload: Annotated[Optional[StrictStr], Field(description="The parameters for making an HTTP call")] = None,
        scheduled_date: Annotated[Optional[StrictInt], Field(description="The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.")] = None,
        cron_expression: Annotated[Optional[StrictStr], Field(description="The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.")] = None,
        cron_type: Annotated[Optional[StrictStr], Field(description="The cron expression type: UNIX, CRON4J, QUARTZ")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="Additional metadata for the scheduled notification")] = None,
        conditional_input: Annotated[Optional[StrictStr], Field(description="Json input representing conditional logic that has to be met before running the scheduled notification")] = None,
        template_type: Annotated[Optional[StrictStr], Field(description="This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.")] = None,
        send_now: Optional[StrictBool] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Sets the event type for the notification")] = None,
        deep_link_uri: Annotated[Optional[StrictStr], Field(description="The payload deep link URI that can be used by the client app to direct users to a screen in the app")] = None,
        send_to_all: Annotated[Optional[StrictBool], Field(description="Determines whether to send to all users of the app if set to true for push notifications (appKey is required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduledNotificationFullResponse:
        """Create Scheduled Notification

        This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the scheduled notification (required)
        :type name: str
        :param type: The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
        :type type: str
        :param message: The message to send (required)
        :type message: str
        :param content_id: The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_id: int
        :param content_name: The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_name: str
        :param content_type: The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_type: str
        :param parent_id: The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_id: int
        :param parent_type: The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_type: str
        :param app_key: The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        :type app_key: str
        :param grouping_id: Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        :type grouping_id: str
        :param connection_group_ids: The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        :type connection_group_ids: str
        :param connection_account_ids: The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        :type connection_account_ids: str
        :param audience_id: This parameter is deprecated. The audience used to generate the list of recipients
        :type audience_id: int
        :param audience_ids: The audiences used to generate the list of recipients (comma separated list of audience IDs)
        :type audience_ids: str
        :param album_ids: The album ids to associate with the scheduled notification (comma separated list of album IDs)
        :type album_ids: str
        :param report_id: The report used to generate the the list of recipients
        :type report_id: int
        :param report_params: The parameters to supply to the report used to generate the the list of recipients
        :type report_params: str
        :param endpoint_url: The URL for making an HTTP call
        :type endpoint_url: str
        :param payload: The parameters for making an HTTP call
        :type payload: str
        :param scheduled_date: The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        :type scheduled_date: int
        :param start_date: The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        :type start_date: int
        :param end_date: The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        :type end_date: int
        :param cron_expression: The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        :type cron_expression: str
        :param cron_type: The cron expression type: UNIX, CRON4J, QUARTZ
        :type cron_type: str
        :param meta_data: Additional metadata for the scheduled notification
        :type meta_data: str
        :param conditional_input: Json input representing conditional logic that has to be met before running the scheduled notification
        :type conditional_input: str
        :param template_type: This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        :type template_type: str
        :param visibility: Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        :type visibility: str
        :param active: Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
        :type active: bool
        :param send_now: 
        :type send_now: bool
        :param event_type: Sets the event type for the notification
        :type event_type: str
        :param deep_link_uri: The payload deep link URI that can be used by the client app to direct users to a screen in the app
        :type deep_link_uri: str
        :param send_to_all: Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        :type send_to_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            name=name,
            type=type,
            message=message,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            app_key=app_key,
            grouping_id=grouping_id,
            connection_group_ids=connection_group_ids,
            connection_account_ids=connection_account_ids,
            audience_id=audience_id,
            audience_ids=audience_ids,
            album_ids=album_ids,
            report_id=report_id,
            report_params=report_params,
            endpoint_url=endpoint_url,
            payload=payload,
            scheduled_date=scheduled_date,
            start_date=start_date,
            end_date=end_date,
            cron_expression=cron_expression,
            cron_type=cron_type,
            meta_data=meta_data,
            conditional_input=conditional_input,
            template_type=template_type,
            visibility=visibility,
            active=active,
            send_now=send_now,
            event_type=event_type,
            deep_link_uri=deep_link_uri,
            send_to_all=send_to_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_scheduled_notification_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[StrictStr, Field(description="The name of the scheduled notification")],
        type: Annotated[StrictStr, Field(description="The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages")],
        message: Annotated[StrictStr, Field(description="The message to send")],
        content_id: Annotated[Optional[StrictInt], Field(description="The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="The connection accounts to use to generate the list of recipients (comma separated list of user account ids)")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. The audience used to generate the list of recipients")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences used to generate the list of recipients (comma separated list of audience IDs)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="The album ids to associate with the scheduled notification (comma separated list of album IDs)")] = None,
        report_id: Annotated[Optional[StrictInt], Field(description="The report used to generate the the list of recipients")] = None,
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters to supply to the report used to generate the the list of recipients")] = None,
        endpoint_url: Annotated[Optional[StrictStr], Field(description="The URL for making an HTTP call")] = None,
        payload: Annotated[Optional[StrictStr], Field(description="The parameters for making an HTTP call")] = None,
        scheduled_date: Annotated[Optional[StrictInt], Field(description="The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.")] = None,
        cron_expression: Annotated[Optional[StrictStr], Field(description="The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.")] = None,
        cron_type: Annotated[Optional[StrictStr], Field(description="The cron expression type: UNIX, CRON4J, QUARTZ")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="Additional metadata for the scheduled notification")] = None,
        conditional_input: Annotated[Optional[StrictStr], Field(description="Json input representing conditional logic that has to be met before running the scheduled notification")] = None,
        template_type: Annotated[Optional[StrictStr], Field(description="This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.")] = None,
        send_now: Optional[StrictBool] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Sets the event type for the notification")] = None,
        deep_link_uri: Annotated[Optional[StrictStr], Field(description="The payload deep link URI that can be used by the client app to direct users to a screen in the app")] = None,
        send_to_all: Annotated[Optional[StrictBool], Field(description="Determines whether to send to all users of the app if set to true for push notifications (appKey is required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduledNotificationFullResponse]:
        """Create Scheduled Notification

        This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the scheduled notification (required)
        :type name: str
        :param type: The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
        :type type: str
        :param message: The message to send (required)
        :type message: str
        :param content_id: The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_id: int
        :param content_name: The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_name: str
        :param content_type: The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_type: str
        :param parent_id: The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_id: int
        :param parent_type: The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_type: str
        :param app_key: The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        :type app_key: str
        :param grouping_id: Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        :type grouping_id: str
        :param connection_group_ids: The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        :type connection_group_ids: str
        :param connection_account_ids: The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        :type connection_account_ids: str
        :param audience_id: This parameter is deprecated. The audience used to generate the list of recipients
        :type audience_id: int
        :param audience_ids: The audiences used to generate the list of recipients (comma separated list of audience IDs)
        :type audience_ids: str
        :param album_ids: The album ids to associate with the scheduled notification (comma separated list of album IDs)
        :type album_ids: str
        :param report_id: The report used to generate the the list of recipients
        :type report_id: int
        :param report_params: The parameters to supply to the report used to generate the the list of recipients
        :type report_params: str
        :param endpoint_url: The URL for making an HTTP call
        :type endpoint_url: str
        :param payload: The parameters for making an HTTP call
        :type payload: str
        :param scheduled_date: The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        :type scheduled_date: int
        :param start_date: The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        :type start_date: int
        :param end_date: The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        :type end_date: int
        :param cron_expression: The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        :type cron_expression: str
        :param cron_type: The cron expression type: UNIX, CRON4J, QUARTZ
        :type cron_type: str
        :param meta_data: Additional metadata for the scheduled notification
        :type meta_data: str
        :param conditional_input: Json input representing conditional logic that has to be met before running the scheduled notification
        :type conditional_input: str
        :param template_type: This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        :type template_type: str
        :param visibility: Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        :type visibility: str
        :param active: Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
        :type active: bool
        :param send_now: 
        :type send_now: bool
        :param event_type: Sets the event type for the notification
        :type event_type: str
        :param deep_link_uri: The payload deep link URI that can be used by the client app to direct users to a screen in the app
        :type deep_link_uri: str
        :param send_to_all: Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        :type send_to_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            name=name,
            type=type,
            message=message,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            app_key=app_key,
            grouping_id=grouping_id,
            connection_group_ids=connection_group_ids,
            connection_account_ids=connection_account_ids,
            audience_id=audience_id,
            audience_ids=audience_ids,
            album_ids=album_ids,
            report_id=report_id,
            report_params=report_params,
            endpoint_url=endpoint_url,
            payload=payload,
            scheduled_date=scheduled_date,
            start_date=start_date,
            end_date=end_date,
            cron_expression=cron_expression,
            cron_type=cron_type,
            meta_data=meta_data,
            conditional_input=conditional_input,
            template_type=template_type,
            visibility=visibility,
            active=active,
            send_now=send_now,
            event_type=event_type,
            deep_link_uri=deep_link_uri,
            send_to_all=send_to_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_scheduled_notification_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[StrictStr, Field(description="The name of the scheduled notification")],
        type: Annotated[StrictStr, Field(description="The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages")],
        message: Annotated[StrictStr, Field(description="The message to send")],
        content_id: Annotated[Optional[StrictInt], Field(description="The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="The connection accounts to use to generate the list of recipients (comma separated list of user account ids)")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. The audience used to generate the list of recipients")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences used to generate the list of recipients (comma separated list of audience IDs)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="The album ids to associate with the scheduled notification (comma separated list of album IDs)")] = None,
        report_id: Annotated[Optional[StrictInt], Field(description="The report used to generate the the list of recipients")] = None,
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters to supply to the report used to generate the the list of recipients")] = None,
        endpoint_url: Annotated[Optional[StrictStr], Field(description="The URL for making an HTTP call")] = None,
        payload: Annotated[Optional[StrictStr], Field(description="The parameters for making an HTTP call")] = None,
        scheduled_date: Annotated[Optional[StrictInt], Field(description="The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.")] = None,
        cron_expression: Annotated[Optional[StrictStr], Field(description="The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.")] = None,
        cron_type: Annotated[Optional[StrictStr], Field(description="The cron expression type: UNIX, CRON4J, QUARTZ")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="Additional metadata for the scheduled notification")] = None,
        conditional_input: Annotated[Optional[StrictStr], Field(description="Json input representing conditional logic that has to be met before running the scheduled notification")] = None,
        template_type: Annotated[Optional[StrictStr], Field(description="This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.")] = None,
        send_now: Optional[StrictBool] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Sets the event type for the notification")] = None,
        deep_link_uri: Annotated[Optional[StrictStr], Field(description="The payload deep link URI that can be used by the client app to direct users to a screen in the app")] = None,
        send_to_all: Annotated[Optional[StrictBool], Field(description="Determines whether to send to all users of the app if set to true for push notifications (appKey is required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Scheduled Notification

        This endpoint creates a Scheduled Notification message that can be configured to process and send periodically at set time periods

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the scheduled notification (required)
        :type name: str
        :param type: The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (required)
        :type type: str
        :param message: The message to send (required)
        :type message: str
        :param content_id: The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_id: int
        :param content_name: The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_name: str
        :param content_type: The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_type: str
        :param parent_id: The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_id: int
        :param parent_type: The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_type: str
        :param app_key: The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        :type app_key: str
        :param grouping_id: Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        :type grouping_id: str
        :param connection_group_ids: The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        :type connection_group_ids: str
        :param connection_account_ids: The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        :type connection_account_ids: str
        :param audience_id: This parameter is deprecated. The audience used to generate the list of recipients
        :type audience_id: int
        :param audience_ids: The audiences used to generate the list of recipients (comma separated list of audience IDs)
        :type audience_ids: str
        :param album_ids: The album ids to associate with the scheduled notification (comma separated list of album IDs)
        :type album_ids: str
        :param report_id: The report used to generate the the list of recipients
        :type report_id: int
        :param report_params: The parameters to supply to the report used to generate the the list of recipients
        :type report_params: str
        :param endpoint_url: The URL for making an HTTP call
        :type endpoint_url: str
        :param payload: The parameters for making an HTTP call
        :type payload: str
        :param scheduled_date: The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        :type scheduled_date: int
        :param start_date: The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        :type start_date: int
        :param end_date: The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        :type end_date: int
        :param cron_expression: The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        :type cron_expression: str
        :param cron_type: The cron expression type: UNIX, CRON4J, QUARTZ
        :type cron_type: str
        :param meta_data: Additional metadata for the scheduled notification
        :type meta_data: str
        :param conditional_input: Json input representing conditional logic that has to be met before running the scheduled notification
        :type conditional_input: str
        :param template_type: This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        :type template_type: str
        :param visibility: Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        :type visibility: str
        :param active: Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
        :type active: bool
        :param send_now: 
        :type send_now: bool
        :param event_type: Sets the event type for the notification
        :type event_type: str
        :param deep_link_uri: The payload deep link URI that can be used by the client app to direct users to a screen in the app
        :type deep_link_uri: str
        :param send_to_all: Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        :type send_to_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            name=name,
            type=type,
            message=message,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            app_key=app_key,
            grouping_id=grouping_id,
            connection_group_ids=connection_group_ids,
            connection_account_ids=connection_account_ids,
            audience_id=audience_id,
            audience_ids=audience_ids,
            album_ids=album_ids,
            report_id=report_id,
            report_params=report_params,
            endpoint_url=endpoint_url,
            payload=payload,
            scheduled_date=scheduled_date,
            start_date=start_date,
            end_date=end_date,
            cron_expression=cron_expression,
            cron_type=cron_type,
            meta_data=meta_data,
            conditional_input=conditional_input,
            template_type=template_type,
            visibility=visibility,
            active=active,
            send_now=send_now,
            event_type=event_type,
            deep_link_uri=deep_link_uri,
            send_to_all=send_to_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_scheduled_notification_serialize(
        self,
        version,
        account_id,
        name,
        type,
        message,
        content_id,
        content_name,
        content_type,
        parent_id,
        parent_type,
        app_key,
        grouping_id,
        connection_group_ids,
        connection_account_ids,
        audience_id,
        audience_ids,
        album_ids,
        report_id,
        report_params,
        endpoint_url,
        payload,
        scheduled_date,
        start_date,
        end_date,
        cron_expression,
        cron_type,
        meta_data,
        conditional_input,
        template_type,
        visibility,
        active,
        send_now,
        event_type,
        deep_link_uri,
        send_to_all,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if message is not None:
            
            _query_params.append(('message', message))
            
        if content_id is not None:
            
            _query_params.append(('contentId', content_id))
            
        if content_name is not None:
            
            _query_params.append(('contentName', content_name))
            
        if content_type is not None:
            
            _query_params.append(('contentType', content_type))
            
        if parent_id is not None:
            
            _query_params.append(('parentId', parent_id))
            
        if parent_type is not None:
            
            _query_params.append(('parentType', parent_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if grouping_id is not None:
            
            _query_params.append(('groupingId', grouping_id))
            
        if connection_group_ids is not None:
            
            _query_params.append(('connectionGroupIds', connection_group_ids))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if album_ids is not None:
            
            _query_params.append(('albumIds', album_ids))
            
        if report_id is not None:
            
            _query_params.append(('reportId', report_id))
            
        if report_params is not None:
            
            _query_params.append(('reportParams', report_params))
            
        if endpoint_url is not None:
            
            _query_params.append(('endpointURL', endpoint_url))
            
        if payload is not None:
            
            _query_params.append(('payload', payload))
            
        if scheduled_date is not None:
            
            _query_params.append(('scheduledDate', scheduled_date))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if cron_expression is not None:
            
            _query_params.append(('cronExpression', cron_expression))
            
        if cron_type is not None:
            
            _query_params.append(('cronType', cron_type))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if conditional_input is not None:
            
            _query_params.append(('conditionalInput', conditional_input))
            
        if template_type is not None:
            
            _query_params.append(('templateType', template_type))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if send_now is not None:
            
            _query_params.append(('sendNow', send_now))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if deep_link_uri is not None:
            
            _query_params.append(('deepLinkURI', deep_link_uri))
            
        if send_to_all is not None:
            
            _query_params.append(('sendToAll', send_to_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/schedule/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_scheduled_notification(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        scheduled_notification_id: Annotated[StrictInt, Field(description="the id of the scheduled notification to delete")],
        delete_by_grouping_id: Annotated[Optional[StrictBool], Field(description="If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduledNotificationFullResponse:
        """Delete Scheduled Notification

        This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param scheduled_notification_id: the id of the scheduled notification to delete (required)
        :type scheduled_notification_id: int
        :param delete_by_grouping_id: If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
        :type delete_by_grouping_id: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            scheduled_notification_id=scheduled_notification_id,
            delete_by_grouping_id=delete_by_grouping_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_scheduled_notification_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        scheduled_notification_id: Annotated[StrictInt, Field(description="the id of the scheduled notification to delete")],
        delete_by_grouping_id: Annotated[Optional[StrictBool], Field(description="If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduledNotificationFullResponse]:
        """Delete Scheduled Notification

        This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param scheduled_notification_id: the id of the scheduled notification to delete (required)
        :type scheduled_notification_id: int
        :param delete_by_grouping_id: If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
        :type delete_by_grouping_id: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            scheduled_notification_id=scheduled_notification_id,
            delete_by_grouping_id=delete_by_grouping_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_scheduled_notification_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        scheduled_notification_id: Annotated[StrictInt, Field(description="the id of the scheduled notification to delete")],
        delete_by_grouping_id: Annotated[Optional[StrictBool], Field(description="If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Scheduled Notification

        This endpoint deletes a Scheduled Notification. Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using the UserPermissionsApi.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param scheduled_notification_id: the id of the scheduled notification to delete (required)
        :type scheduled_notification_id: int
        :param delete_by_grouping_id: If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
        :type delete_by_grouping_id: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            scheduled_notification_id=scheduled_notification_id,
            delete_by_grouping_id=delete_by_grouping_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_scheduled_notification_serialize(
        self,
        version,
        account_id,
        scheduled_notification_id,
        delete_by_grouping_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if scheduled_notification_id is not None:
            
            _query_params.append(('scheduledNotificationId', scheduled_notification_id))
            
        if delete_by_grouping_id is not None:
            
            _query_params.append(('deleteByGroupingId', delete_by_grouping_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/schedule/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_scheduled_notification(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the account logged in")],
        scheduled_notification_id: Annotated[StrictInt, Field(description="the id of the scheduled notification to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduledNotificationFullResponse:
        """Get Scheduled Notification

        Get a ScheduledNotification

        :param version: (required)
        :type version: float
        :param account_id: the id of the account logged in (required)
        :type account_id: int
        :param scheduled_notification_id: the id of the scheduled notification to get (required)
        :type scheduled_notification_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            scheduled_notification_id=scheduled_notification_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_scheduled_notification_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the account logged in")],
        scheduled_notification_id: Annotated[StrictInt, Field(description="the id of the scheduled notification to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduledNotificationFullResponse]:
        """Get Scheduled Notification

        Get a ScheduledNotification

        :param version: (required)
        :type version: float
        :param account_id: the id of the account logged in (required)
        :type account_id: int
        :param scheduled_notification_id: the id of the scheduled notification to get (required)
        :type scheduled_notification_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            scheduled_notification_id=scheduled_notification_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_scheduled_notification_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the account logged in")],
        scheduled_notification_id: Annotated[StrictInt, Field(description="the id of the scheduled notification to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Scheduled Notification

        Get a ScheduledNotification

        :param version: (required)
        :type version: float
        :param account_id: the id of the account logged in (required)
        :type account_id: int
        :param scheduled_notification_id: the id of the scheduled notification to get (required)
        :type scheduled_notification_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_scheduled_notification_serialize(
            version=version,
            account_id=account_id,
            scheduled_notification_id=scheduled_notification_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_scheduled_notification_serialize(
        self,
        version,
        account_id,
        scheduled_notification_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if scheduled_notification_id is not None:
            
            _query_params.append(('scheduledNotificationId', scheduled_notification_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/schedule/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def schedule_notification_listings(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application to target")],
        report_name: Annotated[StrictStr, Field(description="The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail")],
        message: Annotated[StrictStr, Field(description="The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in")],
        offset: Annotated[StrictInt, Field(description="Time in munites before the event starts to notify recipients")],
        recipient_report_id: Annotated[StrictInt, Field(description="The report id used to generate the recipient list")],
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of scheduled notification; supported values are: MOBILE_NOTIFICATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Generate Schedule Notifications

        Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application to target (required)
        :type app_key: str
        :param report_name: The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
        :type report_name: str
        :param message: The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
        :type message: str
        :param offset: Time in munites before the event starts to notify recipients (required)
        :type offset: int
        :param recipient_report_id: The report id used to generate the recipient list (required)
        :type recipient_report_id: int
        :param report_params: The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
        :type report_params: str
        :param type: The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._schedule_notification_listings_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            report_name=report_name,
            message=message,
            offset=offset,
            recipient_report_id=recipient_report_id,
            report_params=report_params,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def schedule_notification_listings_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application to target")],
        report_name: Annotated[StrictStr, Field(description="The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail")],
        message: Annotated[StrictStr, Field(description="The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in")],
        offset: Annotated[StrictInt, Field(description="Time in munites before the event starts to notify recipients")],
        recipient_report_id: Annotated[StrictInt, Field(description="The report id used to generate the recipient list")],
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of scheduled notification; supported values are: MOBILE_NOTIFICATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Generate Schedule Notifications

        Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application to target (required)
        :type app_key: str
        :param report_name: The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
        :type report_name: str
        :param message: The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
        :type message: str
        :param offset: Time in munites before the event starts to notify recipients (required)
        :type offset: int
        :param recipient_report_id: The report id used to generate the recipient list (required)
        :type recipient_report_id: int
        :param report_params: The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
        :type report_params: str
        :param type: The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._schedule_notification_listings_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            report_name=report_name,
            message=message,
            offset=offset,
            recipient_report_id=recipient_report_id,
            report_params=report_params,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def schedule_notification_listings_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application to target")],
        report_name: Annotated[StrictStr, Field(description="The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail")],
        message: Annotated[StrictStr, Field(description="The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in")],
        offset: Annotated[StrictInt, Field(description="Time in munites before the event starts to notify recipients")],
        recipient_report_id: Annotated[StrictInt, Field(description="The report id used to generate the recipient list")],
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` ")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of scheduled notification; supported values are: MOBILE_NOTIFICATION")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Generate Schedule Notifications

        Use a report to identify events that are starting soon and then create a scheduled notification to push a message to matching users.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application to target (required)
        :type app_key: str
        :param report_name: The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail (required)
        :type report_name: str
        :param message: The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in (required)
        :type message: str
        :param offset: Time in munites before the event starts to notify recipients (required)
        :type offset: int
        :param recipient_report_id: The report id used to generate the recipient list (required)
        :type recipient_report_id: int
        :param report_params: The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
        :type report_params: str
        :param type: The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
        :type type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._schedule_notification_listings_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            report_name=report_name,
            message=message,
            offset=offset,
            recipient_report_id=recipient_report_id,
            report_params=report_params,
            type=type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _schedule_notification_listings_serialize(
        self,
        version,
        account_id,
        app_key,
        report_name,
        message,
        offset,
        recipient_report_id,
        report_params,
        type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if report_name is not None:
            
            _query_params.append(('reportName', report_name))
            
        if report_params is not None:
            
            _query_params.append(('reportParams', report_params))
            
        if message is not None:
            
            _query_params.append(('message', message))
            
        if offset is not None:
            
            _query_params.append(('offset', offset))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if recipient_report_id is not None:
            
            _query_params.append(('recipientReportId', recipient_report_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/schedule/generate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_scheduled_notifications(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        grouping_id: Annotated[Optional[StrictStr], Field(description="Filter results by a grouping identifier defined by the client")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="Filter results by audience")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.")] = None,
        types: Annotated[Optional[StrictStr], Field(description="Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="search using content IDs")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="search using content types")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="search using parent IDs")] = None,
        parent_types: Annotated[Optional[StrictStr], Field(description="search using parent types")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending")] = None,
        template_types: Optional[StrictStr] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter the list by a specific application")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword search on the scheduled notification names.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results")] = None,
        group_by_grouping_id: Annotated[Optional[StrictBool], Field(description="Determines whether to group results with the same groupingId together.")] = None,
        return_audience_account_count: Annotated[Optional[StrictBool], Field(description="If true, include audience account counts in the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduledNotificationFullResponse:
        """Search Scheduled Notifications

        This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param grouping_id: Filter results by a grouping identifier defined by the client
        :type grouping_id: str
        :param audience_id: Filter results by audience
        :type audience_id: int
        :param filter: a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
        :type filter: str
        :param types: Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
        :type types: str
        :param content_ids: search using content IDs
        :type content_ids: str
        :param content_types: search using content types
        :type content_types: str
        :param parent_ids: search using parent IDs
        :type parent_ids: str
        :param parent_types: search using parent types
        :type parent_types: str
        :param statuses: Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
        :type statuses: str
        :param template_types: 
        :type template_types: str
        :param app_key: Filter the list by a specific application
        :type app_key: str
        :param keyword: Keyword search on the scheduled notification names.
        :type keyword: str
        :param sort_field: The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number.
        :type limit: int
        :param active_only: Determines whether to return only active results
        :type active_only: bool
        :param group_by_grouping_id: Determines whether to group results with the same groupingId together.
        :type group_by_grouping_id: bool
        :param return_audience_account_count: If true, include audience account counts in the response
        :type return_audience_account_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_scheduled_notifications_serialize(
            version=version,
            account_id=account_id,
            grouping_id=grouping_id,
            audience_id=audience_id,
            filter=filter,
            types=types,
            content_ids=content_ids,
            content_types=content_types,
            parent_ids=parent_ids,
            parent_types=parent_types,
            statuses=statuses,
            template_types=template_types,
            app_key=app_key,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            group_by_grouping_id=group_by_grouping_id,
            return_audience_account_count=return_audience_account_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_scheduled_notifications_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        grouping_id: Annotated[Optional[StrictStr], Field(description="Filter results by a grouping identifier defined by the client")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="Filter results by audience")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.")] = None,
        types: Annotated[Optional[StrictStr], Field(description="Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="search using content IDs")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="search using content types")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="search using parent IDs")] = None,
        parent_types: Annotated[Optional[StrictStr], Field(description="search using parent types")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending")] = None,
        template_types: Optional[StrictStr] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter the list by a specific application")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword search on the scheduled notification names.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results")] = None,
        group_by_grouping_id: Annotated[Optional[StrictBool], Field(description="Determines whether to group results with the same groupingId together.")] = None,
        return_audience_account_count: Annotated[Optional[StrictBool], Field(description="If true, include audience account counts in the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduledNotificationFullResponse]:
        """Search Scheduled Notifications

        This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param grouping_id: Filter results by a grouping identifier defined by the client
        :type grouping_id: str
        :param audience_id: Filter results by audience
        :type audience_id: int
        :param filter: a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
        :type filter: str
        :param types: Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
        :type types: str
        :param content_ids: search using content IDs
        :type content_ids: str
        :param content_types: search using content types
        :type content_types: str
        :param parent_ids: search using parent IDs
        :type parent_ids: str
        :param parent_types: search using parent types
        :type parent_types: str
        :param statuses: Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
        :type statuses: str
        :param template_types: 
        :type template_types: str
        :param app_key: Filter the list by a specific application
        :type app_key: str
        :param keyword: Keyword search on the scheduled notification names.
        :type keyword: str
        :param sort_field: The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number.
        :type limit: int
        :param active_only: Determines whether to return only active results
        :type active_only: bool
        :param group_by_grouping_id: Determines whether to group results with the same groupingId together.
        :type group_by_grouping_id: bool
        :param return_audience_account_count: If true, include audience account counts in the response
        :type return_audience_account_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_scheduled_notifications_serialize(
            version=version,
            account_id=account_id,
            grouping_id=grouping_id,
            audience_id=audience_id,
            filter=filter,
            types=types,
            content_ids=content_ids,
            content_types=content_types,
            parent_ids=parent_ids,
            parent_types=parent_types,
            statuses=statuses,
            template_types=template_types,
            app_key=app_key,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            group_by_grouping_id=group_by_grouping_id,
            return_audience_account_count=return_audience_account_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_scheduled_notifications_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        grouping_id: Annotated[Optional[StrictStr], Field(description="Filter results by a grouping identifier defined by the client")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="Filter results by audience")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.")] = None,
        types: Annotated[Optional[StrictStr], Field(description="Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION")] = None,
        content_ids: Annotated[Optional[StrictStr], Field(description="search using content IDs")] = None,
        content_types: Annotated[Optional[StrictStr], Field(description="search using content types")] = None,
        parent_ids: Annotated[Optional[StrictStr], Field(description="search using parent IDs")] = None,
        parent_types: Annotated[Optional[StrictStr], Field(description="search using parent types")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending")] = None,
        template_types: Optional[StrictStr] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter the list by a specific application")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword search on the scheduled notification names.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results")] = None,
        group_by_grouping_id: Annotated[Optional[StrictBool], Field(description="Determines whether to group results with the same groupingId together.")] = None,
        return_audience_account_count: Annotated[Optional[StrictBool], Field(description="If true, include audience account counts in the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Scheduled Notifications

        This endpoint searches on Scheduled Notifications. If a scheduled notification was created with the visibility parameter set to PUBLIC, then anyone can search on it if the filter parameter includes the PUBLIC value. PRIVATE visibility means that it can only be searched on by the owner or if it has been shared to the user using the UserPermissionsApi.  In addition, if a PUBLIC Scheduled Notification was created for an application that requires content approval (using the publicContentApproval parameter), then an administrator of the application needs to approve it before it can be search on by other users. Before this happens, it is in a PENDING state, and only the original creator or the owner of the application can search and see it. Also, only the owner of the application can use the UserPermissionsApi to approve or reject it. Scheduled notifications that have been rejected are only visible to the original creators.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param grouping_id: Filter results by a grouping identifier defined by the client
        :type grouping_id: str
        :param audience_id: Filter results by audience
        :type audience_id: int
        :param filter: a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
        :type filter: str
        :param types: Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
        :type types: str
        :param content_ids: search using content IDs
        :type content_ids: str
        :param content_types: search using content types
        :type content_types: str
        :param parent_ids: search using parent IDs
        :type parent_ids: str
        :param parent_types: search using parent types
        :type parent_types: str
        :param statuses: Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
        :type statuses: str
        :param template_types: 
        :type template_types: str
        :param app_key: Filter the list by a specific application
        :type app_key: str
        :param keyword: Keyword search on the scheduled notification names.
        :type keyword: str
        :param sort_field: The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number.
        :type limit: int
        :param active_only: Determines whether to return only active results
        :type active_only: bool
        :param group_by_grouping_id: Determines whether to group results with the same groupingId together.
        :type group_by_grouping_id: bool
        :param return_audience_account_count: If true, include audience account counts in the response
        :type return_audience_account_count: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_scheduled_notifications_serialize(
            version=version,
            account_id=account_id,
            grouping_id=grouping_id,
            audience_id=audience_id,
            filter=filter,
            types=types,
            content_ids=content_ids,
            content_types=content_types,
            parent_ids=parent_ids,
            parent_types=parent_types,
            statuses=statuses,
            template_types=template_types,
            app_key=app_key,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            group_by_grouping_id=group_by_grouping_id,
            return_audience_account_count=return_audience_account_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_scheduled_notifications_serialize(
        self,
        version,
        account_id,
        grouping_id,
        audience_id,
        filter,
        types,
        content_ids,
        content_types,
        parent_ids,
        parent_types,
        statuses,
        template_types,
        app_key,
        keyword,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        group_by_grouping_id,
        return_audience_account_count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if grouping_id is not None:
            
            _query_params.append(('groupingId', grouping_id))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if types is not None:
            
            _query_params.append(('types', types))
            
        if content_ids is not None:
            
            _query_params.append(('contentIds', content_ids))
            
        if content_types is not None:
            
            _query_params.append(('contentTypes', content_types))
            
        if parent_ids is not None:
            
            _query_params.append(('parentIds', parent_ids))
            
        if parent_types is not None:
            
            _query_params.append(('parentTypes', parent_types))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        if template_types is not None:
            
            _query_params.append(('templateTypes', template_types))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if group_by_grouping_id is not None:
            
            _query_params.append(('groupByGroupingId', group_by_grouping_id))
            
        if return_audience_account_count is not None:
            
            _query_params.append(('returnAudienceAccountCount', return_audience_account_count))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/notification/schedule/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_scheduled_notification(
        self,
        version: Union[StrictFloat, StrictInt],
        scheduled_notification_id: Annotated[StrictInt, Field(description="The id of scheduled notification to update")],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the scheduled notification")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages")] = None,
        message: Annotated[Optional[StrictStr], Field(description="The message to send")] = None,
        payload: Annotated[Optional[StrictStr], Field(description="The parameters for making an HTTP call")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="The connection accounts to use to generate the list of recipients (comma separated list of user account ids)")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. The audience used to generate the list of recipients")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences used to generate the list of recipients (comma separated list of audience IDs)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="The album ids to associate with the scheduled notification (comma separated list of album IDs)")] = None,
        report_id: Annotated[Optional[StrictInt], Field(description="The report used to generate the the list of recipients")] = None,
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters to supply to the report used to generate the the list of recipients")] = None,
        endpoint_url: Annotated[Optional[StrictStr], Field(description="The URL for making an HTTP call")] = None,
        scheduled_date: Annotated[Optional[StrictInt], Field(description="The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.")] = None,
        cron_expression: Annotated[Optional[StrictStr], Field(description="The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.")] = None,
        cron_type: Annotated[Optional[StrictStr], Field(description="The cron expression type: UNIX, CRON4J, QUARTZ")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="Additional metadata for the scheduled notification")] = None,
        conditional_input: Annotated[Optional[StrictStr], Field(description="Json input representing conditional logic that has to be met before running the scheduled notification")] = None,
        template_type: Annotated[Optional[StrictStr], Field(description="This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.")] = None,
        error_message: Annotated[Optional[StrictStr], Field(description="the error message associated with the scheduled notification")] = None,
        status: Annotated[Optional[StrictStr], Field(description="the status of the scheduled notification")] = None,
        update_by_grouping_id: Annotated[Optional[StrictBool], Field(description="also updates ScheduledNotifications with the same groupingId and account")] = None,
        send_now: Annotated[Optional[StrictBool], Field(description="whether to send the scheduled notification now or not")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Sets the event type for the notification")] = None,
        deep_link_uri: Annotated[Optional[StrictStr], Field(description="The payload deep link URI that can be used by the client app to direct users to a screen in the app")] = None,
        send_to_all: Annotated[Optional[StrictBool], Field(description="Determines whether to send to all users of the app if set to true for push notifications (appKey is required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ScheduledNotificationFullResponse:
        """Update Scheduled Notification

        This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.

        :param version: (required)
        :type version: float
        :param scheduled_notification_id: The id of scheduled notification to update (required)
        :type scheduled_notification_id: int
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the scheduled notification
        :type name: str
        :param type: The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
        :type type: str
        :param message: The message to send
        :type message: str
        :param payload: The parameters for making an HTTP call
        :type payload: str
        :param content_id: The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_id: int
        :param content_name: The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_name: str
        :param content_type: The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_type: str
        :param parent_id: The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_id: int
        :param parent_type: The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_type: str
        :param app_key: The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        :type app_key: str
        :param grouping_id: Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        :type grouping_id: str
        :param connection_group_ids: The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        :type connection_group_ids: str
        :param connection_account_ids: The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        :type connection_account_ids: str
        :param audience_id: This parameter is deprecated. The audience used to generate the list of recipients
        :type audience_id: int
        :param audience_ids: The audiences used to generate the list of recipients (comma separated list of audience IDs)
        :type audience_ids: str
        :param album_ids: The album ids to associate with the scheduled notification (comma separated list of album IDs)
        :type album_ids: str
        :param report_id: The report used to generate the the list of recipients
        :type report_id: int
        :param report_params: The parameters to supply to the report used to generate the the list of recipients
        :type report_params: str
        :param endpoint_url: The URL for making an HTTP call
        :type endpoint_url: str
        :param scheduled_date: The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        :type scheduled_date: int
        :param start_date: The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        :type start_date: int
        :param end_date: The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        :type end_date: int
        :param cron_expression: The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        :type cron_expression: str
        :param cron_type: The cron expression type: UNIX, CRON4J, QUARTZ
        :type cron_type: str
        :param meta_data: Additional metadata for the scheduled notification
        :type meta_data: str
        :param conditional_input: Json input representing conditional logic that has to be met before running the scheduled notification
        :type conditional_input: str
        :param template_type: This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        :type template_type: str
        :param visibility: Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        :type visibility: str
        :param active: Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
        :type active: bool
        :param error_message: the error message associated with the scheduled notification
        :type error_message: str
        :param status: the status of the scheduled notification
        :type status: str
        :param update_by_grouping_id: also updates ScheduledNotifications with the same groupingId and account
        :type update_by_grouping_id: bool
        :param send_now: whether to send the scheduled notification now or not
        :type send_now: bool
        :param event_type: Sets the event type for the notification
        :type event_type: str
        :param deep_link_uri: The payload deep link URI that can be used by the client app to direct users to a screen in the app
        :type deep_link_uri: str
        :param send_to_all: Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        :type send_to_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_scheduled_notification_serialize(
            version=version,
            scheduled_notification_id=scheduled_notification_id,
            account_id=account_id,
            name=name,
            type=type,
            message=message,
            payload=payload,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            app_key=app_key,
            grouping_id=grouping_id,
            connection_group_ids=connection_group_ids,
            connection_account_ids=connection_account_ids,
            audience_id=audience_id,
            audience_ids=audience_ids,
            album_ids=album_ids,
            report_id=report_id,
            report_params=report_params,
            endpoint_url=endpoint_url,
            scheduled_date=scheduled_date,
            start_date=start_date,
            end_date=end_date,
            cron_expression=cron_expression,
            cron_type=cron_type,
            meta_data=meta_data,
            conditional_input=conditional_input,
            template_type=template_type,
            visibility=visibility,
            active=active,
            error_message=error_message,
            status=status,
            update_by_grouping_id=update_by_grouping_id,
            send_now=send_now,
            event_type=event_type,
            deep_link_uri=deep_link_uri,
            send_to_all=send_to_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_scheduled_notification_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        scheduled_notification_id: Annotated[StrictInt, Field(description="The id of scheduled notification to update")],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the scheduled notification")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages")] = None,
        message: Annotated[Optional[StrictStr], Field(description="The message to send")] = None,
        payload: Annotated[Optional[StrictStr], Field(description="The parameters for making an HTTP call")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="The connection accounts to use to generate the list of recipients (comma separated list of user account ids)")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. The audience used to generate the list of recipients")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences used to generate the list of recipients (comma separated list of audience IDs)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="The album ids to associate with the scheduled notification (comma separated list of album IDs)")] = None,
        report_id: Annotated[Optional[StrictInt], Field(description="The report used to generate the the list of recipients")] = None,
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters to supply to the report used to generate the the list of recipients")] = None,
        endpoint_url: Annotated[Optional[StrictStr], Field(description="The URL for making an HTTP call")] = None,
        scheduled_date: Annotated[Optional[StrictInt], Field(description="The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.")] = None,
        cron_expression: Annotated[Optional[StrictStr], Field(description="The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.")] = None,
        cron_type: Annotated[Optional[StrictStr], Field(description="The cron expression type: UNIX, CRON4J, QUARTZ")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="Additional metadata for the scheduled notification")] = None,
        conditional_input: Annotated[Optional[StrictStr], Field(description="Json input representing conditional logic that has to be met before running the scheduled notification")] = None,
        template_type: Annotated[Optional[StrictStr], Field(description="This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.")] = None,
        error_message: Annotated[Optional[StrictStr], Field(description="the error message associated with the scheduled notification")] = None,
        status: Annotated[Optional[StrictStr], Field(description="the status of the scheduled notification")] = None,
        update_by_grouping_id: Annotated[Optional[StrictBool], Field(description="also updates ScheduledNotifications with the same groupingId and account")] = None,
        send_now: Annotated[Optional[StrictBool], Field(description="whether to send the scheduled notification now or not")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Sets the event type for the notification")] = None,
        deep_link_uri: Annotated[Optional[StrictStr], Field(description="The payload deep link URI that can be used by the client app to direct users to a screen in the app")] = None,
        send_to_all: Annotated[Optional[StrictBool], Field(description="Determines whether to send to all users of the app if set to true for push notifications (appKey is required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ScheduledNotificationFullResponse]:
        """Update Scheduled Notification

        This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.

        :param version: (required)
        :type version: float
        :param scheduled_notification_id: The id of scheduled notification to update (required)
        :type scheduled_notification_id: int
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the scheduled notification
        :type name: str
        :param type: The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
        :type type: str
        :param message: The message to send
        :type message: str
        :param payload: The parameters for making an HTTP call
        :type payload: str
        :param content_id: The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_id: int
        :param content_name: The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_name: str
        :param content_type: The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_type: str
        :param parent_id: The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_id: int
        :param parent_type: The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_type: str
        :param app_key: The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        :type app_key: str
        :param grouping_id: Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        :type grouping_id: str
        :param connection_group_ids: The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        :type connection_group_ids: str
        :param connection_account_ids: The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        :type connection_account_ids: str
        :param audience_id: This parameter is deprecated. The audience used to generate the list of recipients
        :type audience_id: int
        :param audience_ids: The audiences used to generate the list of recipients (comma separated list of audience IDs)
        :type audience_ids: str
        :param album_ids: The album ids to associate with the scheduled notification (comma separated list of album IDs)
        :type album_ids: str
        :param report_id: The report used to generate the the list of recipients
        :type report_id: int
        :param report_params: The parameters to supply to the report used to generate the the list of recipients
        :type report_params: str
        :param endpoint_url: The URL for making an HTTP call
        :type endpoint_url: str
        :param scheduled_date: The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        :type scheduled_date: int
        :param start_date: The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        :type start_date: int
        :param end_date: The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        :type end_date: int
        :param cron_expression: The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        :type cron_expression: str
        :param cron_type: The cron expression type: UNIX, CRON4J, QUARTZ
        :type cron_type: str
        :param meta_data: Additional metadata for the scheduled notification
        :type meta_data: str
        :param conditional_input: Json input representing conditional logic that has to be met before running the scheduled notification
        :type conditional_input: str
        :param template_type: This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        :type template_type: str
        :param visibility: Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        :type visibility: str
        :param active: Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
        :type active: bool
        :param error_message: the error message associated with the scheduled notification
        :type error_message: str
        :param status: the status of the scheduled notification
        :type status: str
        :param update_by_grouping_id: also updates ScheduledNotifications with the same groupingId and account
        :type update_by_grouping_id: bool
        :param send_now: whether to send the scheduled notification now or not
        :type send_now: bool
        :param event_type: Sets the event type for the notification
        :type event_type: str
        :param deep_link_uri: The payload deep link URI that can be used by the client app to direct users to a screen in the app
        :type deep_link_uri: str
        :param send_to_all: Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        :type send_to_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_scheduled_notification_serialize(
            version=version,
            scheduled_notification_id=scheduled_notification_id,
            account_id=account_id,
            name=name,
            type=type,
            message=message,
            payload=payload,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            app_key=app_key,
            grouping_id=grouping_id,
            connection_group_ids=connection_group_ids,
            connection_account_ids=connection_account_ids,
            audience_id=audience_id,
            audience_ids=audience_ids,
            album_ids=album_ids,
            report_id=report_id,
            report_params=report_params,
            endpoint_url=endpoint_url,
            scheduled_date=scheduled_date,
            start_date=start_date,
            end_date=end_date,
            cron_expression=cron_expression,
            cron_type=cron_type,
            meta_data=meta_data,
            conditional_input=conditional_input,
            template_type=template_type,
            visibility=visibility,
            active=active,
            error_message=error_message,
            status=status,
            update_by_grouping_id=update_by_grouping_id,
            send_now=send_now,
            event_type=event_type,
            deep_link_uri=deep_link_uri,
            send_to_all=send_to_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_scheduled_notification_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        scheduled_notification_id: Annotated[StrictInt, Field(description="The id of scheduled notification to update")],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the scheduled notification")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages")] = None,
        message: Annotated[Optional[StrictStr], Field(description="The message to send")] = None,
        payload: Annotated[Optional[StrictStr], Field(description="The parameters for making an HTTP call")] = None,
        content_id: Annotated[Optional[StrictInt], Field(description="The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_name: Annotated[Optional[StrictStr], Field(description="The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        content_type: Annotated[Optional[StrictStr], Field(description="The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_id: Annotated[Optional[StrictInt], Field(description="The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        parent_type: Annotated[Optional[StrictStr], Field(description="The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="The connection accounts to use to generate the list of recipients (comma separated list of user account ids)")] = None,
        audience_id: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated. The audience used to generate the list of recipients")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences used to generate the list of recipients (comma separated list of audience IDs)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="The album ids to associate with the scheduled notification (comma separated list of album IDs)")] = None,
        report_id: Annotated[Optional[StrictInt], Field(description="The report used to generate the the list of recipients")] = None,
        report_params: Annotated[Optional[StrictStr], Field(description="The parameters to supply to the report used to generate the the list of recipients")] = None,
        endpoint_url: Annotated[Optional[StrictStr], Field(description="The URL for making an HTTP call")] = None,
        scheduled_date: Annotated[Optional[StrictInt], Field(description="The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.")] = None,
        cron_expression: Annotated[Optional[StrictStr], Field(description="The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.")] = None,
        cron_type: Annotated[Optional[StrictStr], Field(description="The cron expression type: UNIX, CRON4J, QUARTZ")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="Additional metadata for the scheduled notification")] = None,
        conditional_input: Annotated[Optional[StrictStr], Field(description="Json input representing conditional logic that has to be met before running the scheduled notification")] = None,
        template_type: Annotated[Optional[StrictStr], Field(description="This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.")] = None,
        error_message: Annotated[Optional[StrictStr], Field(description="the error message associated with the scheduled notification")] = None,
        status: Annotated[Optional[StrictStr], Field(description="the status of the scheduled notification")] = None,
        update_by_grouping_id: Annotated[Optional[StrictBool], Field(description="also updates ScheduledNotifications with the same groupingId and account")] = None,
        send_now: Annotated[Optional[StrictBool], Field(description="whether to send the scheduled notification now or not")] = None,
        event_type: Annotated[Optional[StrictStr], Field(description="Sets the event type for the notification")] = None,
        deep_link_uri: Annotated[Optional[StrictStr], Field(description="The payload deep link URI that can be used by the client app to direct users to a screen in the app")] = None,
        send_to_all: Annotated[Optional[StrictBool], Field(description="Determines whether to send to all users of the app if set to true for push notifications (appKey is required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Scheduled Notification

        This endpoint updates a Scheduled Notification message that can be configured to process and send periodically at set time periods. Please see createScheduledNotification for more details.  Only the original owner of the Scheduled Notification or someone with write permissions can use this endpoint. Permissions can be granted to other users by using theUserPermissionsApi.

        :param version: (required)
        :type version: float
        :param scheduled_notification_id: The id of scheduled notification to update (required)
        :type scheduled_notification_id: int
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the scheduled notification
        :type name: str
        :param type: The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
        :type type: str
        :param message: The message to send
        :type message: str
        :param payload: The parameters for making an HTTP call
        :type payload: str
        :param content_id: The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_id: int
        :param content_name: The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_name: str
        :param content_type: The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type content_type: str
        :param parent_id: The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_id: int
        :param parent_type: The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
        :type parent_type: str
        :param app_key: The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
        :type app_key: str
        :param grouping_id: Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
        :type grouping_id: str
        :param connection_group_ids: The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
        :type connection_group_ids: str
        :param connection_account_ids: The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
        :type connection_account_ids: str
        :param audience_id: This parameter is deprecated. The audience used to generate the list of recipients
        :type audience_id: int
        :param audience_ids: The audiences used to generate the list of recipients (comma separated list of audience IDs)
        :type audience_ids: str
        :param album_ids: The album ids to associate with the scheduled notification (comma separated list of album IDs)
        :type album_ids: str
        :param report_id: The report used to generate the the list of recipients
        :type report_id: int
        :param report_params: The parameters to supply to the report used to generate the the list of recipients
        :type report_params: str
        :param endpoint_url: The URL for making an HTTP call
        :type endpoint_url: str
        :param scheduled_date: The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
        :type scheduled_date: int
        :param start_date: The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
        :type start_date: int
        :param end_date: The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
        :type end_date: int
        :param cron_expression: The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
        :type cron_expression: str
        :param cron_type: The cron expression type: UNIX, CRON4J, QUARTZ
        :type cron_type: str
        :param meta_data: Additional metadata for the scheduled notification
        :type meta_data: str
        :param conditional_input: Json input representing conditional logic that has to be met before running the scheduled notification
        :type conditional_input: str
        :param template_type: This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
        :type template_type: str
        :param visibility: Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
        :type visibility: str
        :param active: Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
        :type active: bool
        :param error_message: the error message associated with the scheduled notification
        :type error_message: str
        :param status: the status of the scheduled notification
        :type status: str
        :param update_by_grouping_id: also updates ScheduledNotifications with the same groupingId and account
        :type update_by_grouping_id: bool
        :param send_now: whether to send the scheduled notification now or not
        :type send_now: bool
        :param event_type: Sets the event type for the notification
        :type event_type: str
        :param deep_link_uri: The payload deep link URI that can be used by the client app to direct users to a screen in the app
        :type deep_link_uri: str
        :param send_to_all: Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
        :type send_to_all: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_scheduled_notification_serialize(
            version=version,
            scheduled_notification_id=scheduled_notification_id,
            account_id=account_id,
            name=name,
            type=type,
            message=message,
            payload=payload,
            content_id=content_id,
            content_name=content_name,
            content_type=content_type,
            parent_id=parent_id,
            parent_type=parent_type,
            app_key=app_key,
            grouping_id=grouping_id,
            connection_group_ids=connection_group_ids,
            connection_account_ids=connection_account_ids,
            audience_id=audience_id,
            audience_ids=audience_ids,
            album_ids=album_ids,
            report_id=report_id,
            report_params=report_params,
            endpoint_url=endpoint_url,
            scheduled_date=scheduled_date,
            start_date=start_date,
            end_date=end_date,
            cron_expression=cron_expression,
            cron_type=cron_type,
            meta_data=meta_data,
            conditional_input=conditional_input,
            template_type=template_type,
            visibility=visibility,
            active=active,
            error_message=error_message,
            status=status,
            update_by_grouping_id=update_by_grouping_id,
            send_now=send_now,
            event_type=event_type,
            deep_link_uri=deep_link_uri,
            send_to_all=send_to_all,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ScheduledNotificationFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_scheduled_notification_serialize(
        self,
        version,
        scheduled_notification_id,
        account_id,
        name,
        type,
        message,
        payload,
        content_id,
        content_name,
        content_type,
        parent_id,
        parent_type,
        app_key,
        grouping_id,
        connection_group_ids,
        connection_account_ids,
        audience_id,
        audience_ids,
        album_ids,
        report_id,
        report_params,
        endpoint_url,
        scheduled_date,
        start_date,
        end_date,
        cron_expression,
        cron_type,
        meta_data,
        conditional_input,
        template_type,
        visibility,
        active,
        error_message,
        status,
        update_by_grouping_id,
        send_now,
        event_type,
        deep_link_uri,
        send_to_all,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if scheduled_notification_id is not None:
            
            _query_params.append(('scheduledNotificationId', scheduled_notification_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if message is not None:
            
            _query_params.append(('message', message))
            
        if payload is not None:
            
            _query_params.append(('payload', payload))
            
        if content_id is not None:
            
            _query_params.append(('contentId', content_id))
            
        if content_name is not None:
            
            _query_params.append(('contentName', content_name))
            
        if content_type is not None:
            
            _query_params.append(('contentType', content_type))
            
        if parent_id is not None:
            
            _query_params.append(('parentId', parent_id))
            
        if parent_type is not None:
            
            _query_params.append(('parentType', parent_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if grouping_id is not None:
            
            _query_params.append(('groupingId', grouping_id))
            
        if connection_group_ids is not None:
            
            _query_params.append(('connectionGroupIds', connection_group_ids))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if album_ids is not None:
            
            _query_params.append(('albumIds', album_ids))
            
        if report_id is not None:
            
            _query_params.append(('reportId', report_id))
            
        if report_params is not None:
            
            _query_params.append(('reportParams', report_params))
            
        if endpoint_url is not None:
            
            _query_params.append(('endpointURL', endpoint_url))
            
        if scheduled_date is not None:
            
            _query_params.append(('scheduledDate', scheduled_date))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if cron_expression is not None:
            
            _query_params.append(('cronExpression', cron_expression))
            
        if cron_type is not None:
            
            _query_params.append(('cronType', cron_type))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if conditional_input is not None:
            
            _query_params.append(('conditionalInput', conditional_input))
            
        if template_type is not None:
            
            _query_params.append(('templateType', template_type))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if error_message is not None:
            
            _query_params.append(('errorMessage', error_message))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if update_by_grouping_id is not None:
            
            _query_params.append(('updateByGroupingId', update_by_grouping_id))
            
        if send_now is not None:
            
            _query_params.append(('sendNow', send_now))
            
        if event_type is not None:
            
            _query_params.append(('eventType', event_type))
            
        if deep_link_uri is not None:
            
            _query_params.append(('deepLinkURI', deep_link_uri))
            
        if send_to_all is not None:
            
            _query_params.append(('sendToAll', send_to_all))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/notification/schedule/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


