# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.media_offer_response import MediaOfferResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class MediaApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_media(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the logged in user")],
        title: Annotated[StrictStr, Field(description="The title (255 char limit)")],
        barcode_type: Annotated[StrictStr, Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")],
        no_expiration: Annotated[StrictBool, Field(description="Overrides the expiration date so that the offer does not expire")],
        available_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be used by consumers")],
        available_limit_per_user: Annotated[StrictInt, Field(description="The limit of how many times a user can used the same offer")],
        added_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be added to consumer wallets")],
        view_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be viewed")],
        max_prints: Annotated[StrictInt, Field(description="The maximum number of times the offer can be printed")],
        ticket_price: Annotated[StrictInt, Field(description="The cost of the offer in tickets")],
        full_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The retail/full price cost of the offer in real currency")],
        discount_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The cost of the offer at a discounted price (what the consumer pays)")],
        special_offer_type: Annotated[StrictStr, Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")],
        offer_visibility: Annotated[StrictStr, Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")],
        active: Annotated[StrictBool, Field(description="Sets the active flag")],
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details of the media")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print of the media")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy offer")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show how many of the media is remaining (if there is a limit)")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many of the media has been redeemed")] = None,
        replaced: Annotated[Optional[StrictBool], Field(description="if the media has been replaced")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="if the media should be featured or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition type of the media")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date the media is available to use")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="the media type")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released")] = None,
        collection_ids: Annotated[Optional[StrictStr], Field(description="the IDs of the collections this media should be assigned to")] = None,
        availability: Annotated[Optional[StrictStr], Field(description="ability to assign if this media should active or not")] = None,
        availability_summary: Annotated[Optional[StrictStr], Field(description="ability to assign when the media expires")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaOfferResponse:
        """Create Media

        Create a media offering.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the logged in user (required)
        :type account_id: int
        :param title: The title (255 char limit) (required)
        :type title: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
        :type barcode_type: str
        :param no_expiration: Overrides the expiration date so that the offer does not expire (required)
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers (required)
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer (required)
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets (required)
        :type added_limit: int
        :param view_limit: The limit of how many times the offer can be viewed (required)
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed (required)
        :type max_prints: int
        :param ticket_price: The cost of the offer in tickets (required)
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency (required)
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays) (required)
        :type discount_price: float
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
        :type offer_visibility: str
        :param active: Sets the active flag (required)
        :type active: bool
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details of the media
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print of the media
        :type fine_print: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param ticket_price_type: the type of ticket needed to buy offer
        :type ticket_price_type: str
        :param show_remaining: show how many of the media is remaining (if there is a limit)
        :type show_remaining: bool
        :param show_redeemed: show how many of the media has been redeemed
        :type show_redeemed: bool
        :param replaced: if the media has been replaced
        :type replaced: bool
        :param featured: if the media should be featured or not
        :type featured: bool
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param condition_type: The condition type of the media
        :type condition_type: str
        :param isbn: The ISBN id
        :type isbn: str
        :param asin: The ASIN id
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated
        :type catalog_numbers: str
        :param parental_rating: The parental control rating
        :type parental_rating: str
        :param availability_date: The date the media is available to use
        :type availability_date: int
        :param media_type: the media type
        :type media_type: str
        :param duration: The total playing time of the media item
        :type duration: int
        :param author: The created/author of the media item
        :type author: str
        :param release_date: The date/time of when the media item was originally released
        :type release_date: int
        :param collection_ids: the IDs of the collections this media should be assigned to
        :type collection_ids: str
        :param availability: ability to assign if this media should active or not
        :type availability: str
        :param availability_summary: ability to assign when the media expires
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_media_serialize(
            version=version,
            account_id=account_id,
            title=title,
            barcode_type=barcode_type,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            active=active,
            retailer_location_ids=retailer_location_ids,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            ticket_price_type=ticket_price_type,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            category_ids=category_ids,
            filter_ids=filter_ids,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            parental_rating=parental_rating,
            availability_date=availability_date,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_media_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the logged in user")],
        title: Annotated[StrictStr, Field(description="The title (255 char limit)")],
        barcode_type: Annotated[StrictStr, Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")],
        no_expiration: Annotated[StrictBool, Field(description="Overrides the expiration date so that the offer does not expire")],
        available_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be used by consumers")],
        available_limit_per_user: Annotated[StrictInt, Field(description="The limit of how many times a user can used the same offer")],
        added_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be added to consumer wallets")],
        view_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be viewed")],
        max_prints: Annotated[StrictInt, Field(description="The maximum number of times the offer can be printed")],
        ticket_price: Annotated[StrictInt, Field(description="The cost of the offer in tickets")],
        full_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The retail/full price cost of the offer in real currency")],
        discount_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The cost of the offer at a discounted price (what the consumer pays)")],
        special_offer_type: Annotated[StrictStr, Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")],
        offer_visibility: Annotated[StrictStr, Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")],
        active: Annotated[StrictBool, Field(description="Sets the active flag")],
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details of the media")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print of the media")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy offer")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show how many of the media is remaining (if there is a limit)")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many of the media has been redeemed")] = None,
        replaced: Annotated[Optional[StrictBool], Field(description="if the media has been replaced")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="if the media should be featured or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition type of the media")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date the media is available to use")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="the media type")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released")] = None,
        collection_ids: Annotated[Optional[StrictStr], Field(description="the IDs of the collections this media should be assigned to")] = None,
        availability: Annotated[Optional[StrictStr], Field(description="ability to assign if this media should active or not")] = None,
        availability_summary: Annotated[Optional[StrictStr], Field(description="ability to assign when the media expires")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaOfferResponse]:
        """Create Media

        Create a media offering.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the logged in user (required)
        :type account_id: int
        :param title: The title (255 char limit) (required)
        :type title: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
        :type barcode_type: str
        :param no_expiration: Overrides the expiration date so that the offer does not expire (required)
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers (required)
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer (required)
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets (required)
        :type added_limit: int
        :param view_limit: The limit of how many times the offer can be viewed (required)
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed (required)
        :type max_prints: int
        :param ticket_price: The cost of the offer in tickets (required)
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency (required)
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays) (required)
        :type discount_price: float
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
        :type offer_visibility: str
        :param active: Sets the active flag (required)
        :type active: bool
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details of the media
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print of the media
        :type fine_print: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param ticket_price_type: the type of ticket needed to buy offer
        :type ticket_price_type: str
        :param show_remaining: show how many of the media is remaining (if there is a limit)
        :type show_remaining: bool
        :param show_redeemed: show how many of the media has been redeemed
        :type show_redeemed: bool
        :param replaced: if the media has been replaced
        :type replaced: bool
        :param featured: if the media should be featured or not
        :type featured: bool
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param condition_type: The condition type of the media
        :type condition_type: str
        :param isbn: The ISBN id
        :type isbn: str
        :param asin: The ASIN id
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated
        :type catalog_numbers: str
        :param parental_rating: The parental control rating
        :type parental_rating: str
        :param availability_date: The date the media is available to use
        :type availability_date: int
        :param media_type: the media type
        :type media_type: str
        :param duration: The total playing time of the media item
        :type duration: int
        :param author: The created/author of the media item
        :type author: str
        :param release_date: The date/time of when the media item was originally released
        :type release_date: int
        :param collection_ids: the IDs of the collections this media should be assigned to
        :type collection_ids: str
        :param availability: ability to assign if this media should active or not
        :type availability: str
        :param availability_summary: ability to assign when the media expires
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_media_serialize(
            version=version,
            account_id=account_id,
            title=title,
            barcode_type=barcode_type,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            active=active,
            retailer_location_ids=retailer_location_ids,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            ticket_price_type=ticket_price_type,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            category_ids=category_ids,
            filter_ids=filter_ids,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            parental_rating=parental_rating,
            availability_date=availability_date,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_media_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the logged in user")],
        title: Annotated[StrictStr, Field(description="The title (255 char limit)")],
        barcode_type: Annotated[StrictStr, Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")],
        no_expiration: Annotated[StrictBool, Field(description="Overrides the expiration date so that the offer does not expire")],
        available_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be used by consumers")],
        available_limit_per_user: Annotated[StrictInt, Field(description="The limit of how many times a user can used the same offer")],
        added_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be added to consumer wallets")],
        view_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be viewed")],
        max_prints: Annotated[StrictInt, Field(description="The maximum number of times the offer can be printed")],
        ticket_price: Annotated[StrictInt, Field(description="The cost of the offer in tickets")],
        full_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The retail/full price cost of the offer in real currency")],
        discount_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The cost of the offer at a discounted price (what the consumer pays)")],
        special_offer_type: Annotated[StrictStr, Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")],
        offer_visibility: Annotated[StrictStr, Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")],
        active: Annotated[StrictBool, Field(description="Sets the active flag")],
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details of the media")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print of the media")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy offer")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show how many of the media is remaining (if there is a limit)")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many of the media has been redeemed")] = None,
        replaced: Annotated[Optional[StrictBool], Field(description="if the media has been replaced")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="if the media should be featured or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition type of the media")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date the media is available to use")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="the media type")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released")] = None,
        collection_ids: Annotated[Optional[StrictStr], Field(description="the IDs of the collections this media should be assigned to")] = None,
        availability: Annotated[Optional[StrictStr], Field(description="ability to assign if this media should active or not")] = None,
        availability_summary: Annotated[Optional[StrictStr], Field(description="ability to assign when the media expires")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Media

        Create a media offering.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the logged in user (required)
        :type account_id: int
        :param title: The title (255 char limit) (required)
        :type title: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
        :type barcode_type: str
        :param no_expiration: Overrides the expiration date so that the offer does not expire (required)
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers (required)
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer (required)
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets (required)
        :type added_limit: int
        :param view_limit: The limit of how many times the offer can be viewed (required)
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed (required)
        :type max_prints: int
        :param ticket_price: The cost of the offer in tickets (required)
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency (required)
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays) (required)
        :type discount_price: float
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
        :type offer_visibility: str
        :param active: Sets the active flag (required)
        :type active: bool
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details of the media
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print of the media
        :type fine_print: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param ticket_price_type: the type of ticket needed to buy offer
        :type ticket_price_type: str
        :param show_remaining: show how many of the media is remaining (if there is a limit)
        :type show_remaining: bool
        :param show_redeemed: show how many of the media has been redeemed
        :type show_redeemed: bool
        :param replaced: if the media has been replaced
        :type replaced: bool
        :param featured: if the media should be featured or not
        :type featured: bool
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param condition_type: The condition type of the media
        :type condition_type: str
        :param isbn: The ISBN id
        :type isbn: str
        :param asin: The ASIN id
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated
        :type catalog_numbers: str
        :param parental_rating: The parental control rating
        :type parental_rating: str
        :param availability_date: The date the media is available to use
        :type availability_date: int
        :param media_type: the media type
        :type media_type: str
        :param duration: The total playing time of the media item
        :type duration: int
        :param author: The created/author of the media item
        :type author: str
        :param release_date: The date/time of when the media item was originally released
        :type release_date: int
        :param collection_ids: the IDs of the collections this media should be assigned to
        :type collection_ids: str
        :param availability: ability to assign if this media should active or not
        :type availability: str
        :param availability_summary: ability to assign when the media expires
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_media_serialize(
            version=version,
            account_id=account_id,
            title=title,
            barcode_type=barcode_type,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            active=active,
            retailer_location_ids=retailer_location_ids,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            ticket_price_type=ticket_price_type,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            category_ids=category_ids,
            filter_ids=filter_ids,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            parental_rating=parental_rating,
            availability_date=availability_date,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_media_serialize(
        self,
        version,
        account_id,
        title,
        barcode_type,
        no_expiration,
        available_limit,
        available_limit_per_user,
        added_limit,
        view_limit,
        max_prints,
        ticket_price,
        full_price,
        discount_price,
        special_offer_type,
        offer_visibility,
        active,
        retailer_location_ids,
        sub_title,
        details,
        sub_details,
        fine_print,
        barcode_entry,
        external_redeem_options,
        external_url,
        tickets_reward_type,
        tickets_reward,
        activated,
        expires,
        ticket_price_type,
        show_remaining,
        show_redeemed,
        replaced,
        featured,
        category_ids,
        filter_ids,
        barcode_asset_id,
        image_asset_id,
        image_asset_id1,
        image_asset_id2,
        image_asset_id3,
        image_asset_id4,
        image_asset_id5,
        publisher,
        redeemable_start,
        redeemable_end,
        condition_type,
        isbn,
        asin,
        catalog_numbers,
        parental_rating,
        availability_date,
        media_type,
        duration,
        author,
        release_date,
        collection_ids,
        availability,
        availability_summary,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if sub_title is not None:
            
            _query_params.append(('subTitle', sub_title))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if sub_details is not None:
            
            _query_params.append(('subDetails', sub_details))
            
        if fine_print is not None:
            
            _query_params.append(('finePrint', fine_print))
            
        if barcode_type is not None:
            
            _query_params.append(('barcodeType', barcode_type))
            
        if barcode_entry is not None:
            
            _query_params.append(('barcodeEntry', barcode_entry))
            
        if external_redeem_options is not None:
            
            _query_params.append(('externalRedeemOptions', external_redeem_options))
            
        if external_url is not None:
            
            _query_params.append(('externalUrl', external_url))
            
        if tickets_reward_type is not None:
            
            _query_params.append(('ticketsRewardType', tickets_reward_type))
            
        if tickets_reward is not None:
            
            _query_params.append(('ticketsReward', tickets_reward))
            
        if activated is not None:
            
            _query_params.append(('activated', activated))
            
        if expires is not None:
            
            _query_params.append(('expires', expires))
            
        if no_expiration is not None:
            
            _query_params.append(('noExpiration', no_expiration))
            
        if available_limit is not None:
            
            _query_params.append(('availableLimit', available_limit))
            
        if available_limit_per_user is not None:
            
            _query_params.append(('availableLimitPerUser', available_limit_per_user))
            
        if added_limit is not None:
            
            _query_params.append(('addedLimit', added_limit))
            
        if view_limit is not None:
            
            _query_params.append(('viewLimit', view_limit))
            
        if max_prints is not None:
            
            _query_params.append(('maxPrints', max_prints))
            
        if ticket_price_type is not None:
            
            _query_params.append(('ticketPriceType', ticket_price_type))
            
        if ticket_price is not None:
            
            _query_params.append(('ticketPrice', ticket_price))
            
        if full_price is not None:
            
            _query_params.append(('fullPrice', full_price))
            
        if discount_price is not None:
            
            _query_params.append(('discountPrice', discount_price))
            
        if show_remaining is not None:
            
            _query_params.append(('showRemaining', show_remaining))
            
        if show_redeemed is not None:
            
            _query_params.append(('showRedeemed', show_redeemed))
            
        if replaced is not None:
            
            _query_params.append(('replaced', replaced))
            
        if featured is not None:
            
            _query_params.append(('featured', featured))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if offer_visibility is not None:
            
            _query_params.append(('offerVisibility', offer_visibility))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if barcode_asset_id is not None:
            
            _query_params.append(('barcodeAssetId', barcode_asset_id))
            
        if image_asset_id is not None:
            
            _query_params.append(('imageAssetId', image_asset_id))
            
        if image_asset_id1 is not None:
            
            _query_params.append(('imageAssetId1', image_asset_id1))
            
        if image_asset_id2 is not None:
            
            _query_params.append(('imageAssetId2', image_asset_id2))
            
        if image_asset_id3 is not None:
            
            _query_params.append(('imageAssetId3', image_asset_id3))
            
        if image_asset_id4 is not None:
            
            _query_params.append(('imageAssetId4', image_asset_id4))
            
        if image_asset_id5 is not None:
            
            _query_params.append(('imageAssetId5', image_asset_id5))
            
        if publisher is not None:
            
            _query_params.append(('publisher', publisher))
            
        if redeemable_start is not None:
            
            _query_params.append(('redeemableStart', redeemable_start))
            
        if redeemable_end is not None:
            
            _query_params.append(('redeemableEnd', redeemable_end))
            
        if condition_type is not None:
            
            _query_params.append(('conditionType', condition_type))
            
        if isbn is not None:
            
            _query_params.append(('isbn', isbn))
            
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if catalog_numbers is not None:
            
            _query_params.append(('catalogNumbers', catalog_numbers))
            
        if parental_rating is not None:
            
            _query_params.append(('parentalRating', parental_rating))
            
        if availability_date is not None:
            
            _query_params.append(('availabilityDate', availability_date))
            
        if media_type is not None:
            
            _query_params.append(('mediaType', media_type))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if author is not None:
            
            _query_params.append(('author', author))
            
        if release_date is not None:
            
            _query_params.append(('releaseDate', release_date))
            
        if collection_ids is not None:
            
            _query_params.append(('collectionIds', collection_ids))
            
        if availability is not None:
            
            _query_params.append(('availability', availability))
            
        if availability_summary is not None:
            
            _query_params.append(('availabilitySummary', availability_summary))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/media/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_media(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        media_id: Annotated[StrictInt, Field(description="the ID of the media to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Media

        Delete a media offering that the user has permissions to.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param media_id: the ID of the media to delete (required)
        :type media_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_media_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        media_id: Annotated[StrictInt, Field(description="the ID of the media to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Media

        Delete a media offering that the user has permissions to.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param media_id: the ID of the media to delete (required)
        :type media_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_media_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        media_id: Annotated[StrictInt, Field(description="the ID of the media to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Media

        Delete a media offering that the user has permissions to.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param media_id: the ID of the media to delete (required)
        :type media_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_media_serialize(
        self,
        version,
        account_id,
        media_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if media_id is not None:
            
            _query_params.append(('mediaId', media_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/media/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_media(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        media_id: Annotated[StrictInt, Field(description="the id of the media to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaOfferResponse:
        """Media Get

        Get a media offering.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param media_id: the id of the media to get (required)
        :type media_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_media_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        media_id: Annotated[StrictInt, Field(description="the id of the media to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaOfferResponse]:
        """Media Get

        Get a media offering.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param media_id: the id of the media to get (required)
        :type media_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_media_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        media_id: Annotated[StrictInt, Field(description="the id of the media to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Media Get

        Get a media offering.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param media_id: the id of the media to get (required)
        :type media_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_media_serialize(
        self,
        version,
        account_id,
        media_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if media_id is not None:
            
            _query_params.append(('mediaId', media_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/media/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_media(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        category_ids: Optional[StrictStr] = None,
        filter_ids: Optional[StrictStr] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[MediaOfferResponse]:
        """Search Media

        Searches on events that the account has access to.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param keyword: The keyword used to search
        :type keyword: str
        :param category_ids: 
        :type category_ids: str
        :param filter_ids: 
        :type filter_ids: str
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_media_serialize(
            version=version,
            account_id=account_id,
            active_only=active_only,
            sort_field=sort_field,
            descending=descending,
            keyword=keyword,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaOfferResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_media_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        category_ids: Optional[StrictStr] = None,
        filter_ids: Optional[StrictStr] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[MediaOfferResponse]]:
        """Search Media

        Searches on events that the account has access to.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param keyword: The keyword used to search
        :type keyword: str
        :param category_ids: 
        :type category_ids: str
        :param filter_ids: 
        :type filter_ids: str
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_media_serialize(
            version=version,
            account_id=account_id,
            active_only=active_only,
            sort_field=sort_field,
            descending=descending,
            keyword=keyword,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaOfferResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_media_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        category_ids: Optional[StrictStr] = None,
        filter_ids: Optional[StrictStr] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Media

        Searches on events that the account has access to.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY, AVAILABILITY_DATE, RELEASE_DATE (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param keyword: The keyword used to search
        :type keyword: str
        :param category_ids: 
        :type category_ids: str
        :param filter_ids: 
        :type filter_ids: str
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_media_serialize(
            version=version,
            account_id=account_id,
            active_only=active_only,
            sort_field=sort_field,
            descending=descending,
            keyword=keyword,
            category_ids=category_ids,
            filter_ids=filter_ids,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[MediaOfferResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_media_serialize(
        self,
        version,
        account_id,
        active_only,
        sort_field,
        descending,
        keyword,
        category_ids,
        filter_ids,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/media/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_media(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)")],
        media_id: StrictInt,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The title (255 char limit)")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_type: Annotated[Optional[StrictStr], Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        no_expiration: Annotated[Optional[StrictBool], Field(description="Overrides the expiration date so that the offer does not expire")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be used by consumers")] = None,
        available_limit_per_user: Annotated[Optional[StrictInt], Field(description="The limit of how many times a user can used the same offer")] = None,
        added_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be added to consumer wallets")] = None,
        view_limit: Optional[StrictInt] = None,
        max_prints: Annotated[Optional[StrictInt], Field(description="The maximum number of times the offer can be printed")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy the offer")] = None,
        ticket_price: Annotated[Optional[StrictInt], Field(description="The cost of the offer in tickets")] = None,
        full_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The retail/full price cost of the offer in real currency")] = None,
        discount_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The cost of the offer at a discounted price (what the consumer pays)")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="The show remaining")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="The show redeemed")] = None,
        replaced: Annotated[Optional[StrictBool], Field(description="The replaced")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="The featured")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        offer_visibility: Annotated[Optional[StrictStr], Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        media_type: Optional[StrictStr] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MediaOfferResponse:
        """Update Media

        Update a media offering.

        :param version: (required)
        :type version: float
        :param account_id: The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) (required)
        :type account_id: int
        :param media_id:  (required)
        :type media_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param title: The title (255 char limit)
        :type title: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        :type barcode_type: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param no_expiration: Overrides the expiration date so that the offer does not expire
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets
        :type added_limit: int
        :param view_limit: 
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed
        :type max_prints: int
        :param ticket_price_type: the type of ticket needed to buy the offer
        :type ticket_price_type: str
        :param ticket_price: The cost of the offer in tickets
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays)
        :type discount_price: float
        :param show_remaining: The show remaining
        :type show_remaining: bool
        :param show_redeemed: The show redeemed
        :type show_redeemed: bool
        :param replaced: The replaced
        :type replaced: bool
        :param featured: The featured
        :type featured: bool
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        :type offer_visibility: str
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param active: Sets the active flag
        :type active: bool
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param media_type: 
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            title=title,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price_type=ticket_price_type,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            active=active,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            availability_date=availability_date,
            parental_rating=parental_rating,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_media_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)")],
        media_id: StrictInt,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The title (255 char limit)")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_type: Annotated[Optional[StrictStr], Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        no_expiration: Annotated[Optional[StrictBool], Field(description="Overrides the expiration date so that the offer does not expire")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be used by consumers")] = None,
        available_limit_per_user: Annotated[Optional[StrictInt], Field(description="The limit of how many times a user can used the same offer")] = None,
        added_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be added to consumer wallets")] = None,
        view_limit: Optional[StrictInt] = None,
        max_prints: Annotated[Optional[StrictInt], Field(description="The maximum number of times the offer can be printed")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy the offer")] = None,
        ticket_price: Annotated[Optional[StrictInt], Field(description="The cost of the offer in tickets")] = None,
        full_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The retail/full price cost of the offer in real currency")] = None,
        discount_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The cost of the offer at a discounted price (what the consumer pays)")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="The show remaining")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="The show redeemed")] = None,
        replaced: Annotated[Optional[StrictBool], Field(description="The replaced")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="The featured")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        offer_visibility: Annotated[Optional[StrictStr], Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        media_type: Optional[StrictStr] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MediaOfferResponse]:
        """Update Media

        Update a media offering.

        :param version: (required)
        :type version: float
        :param account_id: The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) (required)
        :type account_id: int
        :param media_id:  (required)
        :type media_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param title: The title (255 char limit)
        :type title: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        :type barcode_type: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param no_expiration: Overrides the expiration date so that the offer does not expire
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets
        :type added_limit: int
        :param view_limit: 
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed
        :type max_prints: int
        :param ticket_price_type: the type of ticket needed to buy the offer
        :type ticket_price_type: str
        :param ticket_price: The cost of the offer in tickets
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays)
        :type discount_price: float
        :param show_remaining: The show remaining
        :type show_remaining: bool
        :param show_redeemed: The show redeemed
        :type show_redeemed: bool
        :param replaced: The replaced
        :type replaced: bool
        :param featured: The featured
        :type featured: bool
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        :type offer_visibility: str
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param active: Sets the active flag
        :type active: bool
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param media_type: 
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            title=title,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price_type=ticket_price_type,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            active=active,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            availability_date=availability_date,
            parental_rating=parental_rating,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_media_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)")],
        media_id: StrictInt,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The title (255 char limit)")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_type: Annotated[Optional[StrictStr], Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        no_expiration: Annotated[Optional[StrictBool], Field(description="Overrides the expiration date so that the offer does not expire")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be used by consumers")] = None,
        available_limit_per_user: Annotated[Optional[StrictInt], Field(description="The limit of how many times a user can used the same offer")] = None,
        added_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be added to consumer wallets")] = None,
        view_limit: Optional[StrictInt] = None,
        max_prints: Annotated[Optional[StrictInt], Field(description="The maximum number of times the offer can be printed")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy the offer")] = None,
        ticket_price: Annotated[Optional[StrictInt], Field(description="The cost of the offer in tickets")] = None,
        full_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The retail/full price cost of the offer in real currency")] = None,
        discount_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The cost of the offer at a discounted price (what the consumer pays)")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="The show remaining")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="The show redeemed")] = None,
        replaced: Annotated[Optional[StrictBool], Field(description="The replaced")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="The featured")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        offer_visibility: Annotated[Optional[StrictStr], Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        media_type: Optional[StrictStr] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Media

        Update a media offering.

        :param version: (required)
        :type version: float
        :param account_id: The account used to perform the update, must have rights to edit the offer (deviceId or accountId required) (required)
        :type account_id: int
        :param media_id:  (required)
        :type media_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param title: The title (255 char limit)
        :type title: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        :type barcode_type: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param no_expiration: Overrides the expiration date so that the offer does not expire
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets
        :type added_limit: int
        :param view_limit: 
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed
        :type max_prints: int
        :param ticket_price_type: the type of ticket needed to buy the offer
        :type ticket_price_type: str
        :param ticket_price: The cost of the offer in tickets
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays)
        :type discount_price: float
        :param show_remaining: The show remaining
        :type show_remaining: bool
        :param show_redeemed: The show redeemed
        :type show_redeemed: bool
        :param replaced: The replaced
        :type replaced: bool
        :param featured: The featured
        :type featured: bool
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        :type offer_visibility: str
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param active: Sets the active flag
        :type active: bool
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param media_type: 
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_media_serialize(
            version=version,
            account_id=account_id,
            media_id=media_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            title=title,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price_type=ticket_price_type,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            active=active,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            availability_date=availability_date,
            parental_rating=parental_rating,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MediaOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_media_serialize(
        self,
        version,
        account_id,
        media_id,
        retailer_location_ids,
        offer_locations,
        title,
        sub_title,
        details,
        sub_details,
        fine_print,
        barcode_type,
        barcode_entry,
        external_redeem_options,
        external_url,
        tickets_reward_type,
        tickets_reward,
        activated,
        expires,
        no_expiration,
        available_limit,
        available_limit_per_user,
        added_limit,
        view_limit,
        max_prints,
        ticket_price_type,
        ticket_price,
        full_price,
        discount_price,
        show_remaining,
        show_redeemed,
        replaced,
        featured,
        special_offer_type,
        offer_visibility,
        category_ids,
        filter_ids,
        active,
        barcode_asset_id,
        image_asset_id,
        image_asset_id1,
        image_asset_id2,
        image_asset_id3,
        image_asset_id4,
        image_asset_id5,
        publisher,
        redeemable_start,
        redeemable_end,
        condition_type,
        isbn,
        asin,
        catalog_numbers,
        availability_date,
        parental_rating,
        media_type,
        duration,
        author,
        release_date,
        collection_ids,
        availability,
        availability_summary,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if media_id is not None:
            
            _query_params.append(('mediaId', media_id))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if offer_locations is not None:
            
            _query_params.append(('offerLocations', offer_locations))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if sub_title is not None:
            
            _query_params.append(('subTitle', sub_title))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if sub_details is not None:
            
            _query_params.append(('subDetails', sub_details))
            
        if fine_print is not None:
            
            _query_params.append(('finePrint', fine_print))
            
        if barcode_type is not None:
            
            _query_params.append(('barcodeType', barcode_type))
            
        if barcode_entry is not None:
            
            _query_params.append(('barcodeEntry', barcode_entry))
            
        if external_redeem_options is not None:
            
            _query_params.append(('externalRedeemOptions', external_redeem_options))
            
        if external_url is not None:
            
            _query_params.append(('externalUrl', external_url))
            
        if tickets_reward_type is not None:
            
            _query_params.append(('ticketsRewardType', tickets_reward_type))
            
        if tickets_reward is not None:
            
            _query_params.append(('ticketsReward', tickets_reward))
            
        if activated is not None:
            
            _query_params.append(('activated', activated))
            
        if expires is not None:
            
            _query_params.append(('expires', expires))
            
        if no_expiration is not None:
            
            _query_params.append(('noExpiration', no_expiration))
            
        if available_limit is not None:
            
            _query_params.append(('availableLimit', available_limit))
            
        if available_limit_per_user is not None:
            
            _query_params.append(('availableLimitPerUser', available_limit_per_user))
            
        if added_limit is not None:
            
            _query_params.append(('addedLimit', added_limit))
            
        if view_limit is not None:
            
            _query_params.append(('viewLimit', view_limit))
            
        if max_prints is not None:
            
            _query_params.append(('maxPrints', max_prints))
            
        if ticket_price_type is not None:
            
            _query_params.append(('ticketPriceType', ticket_price_type))
            
        if ticket_price is not None:
            
            _query_params.append(('ticketPrice', ticket_price))
            
        if full_price is not None:
            
            _query_params.append(('fullPrice', full_price))
            
        if discount_price is not None:
            
            _query_params.append(('discountPrice', discount_price))
            
        if show_remaining is not None:
            
            _query_params.append(('showRemaining', show_remaining))
            
        if show_redeemed is not None:
            
            _query_params.append(('showRedeemed', show_redeemed))
            
        if replaced is not None:
            
            _query_params.append(('replaced', replaced))
            
        if featured is not None:
            
            _query_params.append(('featured', featured))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if offer_visibility is not None:
            
            _query_params.append(('offerVisibility', offer_visibility))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if barcode_asset_id is not None:
            
            _query_params.append(('barcodeAssetId', barcode_asset_id))
            
        if image_asset_id is not None:
            
            _query_params.append(('imageAssetId', image_asset_id))
            
        if image_asset_id1 is not None:
            
            _query_params.append(('imageAssetId1', image_asset_id1))
            
        if image_asset_id2 is not None:
            
            _query_params.append(('imageAssetId2', image_asset_id2))
            
        if image_asset_id3 is not None:
            
            _query_params.append(('imageAssetId3', image_asset_id3))
            
        if image_asset_id4 is not None:
            
            _query_params.append(('imageAssetId4', image_asset_id4))
            
        if image_asset_id5 is not None:
            
            _query_params.append(('imageAssetId5', image_asset_id5))
            
        if publisher is not None:
            
            _query_params.append(('publisher', publisher))
            
        if redeemable_start is not None:
            
            _query_params.append(('redeemableStart', redeemable_start))
            
        if redeemable_end is not None:
            
            _query_params.append(('redeemableEnd', redeemable_end))
            
        if condition_type is not None:
            
            _query_params.append(('conditionType', condition_type))
            
        if isbn is not None:
            
            _query_params.append(('isbn', isbn))
            
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if catalog_numbers is not None:
            
            _query_params.append(('catalogNumbers', catalog_numbers))
            
        if availability_date is not None:
            
            _query_params.append(('availabilityDate', availability_date))
            
        if parental_rating is not None:
            
            _query_params.append(('parentalRating', parental_rating))
            
        if media_type is not None:
            
            _query_params.append(('mediaType', media_type))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if author is not None:
            
            _query_params.append(('author', author))
            
        if release_date is not None:
            
            _query_params.append(('releaseDate', release_date))
            
        if collection_ids is not None:
            
            _query_params.append(('collectionIds', collection_ids))
            
        if availability is not None:
            
            _query_params.append(('availability', availability))
            
        if availability_summary is not None:
            
            _query_params.append(('availabilitySummary', availability_summary))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/media/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


