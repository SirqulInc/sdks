# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.album_full_response import AlbumFullResponse
from openapi_client.models.album_response import AlbumResponse
from openapi_client.models.search_response import SearchResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AlbumApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_album_collection(
        self,
        version: Union[StrictFloat, StrictInt],
        title: Annotated[StrictStr, Field(description="the title of the album")],
        cover_asset_nullable: Annotated[StrictBool, Field(description="determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image")],
        include_cover_in_asset_list: Annotated[StrictBool, Field(description="determines whether the cover image should be added to the album asset list")],
        public_read: Annotated[StrictBool, Field(description="determines whether the album's participants has read permissions")],
        public_write: Annotated[StrictBool, Field(description="determines whether the album's participants has write permissions")],
        public_delete: Annotated[StrictBool, Field(description="determines whether the album's participants has delete permissions")],
        public_add: Annotated[StrictBool, Field(description="determines whether the album's participants has add permissions")],
        anonymous: Annotated[StrictBool, Field(description="determines whether the album is posted anonymously")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        assets_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the album cover image")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="the tags")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the album")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="a custom field used for aggregation and searching")] = None,
        album_type_id: Annotated[Optional[StrictInt], Field(description="a custom indexed number used for aggregation and searching")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="a custom string field used for aggregation and searching")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the album's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the album's location")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="@deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the cell phone number")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of of the location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the location")] = None,
        full_address: Annotated[Optional[StrictStr], Field(description="The full address of the location which should include the street address, city, state, and postal code")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="comma separated category ids string associated with the Album")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="comma separated filter ids string associated with the Album")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated audience ids string associated with the album")] = None,
        include_all_app_users_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all app users as members (only admins of the app can do this)")] = None,
        include_audiences_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all users of the audiences as members (only admins of the app can do this)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="determines whether to use ands or ors when using the audience list to add users")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="sets a linked object so that it can be returned as part of the album response")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="sets a linked object id so that it can be returned as part of the album response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SearchResponse:
        """Create Album

        Create an Album.

        :param version: (required)
        :type version: float
        :param title: the title of the album (required)
        :type title: str
        :param cover_asset_nullable: determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image (required)
        :type cover_asset_nullable: bool
        :param include_cover_in_asset_list: determines whether the cover image should be added to the album asset list (required)
        :type include_cover_in_asset_list: bool
        :param public_read: determines whether the album's participants has read permissions (required)
        :type public_read: bool
        :param public_write: determines whether the album's participants has write permissions (required)
        :type public_write: bool
        :param public_delete: determines whether the album's participants has delete permissions (required)
        :type public_delete: bool
        :param public_add: determines whether the album's participants has add permissions (required)
        :type public_add: bool
        :param anonymous: determines whether the album is posted anonymously (required)
        :type anonymous: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param assets_to_add: Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        :type assets_to_add: str
        :param media: a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        :type media_url: str
        :param asset_id: The asset ID to set the album cover image
        :type asset_id: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
        :type attached_media_url: str
        :param start_date: the start date
        :type start_date: int
        :param end_date: the end date
        :type end_date: int
        :param tags: the tags
        :type tags: str
        :param description: the description of the album
        :type description: str
        :param album_type: a custom field used for aggregation and searching
        :type album_type: str
        :param album_type_id: a custom indexed number used for aggregation and searching
        :type album_type_id: int
        :param sub_type: a custom string field used for aggregation and searching
        :type sub_type: str
        :param latitude: latitude used to update the album's location
        :type latitude: float
        :param longitude: longitude used to update the album's location
        :type longitude: float
        :param location_description: the location description
        :type location_description: str
        :param visibility: the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        :type visibility: str
        :param game_type: @deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param cell_phone: the cell phone number
        :type cell_phone: str
        :param street_address: The street address of the location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the location
        :type city: str
        :param state: The state of of the location
        :type state: str
        :param postal_code: The postal code of the location
        :type postal_code: str
        :param full_address: The full address of the location which should include the street address, city, state, and postal code
        :type full_address: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param category_ids: comma separated category ids string associated with the Album
        :type category_ids: str
        :param category_filter_ids: comma separated filter ids string associated with the Album
        :type category_filter_ids: str
        :param audience_ids: comma separated audience ids string associated with the album
        :type audience_ids: str
        :param include_all_app_users_as_members: determines whether to include all app users as members (only admins of the app can do this)
        :type include_all_app_users_as_members: bool
        :param include_audiences_as_members: determines whether to include all users of the audiences as members (only admins of the app can do this)
        :type include_audiences_as_members: bool
        :param audience_operator: determines whether to use ands or ors when using the audience list to add users
        :type audience_operator: str
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param linked_object_type: sets a linked object so that it can be returned as part of the album response
        :type linked_object_type: str
        :param linked_object_id: sets a linked object id so that it can be returned as part of the album response
        :type linked_object_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_album_collection_serialize(
            version=version,
            title=title,
            cover_asset_nullable=cover_asset_nullable,
            include_cover_in_asset_list=include_cover_in_asset_list,
            public_read=public_read,
            public_write=public_write,
            public_delete=public_delete,
            public_add=public_add,
            anonymous=anonymous,
            device_id=device_id,
            account_id=account_id,
            assets_to_add=assets_to_add,
            media=media,
            media_url=media_url,
            asset_id=asset_id,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            description=description,
            album_type=album_type,
            album_type_id=album_type_id,
            sub_type=sub_type,
            latitude=latitude,
            longitude=longitude,
            location_description=location_description,
            visibility=visibility,
            game_type=game_type,
            app_key=app_key,
            cell_phone=cell_phone,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            full_address=full_address,
            meta_data=meta_data,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            include_all_app_users_as_members=include_all_app_users_as_members,
            include_audiences_as_members=include_audiences_as_members,
            audience_operator=audience_operator,
            approval_status=approval_status,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_album_collection_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        title: Annotated[StrictStr, Field(description="the title of the album")],
        cover_asset_nullable: Annotated[StrictBool, Field(description="determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image")],
        include_cover_in_asset_list: Annotated[StrictBool, Field(description="determines whether the cover image should be added to the album asset list")],
        public_read: Annotated[StrictBool, Field(description="determines whether the album's participants has read permissions")],
        public_write: Annotated[StrictBool, Field(description="determines whether the album's participants has write permissions")],
        public_delete: Annotated[StrictBool, Field(description="determines whether the album's participants has delete permissions")],
        public_add: Annotated[StrictBool, Field(description="determines whether the album's participants has add permissions")],
        anonymous: Annotated[StrictBool, Field(description="determines whether the album is posted anonymously")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        assets_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the album cover image")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="the tags")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the album")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="a custom field used for aggregation and searching")] = None,
        album_type_id: Annotated[Optional[StrictInt], Field(description="a custom indexed number used for aggregation and searching")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="a custom string field used for aggregation and searching")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the album's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the album's location")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="@deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the cell phone number")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of of the location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the location")] = None,
        full_address: Annotated[Optional[StrictStr], Field(description="The full address of the location which should include the street address, city, state, and postal code")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="comma separated category ids string associated with the Album")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="comma separated filter ids string associated with the Album")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated audience ids string associated with the album")] = None,
        include_all_app_users_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all app users as members (only admins of the app can do this)")] = None,
        include_audiences_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all users of the audiences as members (only admins of the app can do this)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="determines whether to use ands or ors when using the audience list to add users")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="sets a linked object so that it can be returned as part of the album response")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="sets a linked object id so that it can be returned as part of the album response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SearchResponse]:
        """Create Album

        Create an Album.

        :param version: (required)
        :type version: float
        :param title: the title of the album (required)
        :type title: str
        :param cover_asset_nullable: determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image (required)
        :type cover_asset_nullable: bool
        :param include_cover_in_asset_list: determines whether the cover image should be added to the album asset list (required)
        :type include_cover_in_asset_list: bool
        :param public_read: determines whether the album's participants has read permissions (required)
        :type public_read: bool
        :param public_write: determines whether the album's participants has write permissions (required)
        :type public_write: bool
        :param public_delete: determines whether the album's participants has delete permissions (required)
        :type public_delete: bool
        :param public_add: determines whether the album's participants has add permissions (required)
        :type public_add: bool
        :param anonymous: determines whether the album is posted anonymously (required)
        :type anonymous: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param assets_to_add: Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        :type assets_to_add: str
        :param media: a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        :type media_url: str
        :param asset_id: The asset ID to set the album cover image
        :type asset_id: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
        :type attached_media_url: str
        :param start_date: the start date
        :type start_date: int
        :param end_date: the end date
        :type end_date: int
        :param tags: the tags
        :type tags: str
        :param description: the description of the album
        :type description: str
        :param album_type: a custom field used for aggregation and searching
        :type album_type: str
        :param album_type_id: a custom indexed number used for aggregation and searching
        :type album_type_id: int
        :param sub_type: a custom string field used for aggregation and searching
        :type sub_type: str
        :param latitude: latitude used to update the album's location
        :type latitude: float
        :param longitude: longitude used to update the album's location
        :type longitude: float
        :param location_description: the location description
        :type location_description: str
        :param visibility: the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        :type visibility: str
        :param game_type: @deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param cell_phone: the cell phone number
        :type cell_phone: str
        :param street_address: The street address of the location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the location
        :type city: str
        :param state: The state of of the location
        :type state: str
        :param postal_code: The postal code of the location
        :type postal_code: str
        :param full_address: The full address of the location which should include the street address, city, state, and postal code
        :type full_address: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param category_ids: comma separated category ids string associated with the Album
        :type category_ids: str
        :param category_filter_ids: comma separated filter ids string associated with the Album
        :type category_filter_ids: str
        :param audience_ids: comma separated audience ids string associated with the album
        :type audience_ids: str
        :param include_all_app_users_as_members: determines whether to include all app users as members (only admins of the app can do this)
        :type include_all_app_users_as_members: bool
        :param include_audiences_as_members: determines whether to include all users of the audiences as members (only admins of the app can do this)
        :type include_audiences_as_members: bool
        :param audience_operator: determines whether to use ands or ors when using the audience list to add users
        :type audience_operator: str
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param linked_object_type: sets a linked object so that it can be returned as part of the album response
        :type linked_object_type: str
        :param linked_object_id: sets a linked object id so that it can be returned as part of the album response
        :type linked_object_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_album_collection_serialize(
            version=version,
            title=title,
            cover_asset_nullable=cover_asset_nullable,
            include_cover_in_asset_list=include_cover_in_asset_list,
            public_read=public_read,
            public_write=public_write,
            public_delete=public_delete,
            public_add=public_add,
            anonymous=anonymous,
            device_id=device_id,
            account_id=account_id,
            assets_to_add=assets_to_add,
            media=media,
            media_url=media_url,
            asset_id=asset_id,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            description=description,
            album_type=album_type,
            album_type_id=album_type_id,
            sub_type=sub_type,
            latitude=latitude,
            longitude=longitude,
            location_description=location_description,
            visibility=visibility,
            game_type=game_type,
            app_key=app_key,
            cell_phone=cell_phone,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            full_address=full_address,
            meta_data=meta_data,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            include_all_app_users_as_members=include_all_app_users_as_members,
            include_audiences_as_members=include_audiences_as_members,
            audience_operator=audience_operator,
            approval_status=approval_status,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_album_collection_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        title: Annotated[StrictStr, Field(description="the title of the album")],
        cover_asset_nullable: Annotated[StrictBool, Field(description="determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image")],
        include_cover_in_asset_list: Annotated[StrictBool, Field(description="determines whether the cover image should be added to the album asset list")],
        public_read: Annotated[StrictBool, Field(description="determines whether the album's participants has read permissions")],
        public_write: Annotated[StrictBool, Field(description="determines whether the album's participants has write permissions")],
        public_delete: Annotated[StrictBool, Field(description="determines whether the album's participants has delete permissions")],
        public_add: Annotated[StrictBool, Field(description="determines whether the album's participants has add permissions")],
        anonymous: Annotated[StrictBool, Field(description="determines whether the album is posted anonymously")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        assets_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the album cover image")] = None,
        attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.")] = None,
        attached_media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="the tags")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the album")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="a custom field used for aggregation and searching")] = None,
        album_type_id: Annotated[Optional[StrictInt], Field(description="a custom indexed number used for aggregation and searching")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="a custom string field used for aggregation and searching")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the album's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the album's location")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="@deprecated, use the appKey")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the cell phone number")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of of the location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the location")] = None,
        full_address: Annotated[Optional[StrictStr], Field(description="The full address of the location which should include the street address, city, state, and postal code")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="comma separated category ids string associated with the Album")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="comma separated filter ids string associated with the Album")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated audience ids string associated with the album")] = None,
        include_all_app_users_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all app users as members (only admins of the app can do this)")] = None,
        include_audiences_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all users of the audiences as members (only admins of the app can do this)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="determines whether to use ands or ors when using the audience list to add users")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="sets a linked object so that it can be returned as part of the album response")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="sets a linked object id so that it can be returned as part of the album response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Album

        Create an Album.

        :param version: (required)
        :type version: float
        :param title: the title of the album (required)
        :type title: str
        :param cover_asset_nullable: determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image (required)
        :type cover_asset_nullable: bool
        :param include_cover_in_asset_list: determines whether the cover image should be added to the album asset list (required)
        :type include_cover_in_asset_list: bool
        :param public_read: determines whether the album's participants has read permissions (required)
        :type public_read: bool
        :param public_write: determines whether the album's participants has write permissions (required)
        :type public_write: bool
        :param public_delete: determines whether the album's participants has delete permissions (required)
        :type public_delete: bool
        :param public_add: determines whether the album's participants has add permissions (required)
        :type public_add: bool
        :param anonymous: determines whether the album is posted anonymously (required)
        :type anonymous: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param assets_to_add: Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        :type assets_to_add: str
        :param media: a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        :type media_url: str
        :param asset_id: The asset ID to set the album cover image
        :type asset_id: int
        :param attached_media: a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
        :type attached_media: bytearray
        :param attached_media_url: this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
        :type attached_media_url: str
        :param start_date: the start date
        :type start_date: int
        :param end_date: the end date
        :type end_date: int
        :param tags: the tags
        :type tags: str
        :param description: the description of the album
        :type description: str
        :param album_type: a custom field used for aggregation and searching
        :type album_type: str
        :param album_type_id: a custom indexed number used for aggregation and searching
        :type album_type_id: int
        :param sub_type: a custom string field used for aggregation and searching
        :type sub_type: str
        :param latitude: latitude used to update the album's location
        :type latitude: float
        :param longitude: longitude used to update the album's location
        :type longitude: float
        :param location_description: the location description
        :type location_description: str
        :param visibility: the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        :type visibility: str
        :param game_type: @deprecated, use the appKey
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param cell_phone: the cell phone number
        :type cell_phone: str
        :param street_address: The street address of the location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the location
        :type city: str
        :param state: The state of of the location
        :type state: str
        :param postal_code: The postal code of the location
        :type postal_code: str
        :param full_address: The full address of the location which should include the street address, city, state, and postal code
        :type full_address: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param category_ids: comma separated category ids string associated with the Album
        :type category_ids: str
        :param category_filter_ids: comma separated filter ids string associated with the Album
        :type category_filter_ids: str
        :param audience_ids: comma separated audience ids string associated with the album
        :type audience_ids: str
        :param include_all_app_users_as_members: determines whether to include all app users as members (only admins of the app can do this)
        :type include_all_app_users_as_members: bool
        :param include_audiences_as_members: determines whether to include all users of the audiences as members (only admins of the app can do this)
        :type include_audiences_as_members: bool
        :param audience_operator: determines whether to use ands or ors when using the audience list to add users
        :type audience_operator: str
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param linked_object_type: sets a linked object so that it can be returned as part of the album response
        :type linked_object_type: str
        :param linked_object_id: sets a linked object id so that it can be returned as part of the album response
        :type linked_object_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_album_collection_serialize(
            version=version,
            title=title,
            cover_asset_nullable=cover_asset_nullable,
            include_cover_in_asset_list=include_cover_in_asset_list,
            public_read=public_read,
            public_write=public_write,
            public_delete=public_delete,
            public_add=public_add,
            anonymous=anonymous,
            device_id=device_id,
            account_id=account_id,
            assets_to_add=assets_to_add,
            media=media,
            media_url=media_url,
            asset_id=asset_id,
            attached_media=attached_media,
            attached_media_url=attached_media_url,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            description=description,
            album_type=album_type,
            album_type_id=album_type_id,
            sub_type=sub_type,
            latitude=latitude,
            longitude=longitude,
            location_description=location_description,
            visibility=visibility,
            game_type=game_type,
            app_key=app_key,
            cell_phone=cell_phone,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            full_address=full_address,
            meta_data=meta_data,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            include_all_app_users_as_members=include_all_app_users_as_members,
            include_audiences_as_members=include_audiences_as_members,
            audience_operator=audience_operator,
            approval_status=approval_status,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_album_collection_serialize(
        self,
        version,
        title,
        cover_asset_nullable,
        include_cover_in_asset_list,
        public_read,
        public_write,
        public_delete,
        public_add,
        anonymous,
        device_id,
        account_id,
        assets_to_add,
        media,
        media_url,
        asset_id,
        attached_media,
        attached_media_url,
        start_date,
        end_date,
        tags,
        description,
        album_type,
        album_type_id,
        sub_type,
        latitude,
        longitude,
        location_description,
        visibility,
        game_type,
        app_key,
        cell_phone,
        street_address,
        street_address2,
        city,
        state,
        postal_code,
        full_address,
        meta_data,
        category_ids,
        category_filter_ids,
        audience_ids,
        include_all_app_users_as_members,
        include_audiences_as_members,
        audience_operator,
        approval_status,
        linked_object_type,
        linked_object_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if assets_to_add is not None:
            
            _query_params.append(('assetsToAdd', assets_to_add))
            
        if media is not None:
            
            _query_params.append(('media', media))
            
        if media_url is not None:
            
            _query_params.append(('mediaURL', media_url))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if attached_media is not None:
            
            _query_params.append(('attachedMedia', attached_media))
            
        if attached_media_url is not None:
            
            _query_params.append(('attachedMediaURL', attached_media_url))
            
        if cover_asset_nullable is not None:
            
            _query_params.append(('coverAssetNullable', cover_asset_nullable))
            
        if include_cover_in_asset_list is not None:
            
            _query_params.append(('includeCoverInAssetList', include_cover_in_asset_list))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if album_type is not None:
            
            _query_params.append(('albumType', album_type))
            
        if album_type_id is not None:
            
            _query_params.append(('albumTypeId', album_type_id))
            
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        if public_read is not None:
            
            _query_params.append(('publicRead', public_read))
            
        if public_write is not None:
            
            _query_params.append(('publicWrite', public_write))
            
        if public_delete is not None:
            
            _query_params.append(('publicDelete', public_delete))
            
        if public_add is not None:
            
            _query_params.append(('publicAdd', public_add))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if cell_phone is not None:
            
            _query_params.append(('cellPhone', cell_phone))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if full_address is not None:
            
            _query_params.append(('fullAddress', full_address))
            
        if anonymous is not None:
            
            _query_params.append(('anonymous', anonymous))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if category_filter_ids is not None:
            
            _query_params.append(('categoryFilterIds', category_filter_ids))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if include_all_app_users_as_members is not None:
            
            _query_params.append(('includeAllAppUsersAsMembers', include_all_app_users_as_members))
            
        if include_audiences_as_members is not None:
            
            _query_params.append(('includeAudiencesAsMembers', include_audiences_as_members))
            
        if audience_operator is not None:
            
            _query_params.append(('audienceOperator', audience_operator))
            
        if approval_status is not None:
            
            _query_params.append(('approvalStatus', approval_status))
            
        if linked_object_type is not None:
            
            _query_params.append(('linkedObjectType', linked_object_type))
            
        if linked_object_id is not None:
            
            _query_params.append(('linkedObjectId', linked_object_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_album_users(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        include_friend_group: Annotated[StrictBool, Field(description="determines whether to include all friends as participants")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        read: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have read permissions")] = None,
        write: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have write permissions")] = None,
        delete: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have delete permissions")] = None,
        add: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have add permissions")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        connection_groups: Annotated[Optional[StrictStr], Field(description="comma separated list of connection group IDs")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Add Album Users

        Add users to an album as participants.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param include_friend_group: determines whether to include all friends as participants (required)
        :type include_friend_group: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param read: determines whether the users being added have read permissions
        :type read: bool
        :param write: determines whether the users being added have write permissions
        :type write: bool
        :param delete: determines whether the users being added have delete permissions
        :type delete: bool
        :param add: determines whether the users being added have add permissions
        :type add: bool
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param connection_groups: comma separated list of connection group IDs
        :type connection_groups: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_album_users_serialize(
            version=version,
            album_id=album_id,
            include_friend_group=include_friend_group,
            device_id=device_id,
            account_id=account_id,
            read=read,
            write=write,
            delete=delete,
            add=add,
            connections=connections,
            connection_groups=connection_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_album_users_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        include_friend_group: Annotated[StrictBool, Field(description="determines whether to include all friends as participants")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        read: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have read permissions")] = None,
        write: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have write permissions")] = None,
        delete: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have delete permissions")] = None,
        add: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have add permissions")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        connection_groups: Annotated[Optional[StrictStr], Field(description="comma separated list of connection group IDs")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Add Album Users

        Add users to an album as participants.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param include_friend_group: determines whether to include all friends as participants (required)
        :type include_friend_group: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param read: determines whether the users being added have read permissions
        :type read: bool
        :param write: determines whether the users being added have write permissions
        :type write: bool
        :param delete: determines whether the users being added have delete permissions
        :type delete: bool
        :param add: determines whether the users being added have add permissions
        :type add: bool
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param connection_groups: comma separated list of connection group IDs
        :type connection_groups: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_album_users_serialize(
            version=version,
            album_id=album_id,
            include_friend_group=include_friend_group,
            device_id=device_id,
            account_id=account_id,
            read=read,
            write=write,
            delete=delete,
            add=add,
            connections=connections,
            connection_groups=connection_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_album_users_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        include_friend_group: Annotated[StrictBool, Field(description="determines whether to include all friends as participants")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        read: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have read permissions")] = None,
        write: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have write permissions")] = None,
        delete: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have delete permissions")] = None,
        add: Annotated[Optional[StrictBool], Field(description="determines whether the users being added have add permissions")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        connection_groups: Annotated[Optional[StrictStr], Field(description="comma separated list of connection group IDs")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add Album Users

        Add users to an album as participants.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param include_friend_group: determines whether to include all friends as participants (required)
        :type include_friend_group: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param read: determines whether the users being added have read permissions
        :type read: bool
        :param write: determines whether the users being added have write permissions
        :type write: bool
        :param delete: determines whether the users being added have delete permissions
        :type delete: bool
        :param add: determines whether the users being added have add permissions
        :type add: bool
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param connection_groups: comma separated list of connection group IDs
        :type connection_groups: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_album_users_serialize(
            version=version,
            album_id=album_id,
            include_friend_group=include_friend_group,
            device_id=device_id,
            account_id=account_id,
            read=read,
            write=write,
            delete=delete,
            add=add,
            connections=connections,
            connection_groups=connection_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_album_users_serialize(
        self,
        version,
        album_id,
        include_friend_group,
        device_id,
        account_id,
        read,
        write,
        delete,
        add,
        connections,
        connection_groups,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if read is not None:
            
            _query_params.append(('read', read))
            
        if write is not None:
            
            _query_params.append(('write', write))
            
        if delete is not None:
            
            _query_params.append(('delete', delete))
            
        if add is not None:
            
            _query_params.append(('add', add))
            
        if connections is not None:
            
            _query_params.append(('connections', connections))
            
        if connection_groups is not None:
            
            _query_params.append(('connectionGroups', connection_groups))
            
        if include_friend_group is not None:
            
            _query_params.append(('includeFriendGroup', include_friend_group))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/user/add',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def approve_album(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="The ID of the album")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        verified: Annotated[Optional[StrictBool], Field(description="Sets whether the album should be marked as \"verified\"")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Approve Album

        Sets the approval status of an Album.

        :param version: (required)
        :type version: float
        :param album_id: The ID of the album (required)
        :type album_id: int
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param verified: Sets whether the album should be marked as \"verified\"
        :type verified: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._approve_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            approval_status=approval_status,
            verified=verified,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def approve_album_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="The ID of the album")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        verified: Annotated[Optional[StrictBool], Field(description="Sets whether the album should be marked as \"verified\"")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Approve Album

        Sets the approval status of an Album.

        :param version: (required)
        :type version: float
        :param album_id: The ID of the album (required)
        :type album_id: int
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param verified: Sets whether the album should be marked as \"verified\"
        :type verified: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._approve_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            approval_status=approval_status,
            verified=verified,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def approve_album_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="The ID of the album")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        verified: Annotated[Optional[StrictBool], Field(description="Sets whether the album should be marked as \"verified\"")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Approve Album

        Sets the approval status of an Album.

        :param version: (required)
        :type version: float
        :param album_id: The ID of the album (required)
        :type album_id: int
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param verified: Sets whether the album should be marked as \"verified\"
        :type verified: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._approve_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            approval_status=approval_status,
            verified=verified,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _approve_album_serialize(
        self,
        version,
        album_id,
        device_id,
        account_id,
        approval_status,
        verified,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if approval_status is not None:
            
            _query_params.append(('approvalStatus', approval_status))
            
        if verified is not None:
            
            _query_params.append(('verified', verified))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/approve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_album_collection(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[StrictBool, Field(description="This parameter is deprecated.")],
        album_id: Annotated[StrictInt, Field(description="the album to look up")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        like_preview_size: Annotated[Optional[StrictInt], Field(description="returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.")] = None,
        asset_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.")] = None,
        note_preview_size: Annotated[Optional[StrictInt], Field(description="returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.")] = None,
        connection_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.")] = None,
        audience_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AlbumFullResponse:
        """ Get Album

        Get an Album.

        :param version: (required)
        :type version: float
        :param return_nulls: This parameter is deprecated. (required)
        :type return_nulls: bool
        :param album_id: the album to look up (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param like_preview_size: returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.
        :type like_preview_size: int
        :param asset_preview_size: returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.
        :type asset_preview_size: int
        :param note_preview_size: returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
        :type note_preview_size: int
        :param connection_preview_size: returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
        :type connection_preview_size: int
        :param audience_preview_size: returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
        :type audience_preview_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_album_collection_serialize(
            version=version,
            return_nulls=return_nulls,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            like_preview_size=like_preview_size,
            asset_preview_size=asset_preview_size,
            note_preview_size=note_preview_size,
            connection_preview_size=connection_preview_size,
            audience_preview_size=audience_preview_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlbumFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_album_collection_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[StrictBool, Field(description="This parameter is deprecated.")],
        album_id: Annotated[StrictInt, Field(description="the album to look up")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        like_preview_size: Annotated[Optional[StrictInt], Field(description="returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.")] = None,
        asset_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.")] = None,
        note_preview_size: Annotated[Optional[StrictInt], Field(description="returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.")] = None,
        connection_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.")] = None,
        audience_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AlbumFullResponse]:
        """ Get Album

        Get an Album.

        :param version: (required)
        :type version: float
        :param return_nulls: This parameter is deprecated. (required)
        :type return_nulls: bool
        :param album_id: the album to look up (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param like_preview_size: returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.
        :type like_preview_size: int
        :param asset_preview_size: returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.
        :type asset_preview_size: int
        :param note_preview_size: returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
        :type note_preview_size: int
        :param connection_preview_size: returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
        :type connection_preview_size: int
        :param audience_preview_size: returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
        :type audience_preview_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_album_collection_serialize(
            version=version,
            return_nulls=return_nulls,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            like_preview_size=like_preview_size,
            asset_preview_size=asset_preview_size,
            note_preview_size=note_preview_size,
            connection_preview_size=connection_preview_size,
            audience_preview_size=audience_preview_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlbumFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_album_collection_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[StrictBool, Field(description="This parameter is deprecated.")],
        album_id: Annotated[StrictInt, Field(description="the album to look up")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        like_preview_size: Annotated[Optional[StrictInt], Field(description="returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.")] = None,
        asset_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.")] = None,
        note_preview_size: Annotated[Optional[StrictInt], Field(description="returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.")] = None,
        connection_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.")] = None,
        audience_preview_size: Annotated[Optional[StrictInt], Field(description="returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """ Get Album

        Get an Album.

        :param version: (required)
        :type version: float
        :param return_nulls: This parameter is deprecated. (required)
        :type return_nulls: bool
        :param album_id: the album to look up (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param like_preview_size: returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\" endpoint.
        :type like_preview_size: int
        :param asset_preview_size: returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\" endpoint.
        :type asset_preview_size: int
        :param note_preview_size: returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
        :type note_preview_size: int
        :param connection_preview_size: returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
        :type connection_preview_size: int
        :param audience_preview_size: returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
        :type audience_preview_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_album_collection_serialize(
            version=version,
            return_nulls=return_nulls,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            like_preview_size=like_preview_size,
            asset_preview_size=asset_preview_size,
            note_preview_size=note_preview_size,
            connection_preview_size=connection_preview_size,
            audience_preview_size=audience_preview_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlbumFullResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_album_collection_serialize(
        self,
        version,
        return_nulls,
        album_id,
        device_id,
        account_id,
        like_preview_size,
        asset_preview_size,
        note_preview_size,
        connection_preview_size,
        audience_preview_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if like_preview_size is not None:
            
            _query_params.append(('likePreviewSize', like_preview_size))
            
        if asset_preview_size is not None:
            
            _query_params.append(('assetPreviewSize', asset_preview_size))
            
        if note_preview_size is not None:
            
            _query_params.append(('notePreviewSize', note_preview_size))
            
        if connection_preview_size is not None:
            
            _query_params.append(('connectionPreviewSize', connection_preview_size))
            
        if audience_preview_size is not None:
            
            _query_params.append(('audiencePreviewSize', audience_preview_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/album/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def leave_album(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Leave Album

         Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._leave_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def leave_album_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Leave Album

         Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._leave_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def leave_album_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Leave Album

         Allows a user to leave an album (they are no longer considered a participant). The album creator cannot leave their own albums.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._leave_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _leave_album_serialize(
        self,
        version,
        album_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/user/leave',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_album(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Album

        Deletes an Album

        :param version: (required)
        :type version: float
        :param album_id: the album ID to delete (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_album_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Album

        Deletes an Album

        :param version: (required)
        :type version: float
        :param album_id: the album ID to delete (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_album_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Album

        Deletes an Album

        :param version: (required)
        :type version: float
        :param album_id: the album ID to delete (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_album_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_album_serialize(
        self,
        version,
        album_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_album_users(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        remove_friend_group: Annotated[StrictBool, Field(description="remove friend group")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        connection_groups: Annotated[Optional[StrictStr], Field(description="comma separated list of connection group IDs")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Remove Album Users

        Remove participants of an album.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param remove_friend_group: remove friend group (required)
        :type remove_friend_group: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param connection_groups: comma separated list of connection group IDs
        :type connection_groups: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_album_users_serialize(
            version=version,
            album_id=album_id,
            remove_friend_group=remove_friend_group,
            device_id=device_id,
            account_id=account_id,
            connections=connections,
            connection_groups=connection_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_album_users_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        remove_friend_group: Annotated[StrictBool, Field(description="remove friend group")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        connection_groups: Annotated[Optional[StrictStr], Field(description="comma separated list of connection group IDs")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Remove Album Users

        Remove participants of an album.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param remove_friend_group: remove friend group (required)
        :type remove_friend_group: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param connection_groups: comma separated list of connection group IDs
        :type connection_groups: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_album_users_serialize(
            version=version,
            album_id=album_id,
            remove_friend_group=remove_friend_group,
            device_id=device_id,
            account_id=account_id,
            connections=connections,
            connection_groups=connection_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_album_users_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the album ID")],
        remove_friend_group: Annotated[StrictBool, Field(description="remove friend group")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        connection_groups: Annotated[Optional[StrictStr], Field(description="comma separated list of connection group IDs")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove Album Users

        Remove participants of an album.

        :param version: (required)
        :type version: float
        :param album_id: the album ID (required)
        :type album_id: int
        :param remove_friend_group: remove friend group (required)
        :type remove_friend_group: bool
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param connection_groups: comma separated list of connection group IDs
        :type connection_groups: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_album_users_serialize(
            version=version,
            album_id=album_id,
            remove_friend_group=remove_friend_group,
            device_id=device_id,
            account_id=account_id,
            connections=connections,
            connection_groups=connection_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_album_users_serialize(
        self,
        version,
        album_id,
        remove_friend_group,
        device_id,
        account_id,
        connections,
        connection_groups,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if connections is not None:
            
            _query_params.append(('connections', connections))
            
        if connection_groups is not None:
            
            _query_params.append(('connectionGroups', connection_groups))
            
        if remove_friend_group is not None:
            
            _query_params.append(('removeFriendGroup', remove_friend_group))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/user/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_albums(
        self,
        version: Union[StrictFloat, StrictInt],
        filter: Annotated[StrictStr, Field(description="a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ")],
        album_type_id: Annotated[StrictInt, Field(description="id of custom albumType")],
        sub_type: Annotated[StrictStr, Field(description="filter albums with this album sub type")],
        include_inactive: Annotated[StrictBool, Field(description="determines whether to return inactive albums")],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AlbumApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (There is a hard limit of 100)")],
        range: Annotated[Union[StrictFloat, StrictInt], Field(description="the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)")],
        include_liked: Annotated[StrictBool, Field(description="returns whether or not the current logged in user has liked the album")],
        include_favorited: Annotated[StrictBool, Field(description="returns whether or not the current logged in user has favorited the album")],
        include_permissions: Annotated[StrictBool, Field(description="returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)")],
        like_preview_size: Annotated[StrictInt, Field(description="returns the last X likes")],
        asset_preview_size: Annotated[StrictInt, Field(description="returns the first X assets")],
        note_preview_size: Annotated[StrictInt, Field(description="returns the last X notes")],
        connection_preview_size: Annotated[StrictInt, Field(description="returns the first X users/connections")],
        audience_preview_size: Annotated[StrictInt, Field(description="returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="search on albums that have been created by this account (that the user has permissions to)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)")] = None,
        exclude_album_ids: Annotated[Optional[StrictStr], Field(description="Only for CLOUDINDEX mode, exclude albums with ids matching this list")] = None,
        media_id: Annotated[Optional[StrictInt], Field(description="search on albums that are in a particular media offering")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="filter albums with this album type")] = None,
        limit_per_album_type: Annotated[Optional[StrictInt], Field(description="When using multiple album types this sets a per-album-type limit (used with cloud index mode)")] = None,
        date_created: Annotated[Optional[StrictInt], Field(description="return items that have been created before this date (time-stamp in milliseconds)")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        created_since: Annotated[Optional[StrictInt], Field(description="return items that have been created since this date (time-stamp in milliseconds)")] = None,
        created_before: Annotated[Optional[StrictInt], Field(description="return items that have been created before this date (time-stamp in milliseconds)")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="return items that have been started since this date (time-stamp in milliseconds)")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="return items that have been started before this date (time-stamp in milliseconds)")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="return items that have been ended since this date (time-stamp in milliseconds)")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="return items that have been ended before this date (time-stamp in milliseconds)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="return results with categories matching this list")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="return results with filters matching this list")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="return results with audiences matching this list")] = None,
        exclude_audience_ids: Annotated[Optional[StrictStr], Field(description="exclude audiences with ids matching this list")] = None,
        include_completable: Annotated[Optional[StrictBool], Field(description="returns the user's completable object for the album if it exists")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="returns the user's rating for the album if it exists")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.")] = None,
        stack_search: Annotated[Optional[StrictBool], Field(description="groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize")] = None,
        stack_window_size: Annotated[Optional[StrictInt], Field(description="size of each window for each stack")] = None,
        min_stack_per_page: Annotated[Optional[StrictInt], Field(description="The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results")] = None,
        stack_pagination_identifier: Annotated[Optional[StrictStr], Field(description="this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch")] = None,
        stack_details: Annotated[Optional[StrictBool], Field(description="set this to true when making the call to view the albums in the stack")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)")] = None,
        remove_flagged_content: Annotated[Optional[StrictBool], Field(description="return items that have flagCount >= flagThreshold (controls removal of flagged content)")] = None,
        verified_filter: Annotated[Optional[StrictBool], Field(description="setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="filter results by the linkedObjectType")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="filter results by the linkedObjectId")] = None,
        order_audience_id: Annotated[Optional[StrictInt], Field(description="determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)")] = None,
        ignore_default_app_filter: Annotated[Optional[StrictBool], Field(description="if true, ignore the application's default app filter when searching")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Advanced search expression to be used by the server")] = None,
        generate_albums: Annotated[Optional[StrictBool], Field(description="If true and results are empty, attempt to generate albums via templates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AlbumFullResponse]:
        """Search Albums

        Searches on Albums.

        :param version: (required)
        :type version: float
        :param filter: a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums.  (required)
        :type filter: str
        :param album_type_id: id of custom albumType (required)
        :type album_type_id: int
        :param sub_type: filter albums with this album sub type (required)
        :type sub_type: str
        :param include_inactive: determines whether to return inactive albums (required)
        :type include_inactive: bool
        :param sort_field: the field to sort by. See AlbumApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (There is a hard limit of 100) (required)
        :type limit: int
        :param range: the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE) (required)
        :type range: float
        :param include_liked: returns whether or not the current logged in user has liked the album (required)
        :type include_liked: bool
        :param include_favorited: returns whether or not the current logged in user has favorited the album (required)
        :type include_favorited: bool
        :param include_permissions: returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this) (required)
        :type include_permissions: bool
        :param like_preview_size: returns the last X likes (required)
        :type like_preview_size: int
        :param asset_preview_size: returns the first X assets (required)
        :type asset_preview_size: int
        :param note_preview_size: returns the last X notes (required)
        :type note_preview_size: int
        :param connection_preview_size: returns the first X users/connections (required)
        :type connection_preview_size: int
        :param audience_preview_size: returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint. (required)
        :type audience_preview_size: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
        :type connection_account_id: int
        :param owner_id: search on albums that have been created by this account (that the user has permissions to)
        :type owner_id: int
        :param album_ids: search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
        :type album_ids: str
        :param exclude_album_ids: Only for CLOUDINDEX mode, exclude albums with ids matching this list
        :type exclude_album_ids: str
        :param media_id: search on albums that are in a particular media offering
        :type media_id: int
        :param keyword: keyword search string
        :type keyword: str
        :param album_type: filter albums with this album type
        :type album_type: str
        :param limit_per_album_type: When using multiple album types this sets a per-album-type limit (used with cloud index mode)
        :type limit_per_album_type: int
        :param date_created: return items that have been created before this date (time-stamp in milliseconds)
        :type date_created: int
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param created_since: return items that have been created since this date (time-stamp in milliseconds)
        :type created_since: int
        :param created_before: return items that have been created before this date (time-stamp in milliseconds)
        :type created_before: int
        :param started_since: return items that have been started since this date (time-stamp in milliseconds)
        :type started_since: int
        :param started_before: return items that have been started before this date (time-stamp in milliseconds)
        :type started_before: int
        :param ended_since: return items that have been ended since this date (time-stamp in milliseconds)
        :type ended_since: int
        :param ended_before: return items that have been ended before this date (time-stamp in milliseconds)
        :type ended_before: int
        :param latitude: the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        :type latitude: float
        :param longitude: the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        :type longitude: float
        :param app_key: the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
        :type app_key: str
        :param category_ids: return results with categories matching this list
        :type category_ids: str
        :param category_filter_ids: return results with filters matching this list
        :type category_filter_ids: str
        :param audience_ids: return results with audiences matching this list
        :type audience_ids: str
        :param exclude_audience_ids: exclude audiences with ids matching this list
        :type exclude_audience_ids: str
        :param include_completable: returns the user's completable object for the album if it exists
        :type include_completable: bool
        :param include_rating: returns the user's rating for the album if it exists
        :type include_rating: bool
        :param search_mode: The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
        :type search_mode: str
        :param stack_search: groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
        :type stack_search: bool
        :param stack_window_size: size of each window for each stack
        :type stack_window_size: int
        :param min_stack_per_page: The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
        :type min_stack_per_page: int
        :param stack_pagination_identifier: this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
        :type stack_pagination_identifier: str
        :param stack_details: set this to true when making the call to view the albums in the stack
        :type stack_details: bool
        :param flag_count_minimum: Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        :type flag_count_minimum: int
        :param remove_flagged_content: return items that have flagCount >= flagThreshold (controls removal of flagged content)
        :type remove_flagged_content: bool
        :param verified_filter: setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
        :type verified_filter: bool
        :param linked_object_type: filter results by the linkedObjectType
        :type linked_object_type: str
        :param linked_object_id: filter results by the linkedObjectId
        :type linked_object_id: int
        :param order_audience_id: determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
        :type order_audience_id: int
        :param ignore_default_app_filter: if true, ignore the application's default app filter when searching
        :type ignore_default_app_filter: bool
        :param search_expression: Advanced search expression to be used by the server
        :type search_expression: str
        :param generate_albums: If true and results are empty, attempt to generate albums via templates
        :type generate_albums: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_albums_serialize(
            version=version,
            filter=filter,
            album_type_id=album_type_id,
            sub_type=sub_type,
            include_inactive=include_inactive,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            range=range,
            include_liked=include_liked,
            include_favorited=include_favorited,
            include_permissions=include_permissions,
            like_preview_size=like_preview_size,
            asset_preview_size=asset_preview_size,
            note_preview_size=note_preview_size,
            connection_preview_size=connection_preview_size,
            audience_preview_size=audience_preview_size,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            owner_id=owner_id,
            album_ids=album_ids,
            exclude_album_ids=exclude_album_ids,
            media_id=media_id,
            keyword=keyword,
            album_type=album_type,
            limit_per_album_type=limit_per_album_type,
            date_created=date_created,
            updated_since=updated_since,
            updated_before=updated_before,
            created_since=created_since,
            created_before=created_before,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            exclude_audience_ids=exclude_audience_ids,
            include_completable=include_completable,
            include_rating=include_rating,
            search_mode=search_mode,
            stack_search=stack_search,
            stack_window_size=stack_window_size,
            min_stack_per_page=min_stack_per_page,
            stack_pagination_identifier=stack_pagination_identifier,
            stack_details=stack_details,
            flag_count_minimum=flag_count_minimum,
            remove_flagged_content=remove_flagged_content,
            verified_filter=verified_filter,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            order_audience_id=order_audience_id,
            ignore_default_app_filter=ignore_default_app_filter,
            search_expression=search_expression,
            generate_albums=generate_albums,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlbumFullResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_albums_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        filter: Annotated[StrictStr, Field(description="a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ")],
        album_type_id: Annotated[StrictInt, Field(description="id of custom albumType")],
        sub_type: Annotated[StrictStr, Field(description="filter albums with this album sub type")],
        include_inactive: Annotated[StrictBool, Field(description="determines whether to return inactive albums")],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AlbumApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (There is a hard limit of 100)")],
        range: Annotated[Union[StrictFloat, StrictInt], Field(description="the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)")],
        include_liked: Annotated[StrictBool, Field(description="returns whether or not the current logged in user has liked the album")],
        include_favorited: Annotated[StrictBool, Field(description="returns whether or not the current logged in user has favorited the album")],
        include_permissions: Annotated[StrictBool, Field(description="returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)")],
        like_preview_size: Annotated[StrictInt, Field(description="returns the last X likes")],
        asset_preview_size: Annotated[StrictInt, Field(description="returns the first X assets")],
        note_preview_size: Annotated[StrictInt, Field(description="returns the last X notes")],
        connection_preview_size: Annotated[StrictInt, Field(description="returns the first X users/connections")],
        audience_preview_size: Annotated[StrictInt, Field(description="returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="search on albums that have been created by this account (that the user has permissions to)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)")] = None,
        exclude_album_ids: Annotated[Optional[StrictStr], Field(description="Only for CLOUDINDEX mode, exclude albums with ids matching this list")] = None,
        media_id: Annotated[Optional[StrictInt], Field(description="search on albums that are in a particular media offering")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="filter albums with this album type")] = None,
        limit_per_album_type: Annotated[Optional[StrictInt], Field(description="When using multiple album types this sets a per-album-type limit (used with cloud index mode)")] = None,
        date_created: Annotated[Optional[StrictInt], Field(description="return items that have been created before this date (time-stamp in milliseconds)")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        created_since: Annotated[Optional[StrictInt], Field(description="return items that have been created since this date (time-stamp in milliseconds)")] = None,
        created_before: Annotated[Optional[StrictInt], Field(description="return items that have been created before this date (time-stamp in milliseconds)")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="return items that have been started since this date (time-stamp in milliseconds)")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="return items that have been started before this date (time-stamp in milliseconds)")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="return items that have been ended since this date (time-stamp in milliseconds)")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="return items that have been ended before this date (time-stamp in milliseconds)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="return results with categories matching this list")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="return results with filters matching this list")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="return results with audiences matching this list")] = None,
        exclude_audience_ids: Annotated[Optional[StrictStr], Field(description="exclude audiences with ids matching this list")] = None,
        include_completable: Annotated[Optional[StrictBool], Field(description="returns the user's completable object for the album if it exists")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="returns the user's rating for the album if it exists")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.")] = None,
        stack_search: Annotated[Optional[StrictBool], Field(description="groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize")] = None,
        stack_window_size: Annotated[Optional[StrictInt], Field(description="size of each window for each stack")] = None,
        min_stack_per_page: Annotated[Optional[StrictInt], Field(description="The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results")] = None,
        stack_pagination_identifier: Annotated[Optional[StrictStr], Field(description="this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch")] = None,
        stack_details: Annotated[Optional[StrictBool], Field(description="set this to true when making the call to view the albums in the stack")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)")] = None,
        remove_flagged_content: Annotated[Optional[StrictBool], Field(description="return items that have flagCount >= flagThreshold (controls removal of flagged content)")] = None,
        verified_filter: Annotated[Optional[StrictBool], Field(description="setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="filter results by the linkedObjectType")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="filter results by the linkedObjectId")] = None,
        order_audience_id: Annotated[Optional[StrictInt], Field(description="determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)")] = None,
        ignore_default_app_filter: Annotated[Optional[StrictBool], Field(description="if true, ignore the application's default app filter when searching")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Advanced search expression to be used by the server")] = None,
        generate_albums: Annotated[Optional[StrictBool], Field(description="If true and results are empty, attempt to generate albums via templates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AlbumFullResponse]]:
        """Search Albums

        Searches on Albums.

        :param version: (required)
        :type version: float
        :param filter: a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums.  (required)
        :type filter: str
        :param album_type_id: id of custom albumType (required)
        :type album_type_id: int
        :param sub_type: filter albums with this album sub type (required)
        :type sub_type: str
        :param include_inactive: determines whether to return inactive albums (required)
        :type include_inactive: bool
        :param sort_field: the field to sort by. See AlbumApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (There is a hard limit of 100) (required)
        :type limit: int
        :param range: the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE) (required)
        :type range: float
        :param include_liked: returns whether or not the current logged in user has liked the album (required)
        :type include_liked: bool
        :param include_favorited: returns whether or not the current logged in user has favorited the album (required)
        :type include_favorited: bool
        :param include_permissions: returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this) (required)
        :type include_permissions: bool
        :param like_preview_size: returns the last X likes (required)
        :type like_preview_size: int
        :param asset_preview_size: returns the first X assets (required)
        :type asset_preview_size: int
        :param note_preview_size: returns the last X notes (required)
        :type note_preview_size: int
        :param connection_preview_size: returns the first X users/connections (required)
        :type connection_preview_size: int
        :param audience_preview_size: returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint. (required)
        :type audience_preview_size: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
        :type connection_account_id: int
        :param owner_id: search on albums that have been created by this account (that the user has permissions to)
        :type owner_id: int
        :param album_ids: search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
        :type album_ids: str
        :param exclude_album_ids: Only for CLOUDINDEX mode, exclude albums with ids matching this list
        :type exclude_album_ids: str
        :param media_id: search on albums that are in a particular media offering
        :type media_id: int
        :param keyword: keyword search string
        :type keyword: str
        :param album_type: filter albums with this album type
        :type album_type: str
        :param limit_per_album_type: When using multiple album types this sets a per-album-type limit (used with cloud index mode)
        :type limit_per_album_type: int
        :param date_created: return items that have been created before this date (time-stamp in milliseconds)
        :type date_created: int
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param created_since: return items that have been created since this date (time-stamp in milliseconds)
        :type created_since: int
        :param created_before: return items that have been created before this date (time-stamp in milliseconds)
        :type created_before: int
        :param started_since: return items that have been started since this date (time-stamp in milliseconds)
        :type started_since: int
        :param started_before: return items that have been started before this date (time-stamp in milliseconds)
        :type started_before: int
        :param ended_since: return items that have been ended since this date (time-stamp in milliseconds)
        :type ended_since: int
        :param ended_before: return items that have been ended before this date (time-stamp in milliseconds)
        :type ended_before: int
        :param latitude: the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        :type latitude: float
        :param longitude: the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        :type longitude: float
        :param app_key: the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
        :type app_key: str
        :param category_ids: return results with categories matching this list
        :type category_ids: str
        :param category_filter_ids: return results with filters matching this list
        :type category_filter_ids: str
        :param audience_ids: return results with audiences matching this list
        :type audience_ids: str
        :param exclude_audience_ids: exclude audiences with ids matching this list
        :type exclude_audience_ids: str
        :param include_completable: returns the user's completable object for the album if it exists
        :type include_completable: bool
        :param include_rating: returns the user's rating for the album if it exists
        :type include_rating: bool
        :param search_mode: The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
        :type search_mode: str
        :param stack_search: groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
        :type stack_search: bool
        :param stack_window_size: size of each window for each stack
        :type stack_window_size: int
        :param min_stack_per_page: The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
        :type min_stack_per_page: int
        :param stack_pagination_identifier: this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
        :type stack_pagination_identifier: str
        :param stack_details: set this to true when making the call to view the albums in the stack
        :type stack_details: bool
        :param flag_count_minimum: Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        :type flag_count_minimum: int
        :param remove_flagged_content: return items that have flagCount >= flagThreshold (controls removal of flagged content)
        :type remove_flagged_content: bool
        :param verified_filter: setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
        :type verified_filter: bool
        :param linked_object_type: filter results by the linkedObjectType
        :type linked_object_type: str
        :param linked_object_id: filter results by the linkedObjectId
        :type linked_object_id: int
        :param order_audience_id: determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
        :type order_audience_id: int
        :param ignore_default_app_filter: if true, ignore the application's default app filter when searching
        :type ignore_default_app_filter: bool
        :param search_expression: Advanced search expression to be used by the server
        :type search_expression: str
        :param generate_albums: If true and results are empty, attempt to generate albums via templates
        :type generate_albums: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_albums_serialize(
            version=version,
            filter=filter,
            album_type_id=album_type_id,
            sub_type=sub_type,
            include_inactive=include_inactive,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            range=range,
            include_liked=include_liked,
            include_favorited=include_favorited,
            include_permissions=include_permissions,
            like_preview_size=like_preview_size,
            asset_preview_size=asset_preview_size,
            note_preview_size=note_preview_size,
            connection_preview_size=connection_preview_size,
            audience_preview_size=audience_preview_size,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            owner_id=owner_id,
            album_ids=album_ids,
            exclude_album_ids=exclude_album_ids,
            media_id=media_id,
            keyword=keyword,
            album_type=album_type,
            limit_per_album_type=limit_per_album_type,
            date_created=date_created,
            updated_since=updated_since,
            updated_before=updated_before,
            created_since=created_since,
            created_before=created_before,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            exclude_audience_ids=exclude_audience_ids,
            include_completable=include_completable,
            include_rating=include_rating,
            search_mode=search_mode,
            stack_search=stack_search,
            stack_window_size=stack_window_size,
            min_stack_per_page=min_stack_per_page,
            stack_pagination_identifier=stack_pagination_identifier,
            stack_details=stack_details,
            flag_count_minimum=flag_count_minimum,
            remove_flagged_content=remove_flagged_content,
            verified_filter=verified_filter,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            order_audience_id=order_audience_id,
            ignore_default_app_filter=ignore_default_app_filter,
            search_expression=search_expression,
            generate_albums=generate_albums,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlbumFullResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_albums_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        filter: Annotated[StrictStr, Field(description="a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. ")],
        album_type_id: Annotated[StrictInt, Field(description="id of custom albumType")],
        sub_type: Annotated[StrictStr, Field(description="filter albums with this album sub type")],
        include_inactive: Annotated[StrictBool, Field(description="determines whether to return inactive albums")],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AlbumApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (There is a hard limit of 100)")],
        range: Annotated[Union[StrictFloat, StrictInt], Field(description="the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)")],
        include_liked: Annotated[StrictBool, Field(description="returns whether or not the current logged in user has liked the album")],
        include_favorited: Annotated[StrictBool, Field(description="returns whether or not the current logged in user has favorited the album")],
        include_permissions: Annotated[StrictBool, Field(description="returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)")],
        like_preview_size: Annotated[StrictInt, Field(description="returns the last X likes")],
        asset_preview_size: Annotated[StrictInt, Field(description="returns the first X assets")],
        note_preview_size: Annotated[StrictInt, Field(description="returns the last X notes")],
        connection_preview_size: Annotated[StrictInt, Field(description="returns the first X users/connections")],
        audience_preview_size: Annotated[StrictInt, Field(description="returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="search on albums that have been created by this account (that the user has permissions to)")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)")] = None,
        exclude_album_ids: Annotated[Optional[StrictStr], Field(description="Only for CLOUDINDEX mode, exclude albums with ids matching this list")] = None,
        media_id: Annotated[Optional[StrictInt], Field(description="search on albums that are in a particular media offering")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="filter albums with this album type")] = None,
        limit_per_album_type: Annotated[Optional[StrictInt], Field(description="When using multiple album types this sets a per-album-type limit (used with cloud index mode)")] = None,
        date_created: Annotated[Optional[StrictInt], Field(description="return items that have been created before this date (time-stamp in milliseconds)")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        created_since: Annotated[Optional[StrictInt], Field(description="return items that have been created since this date (time-stamp in milliseconds)")] = None,
        created_before: Annotated[Optional[StrictInt], Field(description="return items that have been created before this date (time-stamp in milliseconds)")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="return items that have been started since this date (time-stamp in milliseconds)")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="return items that have been started before this date (time-stamp in milliseconds)")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="return items that have been ended since this date (time-stamp in milliseconds)")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="return items that have been ended before this date (time-stamp in milliseconds)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="return results with categories matching this list")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="return results with filters matching this list")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="return results with audiences matching this list")] = None,
        exclude_audience_ids: Annotated[Optional[StrictStr], Field(description="exclude audiences with ids matching this list")] = None,
        include_completable: Annotated[Optional[StrictBool], Field(description="returns the user's completable object for the album if it exists")] = None,
        include_rating: Annotated[Optional[StrictBool], Field(description="returns the user's rating for the album if it exists")] = None,
        search_mode: Annotated[Optional[StrictStr], Field(description="The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.")] = None,
        stack_search: Annotated[Optional[StrictBool], Field(description="groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize")] = None,
        stack_window_size: Annotated[Optional[StrictInt], Field(description="size of each window for each stack")] = None,
        min_stack_per_page: Annotated[Optional[StrictInt], Field(description="The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results")] = None,
        stack_pagination_identifier: Annotated[Optional[StrictStr], Field(description="this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch")] = None,
        stack_details: Annotated[Optional[StrictBool], Field(description="set this to true when making the call to view the albums in the stack")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)")] = None,
        remove_flagged_content: Annotated[Optional[StrictBool], Field(description="return items that have flagCount >= flagThreshold (controls removal of flagged content)")] = None,
        verified_filter: Annotated[Optional[StrictBool], Field(description="setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="filter results by the linkedObjectType")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="filter results by the linkedObjectId")] = None,
        order_audience_id: Annotated[Optional[StrictInt], Field(description="determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)")] = None,
        ignore_default_app_filter: Annotated[Optional[StrictBool], Field(description="if true, ignore the application's default app filter when searching")] = None,
        search_expression: Annotated[Optional[StrictStr], Field(description="Advanced search expression to be used by the server")] = None,
        generate_albums: Annotated[Optional[StrictBool], Field(description="If true and results are empty, attempt to generate albums via templates")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Albums

        Searches on Albums.

        :param version: (required)
        :type version: float
        :param filter: a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums.  (required)
        :type filter: str
        :param album_type_id: id of custom albumType (required)
        :type album_type_id: int
        :param sub_type: filter albums with this album sub type (required)
        :type sub_type: str
        :param include_inactive: determines whether to return inactive albums (required)
        :type include_inactive: bool
        :param sort_field: the field to sort by. See AlbumApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (There is a hard limit of 100) (required)
        :type limit: int
        :param range: the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE) (required)
        :type range: float
        :param include_liked: returns whether or not the current logged in user has liked the album (required)
        :type include_liked: bool
        :param include_favorited: returns whether or not the current logged in user has favorited the album (required)
        :type include_favorited: bool
        :param include_permissions: returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this) (required)
        :type include_permissions: bool
        :param like_preview_size: returns the last X likes (required)
        :type like_preview_size: int
        :param asset_preview_size: returns the first X assets (required)
        :type asset_preview_size: int
        :param note_preview_size: returns the last X notes (required)
        :type note_preview_size: int
        :param connection_preview_size: returns the first X users/connections (required)
        :type connection_preview_size: int
        :param audience_preview_size: returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint. (required)
        :type audience_preview_size: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
        :type connection_account_id: int
        :param owner_id: search on albums that have been created by this account (that the user has permissions to)
        :type owner_id: int
        :param album_ids: search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
        :type album_ids: str
        :param exclude_album_ids: Only for CLOUDINDEX mode, exclude albums with ids matching this list
        :type exclude_album_ids: str
        :param media_id: search on albums that are in a particular media offering
        :type media_id: int
        :param keyword: keyword search string
        :type keyword: str
        :param album_type: filter albums with this album type
        :type album_type: str
        :param limit_per_album_type: When using multiple album types this sets a per-album-type limit (used with cloud index mode)
        :type limit_per_album_type: int
        :param date_created: return items that have been created before this date (time-stamp in milliseconds)
        :type date_created: int
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param created_since: return items that have been created since this date (time-stamp in milliseconds)
        :type created_since: int
        :param created_before: return items that have been created before this date (time-stamp in milliseconds)
        :type created_before: int
        :param started_since: return items that have been started since this date (time-stamp in milliseconds)
        :type started_since: int
        :param started_before: return items that have been started before this date (time-stamp in milliseconds)
        :type started_before: int
        :param ended_since: return items that have been ended since this date (time-stamp in milliseconds)
        :type ended_since: int
        :param ended_before: return items that have been ended before this date (time-stamp in milliseconds)
        :type ended_before: int
        :param latitude: the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        :type latitude: float
        :param longitude: the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
        :type longitude: float
        :param app_key: the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
        :type app_key: str
        :param category_ids: return results with categories matching this list
        :type category_ids: str
        :param category_filter_ids: return results with filters matching this list
        :type category_filter_ids: str
        :param audience_ids: return results with audiences matching this list
        :type audience_ids: str
        :param exclude_audience_ids: exclude audiences with ids matching this list
        :type exclude_audience_ids: str
        :param include_completable: returns the user's completable object for the album if it exists
        :type include_completable: bool
        :param include_rating: returns the user's rating for the album if it exists
        :type include_rating: bool
        :param search_mode: The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
        :type search_mode: str
        :param stack_search: groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
        :type stack_search: bool
        :param stack_window_size: size of each window for each stack
        :type stack_window_size: int
        :param min_stack_per_page: The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
        :type min_stack_per_page: int
        :param stack_pagination_identifier: this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
        :type stack_pagination_identifier: str
        :param stack_details: set this to true when making the call to view the albums in the stack
        :type stack_details: bool
        :param flag_count_minimum: Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
        :type flag_count_minimum: int
        :param remove_flagged_content: return items that have flagCount >= flagThreshold (controls removal of flagged content)
        :type remove_flagged_content: bool
        :param verified_filter: setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
        :type verified_filter: bool
        :param linked_object_type: filter results by the linkedObjectType
        :type linked_object_type: str
        :param linked_object_id: filter results by the linkedObjectId
        :type linked_object_id: int
        :param order_audience_id: determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
        :type order_audience_id: int
        :param ignore_default_app_filter: if true, ignore the application's default app filter when searching
        :type ignore_default_app_filter: bool
        :param search_expression: Advanced search expression to be used by the server
        :type search_expression: str
        :param generate_albums: If true and results are empty, attempt to generate albums via templates
        :type generate_albums: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_albums_serialize(
            version=version,
            filter=filter,
            album_type_id=album_type_id,
            sub_type=sub_type,
            include_inactive=include_inactive,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            range=range,
            include_liked=include_liked,
            include_favorited=include_favorited,
            include_permissions=include_permissions,
            like_preview_size=like_preview_size,
            asset_preview_size=asset_preview_size,
            note_preview_size=note_preview_size,
            connection_preview_size=connection_preview_size,
            audience_preview_size=audience_preview_size,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            owner_id=owner_id,
            album_ids=album_ids,
            exclude_album_ids=exclude_album_ids,
            media_id=media_id,
            keyword=keyword,
            album_type=album_type,
            limit_per_album_type=limit_per_album_type,
            date_created=date_created,
            updated_since=updated_since,
            updated_before=updated_before,
            created_since=created_since,
            created_before=created_before,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            exclude_audience_ids=exclude_audience_ids,
            include_completable=include_completable,
            include_rating=include_rating,
            search_mode=search_mode,
            stack_search=stack_search,
            stack_window_size=stack_window_size,
            min_stack_per_page=min_stack_per_page,
            stack_pagination_identifier=stack_pagination_identifier,
            stack_details=stack_details,
            flag_count_minimum=flag_count_minimum,
            remove_flagged_content=remove_flagged_content,
            verified_filter=verified_filter,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            order_audience_id=order_audience_id,
            ignore_default_app_filter=ignore_default_app_filter,
            search_expression=search_expression,
            generate_albums=generate_albums,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AlbumFullResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_albums_serialize(
        self,
        version,
        filter,
        album_type_id,
        sub_type,
        include_inactive,
        sort_field,
        descending,
        start,
        limit,
        range,
        include_liked,
        include_favorited,
        include_permissions,
        like_preview_size,
        asset_preview_size,
        note_preview_size,
        connection_preview_size,
        audience_preview_size,
        device_id,
        account_id,
        connection_account_id,
        owner_id,
        album_ids,
        exclude_album_ids,
        media_id,
        keyword,
        album_type,
        limit_per_album_type,
        date_created,
        updated_since,
        updated_before,
        created_since,
        created_before,
        started_since,
        started_before,
        ended_since,
        ended_before,
        latitude,
        longitude,
        app_key,
        category_ids,
        category_filter_ids,
        audience_ids,
        exclude_audience_ids,
        include_completable,
        include_rating,
        search_mode,
        stack_search,
        stack_window_size,
        min_stack_per_page,
        stack_pagination_identifier,
        stack_details,
        flag_count_minimum,
        remove_flagged_content,
        verified_filter,
        linked_object_type,
        linked_object_id,
        order_audience_id,
        ignore_default_app_filter,
        search_expression,
        generate_albums,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if owner_id is not None:
            
            _query_params.append(('ownerId', owner_id))
            
        if album_ids is not None:
            
            _query_params.append(('albumIds', album_ids))
            
        if exclude_album_ids is not None:
            
            _query_params.append(('excludeAlbumIds', exclude_album_ids))
            
        if media_id is not None:
            
            _query_params.append(('mediaId', media_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if album_type is not None:
            
            _query_params.append(('albumType', album_type))
            
        if album_type_id is not None:
            
            _query_params.append(('albumTypeId', album_type_id))
            
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        if include_inactive is not None:
            
            _query_params.append(('includeInactive', include_inactive))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if limit_per_album_type is not None:
            
            _query_params.append(('limitPerAlbumType', limit_per_album_type))
            
        if date_created is not None:
            
            _query_params.append(('dateCreated', date_created))
            
        if updated_since is not None:
            
            _query_params.append(('updatedSince', updated_since))
            
        if updated_before is not None:
            
            _query_params.append(('updatedBefore', updated_before))
            
        if created_since is not None:
            
            _query_params.append(('createdSince', created_since))
            
        if created_before is not None:
            
            _query_params.append(('createdBefore', created_before))
            
        if started_since is not None:
            
            _query_params.append(('startedSince', started_since))
            
        if started_before is not None:
            
            _query_params.append(('startedBefore', started_before))
            
        if ended_since is not None:
            
            _query_params.append(('endedSince', ended_since))
            
        if ended_before is not None:
            
            _query_params.append(('endedBefore', ended_before))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if range is not None:
            
            _query_params.append(('range', range))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if category_filter_ids is not None:
            
            _query_params.append(('categoryFilterIds', category_filter_ids))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if exclude_audience_ids is not None:
            
            _query_params.append(('excludeAudienceIds', exclude_audience_ids))
            
        if include_liked is not None:
            
            _query_params.append(('includeLiked', include_liked))
            
        if include_favorited is not None:
            
            _query_params.append(('includeFavorited', include_favorited))
            
        if include_permissions is not None:
            
            _query_params.append(('includePermissions', include_permissions))
            
        if include_completable is not None:
            
            _query_params.append(('includeCompletable', include_completable))
            
        if include_rating is not None:
            
            _query_params.append(('includeRating', include_rating))
            
        if like_preview_size is not None:
            
            _query_params.append(('likePreviewSize', like_preview_size))
            
        if asset_preview_size is not None:
            
            _query_params.append(('assetPreviewSize', asset_preview_size))
            
        if note_preview_size is not None:
            
            _query_params.append(('notePreviewSize', note_preview_size))
            
        if connection_preview_size is not None:
            
            _query_params.append(('connectionPreviewSize', connection_preview_size))
            
        if audience_preview_size is not None:
            
            _query_params.append(('audiencePreviewSize', audience_preview_size))
            
        if search_mode is not None:
            
            _query_params.append(('searchMode', search_mode))
            
        if stack_search is not None:
            
            _query_params.append(('stackSearch', stack_search))
            
        if stack_window_size is not None:
            
            _query_params.append(('stackWindowSize', stack_window_size))
            
        if min_stack_per_page is not None:
            
            _query_params.append(('minStackPerPage', min_stack_per_page))
            
        if stack_pagination_identifier is not None:
            
            _query_params.append(('stackPaginationIdentifier', stack_pagination_identifier))
            
        if stack_details is not None:
            
            _query_params.append(('stackDetails', stack_details))
            
        if flag_count_minimum is not None:
            
            _query_params.append(('flagCountMinimum', flag_count_minimum))
            
        if remove_flagged_content is not None:
            
            _query_params.append(('removeFlaggedContent', remove_flagged_content))
            
        if verified_filter is not None:
            
            _query_params.append(('verifiedFilter', verified_filter))
            
        if linked_object_type is not None:
            
            _query_params.append(('linkedObjectType', linked_object_type))
            
        if linked_object_id is not None:
            
            _query_params.append(('linkedObjectId', linked_object_id))
            
        if order_audience_id is not None:
            
            _query_params.append(('orderAudienceId', order_audience_id))
            
        if ignore_default_app_filter is not None:
            
            _query_params.append(('ignoreDefaultAppFilter', ignore_default_app_filter))
            
        if search_expression is not None:
            
            _query_params.append(('searchExpression', search_expression))
            
        if generate_albums is not None:
            
            _query_params.append(('generateAlbums', generate_albums))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/album/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_album_collection(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the ID of the album to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        assets_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)")] = None,
        assets_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to remove from the album's asset list")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the cover asset ID")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="determines whether the album is active or inactive")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the album")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="the tags")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the album")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="a custom field used for aggregation and searching")] = None,
        album_type_id: Annotated[Optional[StrictInt], Field(description="a custom indexed number used for aggregation and searching")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="a custom string field used for aggregation and searching")] = None,
        public_read: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have read permissions")] = None,
        public_write: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have write permissions")] = None,
        public_delete: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have delete permissions")] = None,
        public_add: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have add permissions")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the album's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the album's location")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the cell phone number")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of of the location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the location")] = None,
        full_address: Annotated[Optional[StrictStr], Field(description="The full address of the location which should include the street address, city, state, and postal code")] = None,
        anonymous: Annotated[Optional[StrictBool], Field(description="determines whether the album is posted anonymously")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="comma separated category ids string associated with the Album")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="comma separated filter ids string associated with the Album")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated audience ids string associated with the album")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="comma separated audience ids to add to the album")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)")] = None,
        include_all_app_users_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all app users as members (only admins of the app can do this)")] = None,
        include_audiences_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all users of the audiences as members (only admins of the app can do this)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="determines whether to use ands or ors when using the audience list to add users")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="sets a linked object so that it can be returned as part of the album response")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="sets a linked object id so that it can be returned as part of the album response")] = None,
        index_now: Annotated[Optional[StrictBool], Field(description="determines whether the album should be indexed immediately")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AlbumResponse:
        """Update Album

        Update an Album.

        :param version: (required)
        :type version: float
        :param album_id: the ID of the album to update (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param assets_to_add: Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        :type assets_to_add: str
        :param assets_to_remove: Comma separated list of asset IDs to remove from the album's asset list
        :type assets_to_remove: str
        :param asset_id: the cover asset ID
        :type asset_id: int
        :param media: a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        :type media_url: str
        :param active: determines whether the album is active or inactive
        :type active: bool
        :param title: the title of the album
        :type title: str
        :param start_date: the start date
        :type start_date: int
        :param end_date: the end date
        :type end_date: int
        :param tags: the tags
        :type tags: str
        :param description: the description of the album
        :type description: str
        :param album_type: a custom field used for aggregation and searching
        :type album_type: str
        :param album_type_id: a custom indexed number used for aggregation and searching
        :type album_type_id: int
        :param sub_type: a custom string field used for aggregation and searching
        :type sub_type: str
        :param public_read: determines whether the album's participants have read permissions
        :type public_read: bool
        :param public_write: determines whether the album's participants have write permissions
        :type public_write: bool
        :param public_delete: determines whether the album's participants have delete permissions
        :type public_delete: bool
        :param public_add: determines whether the album's participants have add permissions
        :type public_add: bool
        :param latitude: latitude used to update the album's location
        :type latitude: float
        :param longitude: longitude used to update the album's location
        :type longitude: float
        :param location_description: the location description
        :type location_description: str
        :param visibility: the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        :type visibility: str
        :param cell_phone: the cell phone number
        :type cell_phone: str
        :param street_address: The street address of the location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the location
        :type city: str
        :param state: The state of of the location
        :type state: str
        :param postal_code: The postal code of the location
        :type postal_code: str
        :param full_address: The full address of the location which should include the street address, city, state, and postal code
        :type full_address: str
        :param anonymous: determines whether the album is posted anonymously
        :type anonymous: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param category_ids: comma separated category ids string associated with the Album
        :type category_ids: str
        :param category_filter_ids: comma separated filter ids string associated with the Album
        :type category_filter_ids: str
        :param audience_ids: comma separated audience ids string associated with the album
        :type audience_ids: str
        :param audience_ids_to_add: comma separated audience ids to add to the album
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
        :type audience_ids_to_remove: str
        :param include_all_app_users_as_members: determines whether to include all app users as members (only admins of the app can do this)
        :type include_all_app_users_as_members: bool
        :param include_audiences_as_members: determines whether to include all users of the audiences as members (only admins of the app can do this)
        :type include_audiences_as_members: bool
        :param audience_operator: determines whether to use ands or ors when using the audience list to add users
        :type audience_operator: str
        :param linked_object_type: sets a linked object so that it can be returned as part of the album response
        :type linked_object_type: str
        :param linked_object_id: sets a linked object id so that it can be returned as part of the album response
        :type linked_object_id: int
        :param index_now: determines whether the album should be indexed immediately
        :type index_now: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_album_collection_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            assets_to_add=assets_to_add,
            assets_to_remove=assets_to_remove,
            asset_id=asset_id,
            media=media,
            media_url=media_url,
            active=active,
            title=title,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            description=description,
            album_type=album_type,
            album_type_id=album_type_id,
            sub_type=sub_type,
            public_read=public_read,
            public_write=public_write,
            public_delete=public_delete,
            public_add=public_add,
            latitude=latitude,
            longitude=longitude,
            location_description=location_description,
            visibility=visibility,
            cell_phone=cell_phone,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            full_address=full_address,
            anonymous=anonymous,
            meta_data=meta_data,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            include_all_app_users_as_members=include_all_app_users_as_members,
            include_audiences_as_members=include_audiences_as_members,
            audience_operator=audience_operator,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            index_now=index_now,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlbumResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_album_collection_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the ID of the album to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        assets_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)")] = None,
        assets_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to remove from the album's asset list")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the cover asset ID")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="determines whether the album is active or inactive")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the album")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="the tags")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the album")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="a custom field used for aggregation and searching")] = None,
        album_type_id: Annotated[Optional[StrictInt], Field(description="a custom indexed number used for aggregation and searching")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="a custom string field used for aggregation and searching")] = None,
        public_read: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have read permissions")] = None,
        public_write: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have write permissions")] = None,
        public_delete: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have delete permissions")] = None,
        public_add: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have add permissions")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the album's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the album's location")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the cell phone number")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of of the location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the location")] = None,
        full_address: Annotated[Optional[StrictStr], Field(description="The full address of the location which should include the street address, city, state, and postal code")] = None,
        anonymous: Annotated[Optional[StrictBool], Field(description="determines whether the album is posted anonymously")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="comma separated category ids string associated with the Album")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="comma separated filter ids string associated with the Album")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated audience ids string associated with the album")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="comma separated audience ids to add to the album")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)")] = None,
        include_all_app_users_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all app users as members (only admins of the app can do this)")] = None,
        include_audiences_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all users of the audiences as members (only admins of the app can do this)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="determines whether to use ands or ors when using the audience list to add users")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="sets a linked object so that it can be returned as part of the album response")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="sets a linked object id so that it can be returned as part of the album response")] = None,
        index_now: Annotated[Optional[StrictBool], Field(description="determines whether the album should be indexed immediately")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AlbumResponse]:
        """Update Album

        Update an Album.

        :param version: (required)
        :type version: float
        :param album_id: the ID of the album to update (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param assets_to_add: Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        :type assets_to_add: str
        :param assets_to_remove: Comma separated list of asset IDs to remove from the album's asset list
        :type assets_to_remove: str
        :param asset_id: the cover asset ID
        :type asset_id: int
        :param media: a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        :type media_url: str
        :param active: determines whether the album is active or inactive
        :type active: bool
        :param title: the title of the album
        :type title: str
        :param start_date: the start date
        :type start_date: int
        :param end_date: the end date
        :type end_date: int
        :param tags: the tags
        :type tags: str
        :param description: the description of the album
        :type description: str
        :param album_type: a custom field used for aggregation and searching
        :type album_type: str
        :param album_type_id: a custom indexed number used for aggregation and searching
        :type album_type_id: int
        :param sub_type: a custom string field used for aggregation and searching
        :type sub_type: str
        :param public_read: determines whether the album's participants have read permissions
        :type public_read: bool
        :param public_write: determines whether the album's participants have write permissions
        :type public_write: bool
        :param public_delete: determines whether the album's participants have delete permissions
        :type public_delete: bool
        :param public_add: determines whether the album's participants have add permissions
        :type public_add: bool
        :param latitude: latitude used to update the album's location
        :type latitude: float
        :param longitude: longitude used to update the album's location
        :type longitude: float
        :param location_description: the location description
        :type location_description: str
        :param visibility: the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        :type visibility: str
        :param cell_phone: the cell phone number
        :type cell_phone: str
        :param street_address: The street address of the location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the location
        :type city: str
        :param state: The state of of the location
        :type state: str
        :param postal_code: The postal code of the location
        :type postal_code: str
        :param full_address: The full address of the location which should include the street address, city, state, and postal code
        :type full_address: str
        :param anonymous: determines whether the album is posted anonymously
        :type anonymous: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param category_ids: comma separated category ids string associated with the Album
        :type category_ids: str
        :param category_filter_ids: comma separated filter ids string associated with the Album
        :type category_filter_ids: str
        :param audience_ids: comma separated audience ids string associated with the album
        :type audience_ids: str
        :param audience_ids_to_add: comma separated audience ids to add to the album
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
        :type audience_ids_to_remove: str
        :param include_all_app_users_as_members: determines whether to include all app users as members (only admins of the app can do this)
        :type include_all_app_users_as_members: bool
        :param include_audiences_as_members: determines whether to include all users of the audiences as members (only admins of the app can do this)
        :type include_audiences_as_members: bool
        :param audience_operator: determines whether to use ands or ors when using the audience list to add users
        :type audience_operator: str
        :param linked_object_type: sets a linked object so that it can be returned as part of the album response
        :type linked_object_type: str
        :param linked_object_id: sets a linked object id so that it can be returned as part of the album response
        :type linked_object_id: int
        :param index_now: determines whether the album should be indexed immediately
        :type index_now: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_album_collection_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            assets_to_add=assets_to_add,
            assets_to_remove=assets_to_remove,
            asset_id=asset_id,
            media=media,
            media_url=media_url,
            active=active,
            title=title,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            description=description,
            album_type=album_type,
            album_type_id=album_type_id,
            sub_type=sub_type,
            public_read=public_read,
            public_write=public_write,
            public_delete=public_delete,
            public_add=public_add,
            latitude=latitude,
            longitude=longitude,
            location_description=location_description,
            visibility=visibility,
            cell_phone=cell_phone,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            full_address=full_address,
            anonymous=anonymous,
            meta_data=meta_data,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            include_all_app_users_as_members=include_all_app_users_as_members,
            include_audiences_as_members=include_audiences_as_members,
            audience_operator=audience_operator,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            index_now=index_now,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlbumResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_album_collection_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        album_id: Annotated[StrictInt, Field(description="the ID of the album to update")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account ID of the user (deviceId or accountId required)")] = None,
        assets_to_add: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)")] = None,
        assets_to_remove: Annotated[Optional[StrictStr], Field(description="Comma separated list of asset IDs to remove from the album's asset list")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the cover asset ID")] = None,
        media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)")] = None,
        media_url: Annotated[Optional[StrictStr], Field(description="this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)")] = None,
        active: Annotated[Optional[StrictBool], Field(description="determines whether the album is active or inactive")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the album")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="the tags")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the album")] = None,
        album_type: Annotated[Optional[StrictStr], Field(description="a custom field used for aggregation and searching")] = None,
        album_type_id: Annotated[Optional[StrictInt], Field(description="a custom indexed number used for aggregation and searching")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="a custom string field used for aggregation and searching")] = None,
        public_read: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have read permissions")] = None,
        public_write: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have write permissions")] = None,
        public_delete: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have delete permissions")] = None,
        public_add: Annotated[Optional[StrictBool], Field(description="determines whether the album's participants have add permissions")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude used to update the album's location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude used to update the album's location")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="the location description")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)")] = None,
        cell_phone: Annotated[Optional[StrictStr], Field(description="the cell phone number")] = None,
        street_address: Annotated[Optional[StrictStr], Field(description="The street address of the location")] = None,
        street_address2: Annotated[Optional[StrictStr], Field(description="Additional address information (such as a suite number, floor number, building name, or PO Box)")] = None,
        city: Annotated[Optional[StrictStr], Field(description="The city of the location")] = None,
        state: Annotated[Optional[StrictStr], Field(description="The state of of the location")] = None,
        postal_code: Annotated[Optional[StrictStr], Field(description="The postal code of the location")] = None,
        full_address: Annotated[Optional[StrictStr], Field(description="The full address of the location which should include the street address, city, state, and postal code")] = None,
        anonymous: Annotated[Optional[StrictBool], Field(description="determines whether the album is posted anonymously")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="comma separated category ids string associated with the Album")] = None,
        category_filter_ids: Annotated[Optional[StrictStr], Field(description="comma separated filter ids string associated with the Album")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated audience ids string associated with the album")] = None,
        audience_ids_to_add: Annotated[Optional[StrictStr], Field(description="comma separated audience ids to add to the album")] = None,
        audience_ids_to_remove: Annotated[Optional[StrictStr], Field(description="comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)")] = None,
        include_all_app_users_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all app users as members (only admins of the app can do this)")] = None,
        include_audiences_as_members: Annotated[Optional[StrictBool], Field(description="determines whether to include all users of the audiences as members (only admins of the app can do this)")] = None,
        audience_operator: Annotated[Optional[StrictStr], Field(description="determines whether to use ands or ors when using the audience list to add users")] = None,
        linked_object_type: Annotated[Optional[StrictStr], Field(description="sets a linked object so that it can be returned as part of the album response")] = None,
        linked_object_id: Annotated[Optional[StrictInt], Field(description="sets a linked object id so that it can be returned as part of the album response")] = None,
        index_now: Annotated[Optional[StrictBool], Field(description="determines whether the album should be indexed immediately")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Album

        Update an Album.

        :param version: (required)
        :type version: float
        :param album_id: the ID of the album to update (required)
        :type album_id: int
        :param device_id: a unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param assets_to_add: Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
        :type assets_to_add: str
        :param assets_to_remove: Comma separated list of asset IDs to remove from the album's asset list
        :type assets_to_remove: str
        :param asset_id: the cover asset ID
        :type asset_id: int
        :param media: a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
        :type media: bytearray
        :param media_url: this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
        :type media_url: str
        :param active: determines whether the album is active or inactive
        :type active: bool
        :param title: the title of the album
        :type title: str
        :param start_date: the start date
        :type start_date: int
        :param end_date: the end date
        :type end_date: int
        :param tags: the tags
        :type tags: str
        :param description: the description of the album
        :type description: str
        :param album_type: a custom field used for aggregation and searching
        :type album_type: str
        :param album_type_id: a custom indexed number used for aggregation and searching
        :type album_type_id: int
        :param sub_type: a custom string field used for aggregation and searching
        :type sub_type: str
        :param public_read: determines whether the album's participants have read permissions
        :type public_read: bool
        :param public_write: determines whether the album's participants have write permissions
        :type public_write: bool
        :param public_delete: determines whether the album's participants have delete permissions
        :type public_delete: bool
        :param public_add: determines whether the album's participants have add permissions
        :type public_add: bool
        :param latitude: latitude used to update the album's location
        :type latitude: float
        :param longitude: longitude used to update the album's location
        :type longitude: float
        :param location_description: the location description
        :type location_description: str
        :param visibility: the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
        :type visibility: str
        :param cell_phone: the cell phone number
        :type cell_phone: str
        :param street_address: The street address of the location
        :type street_address: str
        :param street_address2: Additional address information (such as a suite number, floor number, building name, or PO Box)
        :type street_address2: str
        :param city: The city of the location
        :type city: str
        :param state: The state of of the location
        :type state: str
        :param postal_code: The postal code of the location
        :type postal_code: str
        :param full_address: The full address of the location which should include the street address, city, state, and postal code
        :type full_address: str
        :param anonymous: determines whether the album is posted anonymously
        :type anonymous: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param category_ids: comma separated category ids string associated with the Album
        :type category_ids: str
        :param category_filter_ids: comma separated filter ids string associated with the Album
        :type category_filter_ids: str
        :param audience_ids: comma separated audience ids string associated with the album
        :type audience_ids: str
        :param audience_ids_to_add: comma separated audience ids to add to the album
        :type audience_ids_to_add: str
        :param audience_ids_to_remove: comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
        :type audience_ids_to_remove: str
        :param include_all_app_users_as_members: determines whether to include all app users as members (only admins of the app can do this)
        :type include_all_app_users_as_members: bool
        :param include_audiences_as_members: determines whether to include all users of the audiences as members (only admins of the app can do this)
        :type include_audiences_as_members: bool
        :param audience_operator: determines whether to use ands or ors when using the audience list to add users
        :type audience_operator: str
        :param linked_object_type: sets a linked object so that it can be returned as part of the album response
        :type linked_object_type: str
        :param linked_object_id: sets a linked object id so that it can be returned as part of the album response
        :type linked_object_id: int
        :param index_now: determines whether the album should be indexed immediately
        :type index_now: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_album_collection_serialize(
            version=version,
            album_id=album_id,
            device_id=device_id,
            account_id=account_id,
            assets_to_add=assets_to_add,
            assets_to_remove=assets_to_remove,
            asset_id=asset_id,
            media=media,
            media_url=media_url,
            active=active,
            title=title,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            description=description,
            album_type=album_type,
            album_type_id=album_type_id,
            sub_type=sub_type,
            public_read=public_read,
            public_write=public_write,
            public_delete=public_delete,
            public_add=public_add,
            latitude=latitude,
            longitude=longitude,
            location_description=location_description,
            visibility=visibility,
            cell_phone=cell_phone,
            street_address=street_address,
            street_address2=street_address2,
            city=city,
            state=state,
            postal_code=postal_code,
            full_address=full_address,
            anonymous=anonymous,
            meta_data=meta_data,
            category_ids=category_ids,
            category_filter_ids=category_filter_ids,
            audience_ids=audience_ids,
            audience_ids_to_add=audience_ids_to_add,
            audience_ids_to_remove=audience_ids_to_remove,
            include_all_app_users_as_members=include_all_app_users_as_members,
            include_audiences_as_members=include_audiences_as_members,
            audience_operator=audience_operator,
            linked_object_type=linked_object_type,
            linked_object_id=linked_object_id,
            index_now=index_now,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AlbumResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_album_collection_serialize(
        self,
        version,
        album_id,
        device_id,
        account_id,
        assets_to_add,
        assets_to_remove,
        asset_id,
        media,
        media_url,
        active,
        title,
        start_date,
        end_date,
        tags,
        description,
        album_type,
        album_type_id,
        sub_type,
        public_read,
        public_write,
        public_delete,
        public_add,
        latitude,
        longitude,
        location_description,
        visibility,
        cell_phone,
        street_address,
        street_address2,
        city,
        state,
        postal_code,
        full_address,
        anonymous,
        meta_data,
        category_ids,
        category_filter_ids,
        audience_ids,
        audience_ids_to_add,
        audience_ids_to_remove,
        include_all_app_users_as_members,
        include_audiences_as_members,
        audience_operator,
        linked_object_type,
        linked_object_id,
        index_now,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_id is not None:
            
            _query_params.append(('albumId', album_id))
            
        if assets_to_add is not None:
            
            _query_params.append(('assetsToAdd', assets_to_add))
            
        if assets_to_remove is not None:
            
            _query_params.append(('assetsToRemove', assets_to_remove))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if media is not None:
            
            _query_params.append(('media', media))
            
        if media_url is not None:
            
            _query_params.append(('mediaURL', media_url))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if album_type is not None:
            
            _query_params.append(('albumType', album_type))
            
        if album_type_id is not None:
            
            _query_params.append(('albumTypeId', album_type_id))
            
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        if public_read is not None:
            
            _query_params.append(('publicRead', public_read))
            
        if public_write is not None:
            
            _query_params.append(('publicWrite', public_write))
            
        if public_delete is not None:
            
            _query_params.append(('publicDelete', public_delete))
            
        if public_add is not None:
            
            _query_params.append(('publicAdd', public_add))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if cell_phone is not None:
            
            _query_params.append(('cellPhone', cell_phone))
            
        if street_address is not None:
            
            _query_params.append(('streetAddress', street_address))
            
        if street_address2 is not None:
            
            _query_params.append(('streetAddress2', street_address2))
            
        if city is not None:
            
            _query_params.append(('city', city))
            
        if state is not None:
            
            _query_params.append(('state', state))
            
        if postal_code is not None:
            
            _query_params.append(('postalCode', postal_code))
            
        if full_address is not None:
            
            _query_params.append(('fullAddress', full_address))
            
        if anonymous is not None:
            
            _query_params.append(('anonymous', anonymous))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if category_filter_ids is not None:
            
            _query_params.append(('categoryFilterIds', category_filter_ids))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if audience_ids_to_add is not None:
            
            _query_params.append(('audienceIdsToAdd', audience_ids_to_add))
            
        if audience_ids_to_remove is not None:
            
            _query_params.append(('audienceIdsToRemove', audience_ids_to_remove))
            
        if include_all_app_users_as_members is not None:
            
            _query_params.append(('includeAllAppUsersAsMembers', include_all_app_users_as_members))
            
        if include_audiences_as_members is not None:
            
            _query_params.append(('includeAudiencesAsMembers', include_audiences_as_members))
            
        if audience_operator is not None:
            
            _query_params.append(('audienceOperator', audience_operator))
            
        if linked_object_type is not None:
            
            _query_params.append(('linkedObjectType', linked_object_type))
            
        if linked_object_id is not None:
            
            _query_params.append(('linkedObjectId', linked_object_id))
            
        if index_now is not None:
            
            _query_params.append(('indexNow', index_now))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/album/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


