# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.note_response import NoteResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class NoteApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def batch_operation(
        self,
        notable_id: Annotated[StrictInt, Field(description="The id of the notable object the batch operation will affect")],
        notable_type: Annotated[StrictStr, Field(description="The notable object type (for example ALBUM, ASSET, OFFER, etc.)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        batch_operation: Annotated[Optional[StrictStr], Field(description="The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Batch Note Operation

        Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 

        :param notable_id: The id of the notable object the batch operation will affect (required)
        :type notable_id: int
        :param notable_type: The notable object type (for example ALBUM, ASSET, OFFER, etc.) (required)
        :type notable_type: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param batch_operation: The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
        :type batch_operation: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_operation_serialize(
            notable_id=notable_id,
            notable_type=notable_type,
            device_id=device_id,
            account_id=account_id,
            batch_operation=batch_operation,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def batch_operation_with_http_info(
        self,
        notable_id: Annotated[StrictInt, Field(description="The id of the notable object the batch operation will affect")],
        notable_type: Annotated[StrictStr, Field(description="The notable object type (for example ALBUM, ASSET, OFFER, etc.)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        batch_operation: Annotated[Optional[StrictStr], Field(description="The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Batch Note Operation

        Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 

        :param notable_id: The id of the notable object the batch operation will affect (required)
        :type notable_id: int
        :param notable_type: The notable object type (for example ALBUM, ASSET, OFFER, etc.) (required)
        :type notable_type: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param batch_operation: The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
        :type batch_operation: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_operation_serialize(
            notable_id=notable_id,
            notable_type=notable_type,
            device_id=device_id,
            account_id=account_id,
            batch_operation=batch_operation,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def batch_operation_without_preload_content(
        self,
        notable_id: Annotated[StrictInt, Field(description="The id of the notable object the batch operation will affect")],
        notable_type: Annotated[StrictStr, Field(description="The notable object type (for example ALBUM, ASSET, OFFER, etc.)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        batch_operation: Annotated[Optional[StrictStr], Field(description="The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Batch Note Operation

        Perform a batch operation on notes for a notable object (for example: DELETE_ALL_NOTES_IN_NOTABLE). 

        :param notable_id: The id of the notable object the batch operation will affect (required)
        :type notable_id: int
        :param notable_type: The notable object type (for example ALBUM, ASSET, OFFER, etc.) (required)
        :type notable_type: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param batch_operation: The batch operation to perform (e.g., DELETE_ALL_NOTES_IN_NOTABLE). Optional.
        :type batch_operation: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_operation_serialize(
            notable_id=notable_id,
            notable_type=notable_type,
            device_id=device_id,
            account_id=account_id,
            batch_operation=batch_operation,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _batch_operation_serialize(
        self,
        notable_id,
        notable_type,
        device_id,
        account_id,
        batch_operation,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if notable_id is not None:
            
            _query_params.append(('notableId', notable_id))
            
        if notable_type is not None:
            
            _query_params.append(('notableType', notable_type))
            
        if batch_operation is not None:
            
            _query_params.append(('batchOperation', batch_operation))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/note/batch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_note(
        self,
        comment: Annotated[StrictStr, Field(description="The message the user wishes to leave a comment on")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        notable_type: Annotated[Optional[StrictStr], Field(description="The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}")] = None,
        notable_id: Annotated[Optional[StrictInt], Field(description="The id of the notable object")] = None,
        note_type: Annotated[Optional[StrictStr], Field(description="The custom string defined by the client (used for differentiating various note types)")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="A comma separated list of asset IDs to add with the note")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object (for sending group notifications)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        receiver_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of additional account IDs that will receive the note notifications")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="whether to return the full response or not")] = None,
        initialize_asset: Annotated[Optional[StrictBool], Field(description="Check true if need to initialize an asset and assign to current note")] = None,
        asset_return_nulls: Annotated[Optional[StrictBool], Field(description="Return null fields for asset response when creating an asset")] = None,
        asset_album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        asset_collection_id: Annotated[Optional[StrictInt], Field(description="the collection ID that the asset is associated with")] = None,
        asset_add_to_default_album: Annotated[Optional[StrictStr], Field(description="the default album to add the asset to")] = None,
        asset_add_to_media_library: Annotated[Optional[StrictBool], Field(description="the media library to add the asset to")] = None,
        asset_version_code: Annotated[Optional[StrictInt], Field(description="the version code of the asset")] = None,
        asset_version_name: Annotated[Optional[StrictStr], Field(description="the version name of the asset")] = None,
        asset_meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the asset")] = None,
        asset_caption: Annotated[Optional[StrictStr], Field(description="the caption of the asset")] = None,
        asset_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the media of the asset")] = None,
        asset_media_url: Annotated[Optional[StrictStr], Field(description="the media URL of the asset")] = None,
        asset_media_string: Annotated[Optional[StrictStr], Field(description="the media string of the asset")] = None,
        asset_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the media string file name of the asset")] = None,
        asset_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the media string content type of the asset")] = None,
        asset_attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the attached media of the asset")] = None,
        asset_attached_media_url: Annotated[Optional[StrictStr], Field(description="the attached media URL of the asset")] = None,
        asset_attached_media_string: Annotated[Optional[StrictStr], Field(description="the attached media string of the asset")] = None,
        asset_attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the attached media string file name of the asset")] = None,
        asset_attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the attached media string content type of the asset")] = None,
        asset_location_description: Annotated[Optional[StrictStr], Field(description="the location description for the asset")] = None,
        asset_app: Annotated[Optional[StrictStr], Field(description="the application for the asset")] = None,
        asset_search_tags: Annotated[Optional[StrictStr], Field(description="the search tags used for the asset")] = None,
        asset_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the asset")] = None,
        asset_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the asset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NoteResponse:
        """Create Note

        This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.

        :param comment: The message the user wishes to leave a comment on (required)
        :type comment: str
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param notable_type: The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        :type notable_type: str
        :param notable_id: The id of the notable object
        :type notable_id: int
        :param note_type: The custom string defined by the client (used for differentiating various note types)
        :type note_type: str
        :param asset_ids: A comma separated list of asset IDs to add with the note
        :type asset_ids: str
        :param tags: search tags
        :type tags: str
        :param permissionable_type: This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (for sending group notifications)
        :type permissionable_id: int
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param receiver_account_ids: Comma separated list of additional account IDs that will receive the note notifications
        :type receiver_account_ids: str
        :param return_full_response: whether to return the full response or not
        :type return_full_response: bool
        :param initialize_asset: Check true if need to initialize an asset and assign to current note
        :type initialize_asset: bool
        :param asset_return_nulls: Return null fields for asset response when creating an asset
        :type asset_return_nulls: bool
        :param asset_album_id: the album the asset will be added to (optional)
        :type asset_album_id: int
        :param asset_collection_id: the collection ID that the asset is associated with
        :type asset_collection_id: int
        :param asset_add_to_default_album: the default album to add the asset to
        :type asset_add_to_default_album: str
        :param asset_add_to_media_library: the media library to add the asset to
        :type asset_add_to_media_library: bool
        :param asset_version_code: the version code of the asset
        :type asset_version_code: int
        :param asset_version_name: the version name of the asset
        :type asset_version_name: str
        :param asset_meta_data: the meta data of the asset
        :type asset_meta_data: str
        :param asset_caption: the caption of the asset
        :type asset_caption: str
        :param asset_media: the media of the asset
        :type asset_media: bytearray
        :param asset_media_url: the media URL of the asset
        :type asset_media_url: str
        :param asset_media_string: the media string of the asset
        :type asset_media_string: str
        :param asset_media_string_file_name: the media string file name of the asset
        :type asset_media_string_file_name: str
        :param asset_media_string_content_type: the media string content type of the asset
        :type asset_media_string_content_type: str
        :param asset_attached_media: the attached media of the asset
        :type asset_attached_media: bytearray
        :param asset_attached_media_url: the attached media URL of the asset
        :type asset_attached_media_url: str
        :param asset_attached_media_string: the attached media string of the asset
        :type asset_attached_media_string: str
        :param asset_attached_media_string_file_name: the attached media string file name of the asset
        :type asset_attached_media_string_file_name: str
        :param asset_attached_media_string_content_type: the attached media string content type of the asset
        :type asset_attached_media_string_content_type: str
        :param asset_location_description: the location description for the asset
        :type asset_location_description: str
        :param asset_app: the application for the asset
        :type asset_app: str
        :param asset_search_tags: the search tags used for the asset
        :type asset_search_tags: str
        :param asset_latitude: the latitude of the asset
        :type asset_latitude: float
        :param asset_longitude: the longitude of the asset
        :type asset_longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_note_serialize(
            comment=comment,
            device_id=device_id,
            account_id=account_id,
            notable_type=notable_type,
            notable_id=notable_id,
            note_type=note_type,
            asset_ids=asset_ids,
            tags=tags,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            app_key=app_key,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            receiver_account_ids=receiver_account_ids,
            return_full_response=return_full_response,
            initialize_asset=initialize_asset,
            asset_return_nulls=asset_return_nulls,
            asset_album_id=asset_album_id,
            asset_collection_id=asset_collection_id,
            asset_add_to_default_album=asset_add_to_default_album,
            asset_add_to_media_library=asset_add_to_media_library,
            asset_version_code=asset_version_code,
            asset_version_name=asset_version_name,
            asset_meta_data=asset_meta_data,
            asset_caption=asset_caption,
            asset_media=asset_media,
            asset_media_url=asset_media_url,
            asset_media_string=asset_media_string,
            asset_media_string_file_name=asset_media_string_file_name,
            asset_media_string_content_type=asset_media_string_content_type,
            asset_attached_media=asset_attached_media,
            asset_attached_media_url=asset_attached_media_url,
            asset_attached_media_string=asset_attached_media_string,
            asset_attached_media_string_file_name=asset_attached_media_string_file_name,
            asset_attached_media_string_content_type=asset_attached_media_string_content_type,
            asset_location_description=asset_location_description,
            asset_app=asset_app,
            asset_search_tags=asset_search_tags,
            asset_latitude=asset_latitude,
            asset_longitude=asset_longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_note_with_http_info(
        self,
        comment: Annotated[StrictStr, Field(description="The message the user wishes to leave a comment on")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        notable_type: Annotated[Optional[StrictStr], Field(description="The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}")] = None,
        notable_id: Annotated[Optional[StrictInt], Field(description="The id of the notable object")] = None,
        note_type: Annotated[Optional[StrictStr], Field(description="The custom string defined by the client (used for differentiating various note types)")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="A comma separated list of asset IDs to add with the note")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object (for sending group notifications)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        receiver_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of additional account IDs that will receive the note notifications")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="whether to return the full response or not")] = None,
        initialize_asset: Annotated[Optional[StrictBool], Field(description="Check true if need to initialize an asset and assign to current note")] = None,
        asset_return_nulls: Annotated[Optional[StrictBool], Field(description="Return null fields for asset response when creating an asset")] = None,
        asset_album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        asset_collection_id: Annotated[Optional[StrictInt], Field(description="the collection ID that the asset is associated with")] = None,
        asset_add_to_default_album: Annotated[Optional[StrictStr], Field(description="the default album to add the asset to")] = None,
        asset_add_to_media_library: Annotated[Optional[StrictBool], Field(description="the media library to add the asset to")] = None,
        asset_version_code: Annotated[Optional[StrictInt], Field(description="the version code of the asset")] = None,
        asset_version_name: Annotated[Optional[StrictStr], Field(description="the version name of the asset")] = None,
        asset_meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the asset")] = None,
        asset_caption: Annotated[Optional[StrictStr], Field(description="the caption of the asset")] = None,
        asset_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the media of the asset")] = None,
        asset_media_url: Annotated[Optional[StrictStr], Field(description="the media URL of the asset")] = None,
        asset_media_string: Annotated[Optional[StrictStr], Field(description="the media string of the asset")] = None,
        asset_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the media string file name of the asset")] = None,
        asset_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the media string content type of the asset")] = None,
        asset_attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the attached media of the asset")] = None,
        asset_attached_media_url: Annotated[Optional[StrictStr], Field(description="the attached media URL of the asset")] = None,
        asset_attached_media_string: Annotated[Optional[StrictStr], Field(description="the attached media string of the asset")] = None,
        asset_attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the attached media string file name of the asset")] = None,
        asset_attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the attached media string content type of the asset")] = None,
        asset_location_description: Annotated[Optional[StrictStr], Field(description="the location description for the asset")] = None,
        asset_app: Annotated[Optional[StrictStr], Field(description="the application for the asset")] = None,
        asset_search_tags: Annotated[Optional[StrictStr], Field(description="the search tags used for the asset")] = None,
        asset_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the asset")] = None,
        asset_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the asset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NoteResponse]:
        """Create Note

        This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.

        :param comment: The message the user wishes to leave a comment on (required)
        :type comment: str
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param notable_type: The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        :type notable_type: str
        :param notable_id: The id of the notable object
        :type notable_id: int
        :param note_type: The custom string defined by the client (used for differentiating various note types)
        :type note_type: str
        :param asset_ids: A comma separated list of asset IDs to add with the note
        :type asset_ids: str
        :param tags: search tags
        :type tags: str
        :param permissionable_type: This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (for sending group notifications)
        :type permissionable_id: int
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param receiver_account_ids: Comma separated list of additional account IDs that will receive the note notifications
        :type receiver_account_ids: str
        :param return_full_response: whether to return the full response or not
        :type return_full_response: bool
        :param initialize_asset: Check true if need to initialize an asset and assign to current note
        :type initialize_asset: bool
        :param asset_return_nulls: Return null fields for asset response when creating an asset
        :type asset_return_nulls: bool
        :param asset_album_id: the album the asset will be added to (optional)
        :type asset_album_id: int
        :param asset_collection_id: the collection ID that the asset is associated with
        :type asset_collection_id: int
        :param asset_add_to_default_album: the default album to add the asset to
        :type asset_add_to_default_album: str
        :param asset_add_to_media_library: the media library to add the asset to
        :type asset_add_to_media_library: bool
        :param asset_version_code: the version code of the asset
        :type asset_version_code: int
        :param asset_version_name: the version name of the asset
        :type asset_version_name: str
        :param asset_meta_data: the meta data of the asset
        :type asset_meta_data: str
        :param asset_caption: the caption of the asset
        :type asset_caption: str
        :param asset_media: the media of the asset
        :type asset_media: bytearray
        :param asset_media_url: the media URL of the asset
        :type asset_media_url: str
        :param asset_media_string: the media string of the asset
        :type asset_media_string: str
        :param asset_media_string_file_name: the media string file name of the asset
        :type asset_media_string_file_name: str
        :param asset_media_string_content_type: the media string content type of the asset
        :type asset_media_string_content_type: str
        :param asset_attached_media: the attached media of the asset
        :type asset_attached_media: bytearray
        :param asset_attached_media_url: the attached media URL of the asset
        :type asset_attached_media_url: str
        :param asset_attached_media_string: the attached media string of the asset
        :type asset_attached_media_string: str
        :param asset_attached_media_string_file_name: the attached media string file name of the asset
        :type asset_attached_media_string_file_name: str
        :param asset_attached_media_string_content_type: the attached media string content type of the asset
        :type asset_attached_media_string_content_type: str
        :param asset_location_description: the location description for the asset
        :type asset_location_description: str
        :param asset_app: the application for the asset
        :type asset_app: str
        :param asset_search_tags: the search tags used for the asset
        :type asset_search_tags: str
        :param asset_latitude: the latitude of the asset
        :type asset_latitude: float
        :param asset_longitude: the longitude of the asset
        :type asset_longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_note_serialize(
            comment=comment,
            device_id=device_id,
            account_id=account_id,
            notable_type=notable_type,
            notable_id=notable_id,
            note_type=note_type,
            asset_ids=asset_ids,
            tags=tags,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            app_key=app_key,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            receiver_account_ids=receiver_account_ids,
            return_full_response=return_full_response,
            initialize_asset=initialize_asset,
            asset_return_nulls=asset_return_nulls,
            asset_album_id=asset_album_id,
            asset_collection_id=asset_collection_id,
            asset_add_to_default_album=asset_add_to_default_album,
            asset_add_to_media_library=asset_add_to_media_library,
            asset_version_code=asset_version_code,
            asset_version_name=asset_version_name,
            asset_meta_data=asset_meta_data,
            asset_caption=asset_caption,
            asset_media=asset_media,
            asset_media_url=asset_media_url,
            asset_media_string=asset_media_string,
            asset_media_string_file_name=asset_media_string_file_name,
            asset_media_string_content_type=asset_media_string_content_type,
            asset_attached_media=asset_attached_media,
            asset_attached_media_url=asset_attached_media_url,
            asset_attached_media_string=asset_attached_media_string,
            asset_attached_media_string_file_name=asset_attached_media_string_file_name,
            asset_attached_media_string_content_type=asset_attached_media_string_content_type,
            asset_location_description=asset_location_description,
            asset_app=asset_app,
            asset_search_tags=asset_search_tags,
            asset_latitude=asset_latitude,
            asset_longitude=asset_longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_note_without_preload_content(
        self,
        comment: Annotated[StrictStr, Field(description="The message the user wishes to leave a comment on")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        notable_type: Annotated[Optional[StrictStr], Field(description="The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}")] = None,
        notable_id: Annotated[Optional[StrictInt], Field(description="The id of the notable object")] = None,
        note_type: Annotated[Optional[StrictStr], Field(description="The custom string defined by the client (used for differentiating various note types)")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="A comma separated list of asset IDs to add with the note")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object (for sending group notifications)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        receiver_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of additional account IDs that will receive the note notifications")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="whether to return the full response or not")] = None,
        initialize_asset: Annotated[Optional[StrictBool], Field(description="Check true if need to initialize an asset and assign to current note")] = None,
        asset_return_nulls: Annotated[Optional[StrictBool], Field(description="Return null fields for asset response when creating an asset")] = None,
        asset_album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        asset_collection_id: Annotated[Optional[StrictInt], Field(description="the collection ID that the asset is associated with")] = None,
        asset_add_to_default_album: Annotated[Optional[StrictStr], Field(description="the default album to add the asset to")] = None,
        asset_add_to_media_library: Annotated[Optional[StrictBool], Field(description="the media library to add the asset to")] = None,
        asset_version_code: Annotated[Optional[StrictInt], Field(description="the version code of the asset")] = None,
        asset_version_name: Annotated[Optional[StrictStr], Field(description="the version name of the asset")] = None,
        asset_meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the asset")] = None,
        asset_caption: Annotated[Optional[StrictStr], Field(description="the caption of the asset")] = None,
        asset_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the media of the asset")] = None,
        asset_media_url: Annotated[Optional[StrictStr], Field(description="the media URL of the asset")] = None,
        asset_media_string: Annotated[Optional[StrictStr], Field(description="the media string of the asset")] = None,
        asset_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the media string file name of the asset")] = None,
        asset_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the media string content type of the asset")] = None,
        asset_attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the attached media of the asset")] = None,
        asset_attached_media_url: Annotated[Optional[StrictStr], Field(description="the attached media URL of the asset")] = None,
        asset_attached_media_string: Annotated[Optional[StrictStr], Field(description="the attached media string of the asset")] = None,
        asset_attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the attached media string file name of the asset")] = None,
        asset_attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the attached media string content type of the asset")] = None,
        asset_location_description: Annotated[Optional[StrictStr], Field(description="the location description for the asset")] = None,
        asset_app: Annotated[Optional[StrictStr], Field(description="the application for the asset")] = None,
        asset_search_tags: Annotated[Optional[StrictStr], Field(description="the search tags used for the asset")] = None,
        asset_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the asset")] = None,
        asset_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the asset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Note

        This is used to leave a comment (note) on a notable object (i.e. albums, album contests, assets, game levels, offers, offer locations, retailers, retailer locations, and theme descriptors). Leaving a comment on a notable object will be visiable to everyone who has access to view the object.

        :param comment: The message the user wishes to leave a comment on (required)
        :type comment: str
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param notable_type: The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        :type notable_type: str
        :param notable_id: The id of the notable object
        :type notable_id: int
        :param note_type: The custom string defined by the client (used for differentiating various note types)
        :type note_type: str
        :param asset_ids: A comma separated list of asset IDs to add with the note
        :type asset_ids: str
        :param tags: search tags
        :type tags: str
        :param permissionable_type: This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (for sending group notifications)
        :type permissionable_id: int
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param receiver_account_ids: Comma separated list of additional account IDs that will receive the note notifications
        :type receiver_account_ids: str
        :param return_full_response: whether to return the full response or not
        :type return_full_response: bool
        :param initialize_asset: Check true if need to initialize an asset and assign to current note
        :type initialize_asset: bool
        :param asset_return_nulls: Return null fields for asset response when creating an asset
        :type asset_return_nulls: bool
        :param asset_album_id: the album the asset will be added to (optional)
        :type asset_album_id: int
        :param asset_collection_id: the collection ID that the asset is associated with
        :type asset_collection_id: int
        :param asset_add_to_default_album: the default album to add the asset to
        :type asset_add_to_default_album: str
        :param asset_add_to_media_library: the media library to add the asset to
        :type asset_add_to_media_library: bool
        :param asset_version_code: the version code of the asset
        :type asset_version_code: int
        :param asset_version_name: the version name of the asset
        :type asset_version_name: str
        :param asset_meta_data: the meta data of the asset
        :type asset_meta_data: str
        :param asset_caption: the caption of the asset
        :type asset_caption: str
        :param asset_media: the media of the asset
        :type asset_media: bytearray
        :param asset_media_url: the media URL of the asset
        :type asset_media_url: str
        :param asset_media_string: the media string of the asset
        :type asset_media_string: str
        :param asset_media_string_file_name: the media string file name of the asset
        :type asset_media_string_file_name: str
        :param asset_media_string_content_type: the media string content type of the asset
        :type asset_media_string_content_type: str
        :param asset_attached_media: the attached media of the asset
        :type asset_attached_media: bytearray
        :param asset_attached_media_url: the attached media URL of the asset
        :type asset_attached_media_url: str
        :param asset_attached_media_string: the attached media string of the asset
        :type asset_attached_media_string: str
        :param asset_attached_media_string_file_name: the attached media string file name of the asset
        :type asset_attached_media_string_file_name: str
        :param asset_attached_media_string_content_type: the attached media string content type of the asset
        :type asset_attached_media_string_content_type: str
        :param asset_location_description: the location description for the asset
        :type asset_location_description: str
        :param asset_app: the application for the asset
        :type asset_app: str
        :param asset_search_tags: the search tags used for the asset
        :type asset_search_tags: str
        :param asset_latitude: the latitude of the asset
        :type asset_latitude: float
        :param asset_longitude: the longitude of the asset
        :type asset_longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_note_serialize(
            comment=comment,
            device_id=device_id,
            account_id=account_id,
            notable_type=notable_type,
            notable_id=notable_id,
            note_type=note_type,
            asset_ids=asset_ids,
            tags=tags,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            app_key=app_key,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            receiver_account_ids=receiver_account_ids,
            return_full_response=return_full_response,
            initialize_asset=initialize_asset,
            asset_return_nulls=asset_return_nulls,
            asset_album_id=asset_album_id,
            asset_collection_id=asset_collection_id,
            asset_add_to_default_album=asset_add_to_default_album,
            asset_add_to_media_library=asset_add_to_media_library,
            asset_version_code=asset_version_code,
            asset_version_name=asset_version_name,
            asset_meta_data=asset_meta_data,
            asset_caption=asset_caption,
            asset_media=asset_media,
            asset_media_url=asset_media_url,
            asset_media_string=asset_media_string,
            asset_media_string_file_name=asset_media_string_file_name,
            asset_media_string_content_type=asset_media_string_content_type,
            asset_attached_media=asset_attached_media,
            asset_attached_media_url=asset_attached_media_url,
            asset_attached_media_string=asset_attached_media_string,
            asset_attached_media_string_file_name=asset_attached_media_string_file_name,
            asset_attached_media_string_content_type=asset_attached_media_string_content_type,
            asset_location_description=asset_location_description,
            asset_app=asset_app,
            asset_search_tags=asset_search_tags,
            asset_latitude=asset_latitude,
            asset_longitude=asset_longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_note_serialize(
        self,
        comment,
        device_id,
        account_id,
        notable_type,
        notable_id,
        note_type,
        asset_ids,
        tags,
        permissionable_type,
        permissionable_id,
        app_key,
        location_description,
        latitude,
        longitude,
        meta_data,
        receiver_account_ids,
        return_full_response,
        initialize_asset,
        asset_return_nulls,
        asset_album_id,
        asset_collection_id,
        asset_add_to_default_album,
        asset_add_to_media_library,
        asset_version_code,
        asset_version_name,
        asset_meta_data,
        asset_caption,
        asset_media,
        asset_media_url,
        asset_media_string,
        asset_media_string_file_name,
        asset_media_string_content_type,
        asset_attached_media,
        asset_attached_media_url,
        asset_attached_media_string,
        asset_attached_media_string_file_name,
        asset_attached_media_string_content_type,
        asset_location_description,
        asset_app,
        asset_search_tags,
        asset_latitude,
        asset_longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if notable_type is not None:
            
            _query_params.append(('notableType', notable_type))
            
        if notable_id is not None:
            
            _query_params.append(('notableId', notable_id))
            
        if comment is not None:
            
            _query_params.append(('comment', comment))
            
        if note_type is not None:
            
            _query_params.append(('noteType', note_type))
            
        if asset_ids is not None:
            
            _query_params.append(('assetIds', asset_ids))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if receiver_account_ids is not None:
            
            _query_params.append(('receiverAccountIds', receiver_account_ids))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        if initialize_asset is not None:
            
            _query_params.append(('initializeAsset', initialize_asset))
            
        if asset_return_nulls is not None:
            
            _query_params.append(('assetReturnNulls', asset_return_nulls))
            
        if asset_album_id is not None:
            
            _query_params.append(('assetAlbumId', asset_album_id))
            
        if asset_collection_id is not None:
            
            _query_params.append(('assetCollectionId', asset_collection_id))
            
        if asset_add_to_default_album is not None:
            
            _query_params.append(('assetAddToDefaultAlbum', asset_add_to_default_album))
            
        if asset_add_to_media_library is not None:
            
            _query_params.append(('assetAddToMediaLibrary', asset_add_to_media_library))
            
        if asset_version_code is not None:
            
            _query_params.append(('assetVersionCode', asset_version_code))
            
        if asset_version_name is not None:
            
            _query_params.append(('assetVersionName', asset_version_name))
            
        if asset_meta_data is not None:
            
            _query_params.append(('assetMetaData', asset_meta_data))
            
        if asset_caption is not None:
            
            _query_params.append(('assetCaption', asset_caption))
            
        if asset_media is not None:
            
            _query_params.append(('assetMedia', asset_media))
            
        if asset_media_url is not None:
            
            _query_params.append(('assetMediaUrl', asset_media_url))
            
        if asset_media_string is not None:
            
            _query_params.append(('assetMediaString', asset_media_string))
            
        if asset_media_string_file_name is not None:
            
            _query_params.append(('assetMediaStringFileName', asset_media_string_file_name))
            
        if asset_media_string_content_type is not None:
            
            _query_params.append(('assetMediaStringContentType', asset_media_string_content_type))
            
        if asset_attached_media is not None:
            
            _query_params.append(('assetAttachedMedia', asset_attached_media))
            
        if asset_attached_media_url is not None:
            
            _query_params.append(('assetAttachedMediaUrl', asset_attached_media_url))
            
        if asset_attached_media_string is not None:
            
            _query_params.append(('assetAttachedMediaString', asset_attached_media_string))
            
        if asset_attached_media_string_file_name is not None:
            
            _query_params.append(('assetAttachedMediaStringFileName', asset_attached_media_string_file_name))
            
        if asset_attached_media_string_content_type is not None:
            
            _query_params.append(('assetAttachedMediaStringContentType', asset_attached_media_string_content_type))
            
        if asset_location_description is not None:
            
            _query_params.append(('assetLocationDescription', asset_location_description))
            
        if asset_app is not None:
            
            _query_params.append(('assetApp', asset_app))
            
        if asset_search_tags is not None:
            
            _query_params.append(('assetSearchTags', asset_search_tags))
            
        if asset_latitude is not None:
            
            _query_params.append(('assetLatitude', asset_latitude))
            
        if asset_longitude is not None:
            
            _query_params.append(('assetLongitude', asset_longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/note/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_note(
        self,
        note_id: Annotated[StrictInt, Field(description="The ID of the note to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Note

        Sets a comment (note) as deleted.

        :param note_id: The ID of the note to delete (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_note_with_http_info(
        self,
        note_id: Annotated[StrictInt, Field(description="The ID of the note to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Note

        Sets a comment (note) as deleted.

        :param note_id: The ID of the note to delete (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_note_without_preload_content(
        self,
        note_id: Annotated[StrictInt, Field(description="The ID of the note to delete")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Note

        Sets a comment (note) as deleted.

        :param note_id: The ID of the note to delete (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_note_serialize(
        self,
        note_id,
        device_id,
        account_id,
        latitude,
        longitude,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if note_id is not None:
            
            _query_params.append(('noteId', note_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/note/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_note(
        self,
        note_id: Annotated[StrictInt, Field(description="the id of the note to get")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return the NoteFullResponse for the item")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Get Note

        Get for a note based on its Id.

        :param note_id: the id of the note to get (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param return_full_response: Determines whether to return the NoteFullResponse for the item
        :type return_full_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            return_full_response=return_full_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_note_with_http_info(
        self,
        note_id: Annotated[StrictInt, Field(description="the id of the note to get")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return the NoteFullResponse for the item")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Get Note

        Get for a note based on its Id.

        :param note_id: the id of the note to get (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param return_full_response: Determines whether to return the NoteFullResponse for the item
        :type return_full_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            return_full_response=return_full_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_note_without_preload_content(
        self,
        note_id: Annotated[StrictInt, Field(description="the id of the note to get")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return the NoteFullResponse for the item")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Note

        Get for a note based on its Id.

        :param note_id: the id of the note to get (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param return_full_response: Determines whether to return the NoteFullResponse for the item
        :type return_full_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            return_full_response=return_full_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_note_serialize(
        self,
        note_id,
        device_id,
        account_id,
        return_full_response,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        if note_id is not None:
            
            _query_params.append(('noteId', note_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/note/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_notes(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        notable_type: Annotated[Optional[StrictStr], Field(description="The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}")] = None,
        notable_id: Annotated[Optional[StrictInt], Field(description="The id of the notable object")] = None,
        note_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of noteType strings to filter results with")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold")] = None,
        flags_exceed_threshold: Annotated[Optional[StrictBool], Field(description="return items that has flagCount >= flagThreshold, which are hidden by default")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="include inactive in the result")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return the NoteFullResponse for each search item")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[NoteResponse]:
        """Search Notes

        Search for notes on a notable object.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param notable_type: The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        :type notable_type: str
        :param notable_id: The id of the notable object
        :type notable_id: int
        :param note_types: Comma separated list of noteType strings to filter results with
        :type note_types: str
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param flag_count_minimum: return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold
        :type flag_count_minimum: int
        :param flags_exceed_threshold: return items that has flagCount >= flagThreshold, which are hidden by default
        :type flags_exceed_threshold: bool
        :param include_inactive: include inactive in the result
        :type include_inactive: bool
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param return_full_response: Determines whether to return the NoteFullResponse for each search item
        :type return_full_response: bool
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_notes_serialize(
            device_id=device_id,
            account_id=account_id,
            notable_type=notable_type,
            notable_id=notable_id,
            note_types=note_types,
            app_key=app_key,
            keyword=keyword,
            flag_count_minimum=flag_count_minimum,
            flags_exceed_threshold=flags_exceed_threshold,
            include_inactive=include_inactive,
            sort_field=sort_field,
            descending=descending,
            return_full_response=return_full_response,
            updated_since=updated_since,
            updated_before=updated_before,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NoteResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_notes_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        notable_type: Annotated[Optional[StrictStr], Field(description="The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}")] = None,
        notable_id: Annotated[Optional[StrictInt], Field(description="The id of the notable object")] = None,
        note_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of noteType strings to filter results with")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold")] = None,
        flags_exceed_threshold: Annotated[Optional[StrictBool], Field(description="return items that has flagCount >= flagThreshold, which are hidden by default")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="include inactive in the result")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return the NoteFullResponse for each search item")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[NoteResponse]]:
        """Search Notes

        Search for notes on a notable object.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param notable_type: The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        :type notable_type: str
        :param notable_id: The id of the notable object
        :type notable_id: int
        :param note_types: Comma separated list of noteType strings to filter results with
        :type note_types: str
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param flag_count_minimum: return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold
        :type flag_count_minimum: int
        :param flags_exceed_threshold: return items that has flagCount >= flagThreshold, which are hidden by default
        :type flags_exceed_threshold: bool
        :param include_inactive: include inactive in the result
        :type include_inactive: bool
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param return_full_response: Determines whether to return the NoteFullResponse for each search item
        :type return_full_response: bool
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_notes_serialize(
            device_id=device_id,
            account_id=account_id,
            notable_type=notable_type,
            notable_id=notable_id,
            note_types=note_types,
            app_key=app_key,
            keyword=keyword,
            flag_count_minimum=flag_count_minimum,
            flags_exceed_threshold=flags_exceed_threshold,
            include_inactive=include_inactive,
            sort_field=sort_field,
            descending=descending,
            return_full_response=return_full_response,
            updated_since=updated_since,
            updated_before=updated_before,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NoteResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_notes_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        notable_type: Annotated[Optional[StrictStr], Field(description="The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}")] = None,
        notable_id: Annotated[Optional[StrictInt], Field(description="The id of the notable object")] = None,
        note_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of noteType strings to filter results with")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        flag_count_minimum: Annotated[Optional[StrictInt], Field(description="return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold")] = None,
        flags_exceed_threshold: Annotated[Optional[StrictBool], Field(description="return items that has flagCount >= flagThreshold, which are hidden by default")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="include inactive in the result")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return the NoteFullResponse for each search item")] = None,
        updated_since: Annotated[Optional[StrictInt], Field(description="return items that have been updated since this date (time-stamp in milliseconds)")] = None,
        updated_before: Annotated[Optional[StrictInt], Field(description="return items that have been updated before this date (time-stamp in milliseconds)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Notes

        Search for notes on a notable object.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param notable_type: The notable object type {ALBUM, ALBUM_CONTEST, ASSET, GAME_LEVEL, OFFER, OFFER_LOCATION, RETAILER, RETAILER_LOCATION, THEME_DESCRIPTOR}
        :type notable_type: str
        :param notable_id: The id of the notable object
        :type notable_id: int
        :param note_types: Comma separated list of noteType strings to filter results with
        :type note_types: str
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param flag_count_minimum: return items that has flagCount >= flagCountMinimum if this is set, return all items, even ones with flagCount >= flagThreshold
        :type flag_count_minimum: int
        :param flags_exceed_threshold: return items that has flagCount >= flagThreshold, which are hidden by default
        :type flags_exceed_threshold: bool
        :param include_inactive: include inactive in the result
        :type include_inactive: bool
        :param sort_field: The column to sort the search on
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param return_full_response: Determines whether to return the NoteFullResponse for each search item
        :type return_full_response: bool
        :param updated_since: return items that have been updated since this date (time-stamp in milliseconds)
        :type updated_since: int
        :param updated_before: return items that have been updated before this date (time-stamp in milliseconds)
        :type updated_before: int
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_notes_serialize(
            device_id=device_id,
            account_id=account_id,
            notable_type=notable_type,
            notable_id=notable_id,
            note_types=note_types,
            app_key=app_key,
            keyword=keyword,
            flag_count_minimum=flag_count_minimum,
            flags_exceed_threshold=flags_exceed_threshold,
            include_inactive=include_inactive,
            sort_field=sort_field,
            descending=descending,
            return_full_response=return_full_response,
            updated_since=updated_since,
            updated_before=updated_before,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[NoteResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_notes_serialize(
        self,
        device_id,
        account_id,
        notable_type,
        notable_id,
        note_types,
        app_key,
        keyword,
        flag_count_minimum,
        flags_exceed_threshold,
        include_inactive,
        sort_field,
        descending,
        return_full_response,
        updated_since,
        updated_before,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if notable_type is not None:
            
            _query_params.append(('notableType', notable_type))
            
        if notable_id is not None:
            
            _query_params.append(('notableId', notable_id))
            
        if note_types is not None:
            
            _query_params.append(('noteTypes', note_types))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if flag_count_minimum is not None:
            
            _query_params.append(('flagCountMinimum', flag_count_minimum))
            
        if flags_exceed_threshold is not None:
            
            _query_params.append(('flagsExceedThreshold', flags_exceed_threshold))
            
        if include_inactive is not None:
            
            _query_params.append(('includeInactive', include_inactive))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        if updated_since is not None:
            
            _query_params.append(('updatedSince', updated_since))
            
        if updated_before is not None:
            
            _query_params.append(('updatedBefore', updated_before))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/note/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_note(
        self,
        note_id: Annotated[StrictInt, Field(description="The id of the note, used when editing a comment")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="The message the user wishes to leave a comment on")] = None,
        note_type: Annotated[Optional[StrictStr], Field(description="The custom string defined by the client (used for differentiating on various note types)")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="A comma separated list of asset IDs to add with the note")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object (for sending group notifications)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="meta data to update with the note")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="whether to return the full response or not")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag for the note")] = None,
        update_asset: Annotated[Optional[StrictBool], Field(description="main flag for updating asset in note, must set to true if you want to update the note's asset")] = None,
        asset_return_nulls: Annotated[Optional[StrictBool], Field(description="Return null fields for asset response when updating an asset")] = None,
        asset_album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        asset_collection_id: Annotated[Optional[StrictInt], Field(description="the collection ID that the asset is associated with")] = None,
        asset_add_to_default_album: Annotated[Optional[StrictStr], Field(description="the default album to add the asset to")] = None,
        asset_add_to_media_library: Annotated[Optional[StrictBool], Field(description="the media library to add the asset to")] = None,
        asset_version_code: Annotated[Optional[StrictInt], Field(description="the version code of the asset")] = None,
        asset_version_name: Annotated[Optional[StrictStr], Field(description="the version name of the asset")] = None,
        asset_meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the asset")] = None,
        asset_caption: Annotated[Optional[StrictStr], Field(description="the caption of the asset")] = None,
        asset_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the media of the asset")] = None,
        asset_media_url: Annotated[Optional[StrictStr], Field(description="the media URL of the asset")] = None,
        asset_media_string: Annotated[Optional[StrictStr], Field(description="the media string of the asset")] = None,
        asset_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the media string file name of the asset")] = None,
        asset_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the media string content type of the asset")] = None,
        asset_attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the attached media of the asset")] = None,
        asset_attached_media_url: Annotated[Optional[StrictStr], Field(description="the attached media URL of the asset")] = None,
        asset_attached_media_string: Annotated[Optional[StrictStr], Field(description="the attached media string of the asset")] = None,
        asset_attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the attached media string file name of the asset")] = None,
        asset_attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the attached media string content type of the asset")] = None,
        asset_location_description: Annotated[Optional[StrictStr], Field(description="the location description for the asset")] = None,
        asset_app: Annotated[Optional[StrictStr], Field(description="the application for the asset")] = None,
        asset_search_tags: Annotated[Optional[StrictStr], Field(description="the search tags used for the asset")] = None,
        asset_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the asset")] = None,
        asset_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the asset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> NoteResponse:
        """Update Note

        Update an existing comment (note). Only the creator of the note have permission to update.

        :param note_id: The id of the note, used when editing a comment (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param comment: The message the user wishes to leave a comment on
        :type comment: str
        :param note_type: The custom string defined by the client (used for differentiating on various note types)
        :type note_type: str
        :param asset_ids: A comma separated list of asset IDs to add with the note
        :type asset_ids: str
        :param tags: search tags
        :type tags: str
        :param permissionable_type: This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (for sending group notifications)
        :type permissionable_id: int
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param meta_data: meta data to update with the note
        :type meta_data: str
        :param return_full_response: whether to return the full response or not
        :type return_full_response: bool
        :param active: Sets the active flag for the note
        :type active: bool
        :param update_asset: main flag for updating asset in note, must set to true if you want to update the note's asset
        :type update_asset: bool
        :param asset_return_nulls: Return null fields for asset response when updating an asset
        :type asset_return_nulls: bool
        :param asset_album_id: the album the asset will be added to (optional)
        :type asset_album_id: int
        :param asset_collection_id: the collection ID that the asset is associated with
        :type asset_collection_id: int
        :param asset_add_to_default_album: the default album to add the asset to
        :type asset_add_to_default_album: str
        :param asset_add_to_media_library: the media library to add the asset to
        :type asset_add_to_media_library: bool
        :param asset_version_code: the version code of the asset
        :type asset_version_code: int
        :param asset_version_name: the version name of the asset
        :type asset_version_name: str
        :param asset_meta_data: the meta data of the asset
        :type asset_meta_data: str
        :param asset_caption: the caption of the asset
        :type asset_caption: str
        :param asset_media: the media of the asset
        :type asset_media: bytearray
        :param asset_media_url: the media URL of the asset
        :type asset_media_url: str
        :param asset_media_string: the media string of the asset
        :type asset_media_string: str
        :param asset_media_string_file_name: the media string file name of the asset
        :type asset_media_string_file_name: str
        :param asset_media_string_content_type: the media string content type of the asset
        :type asset_media_string_content_type: str
        :param asset_attached_media: the attached media of the asset
        :type asset_attached_media: bytearray
        :param asset_attached_media_url: the attached media URL of the asset
        :type asset_attached_media_url: str
        :param asset_attached_media_string: the attached media string of the asset
        :type asset_attached_media_string: str
        :param asset_attached_media_string_file_name: the attached media string file name of the asset
        :type asset_attached_media_string_file_name: str
        :param asset_attached_media_string_content_type: the attached media string content type of the asset
        :type asset_attached_media_string_content_type: str
        :param asset_location_description: the location description for the asset
        :type asset_location_description: str
        :param asset_app: the application for the asset
        :type asset_app: str
        :param asset_search_tags: the search tags used for the asset
        :type asset_search_tags: str
        :param asset_latitude: the latitude of the asset
        :type asset_latitude: float
        :param asset_longitude: the longitude of the asset
        :type asset_longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            comment=comment,
            note_type=note_type,
            asset_ids=asset_ids,
            tags=tags,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            app_key=app_key,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            return_full_response=return_full_response,
            active=active,
            update_asset=update_asset,
            asset_return_nulls=asset_return_nulls,
            asset_album_id=asset_album_id,
            asset_collection_id=asset_collection_id,
            asset_add_to_default_album=asset_add_to_default_album,
            asset_add_to_media_library=asset_add_to_media_library,
            asset_version_code=asset_version_code,
            asset_version_name=asset_version_name,
            asset_meta_data=asset_meta_data,
            asset_caption=asset_caption,
            asset_media=asset_media,
            asset_media_url=asset_media_url,
            asset_media_string=asset_media_string,
            asset_media_string_file_name=asset_media_string_file_name,
            asset_media_string_content_type=asset_media_string_content_type,
            asset_attached_media=asset_attached_media,
            asset_attached_media_url=asset_attached_media_url,
            asset_attached_media_string=asset_attached_media_string,
            asset_attached_media_string_file_name=asset_attached_media_string_file_name,
            asset_attached_media_string_content_type=asset_attached_media_string_content_type,
            asset_location_description=asset_location_description,
            asset_app=asset_app,
            asset_search_tags=asset_search_tags,
            asset_latitude=asset_latitude,
            asset_longitude=asset_longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_note_with_http_info(
        self,
        note_id: Annotated[StrictInt, Field(description="The id of the note, used when editing a comment")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="The message the user wishes to leave a comment on")] = None,
        note_type: Annotated[Optional[StrictStr], Field(description="The custom string defined by the client (used for differentiating on various note types)")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="A comma separated list of asset IDs to add with the note")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object (for sending group notifications)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="meta data to update with the note")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="whether to return the full response or not")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag for the note")] = None,
        update_asset: Annotated[Optional[StrictBool], Field(description="main flag for updating asset in note, must set to true if you want to update the note's asset")] = None,
        asset_return_nulls: Annotated[Optional[StrictBool], Field(description="Return null fields for asset response when updating an asset")] = None,
        asset_album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        asset_collection_id: Annotated[Optional[StrictInt], Field(description="the collection ID that the asset is associated with")] = None,
        asset_add_to_default_album: Annotated[Optional[StrictStr], Field(description="the default album to add the asset to")] = None,
        asset_add_to_media_library: Annotated[Optional[StrictBool], Field(description="the media library to add the asset to")] = None,
        asset_version_code: Annotated[Optional[StrictInt], Field(description="the version code of the asset")] = None,
        asset_version_name: Annotated[Optional[StrictStr], Field(description="the version name of the asset")] = None,
        asset_meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the asset")] = None,
        asset_caption: Annotated[Optional[StrictStr], Field(description="the caption of the asset")] = None,
        asset_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the media of the asset")] = None,
        asset_media_url: Annotated[Optional[StrictStr], Field(description="the media URL of the asset")] = None,
        asset_media_string: Annotated[Optional[StrictStr], Field(description="the media string of the asset")] = None,
        asset_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the media string file name of the asset")] = None,
        asset_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the media string content type of the asset")] = None,
        asset_attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the attached media of the asset")] = None,
        asset_attached_media_url: Annotated[Optional[StrictStr], Field(description="the attached media URL of the asset")] = None,
        asset_attached_media_string: Annotated[Optional[StrictStr], Field(description="the attached media string of the asset")] = None,
        asset_attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the attached media string file name of the asset")] = None,
        asset_attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the attached media string content type of the asset")] = None,
        asset_location_description: Annotated[Optional[StrictStr], Field(description="the location description for the asset")] = None,
        asset_app: Annotated[Optional[StrictStr], Field(description="the application for the asset")] = None,
        asset_search_tags: Annotated[Optional[StrictStr], Field(description="the search tags used for the asset")] = None,
        asset_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the asset")] = None,
        asset_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the asset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[NoteResponse]:
        """Update Note

        Update an existing comment (note). Only the creator of the note have permission to update.

        :param note_id: The id of the note, used when editing a comment (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param comment: The message the user wishes to leave a comment on
        :type comment: str
        :param note_type: The custom string defined by the client (used for differentiating on various note types)
        :type note_type: str
        :param asset_ids: A comma separated list of asset IDs to add with the note
        :type asset_ids: str
        :param tags: search tags
        :type tags: str
        :param permissionable_type: This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (for sending group notifications)
        :type permissionable_id: int
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param meta_data: meta data to update with the note
        :type meta_data: str
        :param return_full_response: whether to return the full response or not
        :type return_full_response: bool
        :param active: Sets the active flag for the note
        :type active: bool
        :param update_asset: main flag for updating asset in note, must set to true if you want to update the note's asset
        :type update_asset: bool
        :param asset_return_nulls: Return null fields for asset response when updating an asset
        :type asset_return_nulls: bool
        :param asset_album_id: the album the asset will be added to (optional)
        :type asset_album_id: int
        :param asset_collection_id: the collection ID that the asset is associated with
        :type asset_collection_id: int
        :param asset_add_to_default_album: the default album to add the asset to
        :type asset_add_to_default_album: str
        :param asset_add_to_media_library: the media library to add the asset to
        :type asset_add_to_media_library: bool
        :param asset_version_code: the version code of the asset
        :type asset_version_code: int
        :param asset_version_name: the version name of the asset
        :type asset_version_name: str
        :param asset_meta_data: the meta data of the asset
        :type asset_meta_data: str
        :param asset_caption: the caption of the asset
        :type asset_caption: str
        :param asset_media: the media of the asset
        :type asset_media: bytearray
        :param asset_media_url: the media URL of the asset
        :type asset_media_url: str
        :param asset_media_string: the media string of the asset
        :type asset_media_string: str
        :param asset_media_string_file_name: the media string file name of the asset
        :type asset_media_string_file_name: str
        :param asset_media_string_content_type: the media string content type of the asset
        :type asset_media_string_content_type: str
        :param asset_attached_media: the attached media of the asset
        :type asset_attached_media: bytearray
        :param asset_attached_media_url: the attached media URL of the asset
        :type asset_attached_media_url: str
        :param asset_attached_media_string: the attached media string of the asset
        :type asset_attached_media_string: str
        :param asset_attached_media_string_file_name: the attached media string file name of the asset
        :type asset_attached_media_string_file_name: str
        :param asset_attached_media_string_content_type: the attached media string content type of the asset
        :type asset_attached_media_string_content_type: str
        :param asset_location_description: the location description for the asset
        :type asset_location_description: str
        :param asset_app: the application for the asset
        :type asset_app: str
        :param asset_search_tags: the search tags used for the asset
        :type asset_search_tags: str
        :param asset_latitude: the latitude of the asset
        :type asset_latitude: float
        :param asset_longitude: the longitude of the asset
        :type asset_longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            comment=comment,
            note_type=note_type,
            asset_ids=asset_ids,
            tags=tags,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            app_key=app_key,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            return_full_response=return_full_response,
            active=active,
            update_asset=update_asset,
            asset_return_nulls=asset_return_nulls,
            asset_album_id=asset_album_id,
            asset_collection_id=asset_collection_id,
            asset_add_to_default_album=asset_add_to_default_album,
            asset_add_to_media_library=asset_add_to_media_library,
            asset_version_code=asset_version_code,
            asset_version_name=asset_version_name,
            asset_meta_data=asset_meta_data,
            asset_caption=asset_caption,
            asset_media=asset_media,
            asset_media_url=asset_media_url,
            asset_media_string=asset_media_string,
            asset_media_string_file_name=asset_media_string_file_name,
            asset_media_string_content_type=asset_media_string_content_type,
            asset_attached_media=asset_attached_media,
            asset_attached_media_url=asset_attached_media_url,
            asset_attached_media_string=asset_attached_media_string,
            asset_attached_media_string_file_name=asset_attached_media_string_file_name,
            asset_attached_media_string_content_type=asset_attached_media_string_content_type,
            asset_location_description=asset_location_description,
            asset_app=asset_app,
            asset_search_tags=asset_search_tags,
            asset_latitude=asset_latitude,
            asset_longitude=asset_longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_note_without_preload_content(
        self,
        note_id: Annotated[StrictInt, Field(description="The id of the note, used when editing a comment")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique device identifier that made the request (either deviceId or accountId must be used)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The unique accountId that made the request (either deviceId or accountId must be used)")] = None,
        comment: Annotated[Optional[StrictStr], Field(description="The message the user wishes to leave a comment on")] = None,
        note_type: Annotated[Optional[StrictStr], Field(description="The custom string defined by the client (used for differentiating on various note types)")] = None,
        asset_ids: Annotated[Optional[StrictStr], Field(description="A comma separated list of asset IDs to add with the note")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="search tags")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object (for sending group notifications)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        location_description: Annotated[Optional[StrictStr], Field(description="The description of the location")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The current location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="meta data to update with the note")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="whether to return the full response or not")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag for the note")] = None,
        update_asset: Annotated[Optional[StrictBool], Field(description="main flag for updating asset in note, must set to true if you want to update the note's asset")] = None,
        asset_return_nulls: Annotated[Optional[StrictBool], Field(description="Return null fields for asset response when updating an asset")] = None,
        asset_album_id: Annotated[Optional[StrictInt], Field(description="the album the asset will be added to (optional)")] = None,
        asset_collection_id: Annotated[Optional[StrictInt], Field(description="the collection ID that the asset is associated with")] = None,
        asset_add_to_default_album: Annotated[Optional[StrictStr], Field(description="the default album to add the asset to")] = None,
        asset_add_to_media_library: Annotated[Optional[StrictBool], Field(description="the media library to add the asset to")] = None,
        asset_version_code: Annotated[Optional[StrictInt], Field(description="the version code of the asset")] = None,
        asset_version_name: Annotated[Optional[StrictStr], Field(description="the version name of the asset")] = None,
        asset_meta_data: Annotated[Optional[StrictStr], Field(description="the meta data of the asset")] = None,
        asset_caption: Annotated[Optional[StrictStr], Field(description="the caption of the asset")] = None,
        asset_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the media of the asset")] = None,
        asset_media_url: Annotated[Optional[StrictStr], Field(description="the media URL of the asset")] = None,
        asset_media_string: Annotated[Optional[StrictStr], Field(description="the media string of the asset")] = None,
        asset_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the media string file name of the asset")] = None,
        asset_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the media string content type of the asset")] = None,
        asset_attached_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="the attached media of the asset")] = None,
        asset_attached_media_url: Annotated[Optional[StrictStr], Field(description="the attached media URL of the asset")] = None,
        asset_attached_media_string: Annotated[Optional[StrictStr], Field(description="the attached media string of the asset")] = None,
        asset_attached_media_string_file_name: Annotated[Optional[StrictStr], Field(description="the attached media string file name of the asset")] = None,
        asset_attached_media_string_content_type: Annotated[Optional[StrictStr], Field(description="the attached media string content type of the asset")] = None,
        asset_location_description: Annotated[Optional[StrictStr], Field(description="the location description for the asset")] = None,
        asset_app: Annotated[Optional[StrictStr], Field(description="the application for the asset")] = None,
        asset_search_tags: Annotated[Optional[StrictStr], Field(description="the search tags used for the asset")] = None,
        asset_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the asset")] = None,
        asset_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the asset")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Note

        Update an existing comment (note). Only the creator of the note have permission to update.

        :param note_id: The id of the note, used when editing a comment (required)
        :type note_id: int
        :param device_id: The unique device identifier that made the request (either deviceId or accountId must be used)
        :type device_id: str
        :param account_id: The unique accountId that made the request (either deviceId or accountId must be used)
        :type account_id: int
        :param comment: The message the user wishes to leave a comment on
        :type comment: str
        :param note_type: The custom string defined by the client (used for differentiating on various note types)
        :type note_type: str
        :param asset_ids: A comma separated list of asset IDs to add with the note
        :type asset_ids: str
        :param tags: search tags
        :type tags: str
        :param permissionable_type: This is used for sending out group notifications. For example, when someone adds a note to an asset which is also a part of an album, everyone in the album will receive a notification. This is achieved by passing in the permissionable type (in this case \"album\"), and the permissionable id (the album id). Possible types: {ALBUM, ALBUM_CONTEST, GAME_LEVEL, THEME_DESCRIPTOR}
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (for sending group notifications)
        :type permissionable_id: int
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param location_description: The description of the location
        :type location_description: str
        :param latitude: The current location of the user
        :type latitude: float
        :param longitude: The current location of the user
        :type longitude: float
        :param meta_data: meta data to update with the note
        :type meta_data: str
        :param return_full_response: whether to return the full response or not
        :type return_full_response: bool
        :param active: Sets the active flag for the note
        :type active: bool
        :param update_asset: main flag for updating asset in note, must set to true if you want to update the note's asset
        :type update_asset: bool
        :param asset_return_nulls: Return null fields for asset response when updating an asset
        :type asset_return_nulls: bool
        :param asset_album_id: the album the asset will be added to (optional)
        :type asset_album_id: int
        :param asset_collection_id: the collection ID that the asset is associated with
        :type asset_collection_id: int
        :param asset_add_to_default_album: the default album to add the asset to
        :type asset_add_to_default_album: str
        :param asset_add_to_media_library: the media library to add the asset to
        :type asset_add_to_media_library: bool
        :param asset_version_code: the version code of the asset
        :type asset_version_code: int
        :param asset_version_name: the version name of the asset
        :type asset_version_name: str
        :param asset_meta_data: the meta data of the asset
        :type asset_meta_data: str
        :param asset_caption: the caption of the asset
        :type asset_caption: str
        :param asset_media: the media of the asset
        :type asset_media: bytearray
        :param asset_media_url: the media URL of the asset
        :type asset_media_url: str
        :param asset_media_string: the media string of the asset
        :type asset_media_string: str
        :param asset_media_string_file_name: the media string file name of the asset
        :type asset_media_string_file_name: str
        :param asset_media_string_content_type: the media string content type of the asset
        :type asset_media_string_content_type: str
        :param asset_attached_media: the attached media of the asset
        :type asset_attached_media: bytearray
        :param asset_attached_media_url: the attached media URL of the asset
        :type asset_attached_media_url: str
        :param asset_attached_media_string: the attached media string of the asset
        :type asset_attached_media_string: str
        :param asset_attached_media_string_file_name: the attached media string file name of the asset
        :type asset_attached_media_string_file_name: str
        :param asset_attached_media_string_content_type: the attached media string content type of the asset
        :type asset_attached_media_string_content_type: str
        :param asset_location_description: the location description for the asset
        :type asset_location_description: str
        :param asset_app: the application for the asset
        :type asset_app: str
        :param asset_search_tags: the search tags used for the asset
        :type asset_search_tags: str
        :param asset_latitude: the latitude of the asset
        :type asset_latitude: float
        :param asset_longitude: the longitude of the asset
        :type asset_longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_note_serialize(
            note_id=note_id,
            device_id=device_id,
            account_id=account_id,
            comment=comment,
            note_type=note_type,
            asset_ids=asset_ids,
            tags=tags,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            app_key=app_key,
            location_description=location_description,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            return_full_response=return_full_response,
            active=active,
            update_asset=update_asset,
            asset_return_nulls=asset_return_nulls,
            asset_album_id=asset_album_id,
            asset_collection_id=asset_collection_id,
            asset_add_to_default_album=asset_add_to_default_album,
            asset_add_to_media_library=asset_add_to_media_library,
            asset_version_code=asset_version_code,
            asset_version_name=asset_version_name,
            asset_meta_data=asset_meta_data,
            asset_caption=asset_caption,
            asset_media=asset_media,
            asset_media_url=asset_media_url,
            asset_media_string=asset_media_string,
            asset_media_string_file_name=asset_media_string_file_name,
            asset_media_string_content_type=asset_media_string_content_type,
            asset_attached_media=asset_attached_media,
            asset_attached_media_url=asset_attached_media_url,
            asset_attached_media_string=asset_attached_media_string,
            asset_attached_media_string_file_name=asset_attached_media_string_file_name,
            asset_attached_media_string_content_type=asset_attached_media_string_content_type,
            asset_location_description=asset_location_description,
            asset_app=asset_app,
            asset_search_tags=asset_search_tags,
            asset_latitude=asset_latitude,
            asset_longitude=asset_longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "NoteResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_note_serialize(
        self,
        note_id,
        device_id,
        account_id,
        comment,
        note_type,
        asset_ids,
        tags,
        permissionable_type,
        permissionable_id,
        app_key,
        location_description,
        latitude,
        longitude,
        meta_data,
        return_full_response,
        active,
        update_asset,
        asset_return_nulls,
        asset_album_id,
        asset_collection_id,
        asset_add_to_default_album,
        asset_add_to_media_library,
        asset_version_code,
        asset_version_name,
        asset_meta_data,
        asset_caption,
        asset_media,
        asset_media_url,
        asset_media_string,
        asset_media_string_file_name,
        asset_media_string_content_type,
        asset_attached_media,
        asset_attached_media_url,
        asset_attached_media_string,
        asset_attached_media_string_file_name,
        asset_attached_media_string_content_type,
        asset_location_description,
        asset_app,
        asset_search_tags,
        asset_latitude,
        asset_longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if note_id is not None:
            
            _query_params.append(('noteId', note_id))
            
        if comment is not None:
            
            _query_params.append(('comment', comment))
            
        if note_type is not None:
            
            _query_params.append(('noteType', note_type))
            
        if asset_ids is not None:
            
            _query_params.append(('assetIds', asset_ids))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if location_description is not None:
            
            _query_params.append(('locationDescription', location_description))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if update_asset is not None:
            
            _query_params.append(('updateAsset', update_asset))
            
        if asset_return_nulls is not None:
            
            _query_params.append(('assetReturnNulls', asset_return_nulls))
            
        if asset_album_id is not None:
            
            _query_params.append(('assetAlbumId', asset_album_id))
            
        if asset_collection_id is not None:
            
            _query_params.append(('assetCollectionId', asset_collection_id))
            
        if asset_add_to_default_album is not None:
            
            _query_params.append(('assetAddToDefaultAlbum', asset_add_to_default_album))
            
        if asset_add_to_media_library is not None:
            
            _query_params.append(('assetAddToMediaLibrary', asset_add_to_media_library))
            
        if asset_version_code is not None:
            
            _query_params.append(('assetVersionCode', asset_version_code))
            
        if asset_version_name is not None:
            
            _query_params.append(('assetVersionName', asset_version_name))
            
        if asset_meta_data is not None:
            
            _query_params.append(('assetMetaData', asset_meta_data))
            
        if asset_caption is not None:
            
            _query_params.append(('assetCaption', asset_caption))
            
        if asset_media is not None:
            
            _query_params.append(('assetMedia', asset_media))
            
        if asset_media_url is not None:
            
            _query_params.append(('assetMediaUrl', asset_media_url))
            
        if asset_media_string is not None:
            
            _query_params.append(('assetMediaString', asset_media_string))
            
        if asset_media_string_file_name is not None:
            
            _query_params.append(('assetMediaStringFileName', asset_media_string_file_name))
            
        if asset_media_string_content_type is not None:
            
            _query_params.append(('assetMediaStringContentType', asset_media_string_content_type))
            
        if asset_attached_media is not None:
            
            _query_params.append(('assetAttachedMedia', asset_attached_media))
            
        if asset_attached_media_url is not None:
            
            _query_params.append(('assetAttachedMediaUrl', asset_attached_media_url))
            
        if asset_attached_media_string is not None:
            
            _query_params.append(('assetAttachedMediaString', asset_attached_media_string))
            
        if asset_attached_media_string_file_name is not None:
            
            _query_params.append(('assetAttachedMediaStringFileName', asset_attached_media_string_file_name))
            
        if asset_attached_media_string_content_type is not None:
            
            _query_params.append(('assetAttachedMediaStringContentType', asset_attached_media_string_content_type))
            
        if asset_location_description is not None:
            
            _query_params.append(('assetLocationDescription', asset_location_description))
            
        if asset_app is not None:
            
            _query_params.append(('assetApp', asset_app))
            
        if asset_search_tags is not None:
            
            _query_params.append(('assetSearchTags', asset_search_tags))
            
        if asset_latitude is not None:
            
            _query_params.append(('assetLatitude', asset_latitude))
            
        if asset_longitude is not None:
            
            _query_params.append(('assetLongitude', asset_longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/note/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


