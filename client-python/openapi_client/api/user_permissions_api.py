# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.user_permissions_response import UserPermissionsResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class UserPermissionsApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_users_to_permissionable(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        read: Annotated[Optional[StrictBool], Field(description="the read permission of the users/groups")] = None,
        write: Annotated[Optional[StrictBool], Field(description="the write permission of the users/groups")] = None,
        delete: Annotated[Optional[StrictBool], Field(description="the delete permission of the users/groups")] = None,
        add: Annotated[Optional[StrictBool], Field(description="the add permission of the users/groups")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection ids (NOT the account ids)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of account ids")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection group ids (these are groups made by the user)")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="sets whether the added users will become admins or not")] = None,
        include_friend_group: Annotated[Optional[StrictBool], Field(description="flag to determine whether to include the built-in \"friends\" group")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Add User

        Adds a user to a permissionable object.

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param read: the read permission of the users/groups
        :type read: bool
        :param write: the write permission of the users/groups
        :type write: bool
        :param delete: the delete permission of the users/groups
        :type delete: bool
        :param add: the add permission of the users/groups
        :type add: bool
        :param connection_ids: a comma separated list of connection ids (NOT the account ids)
        :type connection_ids: str
        :param connection_account_ids: a comma separated list of account ids
        :type connection_account_ids: str
        :param connection_group_ids: a comma separated list of connection group ids (these are groups made by the user)
        :type connection_group_ids: str
        :param pending: sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
        :type pending: bool
        :param admin: sets whether the added users will become admins or not
        :type admin: bool
        :param include_friend_group: flag to determine whether to include the built-in \"friends\" group
        :type include_friend_group: bool
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param audience_ids: comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
        :type audience_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_users_to_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            read=read,
            write=write,
            delete=delete,
            add=add,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            connection_group_ids=connection_group_ids,
            pending=pending,
            admin=admin,
            include_friend_group=include_friend_group,
            latitude=latitude,
            longitude=longitude,
            audience_ids=audience_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_users_to_permissionable_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        read: Annotated[Optional[StrictBool], Field(description="the read permission of the users/groups")] = None,
        write: Annotated[Optional[StrictBool], Field(description="the write permission of the users/groups")] = None,
        delete: Annotated[Optional[StrictBool], Field(description="the delete permission of the users/groups")] = None,
        add: Annotated[Optional[StrictBool], Field(description="the add permission of the users/groups")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection ids (NOT the account ids)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of account ids")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection group ids (these are groups made by the user)")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="sets whether the added users will become admins or not")] = None,
        include_friend_group: Annotated[Optional[StrictBool], Field(description="flag to determine whether to include the built-in \"friends\" group")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Add User

        Adds a user to a permissionable object.

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param read: the read permission of the users/groups
        :type read: bool
        :param write: the write permission of the users/groups
        :type write: bool
        :param delete: the delete permission of the users/groups
        :type delete: bool
        :param add: the add permission of the users/groups
        :type add: bool
        :param connection_ids: a comma separated list of connection ids (NOT the account ids)
        :type connection_ids: str
        :param connection_account_ids: a comma separated list of account ids
        :type connection_account_ids: str
        :param connection_group_ids: a comma separated list of connection group ids (these are groups made by the user)
        :type connection_group_ids: str
        :param pending: sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
        :type pending: bool
        :param admin: sets whether the added users will become admins or not
        :type admin: bool
        :param include_friend_group: flag to determine whether to include the built-in \"friends\" group
        :type include_friend_group: bool
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param audience_ids: comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
        :type audience_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_users_to_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            read=read,
            write=write,
            delete=delete,
            add=add,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            connection_group_ids=connection_group_ids,
            pending=pending,
            admin=admin,
            include_friend_group=include_friend_group,
            latitude=latitude,
            longitude=longitude,
            audience_ids=audience_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_users_to_permissionable_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        read: Annotated[Optional[StrictBool], Field(description="the read permission of the users/groups")] = None,
        write: Annotated[Optional[StrictBool], Field(description="the write permission of the users/groups")] = None,
        delete: Annotated[Optional[StrictBool], Field(description="the delete permission of the users/groups")] = None,
        add: Annotated[Optional[StrictBool], Field(description="the add permission of the users/groups")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection ids (NOT the account ids)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of account ids")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection group ids (these are groups made by the user)")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="sets whether the added users will become admins or not")] = None,
        include_friend_group: Annotated[Optional[StrictBool], Field(description="flag to determine whether to include the built-in \"friends\" group")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add User

        Adds a user to a permissionable object.

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param read: the read permission of the users/groups
        :type read: bool
        :param write: the write permission of the users/groups
        :type write: bool
        :param delete: the delete permission of the users/groups
        :type delete: bool
        :param add: the add permission of the users/groups
        :type add: bool
        :param connection_ids: a comma separated list of connection ids (NOT the account ids)
        :type connection_ids: str
        :param connection_account_ids: a comma separated list of account ids
        :type connection_account_ids: str
        :param connection_group_ids: a comma separated list of connection group ids (these are groups made by the user)
        :type connection_group_ids: str
        :param pending: sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept)
        :type pending: bool
        :param admin: sets whether the added users will become admins or not
        :type admin: bool
        :param include_friend_group: flag to determine whether to include the built-in \"friends\" group
        :type include_friend_group: bool
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param audience_ids: comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
        :type audience_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_users_to_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            read=read,
            write=write,
            delete=delete,
            add=add,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            connection_group_ids=connection_group_ids,
            pending=pending,
            admin=admin,
            include_friend_group=include_friend_group,
            latitude=latitude,
            longitude=longitude,
            audience_ids=audience_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_users_to_permissionable_serialize(
        self,
        version,
        permissionable_type,
        permissionable_id,
        device_id,
        account_id,
        read,
        write,
        delete,
        add,
        connection_ids,
        connection_account_ids,
        connection_group_ids,
        pending,
        admin,
        include_friend_group,
        latitude,
        longitude,
        audience_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if read is not None:
            
            _query_params.append(('read', read))
            
        if write is not None:
            
            _query_params.append(('write', write))
            
        if delete is not None:
            
            _query_params.append(('delete', delete))
            
        if add is not None:
            
            _query_params.append(('add', add))
            
        if connection_ids is not None:
            
            _query_params.append(('connectionIds', connection_ids))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if connection_group_ids is not None:
            
            _query_params.append(('connectionGroupIds', connection_group_ids))
            
        if pending is not None:
            
            _query_params.append(('pending', pending))
            
        if admin is not None:
            
            _query_params.append(('admin', admin))
            
        if include_friend_group is not None:
            
            _query_params.append(('includeFriendGroup', include_friend_group))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/consumer/permissions/add',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def approve_permissionable(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="The permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="The id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Approve Permissionable

        Sets the approval status of a permissionable object.

        :param version: (required)
        :type version: float
        :param permissionable_type: The permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._approve_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            approval_status=approval_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def approve_permissionable_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="The permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="The id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Approve Permissionable

        Sets the approval status of a permissionable object.

        :param version: (required)
        :type version: float
        :param permissionable_type: The permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._approve_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            approval_status=approval_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def approve_permissionable_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="The permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="The id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        approval_status: Annotated[Optional[StrictStr], Field(description="The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Approve Permissionable

        Sets the approval status of a permissionable object.

        :param version: (required)
        :type version: float
        :param permissionable_type: The permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param approval_status: The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
        :type approval_status: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._approve_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            approval_status=approval_status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _approve_permissionable_serialize(
        self,
        version,
        permissionable_type,
        permissionable_id,
        device_id,
        account_id,
        approval_status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if approval_status is not None:
            
            _query_params.append(('approvalStatus', approval_status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/permissionable/approve',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def leave_from_permissionable(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type PermissionableType")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Leave

        Used when the user wants to leave from someone else's permissionable object

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type PermissionableType (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._leave_from_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def leave_from_permissionable_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type PermissionableType")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Leave

        Used when the user wants to leave from someone else's permissionable object

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type PermissionableType (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._leave_from_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def leave_from_permissionable_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type PermissionableType")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Leave

        Used when the user wants to leave from someone else's permissionable object

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type PermissionableType (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._leave_from_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _leave_from_permissionable_serialize(
        self,
        version,
        permissionable_type,
        permissionable_id,
        device_id,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/consumer/permissions/leave',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_users_from_permissionable(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection ids (NOT the account ids)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of account ids")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection group ids (these are groups made by the user)")] = None,
        remove_friend_group: Annotated[Optional[StrictBool], Field(description="flag to determine whether to remove the built-in \"friends\" group")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Remove User

        Used to remove someone (assuming they have permission) from a permissionable object

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: a comma separated list of connection ids (NOT the account ids)
        :type connection_ids: str
        :param connection_account_ids: a comma separated list of account ids
        :type connection_account_ids: str
        :param connection_group_ids: a comma separated list of connection group ids (these are groups made by the user)
        :type connection_group_ids: str
        :param remove_friend_group: flag to determine whether to remove the built-in \"friends\" group
        :type remove_friend_group: bool
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param audience_ids: comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
        :type audience_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_users_from_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            connection_group_ids=connection_group_ids,
            remove_friend_group=remove_friend_group,
            latitude=latitude,
            longitude=longitude,
            audience_ids=audience_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_users_from_permissionable_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection ids (NOT the account ids)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of account ids")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection group ids (these are groups made by the user)")] = None,
        remove_friend_group: Annotated[Optional[StrictBool], Field(description="flag to determine whether to remove the built-in \"friends\" group")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Remove User

        Used to remove someone (assuming they have permission) from a permissionable object

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: a comma separated list of connection ids (NOT the account ids)
        :type connection_ids: str
        :param connection_account_ids: a comma separated list of account ids
        :type connection_account_ids: str
        :param connection_group_ids: a comma separated list of connection group ids (these are groups made by the user)
        :type connection_group_ids: str
        :param remove_friend_group: flag to determine whether to remove the built-in \"friends\" group
        :type remove_friend_group: bool
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param audience_ids: comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
        :type audience_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_users_from_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            connection_group_ids=connection_group_ids,
            remove_friend_group=remove_friend_group,
            latitude=latitude,
            longitude=longitude,
            audience_ids=audience_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_users_from_permissionable_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        permissionable_type: Annotated[StrictStr, Field(description="the permissionable type of the object")],
        permissionable_id: Annotated[StrictInt, Field(description="the id of the permissionable object")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection ids (NOT the account ids)")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of account ids")] = None,
        connection_group_ids: Annotated[Optional[StrictStr], Field(description="a comma separated list of connection group ids (these are groups made by the user)")] = None,
        remove_friend_group: Annotated[Optional[StrictBool], Field(description="flag to determine whether to remove the built-in \"friends\" group")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove User

        Used to remove someone (assuming they have permission) from a permissionable object

        :param version: (required)
        :type version: float
        :param permissionable_type: the permissionable type of the object (required)
        :type permissionable_type: str
        :param permissionable_id: the id of the permissionable object (required)
        :type permissionable_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: a comma separated list of connection ids (NOT the account ids)
        :type connection_ids: str
        :param connection_account_ids: a comma separated list of account ids
        :type connection_account_ids: str
        :param connection_group_ids: a comma separated list of connection group ids (these are groups made by the user)
        :type connection_group_ids: str
        :param remove_friend_group: flag to determine whether to remove the built-in \"friends\" group
        :type remove_friend_group: bool
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param audience_ids: comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
        :type audience_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_users_from_permissionable_serialize(
            version=version,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            connection_group_ids=connection_group_ids,
            remove_friend_group=remove_friend_group,
            latitude=latitude,
            longitude=longitude,
            audience_ids=audience_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_users_from_permissionable_serialize(
        self,
        version,
        permissionable_type,
        permissionable_id,
        device_id,
        account_id,
        connection_ids,
        connection_account_ids,
        connection_group_ids,
        remove_friend_group,
        latitude,
        longitude,
        audience_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if connection_ids is not None:
            
            _query_params.append(('connectionIds', connection_ids))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if connection_group_ids is not None:
            
            _query_params.append(('connectionGroupIds', connection_group_ids))
            
        if remove_friend_group is not None:
            
            _query_params.append(('removeFriendGroup', remove_friend_group))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/consumer/permissions/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_permissionables(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific user account")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of account IDs to filter results with")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="Filter user permissions by the permissionable object type")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object to filter by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword to search within permissionable records")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Field to sort results on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Sort descending when true")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="Return user permissions that are pending")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="Return user permissions that are admins")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[UserPermissionsResponse]:
        """Search Permissionables

        Search on UserPermissions

        :param version: (required)
        :type version: float
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: Filter results for a specific user account
        :type connection_account_id: int
        :param connection_account_ids: Comma separated list of account IDs to filter results with
        :type connection_account_ids: str
        :param permissionable_type: Filter user permissions by the permissionable object type
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object to filter by
        :type permissionable_id: int
        :param keyword: Keyword to search within permissionable records
        :type keyword: str
        :param sort_field: Field to sort results on
        :type sort_field: str
        :param descending: Sort descending when true
        :type descending: bool
        :param pending: Return user permissions that are pending
        :type pending: bool
        :param admin: Return user permissions that are admins
        :type admin: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_permissionables_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            connection_account_ids=connection_account_ids,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            pending=pending,
            admin=admin,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserPermissionsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_permissionables_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific user account")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of account IDs to filter results with")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="Filter user permissions by the permissionable object type")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object to filter by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword to search within permissionable records")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Field to sort results on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Sort descending when true")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="Return user permissions that are pending")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="Return user permissions that are admins")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[UserPermissionsResponse]]:
        """Search Permissionables

        Search on UserPermissions

        :param version: (required)
        :type version: float
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: Filter results for a specific user account
        :type connection_account_id: int
        :param connection_account_ids: Comma separated list of account IDs to filter results with
        :type connection_account_ids: str
        :param permissionable_type: Filter user permissions by the permissionable object type
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object to filter by
        :type permissionable_id: int
        :param keyword: Keyword to search within permissionable records
        :type keyword: str
        :param sort_field: Field to sort results on
        :type sort_field: str
        :param descending: Sort descending when true
        :type descending: bool
        :param pending: Return user permissions that are pending
        :type pending: bool
        :param admin: Return user permissions that are admins
        :type admin: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_permissionables_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            connection_account_ids=connection_account_ids,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            pending=pending,
            admin=admin,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserPermissionsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_permissionables_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific user account")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of account IDs to filter results with")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="Filter user permissions by the permissionable object type")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object to filter by")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword to search within permissionable records")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Field to sort results on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Sort descending when true")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="Return user permissions that are pending")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="Return user permissions that are admins")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Permissionables

        Search on UserPermissions

        :param version: (required)
        :type version: float
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: Filter results for a specific user account
        :type connection_account_id: int
        :param connection_account_ids: Comma separated list of account IDs to filter results with
        :type connection_account_ids: str
        :param permissionable_type: Filter user permissions by the permissionable object type
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object to filter by
        :type permissionable_id: int
        :param keyword: Keyword to search within permissionable records
        :type keyword: str
        :param sort_field: Field to sort results on
        :type sort_field: str
        :param descending: Sort descending when true
        :type descending: bool
        :param pending: Return user permissions that are pending
        :type pending: bool
        :param admin: Return user permissions that are admins
        :type admin: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_permissionables_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            connection_account_ids=connection_account_ids,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            keyword=keyword,
            sort_field=sort_field,
            descending=descending,
            pending=pending,
            admin=admin,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserPermissionsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_permissionables_serialize(
        self,
        version,
        device_id,
        account_id,
        connection_account_id,
        connection_account_ids,
        permissionable_type,
        permissionable_id,
        keyword,
        sort_field,
        descending,
        pending,
        admin,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if pending is not None:
            
            _query_params.append(('pending', pending))
            
        if admin is not None:
            
            _query_params.append(('admin', admin))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/permissions/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_permissionables_following_distance(
        self,
        version: Union[StrictFloat, StrictInt],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of the current account")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of the current account")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific user account")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of account IDs to filter results with")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="Filter user permissions by the permissionable object type")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object to filter by")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The search range in miles")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword to search within permissionable records")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="Return user permissions that are pending")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="Return user permissions that are admins")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[UserPermissionsResponse]:
        """Search Permissionables by Distnace

        Search on UserPermissions by distance

        :param version: (required)
        :type version: float
        :param latitude: The latitude of the current account (required)
        :type latitude: float
        :param longitude: The longitude of the current account (required)
        :type longitude: float
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: Filter results for a specific user account
        :type connection_account_id: int
        :param connection_account_ids: Comma separated list of account IDs to filter results with
        :type connection_account_ids: str
        :param permissionable_type: Filter user permissions by the permissionable object type
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object to filter by
        :type permissionable_id: int
        :param search_range: The search range in miles
        :type search_range: float
        :param keyword: Keyword to search within permissionable records
        :type keyword: str
        :param pending: Return user permissions that are pending
        :type pending: bool
        :param admin: Return user permissions that are admins
        :type admin: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_permissionables_following_distance_serialize(
            version=version,
            latitude=latitude,
            longitude=longitude,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            connection_account_ids=connection_account_ids,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            search_range=search_range,
            keyword=keyword,
            pending=pending,
            admin=admin,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserPermissionsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_permissionables_following_distance_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of the current account")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of the current account")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific user account")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of account IDs to filter results with")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="Filter user permissions by the permissionable object type")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object to filter by")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The search range in miles")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword to search within permissionable records")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="Return user permissions that are pending")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="Return user permissions that are admins")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[UserPermissionsResponse]]:
        """Search Permissionables by Distnace

        Search on UserPermissions by distance

        :param version: (required)
        :type version: float
        :param latitude: The latitude of the current account (required)
        :type latitude: float
        :param longitude: The longitude of the current account (required)
        :type longitude: float
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: Filter results for a specific user account
        :type connection_account_id: int
        :param connection_account_ids: Comma separated list of account IDs to filter results with
        :type connection_account_ids: str
        :param permissionable_type: Filter user permissions by the permissionable object type
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object to filter by
        :type permissionable_id: int
        :param search_range: The search range in miles
        :type search_range: float
        :param keyword: Keyword to search within permissionable records
        :type keyword: str
        :param pending: Return user permissions that are pending
        :type pending: bool
        :param admin: Return user permissions that are admins
        :type admin: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_permissionables_following_distance_serialize(
            version=version,
            latitude=latitude,
            longitude=longitude,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            connection_account_ids=connection_account_ids,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            search_range=search_range,
            keyword=keyword,
            pending=pending,
            admin=admin,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserPermissionsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_permissionables_following_distance_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of the current account")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of the current account")],
        device_id: Annotated[Optional[StrictStr], Field(description="A unique ID given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account ID of the user (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific user account")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of account IDs to filter results with")] = None,
        permissionable_type: Annotated[Optional[StrictStr], Field(description="Filter user permissions by the permissionable object type")] = None,
        permissionable_id: Annotated[Optional[StrictInt], Field(description="The id of the permissionable object to filter by")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The search range in miles")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="Keyword to search within permissionable records")] = None,
        pending: Annotated[Optional[StrictBool], Field(description="Return user permissions that are pending")] = None,
        admin: Annotated[Optional[StrictBool], Field(description="Return user permissions that are admins")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Permissionables by Distnace

        Search on UserPermissions by distance

        :param version: (required)
        :type version: float
        :param latitude: The latitude of the current account (required)
        :type latitude: float
        :param longitude: The longitude of the current account (required)
        :type longitude: float
        :param device_id: A unique ID given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account ID of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: Filter results for a specific user account
        :type connection_account_id: int
        :param connection_account_ids: Comma separated list of account IDs to filter results with
        :type connection_account_ids: str
        :param permissionable_type: Filter user permissions by the permissionable object type
        :type permissionable_type: str
        :param permissionable_id: The id of the permissionable object to filter by
        :type permissionable_id: int
        :param search_range: The search range in miles
        :type search_range: float
        :param keyword: Keyword to search within permissionable records
        :type keyword: str
        :param pending: Return user permissions that are pending
        :type pending: bool
        :param admin: Return user permissions that are admins
        :type admin: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_permissionables_following_distance_serialize(
            version=version,
            latitude=latitude,
            longitude=longitude,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            connection_account_ids=connection_account_ids,
            permissionable_type=permissionable_type,
            permissionable_id=permissionable_id,
            search_range=search_range,
            keyword=keyword,
            pending=pending,
            admin=admin,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[UserPermissionsResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_permissionables_following_distance_serialize(
        self,
        version,
        latitude,
        longitude,
        device_id,
        account_id,
        connection_account_id,
        connection_account_ids,
        permissionable_type,
        permissionable_id,
        search_range,
        keyword,
        pending,
        admin,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if permissionable_type is not None:
            
            _query_params.append(('permissionableType', permissionable_type))
            
        if permissionable_id is not None:
            
            _query_params.append(('permissionableId', permissionable_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if pending is not None:
            
            _query_params.append(('pending', pending))
            
        if admin is not None:
            
            _query_params.append(('admin', admin))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/permissions/distancesearch',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


