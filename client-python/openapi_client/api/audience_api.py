# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.age_group_response import AgeGroupResponse
from openapi_client.models.audience_device_response import AudienceDeviceResponse
from openapi_client.models.audience_response import AudienceResponse
from openapi_client.models.offer_list_response import OfferListResponse
from openapi_client.models.search_response import SearchResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AudienceApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_audience(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[StrictStr, Field(description="The name of the audience")],
        description: Annotated[Optional[StrictStr], Field(description="The description of the audience")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="The search tags")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender; possible values are: MALE, FEMALE, ANY")] = None,
        age_groups: Annotated[Optional[StrictStr], Field(description="The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)")] = None,
        game_experience_level: Annotated[Optional[StrictStr], Field(description="The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        devices: Annotated[Optional[StrictStr], Field(description="(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)")] = None,
        radius: Annotated[Optional[StrictStr], Field(description="The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.")] = None,
        start_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the start time of an event")] = None,
        end_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the end time of an event")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="If true, then notify matching users when they are inside the radius")] = None,
        associate_description: Annotated[Optional[StrictStr], Field(description="The description of the associated object")] = None,
        associate_type: Annotated[Optional[StrictStr], Field(description="The type of the object to center the audience geofence")] = None,
        associate_id: Annotated[Optional[StrictInt], Field(description="The ID of the object to center the audience geofence")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Optional grouping id for the audience")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Visibility of the audience")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="Type of audience")] = None,
        use_order: Annotated[Optional[StrictBool], Field(description="Use order for cohort")] = None,
        cohort_regions_data: Annotated[Optional[StrictStr], Field(description="Cohort data for \"cohort\" audience type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        trilateration_types: Annotated[Optional[StrictStr], Field(description="Trilateration types")] = None,
        unique_name: Annotated[Optional[StrictBool], Field(description="If true, makes sure the audience name is unique")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AudienceResponse:
        """Create Audience

        Create a user defined audience.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the audience (required)
        :type name: str
        :param description: The description of the audience
        :type description: str
        :param search_tags: The search tags
        :type search_tags: str
        :param gender: The gender; possible values are: MALE, FEMALE, ANY
        :type gender: str
        :param age_groups: The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        :type age_groups: str
        :param category_ids: The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        :type category_ids: str
        :param application_ids: The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        :type application_ids: str
        :param game_experience_level: The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience_level: str
        :param devices: (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        :type devices: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        :type device_versions: str
        :param locations: The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        :type locations: str
        :param radius: The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        :type radius: str
        :param start_time_offset: Seconds from the start time of an event
        :type start_time_offset: int
        :param end_time_offset: Seconds from the end time of an event
        :type end_time_offset: int
        :param send_suggestion: If true, then notify matching users when they are inside the radius
        :type send_suggestion: bool
        :param associate_description: The description of the associated object
        :type associate_description: str
        :param associate_type: The type of the object to center the audience geofence
        :type associate_type: str
        :param associate_id: The ID of the object to center the audience geofence
        :type associate_id: int
        :param grouping_id: Optional grouping id for the audience
        :type grouping_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param visibility: Visibility of the audience
        :type visibility: str
        :param audience_type: Type of audience
        :type audience_type: str
        :param use_order: Use order for cohort
        :type use_order: bool
        :param cohort_regions_data: Cohort data for \"cohort\" audience type
        :type cohort_regions_data: str
        :param app_key: Filter results by application key
        :type app_key: str
        :param trilateration_types: Trilateration types
        :type trilateration_types: str
        :param unique_name: If true, makes sure the audience name is unique
        :type unique_name: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audience_serialize(
            account_id=account_id,
            name=name,
            description=description,
            search_tags=search_tags,
            gender=gender,
            age_groups=age_groups,
            category_ids=category_ids,
            application_ids=application_ids,
            game_experience_level=game_experience_level,
            devices=devices,
            device_ids=device_ids,
            device_versions=device_versions,
            locations=locations,
            radius=radius,
            start_time_offset=start_time_offset,
            end_time_offset=end_time_offset,
            send_suggestion=send_suggestion,
            associate_description=associate_description,
            associate_type=associate_type,
            associate_id=associate_id,
            grouping_id=grouping_id,
            meta_data=meta_data,
            visibility=visibility,
            audience_type=audience_type,
            use_order=use_order,
            cohort_regions_data=cohort_regions_data,
            app_key=app_key,
            trilateration_types=trilateration_types,
            unique_name=unique_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_audience_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[StrictStr, Field(description="The name of the audience")],
        description: Annotated[Optional[StrictStr], Field(description="The description of the audience")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="The search tags")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender; possible values are: MALE, FEMALE, ANY")] = None,
        age_groups: Annotated[Optional[StrictStr], Field(description="The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)")] = None,
        game_experience_level: Annotated[Optional[StrictStr], Field(description="The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        devices: Annotated[Optional[StrictStr], Field(description="(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)")] = None,
        radius: Annotated[Optional[StrictStr], Field(description="The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.")] = None,
        start_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the start time of an event")] = None,
        end_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the end time of an event")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="If true, then notify matching users when they are inside the radius")] = None,
        associate_description: Annotated[Optional[StrictStr], Field(description="The description of the associated object")] = None,
        associate_type: Annotated[Optional[StrictStr], Field(description="The type of the object to center the audience geofence")] = None,
        associate_id: Annotated[Optional[StrictInt], Field(description="The ID of the object to center the audience geofence")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Optional grouping id for the audience")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Visibility of the audience")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="Type of audience")] = None,
        use_order: Annotated[Optional[StrictBool], Field(description="Use order for cohort")] = None,
        cohort_regions_data: Annotated[Optional[StrictStr], Field(description="Cohort data for \"cohort\" audience type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        trilateration_types: Annotated[Optional[StrictStr], Field(description="Trilateration types")] = None,
        unique_name: Annotated[Optional[StrictBool], Field(description="If true, makes sure the audience name is unique")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AudienceResponse]:
        """Create Audience

        Create a user defined audience.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the audience (required)
        :type name: str
        :param description: The description of the audience
        :type description: str
        :param search_tags: The search tags
        :type search_tags: str
        :param gender: The gender; possible values are: MALE, FEMALE, ANY
        :type gender: str
        :param age_groups: The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        :type age_groups: str
        :param category_ids: The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        :type category_ids: str
        :param application_ids: The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        :type application_ids: str
        :param game_experience_level: The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience_level: str
        :param devices: (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        :type devices: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        :type device_versions: str
        :param locations: The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        :type locations: str
        :param radius: The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        :type radius: str
        :param start_time_offset: Seconds from the start time of an event
        :type start_time_offset: int
        :param end_time_offset: Seconds from the end time of an event
        :type end_time_offset: int
        :param send_suggestion: If true, then notify matching users when they are inside the radius
        :type send_suggestion: bool
        :param associate_description: The description of the associated object
        :type associate_description: str
        :param associate_type: The type of the object to center the audience geofence
        :type associate_type: str
        :param associate_id: The ID of the object to center the audience geofence
        :type associate_id: int
        :param grouping_id: Optional grouping id for the audience
        :type grouping_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param visibility: Visibility of the audience
        :type visibility: str
        :param audience_type: Type of audience
        :type audience_type: str
        :param use_order: Use order for cohort
        :type use_order: bool
        :param cohort_regions_data: Cohort data for \"cohort\" audience type
        :type cohort_regions_data: str
        :param app_key: Filter results by application key
        :type app_key: str
        :param trilateration_types: Trilateration types
        :type trilateration_types: str
        :param unique_name: If true, makes sure the audience name is unique
        :type unique_name: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audience_serialize(
            account_id=account_id,
            name=name,
            description=description,
            search_tags=search_tags,
            gender=gender,
            age_groups=age_groups,
            category_ids=category_ids,
            application_ids=application_ids,
            game_experience_level=game_experience_level,
            devices=devices,
            device_ids=device_ids,
            device_versions=device_versions,
            locations=locations,
            radius=radius,
            start_time_offset=start_time_offset,
            end_time_offset=end_time_offset,
            send_suggestion=send_suggestion,
            associate_description=associate_description,
            associate_type=associate_type,
            associate_id=associate_id,
            grouping_id=grouping_id,
            meta_data=meta_data,
            visibility=visibility,
            audience_type=audience_type,
            use_order=use_order,
            cohort_regions_data=cohort_regions_data,
            app_key=app_key,
            trilateration_types=trilateration_types,
            unique_name=unique_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_audience_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        name: Annotated[StrictStr, Field(description="The name of the audience")],
        description: Annotated[Optional[StrictStr], Field(description="The description of the audience")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="The search tags")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender; possible values are: MALE, FEMALE, ANY")] = None,
        age_groups: Annotated[Optional[StrictStr], Field(description="The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)")] = None,
        game_experience_level: Annotated[Optional[StrictStr], Field(description="The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        devices: Annotated[Optional[StrictStr], Field(description="(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)")] = None,
        radius: Annotated[Optional[StrictStr], Field(description="The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.")] = None,
        start_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the start time of an event")] = None,
        end_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the end time of an event")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="If true, then notify matching users when they are inside the radius")] = None,
        associate_description: Annotated[Optional[StrictStr], Field(description="The description of the associated object")] = None,
        associate_type: Annotated[Optional[StrictStr], Field(description="The type of the object to center the audience geofence")] = None,
        associate_id: Annotated[Optional[StrictInt], Field(description="The ID of the object to center the audience geofence")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Optional grouping id for the audience")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Visibility of the audience")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="Type of audience")] = None,
        use_order: Annotated[Optional[StrictBool], Field(description="Use order for cohort")] = None,
        cohort_regions_data: Annotated[Optional[StrictStr], Field(description="Cohort data for \"cohort\" audience type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        trilateration_types: Annotated[Optional[StrictStr], Field(description="Trilateration types")] = None,
        unique_name: Annotated[Optional[StrictBool], Field(description="If true, makes sure the audience name is unique")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Audience

        Create a user defined audience.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param name: The name of the audience (required)
        :type name: str
        :param description: The description of the audience
        :type description: str
        :param search_tags: The search tags
        :type search_tags: str
        :param gender: The gender; possible values are: MALE, FEMALE, ANY
        :type gender: str
        :param age_groups: The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        :type age_groups: str
        :param category_ids: The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        :type category_ids: str
        :param application_ids: The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        :type application_ids: str
        :param game_experience_level: The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience_level: str
        :param devices: (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        :type devices: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        :type device_versions: str
        :param locations: The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        :type locations: str
        :param radius: The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        :type radius: str
        :param start_time_offset: Seconds from the start time of an event
        :type start_time_offset: int
        :param end_time_offset: Seconds from the end time of an event
        :type end_time_offset: int
        :param send_suggestion: If true, then notify matching users when they are inside the radius
        :type send_suggestion: bool
        :param associate_description: The description of the associated object
        :type associate_description: str
        :param associate_type: The type of the object to center the audience geofence
        :type associate_type: str
        :param associate_id: The ID of the object to center the audience geofence
        :type associate_id: int
        :param grouping_id: Optional grouping id for the audience
        :type grouping_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param visibility: Visibility of the audience
        :type visibility: str
        :param audience_type: Type of audience
        :type audience_type: str
        :param use_order: Use order for cohort
        :type use_order: bool
        :param cohort_regions_data: Cohort data for \"cohort\" audience type
        :type cohort_regions_data: str
        :param app_key: Filter results by application key
        :type app_key: str
        :param trilateration_types: Trilateration types
        :type trilateration_types: str
        :param unique_name: If true, makes sure the audience name is unique
        :type unique_name: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_audience_serialize(
            account_id=account_id,
            name=name,
            description=description,
            search_tags=search_tags,
            gender=gender,
            age_groups=age_groups,
            category_ids=category_ids,
            application_ids=application_ids,
            game_experience_level=game_experience_level,
            devices=devices,
            device_ids=device_ids,
            device_versions=device_versions,
            locations=locations,
            radius=radius,
            start_time_offset=start_time_offset,
            end_time_offset=end_time_offset,
            send_suggestion=send_suggestion,
            associate_description=associate_description,
            associate_type=associate_type,
            associate_id=associate_id,
            grouping_id=grouping_id,
            meta_data=meta_data,
            visibility=visibility,
            audience_type=audience_type,
            use_order=use_order,
            cohort_regions_data=cohort_regions_data,
            app_key=app_key,
            trilateration_types=trilateration_types,
            unique_name=unique_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_audience_serialize(
        self,
        account_id,
        name,
        description,
        search_tags,
        gender,
        age_groups,
        category_ids,
        application_ids,
        game_experience_level,
        devices,
        device_ids,
        device_versions,
        locations,
        radius,
        start_time_offset,
        end_time_offset,
        send_suggestion,
        associate_description,
        associate_type,
        associate_id,
        grouping_id,
        meta_data,
        visibility,
        audience_type,
        use_order,
        cohort_regions_data,
        app_key,
        trilateration_types,
        unique_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age_groups is not None:
            
            _query_params.append(('ageGroups', age_groups))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if application_ids is not None:
            
            _query_params.append(('applicationIds', application_ids))
            
        if game_experience_level is not None:
            
            _query_params.append(('gameExperienceLevel', game_experience_level))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if device_ids is not None:
            
            _query_params.append(('deviceIds', device_ids))
            
        if device_versions is not None:
            
            _query_params.append(('deviceVersions', device_versions))
            
        if locations is not None:
            
            _query_params.append(('locations', locations))
            
        if radius is not None:
            
            _query_params.append(('radius', radius))
            
        if start_time_offset is not None:
            
            _query_params.append(('startTimeOffset', start_time_offset))
            
        if end_time_offset is not None:
            
            _query_params.append(('endTimeOffset', end_time_offset))
            
        if send_suggestion is not None:
            
            _query_params.append(('sendSuggestion', send_suggestion))
            
        if associate_description is not None:
            
            _query_params.append(('associateDescription', associate_description))
            
        if associate_type is not None:
            
            _query_params.append(('associateType', associate_type))
            
        if associate_id is not None:
            
            _query_params.append(('associateId', associate_id))
            
        if grouping_id is not None:
            
            _query_params.append(('groupingId', grouping_id))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if audience_type is not None:
            
            _query_params.append(('audienceType', audience_type))
            
        if use_order is not None:
            
            _query_params.append(('useOrder', use_order))
            
        if cohort_regions_data is not None:
            
            _query_params.append(('cohortRegionsData', cohort_regions_data))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if trilateration_types is not None:
            
            _query_params.append(('trilaterationTypes', trilateration_types))
            
        if unique_name is not None:
            
            _query_params.append(('uniqueName', unique_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/audience/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_audience(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Audience

        Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to delete. (required)
        :type audience_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_audience_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Audience

        Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to delete. (required)
        :type audience_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_audience_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to delete.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Audience

        Delete an audience. The audience and account must be valid and have the appropirate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to delete. (required)
        :type audience_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_audience_serialize(
        self,
        account_id,
        audience_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/audience/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_age_groups(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AgeGroupResponse]:
        """Get Age Groups

        Gets the list of available age groups that can be selected by consumers and retailers targeting offers.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_age_groups_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AgeGroupResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_age_groups_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AgeGroupResponse]]:
        """Get Age Groups

        Gets the list of available age groups that can be selected by consumers and retailers targeting offers.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_age_groups_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AgeGroupResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_age_groups_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Age Groups

        Gets the list of available age groups that can be selected by consumers and retailers targeting offers.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_age_groups_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AgeGroupResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_age_groups_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/ageGroups',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audience(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to return.")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key (optional). If provided, results may be scoped to this application.")] = None,
        return_account_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the accountCount associated with current audience of the current app")] = None,
        return_album_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the albumCount associated with current audience of the current app")] = None,
        album_types_for_count: Annotated[Optional[StrictStr], Field(description="(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AudienceResponse:
        """Get Audience

        Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to return. (required)
        :type audience_id: int
        :param app_key: The application key (optional). If provided, results may be scoped to this application.
        :type app_key: str
        :param return_account_count: (boolean) set to true to include the accountCount associated with current audience of the current app
        :type return_account_count: bool
        :param return_album_count: (boolean) set to true to include the albumCount associated with current audience of the current app
        :type return_album_count: bool
        :param album_types_for_count: (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        :type album_types_for_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            app_key=app_key,
            return_account_count=return_account_count,
            return_album_count=return_album_count,
            album_types_for_count=album_types_for_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audience_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to return.")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key (optional). If provided, results may be scoped to this application.")] = None,
        return_account_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the accountCount associated with current audience of the current app")] = None,
        return_album_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the albumCount associated with current audience of the current app")] = None,
        album_types_for_count: Annotated[Optional[StrictStr], Field(description="(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AudienceResponse]:
        """Get Audience

        Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to return. (required)
        :type audience_id: int
        :param app_key: The application key (optional). If provided, results may be scoped to this application.
        :type app_key: str
        :param return_account_count: (boolean) set to true to include the accountCount associated with current audience of the current app
        :type return_account_count: bool
        :param return_album_count: (boolean) set to true to include the albumCount associated with current audience of the current app
        :type return_album_count: bool
        :param album_types_for_count: (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        :type album_types_for_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            app_key=app_key,
            return_account_count=return_account_count,
            return_album_count=return_album_count,
            album_types_for_count=album_types_for_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audience_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to return.")],
        app_key: Annotated[Optional[StrictStr], Field(description="The application key (optional). If provided, results may be scoped to this application.")] = None,
        return_account_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the accountCount associated with current audience of the current app")] = None,
        return_album_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the albumCount associated with current audience of the current app")] = None,
        album_types_for_count: Annotated[Optional[StrictStr], Field(description="(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Audience

        Get an audience. The audience and account must be valid and have the appropriate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to return. (required)
        :type audience_id: int
        :param app_key: The application key (optional). If provided, results may be scoped to this application.
        :type app_key: str
        :param return_account_count: (boolean) set to true to include the accountCount associated with current audience of the current app
        :type return_account_count: bool
        :param return_album_count: (boolean) set to true to include the albumCount associated with current audience of the current app
        :type return_album_count: bool
        :param album_types_for_count: (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        :type album_types_for_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            app_key=app_key,
            return_account_count=return_account_count,
            return_album_count=return_album_count,
            album_types_for_count=album_types_for_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audience_serialize(
        self,
        account_id,
        audience_id,
        app_key,
        return_account_count,
        return_album_count,
        album_types_for_count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if return_account_count is not None:
            
            _query_params.append(('returnAccountCount', return_account_count))
            
        if return_album_count is not None:
            
            _query_params.append(('returnAlbumCount', return_album_count))
            
        if album_types_for_count is not None:
            
            _query_params.append(('albumTypesForCount', album_types_for_count))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_audience_list(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The logged in user.")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of album IDs to filter results with")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        keyword_fields: Annotated[Optional[StrictStr], Field(description="Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return (there is a hard limit of 100).")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="Filter results based on whether or not the audience is set to send suggestions")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        group_by_grouping_id: Annotated[Optional[StrictBool], Field(description="Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        return_global: Annotated[Optional[StrictBool], Field(description="If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well")] = None,
        exact_keyword: Annotated[Optional[StrictBool], Field(description="If true, match keyword exactly")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="(Deprecated) Filter results by audience type")] = None,
        audience_types: Annotated[Optional[StrictStr], Field(description="comma separated string with the different audience types you want to filter for")] = None,
        return_account_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the accountCount associated with current audience of the current app")] = None,
        return_album_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the albumCount associated with current audience of the current app")] = None,
        album_types_for_count: Annotated[Optional[StrictStr], Field(description="(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[SearchResponse]:
        """Search Audiences

        Get the list audiences owned by the account

        :param account_id: The logged in user.
        :type account_id: int
        :param album_ids: Comma separated list of album IDs to filter results with
        :type album_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param keyword_fields: Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
        :type keyword_fields: str
        :param sort_field: The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with.
        :type start: int
        :param limit: The total number of record to return (there is a hard limit of 100).
        :type limit: int
        :param send_suggestion: Filter results based on whether or not the audience is set to send suggestions
        :type send_suggestion: bool
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param group_by_grouping_id: Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
        :type group_by_grouping_id: bool
        :param app_key: Filter results by application key
        :type app_key: str
        :param return_global: If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
        :type return_global: bool
        :param exact_keyword: If true, match keyword exactly
        :type exact_keyword: bool
        :param audience_type: (Deprecated) Filter results by audience type
        :type audience_type: str
        :param audience_types: comma separated string with the different audience types you want to filter for
        :type audience_types: str
        :param return_account_count: (boolean) set to true to include the accountCount associated with current audience of the current app
        :type return_account_count: bool
        :param return_album_count: (boolean) set to true to include the albumCount associated with current audience of the current app
        :type return_album_count: bool
        :param album_types_for_count: (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        :type album_types_for_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audience_list_serialize(
            account_id=account_id,
            album_ids=album_ids,
            keyword=keyword,
            keyword_fields=keyword_fields,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            send_suggestion=send_suggestion,
            active_only=active_only,
            group_by_grouping_id=group_by_grouping_id,
            app_key=app_key,
            return_global=return_global,
            exact_keyword=exact_keyword,
            audience_type=audience_type,
            audience_types=audience_types,
            return_account_count=return_account_count,
            return_album_count=return_album_count,
            album_types_for_count=album_types_for_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_audience_list_with_http_info(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The logged in user.")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of album IDs to filter results with")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        keyword_fields: Annotated[Optional[StrictStr], Field(description="Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return (there is a hard limit of 100).")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="Filter results based on whether or not the audience is set to send suggestions")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        group_by_grouping_id: Annotated[Optional[StrictBool], Field(description="Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        return_global: Annotated[Optional[StrictBool], Field(description="If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well")] = None,
        exact_keyword: Annotated[Optional[StrictBool], Field(description="If true, match keyword exactly")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="(Deprecated) Filter results by audience type")] = None,
        audience_types: Annotated[Optional[StrictStr], Field(description="comma separated string with the different audience types you want to filter for")] = None,
        return_account_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the accountCount associated with current audience of the current app")] = None,
        return_album_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the albumCount associated with current audience of the current app")] = None,
        album_types_for_count: Annotated[Optional[StrictStr], Field(description="(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[SearchResponse]]:
        """Search Audiences

        Get the list audiences owned by the account

        :param account_id: The logged in user.
        :type account_id: int
        :param album_ids: Comma separated list of album IDs to filter results with
        :type album_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param keyword_fields: Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
        :type keyword_fields: str
        :param sort_field: The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with.
        :type start: int
        :param limit: The total number of record to return (there is a hard limit of 100).
        :type limit: int
        :param send_suggestion: Filter results based on whether or not the audience is set to send suggestions
        :type send_suggestion: bool
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param group_by_grouping_id: Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
        :type group_by_grouping_id: bool
        :param app_key: Filter results by application key
        :type app_key: str
        :param return_global: If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
        :type return_global: bool
        :param exact_keyword: If true, match keyword exactly
        :type exact_keyword: bool
        :param audience_type: (Deprecated) Filter results by audience type
        :type audience_type: str
        :param audience_types: comma separated string with the different audience types you want to filter for
        :type audience_types: str
        :param return_account_count: (boolean) set to true to include the accountCount associated with current audience of the current app
        :type return_account_count: bool
        :param return_album_count: (boolean) set to true to include the albumCount associated with current audience of the current app
        :type return_album_count: bool
        :param album_types_for_count: (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        :type album_types_for_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audience_list_serialize(
            account_id=account_id,
            album_ids=album_ids,
            keyword=keyword,
            keyword_fields=keyword_fields,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            send_suggestion=send_suggestion,
            active_only=active_only,
            group_by_grouping_id=group_by_grouping_id,
            app_key=app_key,
            return_global=return_global,
            exact_keyword=exact_keyword,
            audience_type=audience_type,
            audience_types=audience_types,
            return_account_count=return_account_count,
            return_album_count=return_album_count,
            album_types_for_count=album_types_for_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_audience_list_without_preload_content(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The logged in user.")] = None,
        album_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of album IDs to filter results with")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        keyword_fields: Annotated[Optional[StrictStr], Field(description="Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return (there is a hard limit of 100).")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="Filter results based on whether or not the audience is set to send suggestions")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        group_by_grouping_id: Annotated[Optional[StrictBool], Field(description="Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        return_global: Annotated[Optional[StrictBool], Field(description="If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well")] = None,
        exact_keyword: Annotated[Optional[StrictBool], Field(description="If true, match keyword exactly")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="(Deprecated) Filter results by audience type")] = None,
        audience_types: Annotated[Optional[StrictStr], Field(description="comma separated string with the different audience types you want to filter for")] = None,
        return_account_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the accountCount associated with current audience of the current app")] = None,
        return_album_count: Annotated[Optional[StrictBool], Field(description="(boolean) set to true to include the albumCount associated with current audience of the current app")] = None,
        album_types_for_count: Annotated[Optional[StrictStr], Field(description="(String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Audiences

        Get the list audiences owned by the account

        :param account_id: The logged in user.
        :type account_id: int
        :param album_ids: Comma separated list of album IDs to filter results with
        :type album_ids: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param keyword_fields: Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY
        :type keyword_fields: str
        :param sort_field: The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER}
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with.
        :type start: int
        :param limit: The total number of record to return (there is a hard limit of 100).
        :type limit: int
        :param send_suggestion: Filter results based on whether or not the audience is set to send suggestions
        :type send_suggestion: bool
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param group_by_grouping_id: Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
        :type group_by_grouping_id: bool
        :param app_key: Filter results by application key
        :type app_key: str
        :param return_global: If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
        :type return_global: bool
        :param exact_keyword: If true, match keyword exactly
        :type exact_keyword: bool
        :param audience_type: (Deprecated) Filter results by audience type
        :type audience_type: str
        :param audience_types: comma separated string with the different audience types you want to filter for
        :type audience_types: str
        :param return_account_count: (boolean) set to true to include the accountCount associated with current audience of the current app
        :type return_account_count: bool
        :param return_album_count: (boolean) set to true to include the albumCount associated with current audience of the current app
        :type return_album_count: bool
        :param album_types_for_count: (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
        :type album_types_for_count: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_audience_list_serialize(
            account_id=account_id,
            album_ids=album_ids,
            keyword=keyword,
            keyword_fields=keyword_fields,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            send_suggestion=send_suggestion,
            active_only=active_only,
            group_by_grouping_id=group_by_grouping_id,
            app_key=app_key,
            return_global=return_global,
            exact_keyword=exact_keyword,
            audience_type=audience_type,
            audience_types=audience_types,
            return_account_count=return_account_count,
            return_album_count=return_album_count,
            album_types_for_count=album_types_for_count,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[SearchResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_audience_list_serialize(
        self,
        account_id,
        album_ids,
        keyword,
        keyword_fields,
        sort_field,
        descending,
        start,
        limit,
        send_suggestion,
        active_only,
        group_by_grouping_id,
        app_key,
        return_global,
        exact_keyword,
        audience_type,
        audience_types,
        return_account_count,
        return_album_count,
        album_types_for_count,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if album_ids is not None:
            
            _query_params.append(('albumIds', album_ids))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if keyword_fields is not None:
            
            _query_params.append(('keywordFields', keyword_fields))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if send_suggestion is not None:
            
            _query_params.append(('sendSuggestion', send_suggestion))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if group_by_grouping_id is not None:
            
            _query_params.append(('groupByGroupingId', group_by_grouping_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if return_global is not None:
            
            _query_params.append(('returnGlobal', return_global))
            
        if exact_keyword is not None:
            
            _query_params.append(('exactKeyword', exact_keyword))
            
        if audience_type is not None:
            
            _query_params.append(('audienceType', audience_type))
            
        if audience_types is not None:
            
            _query_params.append(('audienceTypes', audience_types))
            
        if return_account_count is not None:
            
            _query_params.append(('returnAccountCount', return_account_count))
            
        if return_album_count is not None:
            
            _query_params.append(('returnAlbumCount', return_album_count))
            
        if album_types_for_count is not None:
            
            _query_params.append(('albumTypesForCount', album_types_for_count))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_devices(
        self,
        include_inactive: Annotated[StrictBool, Field(description="If true return inactive record as well. default is false.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AudienceDeviceResponse]:
        """Get Devices

        Gets the list of available devices that can be selected by consumers and retailers.

        :param include_inactive: If true return inactive record as well. default is false. (required)
        :type include_inactive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_devices_serialize(
            include_inactive=include_inactive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AudienceDeviceResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_devices_with_http_info(
        self,
        include_inactive: Annotated[StrictBool, Field(description="If true return inactive record as well. default is false.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AudienceDeviceResponse]]:
        """Get Devices

        Gets the list of available devices that can be selected by consumers and retailers.

        :param include_inactive: If true return inactive record as well. default is false. (required)
        :type include_inactive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_devices_serialize(
            include_inactive=include_inactive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AudienceDeviceResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_devices_without_preload_content(
        self,
        include_inactive: Annotated[StrictBool, Field(description="If true return inactive record as well. default is false.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Devices

        Gets the list of available devices that can be selected by consumers and retailers.

        :param include_inactive: If true return inactive record as well. default is false. (required)
        :type include_inactive: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_devices_serialize(
            include_inactive=include_inactive,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AudienceDeviceResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_devices_serialize(
        self,
        include_inactive,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if include_inactive is not None:
            
            _query_params.append(('includeInactive', include_inactive))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/devices',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_experiences(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Get Experiences

        Gets the list of available experiences that can be selected by consumers and retailers.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiences_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_experiences_with_http_info(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Get Experiences

        Gets the list of available experiences that can be selected by consumers and retailers.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiences_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_experiences_without_preload_content(
        self,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Experiences

        Gets the list of available experiences that can be selected by consumers and retailers.

        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_experiences_serialize(
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_experiences_serialize(
        self,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/experiences',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_grouped_audiences(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_grouping_id: Annotated[StrictStr, Field(description="The audience grouping id to return.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AudienceResponse:
        """Get GroupedAudiences

        Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_grouping_id: The audience grouping id to return. (required)
        :type audience_grouping_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_grouped_audiences_serialize(
            account_id=account_id,
            audience_grouping_id=audience_grouping_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_grouped_audiences_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_grouping_id: Annotated[StrictStr, Field(description="The audience grouping id to return.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AudienceResponse]:
        """Get GroupedAudiences

        Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_grouping_id: The audience grouping id to return. (required)
        :type audience_grouping_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_grouped_audiences_serialize(
            account_id=account_id,
            audience_grouping_id=audience_grouping_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_grouped_audiences_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_grouping_id: Annotated[StrictStr, Field(description="The audience grouping id to return.")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get GroupedAudiences

        Get a group of audiences. The audience and account must be valid and have the appropriate permissions to view the content.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_grouping_id: The audience grouping id to return. (required)
        :type audience_grouping_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_grouped_audiences_serialize(
            account_id=account_id,
            audience_grouping_id=audience_grouping_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_grouped_audiences_serialize(
        self,
        account_id,
        audience_grouping_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if audience_grouping_id is not None:
            
            _query_params.append(('audienceGroupingId', audience_grouping_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/grouped/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_by_account(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        limit: Annotated[StrictInt, Field(description="the limit of the index")],
        suggestion_type: Annotated[StrictStr, Field(description="the type of suggestion")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferListResponse:
        """List Suggestions by Audience

        List either Missions or Offers that the user matches the assigned audience.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param limit: the limit of the index (required)
        :type limit: int
        :param suggestion_type: the type of suggestion (required)
        :type suggestion_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_by_account_serialize(
            account_id=account_id,
            limit=limit,
            suggestion_type=suggestion_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_by_account_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        limit: Annotated[StrictInt, Field(description="the limit of the index")],
        suggestion_type: Annotated[StrictStr, Field(description="the type of suggestion")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferListResponse]:
        """List Suggestions by Audience

        List either Missions or Offers that the user matches the assigned audience.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param limit: the limit of the index (required)
        :type limit: int
        :param suggestion_type: the type of suggestion (required)
        :type suggestion_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_by_account_serialize(
            account_id=account_id,
            limit=limit,
            suggestion_type=suggestion_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_by_account_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        limit: Annotated[StrictInt, Field(description="the limit of the index")],
        suggestion_type: Annotated[StrictStr, Field(description="the type of suggestion")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Suggestions by Audience

        List either Missions or Offers that the user matches the assigned audience.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param limit: the limit of the index (required)
        :type limit: int
        :param suggestion_type: the type of suggestion (required)
        :type suggestion_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_by_account_serialize(
            account_id=account_id,
            limit=limit,
            suggestion_type=suggestion_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_by_account_serialize(
        self,
        account_id,
        limit,
        suggestion_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if suggestion_type is not None:
            
            _query_params.append(('suggestionType', suggestion_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/audience/suggestion/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_by_audience(
        self,
        limit: Annotated[StrictInt, Field(description="this is the limit of the index")],
        gender: Annotated[Optional[StrictStr], Field(description="this is the gender to list offers by")] = None,
        age: Annotated[Optional[StrictInt], Field(description="this is the age to list offers by")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="this is the category IDs to list offers by")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="this is the latitude to list offers by")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="this is the longitude to list offers by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferListResponse:
        """List Offers by Audience

        Get a list of offer locations based on audience information provided.

        :param limit: this is the limit of the index (required)
        :type limit: int
        :param gender: this is the gender to list offers by
        :type gender: str
        :param age: this is the age to list offers by
        :type age: int
        :param category_ids: this is the category IDs to list offers by
        :type category_ids: str
        :param latitude: this is the latitude to list offers by
        :type latitude: float
        :param longitude: this is the longitude to list offers by
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_by_audience_serialize(
            limit=limit,
            gender=gender,
            age=age,
            category_ids=category_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_by_audience_with_http_info(
        self,
        limit: Annotated[StrictInt, Field(description="this is the limit of the index")],
        gender: Annotated[Optional[StrictStr], Field(description="this is the gender to list offers by")] = None,
        age: Annotated[Optional[StrictInt], Field(description="this is the age to list offers by")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="this is the category IDs to list offers by")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="this is the latitude to list offers by")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="this is the longitude to list offers by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferListResponse]:
        """List Offers by Audience

        Get a list of offer locations based on audience information provided.

        :param limit: this is the limit of the index (required)
        :type limit: int
        :param gender: this is the gender to list offers by
        :type gender: str
        :param age: this is the age to list offers by
        :type age: int
        :param category_ids: this is the category IDs to list offers by
        :type category_ids: str
        :param latitude: this is the latitude to list offers by
        :type latitude: float
        :param longitude: this is the longitude to list offers by
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_by_audience_serialize(
            limit=limit,
            gender=gender,
            age=age,
            category_ids=category_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_by_audience_without_preload_content(
        self,
        limit: Annotated[StrictInt, Field(description="this is the limit of the index")],
        gender: Annotated[Optional[StrictStr], Field(description="this is the gender to list offers by")] = None,
        age: Annotated[Optional[StrictInt], Field(description="this is the age to list offers by")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="this is the category IDs to list offers by")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="this is the latitude to list offers by")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="this is the longitude to list offers by")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Offers by Audience

        Get a list of offer locations based on audience information provided.

        :param limit: this is the limit of the index (required)
        :type limit: int
        :param gender: this is the gender to list offers by
        :type gender: str
        :param age: this is the age to list offers by
        :type age: int
        :param category_ids: this is the category IDs to list offers by
        :type category_ids: str
        :param latitude: this is the latitude to list offers by
        :type latitude: float
        :param longitude: this is the longitude to list offers by
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_by_audience_serialize(
            limit=limit,
            gender=gender,
            age=age,
            category_ids=category_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_by_audience_serialize(
        self,
        limit,
        gender,
        age,
        category_ids,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age is not None:
            
            _query_params.append(('age', age))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/suggestion/offersByAudience',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_lastest_by_account(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        timeframe: Annotated[StrictInt, Field(description="The timeframe in seconds of the latest suggestions")],
        suggestion_type: Annotated[StrictStr, Field(description="The type of trigger suggestions to return")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferListResponse:
        """List Sent Suggestions 

        Return list of recent trigger suggestions that have been sent to the user.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param timeframe: The timeframe in seconds of the latest suggestions (required)
        :type timeframe: int
        :param suggestion_type: The type of trigger suggestions to return (required)
        :type suggestion_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_lastest_by_account_serialize(
            account_id=account_id,
            timeframe=timeframe,
            suggestion_type=suggestion_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_lastest_by_account_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        timeframe: Annotated[StrictInt, Field(description="The timeframe in seconds of the latest suggestions")],
        suggestion_type: Annotated[StrictStr, Field(description="The type of trigger suggestions to return")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferListResponse]:
        """List Sent Suggestions 

        Return list of recent trigger suggestions that have been sent to the user.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param timeframe: The timeframe in seconds of the latest suggestions (required)
        :type timeframe: int
        :param suggestion_type: The type of trigger suggestions to return (required)
        :type suggestion_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_lastest_by_account_serialize(
            account_id=account_id,
            timeframe=timeframe,
            suggestion_type=suggestion_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_lastest_by_account_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        timeframe: Annotated[StrictInt, Field(description="The timeframe in seconds of the latest suggestions")],
        suggestion_type: Annotated[StrictStr, Field(description="The type of trigger suggestions to return")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Sent Suggestions 

        Return list of recent trigger suggestions that have been sent to the user.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param timeframe: The timeframe in seconds of the latest suggestions (required)
        :type timeframe: int
        :param suggestion_type: The type of trigger suggestions to return (required)
        :type suggestion_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_lastest_by_account_serialize(
            account_id=account_id,
            timeframe=timeframe,
            suggestion_type=suggestion_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_lastest_by_account_serialize(
        self,
        account_id,
        timeframe,
        suggestion_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if timeframe is not None:
            
            _query_params.append(('timeframe', timeframe))
            
        if suggestion_type is not None:
            
            _query_params.append(('suggestionType', suggestion_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/audience/suggestion/latest',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def send_by_account(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Send Suggestions

        Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param latitude: the latitude (required)
        :type latitude: float
        :param longitude: the longitude (required)
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_by_account_serialize(
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def send_by_account_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Send Suggestions

        Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param latitude: the latitude (required)
        :type latitude: float
        :param longitude: the longitude (required)
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_by_account_serialize(
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def send_by_account_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The account to match offers for.")],
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Suggestions

        Use the accountId to determine the associated BillableEntity. From there get a list of all triggers associated with the BillableEntity.

        :param account_id: The account to match offers for. (required)
        :type account_id: int
        :param latitude: the latitude (required)
        :type latitude: float
        :param longitude: the longitude (required)
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._send_by_account_serialize(
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _send_by_account_serialize(
        self,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/audience/suggestion/send',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_audience(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to update.")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the audience")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the audience")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="The search tags")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender; possible values are: MALE, FEMALE, ANY")] = None,
        age_groups: Annotated[Optional[StrictStr], Field(description="The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)")] = None,
        game_experience_level: Annotated[Optional[StrictStr], Field(description="The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        devices: Annotated[Optional[StrictStr], Field(description="(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)")] = None,
        radius: Annotated[Optional[StrictStr], Field(description="The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="if audience is active")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="If true, then notify matching users when they are inside the radius")] = None,
        start_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the start time of an event")] = None,
        end_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the end time of an event")] = None,
        associate_description: Annotated[Optional[StrictStr], Field(description="the associate description")] = None,
        associate_type: Annotated[Optional[StrictStr], Field(description="The type of the object to center the audience geofence")] = None,
        associate_id: Annotated[Optional[StrictInt], Field(description="The ID of the object to center the audience geofence")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Optional grouping id for the audience")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Visibility of the audience")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="Type of audience")] = None,
        use_order: Annotated[Optional[StrictBool], Field(description="Use order for cohort")] = None,
        cohort_regions_data: Annotated[Optional[StrictStr], Field(description="Cohort data for \"cohort\" audience type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        trilateration_types: Annotated[Optional[StrictStr], Field(description="Trilateration types")] = None,
        unique_name: Annotated[Optional[StrictBool], Field(description="If true, makes sure the audience name is unique")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AudienceResponse:
        """Update Audience

        Update a user defined audience.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to update. (required)
        :type audience_id: int
        :param name: The name of the audience
        :type name: str
        :param description: The description of the audience
        :type description: str
        :param search_tags: The search tags
        :type search_tags: str
        :param gender: The gender; possible values are: MALE, FEMALE, ANY
        :type gender: str
        :param age_groups: The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        :type age_groups: str
        :param category_ids: The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        :type category_ids: str
        :param application_ids: The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        :type application_ids: str
        :param game_experience_level: The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience_level: str
        :param devices: (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        :type devices: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        :type device_versions: str
        :param locations: The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        :type locations: str
        :param radius: The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        :type radius: str
        :param active: if audience is active
        :type active: bool
        :param send_suggestion: If true, then notify matching users when they are inside the radius
        :type send_suggestion: bool
        :param start_time_offset: Seconds from the start time of an event
        :type start_time_offset: int
        :param end_time_offset: Seconds from the end time of an event
        :type end_time_offset: int
        :param associate_description: the associate description
        :type associate_description: str
        :param associate_type: The type of the object to center the audience geofence
        :type associate_type: str
        :param associate_id: The ID of the object to center the audience geofence
        :type associate_id: int
        :param grouping_id: Optional grouping id for the audience
        :type grouping_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param visibility: Visibility of the audience
        :type visibility: str
        :param audience_type: Type of audience
        :type audience_type: str
        :param use_order: Use order for cohort
        :type use_order: bool
        :param cohort_regions_data: Cohort data for \"cohort\" audience type
        :type cohort_regions_data: str
        :param app_key: Filter results by application key
        :type app_key: str
        :param trilateration_types: Trilateration types
        :type trilateration_types: str
        :param unique_name: If true, makes sure the audience name is unique
        :type unique_name: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            name=name,
            description=description,
            search_tags=search_tags,
            gender=gender,
            age_groups=age_groups,
            category_ids=category_ids,
            application_ids=application_ids,
            game_experience_level=game_experience_level,
            devices=devices,
            device_ids=device_ids,
            device_versions=device_versions,
            locations=locations,
            radius=radius,
            active=active,
            send_suggestion=send_suggestion,
            start_time_offset=start_time_offset,
            end_time_offset=end_time_offset,
            associate_description=associate_description,
            associate_type=associate_type,
            associate_id=associate_id,
            grouping_id=grouping_id,
            meta_data=meta_data,
            visibility=visibility,
            audience_type=audience_type,
            use_order=use_order,
            cohort_regions_data=cohort_regions_data,
            app_key=app_key,
            trilateration_types=trilateration_types,
            unique_name=unique_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_audience_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to update.")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the audience")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the audience")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="The search tags")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender; possible values are: MALE, FEMALE, ANY")] = None,
        age_groups: Annotated[Optional[StrictStr], Field(description="The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)")] = None,
        game_experience_level: Annotated[Optional[StrictStr], Field(description="The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        devices: Annotated[Optional[StrictStr], Field(description="(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)")] = None,
        radius: Annotated[Optional[StrictStr], Field(description="The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="if audience is active")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="If true, then notify matching users when they are inside the radius")] = None,
        start_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the start time of an event")] = None,
        end_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the end time of an event")] = None,
        associate_description: Annotated[Optional[StrictStr], Field(description="the associate description")] = None,
        associate_type: Annotated[Optional[StrictStr], Field(description="The type of the object to center the audience geofence")] = None,
        associate_id: Annotated[Optional[StrictInt], Field(description="The ID of the object to center the audience geofence")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Optional grouping id for the audience")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Visibility of the audience")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="Type of audience")] = None,
        use_order: Annotated[Optional[StrictBool], Field(description="Use order for cohort")] = None,
        cohort_regions_data: Annotated[Optional[StrictStr], Field(description="Cohort data for \"cohort\" audience type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        trilateration_types: Annotated[Optional[StrictStr], Field(description="Trilateration types")] = None,
        unique_name: Annotated[Optional[StrictBool], Field(description="If true, makes sure the audience name is unique")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AudienceResponse]:
        """Update Audience

        Update a user defined audience.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to update. (required)
        :type audience_id: int
        :param name: The name of the audience
        :type name: str
        :param description: The description of the audience
        :type description: str
        :param search_tags: The search tags
        :type search_tags: str
        :param gender: The gender; possible values are: MALE, FEMALE, ANY
        :type gender: str
        :param age_groups: The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        :type age_groups: str
        :param category_ids: The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        :type category_ids: str
        :param application_ids: The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        :type application_ids: str
        :param game_experience_level: The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience_level: str
        :param devices: (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        :type devices: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        :type device_versions: str
        :param locations: The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        :type locations: str
        :param radius: The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        :type radius: str
        :param active: if audience is active
        :type active: bool
        :param send_suggestion: If true, then notify matching users when they are inside the radius
        :type send_suggestion: bool
        :param start_time_offset: Seconds from the start time of an event
        :type start_time_offset: int
        :param end_time_offset: Seconds from the end time of an event
        :type end_time_offset: int
        :param associate_description: the associate description
        :type associate_description: str
        :param associate_type: The type of the object to center the audience geofence
        :type associate_type: str
        :param associate_id: The ID of the object to center the audience geofence
        :type associate_id: int
        :param grouping_id: Optional grouping id for the audience
        :type grouping_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param visibility: Visibility of the audience
        :type visibility: str
        :param audience_type: Type of audience
        :type audience_type: str
        :param use_order: Use order for cohort
        :type use_order: bool
        :param cohort_regions_data: Cohort data for \"cohort\" audience type
        :type cohort_regions_data: str
        :param app_key: Filter results by application key
        :type app_key: str
        :param trilateration_types: Trilateration types
        :type trilateration_types: str
        :param unique_name: If true, makes sure the audience name is unique
        :type unique_name: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            name=name,
            description=description,
            search_tags=search_tags,
            gender=gender,
            age_groups=age_groups,
            category_ids=category_ids,
            application_ids=application_ids,
            game_experience_level=game_experience_level,
            devices=devices,
            device_ids=device_ids,
            device_versions=device_versions,
            locations=locations,
            radius=radius,
            active=active,
            send_suggestion=send_suggestion,
            start_time_offset=start_time_offset,
            end_time_offset=end_time_offset,
            associate_description=associate_description,
            associate_type=associate_type,
            associate_id=associate_id,
            grouping_id=grouping_id,
            meta_data=meta_data,
            visibility=visibility,
            audience_type=audience_type,
            use_order=use_order,
            cohort_regions_data=cohort_regions_data,
            app_key=app_key,
            trilateration_types=trilateration_types,
            unique_name=unique_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_audience_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        audience_id: Annotated[StrictInt, Field(description="The id of the audience to update.")],
        name: Annotated[Optional[StrictStr], Field(description="The name of the audience")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the audience")] = None,
        search_tags: Annotated[Optional[StrictStr], Field(description="The search tags")] = None,
        gender: Annotated[Optional[StrictStr], Field(description="The gender; possible values are: MALE, FEMALE, ANY")] = None,
        age_groups: Annotated[Optional[StrictStr], Field(description="The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)")] = None,
        application_ids: Annotated[Optional[StrictStr], Field(description="The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)")] = None,
        game_experience_level: Annotated[Optional[StrictStr], Field(description="The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT")] = None,
        devices: Annotated[Optional[StrictStr], Field(description="(Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)")] = None,
        device_ids: Annotated[Optional[StrictStr], Field(description="The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)")] = None,
        device_versions: Annotated[Optional[StrictStr], Field(description="The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)")] = None,
        locations: Annotated[Optional[StrictStr], Field(description="The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)")] = None,
        radius: Annotated[Optional[StrictStr], Field(description="The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="if audience is active")] = None,
        send_suggestion: Annotated[Optional[StrictBool], Field(description="If true, then notify matching users when they are inside the radius")] = None,
        start_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the start time of an event")] = None,
        end_time_offset: Annotated[Optional[StrictInt], Field(description="Seconds from the end time of an event")] = None,
        associate_description: Annotated[Optional[StrictStr], Field(description="the associate description")] = None,
        associate_type: Annotated[Optional[StrictStr], Field(description="The type of the object to center the audience geofence")] = None,
        associate_id: Annotated[Optional[StrictInt], Field(description="The ID of the object to center the audience geofence")] = None,
        grouping_id: Annotated[Optional[StrictStr], Field(description="Optional grouping id for the audience")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Visibility of the audience")] = None,
        audience_type: Annotated[Optional[StrictStr], Field(description="Type of audience")] = None,
        use_order: Annotated[Optional[StrictBool], Field(description="Use order for cohort")] = None,
        cohort_regions_data: Annotated[Optional[StrictStr], Field(description="Cohort data for \"cohort\" audience type")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="Filter results by application key")] = None,
        trilateration_types: Annotated[Optional[StrictStr], Field(description="Trilateration types")] = None,
        unique_name: Annotated[Optional[StrictBool], Field(description="If true, makes sure the audience name is unique")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Audience

        Update a user defined audience.

        :param account_id: The logged in user. (required)
        :type account_id: int
        :param audience_id: The id of the audience to update. (required)
        :type audience_id: int
        :param name: The name of the audience
        :type name: str
        :param description: The description of the audience
        :type description: str
        :param search_tags: The search tags
        :type search_tags: str
        :param gender: The gender; possible values are: MALE, FEMALE, ANY
        :type gender: str
        :param age_groups: The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
        :type age_groups: str
        :param category_ids: The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
        :type category_ids: str
        :param application_ids: The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
        :type application_ids: str
        :param game_experience_level: The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
        :type game_experience_level: str
        :param devices: (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
        :type devices: str
        :param device_ids: The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
        :type device_ids: str
        :param device_versions: The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
        :type device_versions: str
        :param locations: The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
        :type locations: str
        :param radius: The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
        :type radius: str
        :param active: if audience is active
        :type active: bool
        :param send_suggestion: If true, then notify matching users when they are inside the radius
        :type send_suggestion: bool
        :param start_time_offset: Seconds from the start time of an event
        :type start_time_offset: int
        :param end_time_offset: Seconds from the end time of an event
        :type end_time_offset: int
        :param associate_description: the associate description
        :type associate_description: str
        :param associate_type: The type of the object to center the audience geofence
        :type associate_type: str
        :param associate_id: The ID of the object to center the audience geofence
        :type associate_id: int
        :param grouping_id: Optional grouping id for the audience
        :type grouping_id: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param visibility: Visibility of the audience
        :type visibility: str
        :param audience_type: Type of audience
        :type audience_type: str
        :param use_order: Use order for cohort
        :type use_order: bool
        :param cohort_regions_data: Cohort data for \"cohort\" audience type
        :type cohort_regions_data: str
        :param app_key: Filter results by application key
        :type app_key: str
        :param trilateration_types: Trilateration types
        :type trilateration_types: str
        :param unique_name: If true, makes sure the audience name is unique
        :type unique_name: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_audience_serialize(
            account_id=account_id,
            audience_id=audience_id,
            name=name,
            description=description,
            search_tags=search_tags,
            gender=gender,
            age_groups=age_groups,
            category_ids=category_ids,
            application_ids=application_ids,
            game_experience_level=game_experience_level,
            devices=devices,
            device_ids=device_ids,
            device_versions=device_versions,
            locations=locations,
            radius=radius,
            active=active,
            send_suggestion=send_suggestion,
            start_time_offset=start_time_offset,
            end_time_offset=end_time_offset,
            associate_description=associate_description,
            associate_type=associate_type,
            associate_id=associate_id,
            grouping_id=grouping_id,
            meta_data=meta_data,
            visibility=visibility,
            audience_type=audience_type,
            use_order=use_order,
            cohort_regions_data=cohort_regions_data,
            app_key=app_key,
            trilateration_types=trilateration_types,
            unique_name=unique_name,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AudienceResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_audience_serialize(
        self,
        account_id,
        audience_id,
        name,
        description,
        search_tags,
        gender,
        age_groups,
        category_ids,
        application_ids,
        game_experience_level,
        devices,
        device_ids,
        device_versions,
        locations,
        radius,
        active,
        send_suggestion,
        start_time_offset,
        end_time_offset,
        associate_description,
        associate_type,
        associate_id,
        grouping_id,
        meta_data,
        visibility,
        audience_type,
        use_order,
        cohort_regions_data,
        app_key,
        trilateration_types,
        unique_name,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if audience_id is not None:
            
            _query_params.append(('audienceId', audience_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if search_tags is not None:
            
            _query_params.append(('searchTags', search_tags))
            
        if gender is not None:
            
            _query_params.append(('gender', gender))
            
        if age_groups is not None:
            
            _query_params.append(('ageGroups', age_groups))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if application_ids is not None:
            
            _query_params.append(('applicationIds', application_ids))
            
        if game_experience_level is not None:
            
            _query_params.append(('gameExperienceLevel', game_experience_level))
            
        if devices is not None:
            
            _query_params.append(('devices', devices))
            
        if device_ids is not None:
            
            _query_params.append(('deviceIds', device_ids))
            
        if device_versions is not None:
            
            _query_params.append(('deviceVersions', device_versions))
            
        if locations is not None:
            
            _query_params.append(('locations', locations))
            
        if radius is not None:
            
            _query_params.append(('radius', radius))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if send_suggestion is not None:
            
            _query_params.append(('sendSuggestion', send_suggestion))
            
        if start_time_offset is not None:
            
            _query_params.append(('startTimeOffset', start_time_offset))
            
        if end_time_offset is not None:
            
            _query_params.append(('endTimeOffset', end_time_offset))
            
        if associate_description is not None:
            
            _query_params.append(('associateDescription', associate_description))
            
        if associate_type is not None:
            
            _query_params.append(('associateType', associate_type))
            
        if associate_id is not None:
            
            _query_params.append(('associateId', associate_id))
            
        if grouping_id is not None:
            
            _query_params.append(('groupingId', grouping_id))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if audience_type is not None:
            
            _query_params.append(('audienceType', audience_type))
            
        if use_order is not None:
            
            _query_params.append(('useOrder', use_order))
            
        if cohort_regions_data is not None:
            
            _query_params.append(('cohortRegionsData', cohort_regions_data))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if trilateration_types is not None:
            
            _query_params.append(('trilaterationTypes', trilateration_types))
            
        if unique_name is not None:
            
            _query_params.append(('uniqueName', unique_name))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/audience/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


