# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import Optional, Union
from typing_extensions import Annotated
from openapi_client.models.mission_short_response import MissionShortResponse
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.tournament_response import TournamentResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TournamentApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_tournament(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The appKey the tournament is created for.")],
        title: Annotated[StrictStr, Field(description="The title of the tournament")],
        cost_to_play: Annotated[StrictInt, Field(description="The number of tickets required to pay to enter the tournament")],
        start_date: Annotated[StrictInt, Field(description="The date/time to start the tournament")],
        sub_type: Annotated[Optional[StrictStr], Field(description="Custom string client apps can use for searching/filtering tournaments")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to attach to the tournament")] = None,
        seconds_between_levels: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament game/group")] = None,
        seconds_for_tie_breaker: Annotated[Optional[StrictInt], Field(description="The number of seconds to extend the round end time in the case of a tie breaker")] = None,
        seconds_between_packs: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament round")] = None,
        maximum_level_length: Annotated[Optional[StrictInt], Field(description="The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity")] = None,
        cost_to_play_type: Annotated[Optional[StrictStr], Field(description="The type of ticket required to pay")] = None,
        minimum_to_play: Annotated[Optional[StrictInt], Field(description="The minimum number of players required to sign up for the tournament to be played")] = None,
        starting_limit: Annotated[Optional[StrictInt], Field(description="The starting number of players for a tournament (filled with AI's)")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The maximum number of players for a tournament (currently 128 but not enforced)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the tournament")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences associated with the tournament")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Activate/deactivate the tournament")] = None,
        enable_buy_back: Annotated[Optional[StrictBool], Field(description="Determines whether to allow players to buy back into a tournament")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="The list of offers to give as a reward beyond the tickets")] = None,
        offer_asset_id: Annotated[Optional[StrictInt], Field(description="The artwork ID to attach to the reward tickets offers")] = None,
        fixed_reward: Annotated[Optional[StrictBool], Field(description="If set then do not update the ticket reward, auto set to true if offerIds provided")] = None,
        split_reward: Annotated[Optional[StrictStr], Field(description="Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored")] = None,
        allocate_tickets: Annotated[Optional[StrictBool], Field(description="Flag to indicate owner should receive tickets for completed missions")] = None,
        tournament_data: Annotated[Optional[StrictStr], Field(description="A text based string that will be passed into each tournament setup to populate the content")] = None,
        mission_type: Annotated[Optional[StrictStr], Field(description="The style of tournament to build, options are: TOURNAMENT, POOLPLAY")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Sets the visibility flag for the tournament")] = None,
        preliminary_groups: Annotated[Optional[StrictInt], Field(description="The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)")] = None,
        preliminary_group_advancements: Annotated[Optional[StrictStr], Field(description="This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)")] = None,
        enable_multiple_entries: Annotated[Optional[StrictBool], Field(description="This determines if multiple submissions/entries are allowed in a multi-stage album tournament")] = None,
        enable_multiple_votes: Annotated[Optional[StrictBool], Field(description="This determines if users are allowed to vote multiple times per group in a multi-stage album tournament")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="This determines whether the tournament is \"featured\" or not")] = None,
        winner_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        tie_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a tie has occurred")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TournamentResponse:
        """Create Tournament

        Create a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The appKey the tournament is created for. (required)
        :type app_key: str
        :param title: The title of the tournament (required)
        :type title: str
        :param cost_to_play: The number of tickets required to pay to enter the tournament (required)
        :type cost_to_play: int
        :param start_date: The date/time to start the tournament (required)
        :type start_date: int
        :param sub_type: Custom string client apps can use for searching/filtering tournaments
        :type sub_type: str
        :param image_asset_id: The asset ID to attach to the tournament
        :type image_asset_id: int
        :param seconds_between_levels: The number of seconds in between the start of each tournament game/group
        :type seconds_between_levels: int
        :param seconds_for_tie_breaker: The number of seconds to extend the round end time in the case of a tie breaker
        :type seconds_for_tie_breaker: int
        :param seconds_between_packs: The number of seconds in between the start of each tournament round
        :type seconds_between_packs: int
        :param maximum_level_length: The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        :type maximum_level_length: int
        :param cost_to_play_type: The type of ticket required to pay
        :type cost_to_play_type: str
        :param minimum_to_play: The minimum number of players required to sign up for the tournament to be played
        :type minimum_to_play: int
        :param starting_limit: The starting number of players for a tournament (filled with AI's)
        :type starting_limit: int
        :param available_limit: The maximum number of players for a tournament (currently 128 but not enforced)
        :type available_limit: int
        :param description: The description of the tournament
        :type description: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param audience_ids: The audiences associated with the tournament
        :type audience_ids: str
        :param active: Activate/deactivate the tournament
        :type active: bool
        :param enable_buy_back: Determines whether to allow players to buy back into a tournament
        :type enable_buy_back: bool
        :param offer_ids: The list of offers to give as a reward beyond the tickets
        :type offer_ids: str
        :param offer_asset_id: The artwork ID to attach to the reward tickets offers
        :type offer_asset_id: int
        :param fixed_reward: If set then do not update the ticket reward, auto set to true if offerIds provided
        :type fixed_reward: bool
        :param split_reward: Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        :type split_reward: str
        :param allocate_tickets: Flag to indicate owner should receive tickets for completed missions
        :type allocate_tickets: bool
        :param tournament_data: A text based string that will be passed into each tournament setup to populate the content
        :type tournament_data: str
        :param mission_type: The style of tournament to build, options are: TOURNAMENT, POOLPLAY
        :type mission_type: str
        :param visibility: Sets the visibility flag for the tournament
        :type visibility: str
        :param preliminary_groups: The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        :type preliminary_groups: int
        :param preliminary_group_advancements: This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        :type preliminary_group_advancements: str
        :param enable_multiple_entries: This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        :type enable_multiple_entries: bool
        :param enable_multiple_votes: This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        :type enable_multiple_votes: bool
        :param featured: This determines whether the tournament is \"featured\" or not
        :type featured: bool
        :param winner_tag: This sets what analytic tag is used when a winner is determined
        :type winner_tag: str
        :param tie_tag: This sets what analytic tag is used when a tie has occurred
        :type tie_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_tournament_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            title=title,
            cost_to_play=cost_to_play,
            start_date=start_date,
            sub_type=sub_type,
            image_asset_id=image_asset_id,
            seconds_between_levels=seconds_between_levels,
            seconds_for_tie_breaker=seconds_for_tie_breaker,
            seconds_between_packs=seconds_between_packs,
            maximum_level_length=maximum_level_length,
            cost_to_play_type=cost_to_play_type,
            minimum_to_play=minimum_to_play,
            starting_limit=starting_limit,
            available_limit=available_limit,
            description=description,
            meta_data=meta_data,
            audience_ids=audience_ids,
            active=active,
            enable_buy_back=enable_buy_back,
            offer_ids=offer_ids,
            offer_asset_id=offer_asset_id,
            fixed_reward=fixed_reward,
            split_reward=split_reward,
            allocate_tickets=allocate_tickets,
            tournament_data=tournament_data,
            mission_type=mission_type,
            visibility=visibility,
            preliminary_groups=preliminary_groups,
            preliminary_group_advancements=preliminary_group_advancements,
            enable_multiple_entries=enable_multiple_entries,
            enable_multiple_votes=enable_multiple_votes,
            featured=featured,
            winner_tag=winner_tag,
            tie_tag=tie_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_tournament_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The appKey the tournament is created for.")],
        title: Annotated[StrictStr, Field(description="The title of the tournament")],
        cost_to_play: Annotated[StrictInt, Field(description="The number of tickets required to pay to enter the tournament")],
        start_date: Annotated[StrictInt, Field(description="The date/time to start the tournament")],
        sub_type: Annotated[Optional[StrictStr], Field(description="Custom string client apps can use for searching/filtering tournaments")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to attach to the tournament")] = None,
        seconds_between_levels: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament game/group")] = None,
        seconds_for_tie_breaker: Annotated[Optional[StrictInt], Field(description="The number of seconds to extend the round end time in the case of a tie breaker")] = None,
        seconds_between_packs: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament round")] = None,
        maximum_level_length: Annotated[Optional[StrictInt], Field(description="The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity")] = None,
        cost_to_play_type: Annotated[Optional[StrictStr], Field(description="The type of ticket required to pay")] = None,
        minimum_to_play: Annotated[Optional[StrictInt], Field(description="The minimum number of players required to sign up for the tournament to be played")] = None,
        starting_limit: Annotated[Optional[StrictInt], Field(description="The starting number of players for a tournament (filled with AI's)")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The maximum number of players for a tournament (currently 128 but not enforced)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the tournament")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences associated with the tournament")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Activate/deactivate the tournament")] = None,
        enable_buy_back: Annotated[Optional[StrictBool], Field(description="Determines whether to allow players to buy back into a tournament")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="The list of offers to give as a reward beyond the tickets")] = None,
        offer_asset_id: Annotated[Optional[StrictInt], Field(description="The artwork ID to attach to the reward tickets offers")] = None,
        fixed_reward: Annotated[Optional[StrictBool], Field(description="If set then do not update the ticket reward, auto set to true if offerIds provided")] = None,
        split_reward: Annotated[Optional[StrictStr], Field(description="Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored")] = None,
        allocate_tickets: Annotated[Optional[StrictBool], Field(description="Flag to indicate owner should receive tickets for completed missions")] = None,
        tournament_data: Annotated[Optional[StrictStr], Field(description="A text based string that will be passed into each tournament setup to populate the content")] = None,
        mission_type: Annotated[Optional[StrictStr], Field(description="The style of tournament to build, options are: TOURNAMENT, POOLPLAY")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Sets the visibility flag for the tournament")] = None,
        preliminary_groups: Annotated[Optional[StrictInt], Field(description="The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)")] = None,
        preliminary_group_advancements: Annotated[Optional[StrictStr], Field(description="This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)")] = None,
        enable_multiple_entries: Annotated[Optional[StrictBool], Field(description="This determines if multiple submissions/entries are allowed in a multi-stage album tournament")] = None,
        enable_multiple_votes: Annotated[Optional[StrictBool], Field(description="This determines if users are allowed to vote multiple times per group in a multi-stage album tournament")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="This determines whether the tournament is \"featured\" or not")] = None,
        winner_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        tie_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a tie has occurred")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TournamentResponse]:
        """Create Tournament

        Create a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The appKey the tournament is created for. (required)
        :type app_key: str
        :param title: The title of the tournament (required)
        :type title: str
        :param cost_to_play: The number of tickets required to pay to enter the tournament (required)
        :type cost_to_play: int
        :param start_date: The date/time to start the tournament (required)
        :type start_date: int
        :param sub_type: Custom string client apps can use for searching/filtering tournaments
        :type sub_type: str
        :param image_asset_id: The asset ID to attach to the tournament
        :type image_asset_id: int
        :param seconds_between_levels: The number of seconds in between the start of each tournament game/group
        :type seconds_between_levels: int
        :param seconds_for_tie_breaker: The number of seconds to extend the round end time in the case of a tie breaker
        :type seconds_for_tie_breaker: int
        :param seconds_between_packs: The number of seconds in between the start of each tournament round
        :type seconds_between_packs: int
        :param maximum_level_length: The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        :type maximum_level_length: int
        :param cost_to_play_type: The type of ticket required to pay
        :type cost_to_play_type: str
        :param minimum_to_play: The minimum number of players required to sign up for the tournament to be played
        :type minimum_to_play: int
        :param starting_limit: The starting number of players for a tournament (filled with AI's)
        :type starting_limit: int
        :param available_limit: The maximum number of players for a tournament (currently 128 but not enforced)
        :type available_limit: int
        :param description: The description of the tournament
        :type description: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param audience_ids: The audiences associated with the tournament
        :type audience_ids: str
        :param active: Activate/deactivate the tournament
        :type active: bool
        :param enable_buy_back: Determines whether to allow players to buy back into a tournament
        :type enable_buy_back: bool
        :param offer_ids: The list of offers to give as a reward beyond the tickets
        :type offer_ids: str
        :param offer_asset_id: The artwork ID to attach to the reward tickets offers
        :type offer_asset_id: int
        :param fixed_reward: If set then do not update the ticket reward, auto set to true if offerIds provided
        :type fixed_reward: bool
        :param split_reward: Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        :type split_reward: str
        :param allocate_tickets: Flag to indicate owner should receive tickets for completed missions
        :type allocate_tickets: bool
        :param tournament_data: A text based string that will be passed into each tournament setup to populate the content
        :type tournament_data: str
        :param mission_type: The style of tournament to build, options are: TOURNAMENT, POOLPLAY
        :type mission_type: str
        :param visibility: Sets the visibility flag for the tournament
        :type visibility: str
        :param preliminary_groups: The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        :type preliminary_groups: int
        :param preliminary_group_advancements: This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        :type preliminary_group_advancements: str
        :param enable_multiple_entries: This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        :type enable_multiple_entries: bool
        :param enable_multiple_votes: This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        :type enable_multiple_votes: bool
        :param featured: This determines whether the tournament is \"featured\" or not
        :type featured: bool
        :param winner_tag: This sets what analytic tag is used when a winner is determined
        :type winner_tag: str
        :param tie_tag: This sets what analytic tag is used when a tie has occurred
        :type tie_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_tournament_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            title=title,
            cost_to_play=cost_to_play,
            start_date=start_date,
            sub_type=sub_type,
            image_asset_id=image_asset_id,
            seconds_between_levels=seconds_between_levels,
            seconds_for_tie_breaker=seconds_for_tie_breaker,
            seconds_between_packs=seconds_between_packs,
            maximum_level_length=maximum_level_length,
            cost_to_play_type=cost_to_play_type,
            minimum_to_play=minimum_to_play,
            starting_limit=starting_limit,
            available_limit=available_limit,
            description=description,
            meta_data=meta_data,
            audience_ids=audience_ids,
            active=active,
            enable_buy_back=enable_buy_back,
            offer_ids=offer_ids,
            offer_asset_id=offer_asset_id,
            fixed_reward=fixed_reward,
            split_reward=split_reward,
            allocate_tickets=allocate_tickets,
            tournament_data=tournament_data,
            mission_type=mission_type,
            visibility=visibility,
            preliminary_groups=preliminary_groups,
            preliminary_group_advancements=preliminary_group_advancements,
            enable_multiple_entries=enable_multiple_entries,
            enable_multiple_votes=enable_multiple_votes,
            featured=featured,
            winner_tag=winner_tag,
            tie_tag=tie_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_tournament_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The appKey the tournament is created for.")],
        title: Annotated[StrictStr, Field(description="The title of the tournament")],
        cost_to_play: Annotated[StrictInt, Field(description="The number of tickets required to pay to enter the tournament")],
        start_date: Annotated[StrictInt, Field(description="The date/time to start the tournament")],
        sub_type: Annotated[Optional[StrictStr], Field(description="Custom string client apps can use for searching/filtering tournaments")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to attach to the tournament")] = None,
        seconds_between_levels: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament game/group")] = None,
        seconds_for_tie_breaker: Annotated[Optional[StrictInt], Field(description="The number of seconds to extend the round end time in the case of a tie breaker")] = None,
        seconds_between_packs: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament round")] = None,
        maximum_level_length: Annotated[Optional[StrictInt], Field(description="The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity")] = None,
        cost_to_play_type: Annotated[Optional[StrictStr], Field(description="The type of ticket required to pay")] = None,
        minimum_to_play: Annotated[Optional[StrictInt], Field(description="The minimum number of players required to sign up for the tournament to be played")] = None,
        starting_limit: Annotated[Optional[StrictInt], Field(description="The starting number of players for a tournament (filled with AI's)")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The maximum number of players for a tournament (currently 128 but not enforced)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the tournament")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences associated with the tournament")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Activate/deactivate the tournament")] = None,
        enable_buy_back: Annotated[Optional[StrictBool], Field(description="Determines whether to allow players to buy back into a tournament")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="The list of offers to give as a reward beyond the tickets")] = None,
        offer_asset_id: Annotated[Optional[StrictInt], Field(description="The artwork ID to attach to the reward tickets offers")] = None,
        fixed_reward: Annotated[Optional[StrictBool], Field(description="If set then do not update the ticket reward, auto set to true if offerIds provided")] = None,
        split_reward: Annotated[Optional[StrictStr], Field(description="Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored")] = None,
        allocate_tickets: Annotated[Optional[StrictBool], Field(description="Flag to indicate owner should receive tickets for completed missions")] = None,
        tournament_data: Annotated[Optional[StrictStr], Field(description="A text based string that will be passed into each tournament setup to populate the content")] = None,
        mission_type: Annotated[Optional[StrictStr], Field(description="The style of tournament to build, options are: TOURNAMENT, POOLPLAY")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Sets the visibility flag for the tournament")] = None,
        preliminary_groups: Annotated[Optional[StrictInt], Field(description="The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)")] = None,
        preliminary_group_advancements: Annotated[Optional[StrictStr], Field(description="This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)")] = None,
        enable_multiple_entries: Annotated[Optional[StrictBool], Field(description="This determines if multiple submissions/entries are allowed in a multi-stage album tournament")] = None,
        enable_multiple_votes: Annotated[Optional[StrictBool], Field(description="This determines if users are allowed to vote multiple times per group in a multi-stage album tournament")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="This determines whether the tournament is \"featured\" or not")] = None,
        winner_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        tie_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a tie has occurred")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Tournament

        Create a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The appKey the tournament is created for. (required)
        :type app_key: str
        :param title: The title of the tournament (required)
        :type title: str
        :param cost_to_play: The number of tickets required to pay to enter the tournament (required)
        :type cost_to_play: int
        :param start_date: The date/time to start the tournament (required)
        :type start_date: int
        :param sub_type: Custom string client apps can use for searching/filtering tournaments
        :type sub_type: str
        :param image_asset_id: The asset ID to attach to the tournament
        :type image_asset_id: int
        :param seconds_between_levels: The number of seconds in between the start of each tournament game/group
        :type seconds_between_levels: int
        :param seconds_for_tie_breaker: The number of seconds to extend the round end time in the case of a tie breaker
        :type seconds_for_tie_breaker: int
        :param seconds_between_packs: The number of seconds in between the start of each tournament round
        :type seconds_between_packs: int
        :param maximum_level_length: The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        :type maximum_level_length: int
        :param cost_to_play_type: The type of ticket required to pay
        :type cost_to_play_type: str
        :param minimum_to_play: The minimum number of players required to sign up for the tournament to be played
        :type minimum_to_play: int
        :param starting_limit: The starting number of players for a tournament (filled with AI's)
        :type starting_limit: int
        :param available_limit: The maximum number of players for a tournament (currently 128 but not enforced)
        :type available_limit: int
        :param description: The description of the tournament
        :type description: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param audience_ids: The audiences associated with the tournament
        :type audience_ids: str
        :param active: Activate/deactivate the tournament
        :type active: bool
        :param enable_buy_back: Determines whether to allow players to buy back into a tournament
        :type enable_buy_back: bool
        :param offer_ids: The list of offers to give as a reward beyond the tickets
        :type offer_ids: str
        :param offer_asset_id: The artwork ID to attach to the reward tickets offers
        :type offer_asset_id: int
        :param fixed_reward: If set then do not update the ticket reward, auto set to true if offerIds provided
        :type fixed_reward: bool
        :param split_reward: Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        :type split_reward: str
        :param allocate_tickets: Flag to indicate owner should receive tickets for completed missions
        :type allocate_tickets: bool
        :param tournament_data: A text based string that will be passed into each tournament setup to populate the content
        :type tournament_data: str
        :param mission_type: The style of tournament to build, options are: TOURNAMENT, POOLPLAY
        :type mission_type: str
        :param visibility: Sets the visibility flag for the tournament
        :type visibility: str
        :param preliminary_groups: The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        :type preliminary_groups: int
        :param preliminary_group_advancements: This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        :type preliminary_group_advancements: str
        :param enable_multiple_entries: This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        :type enable_multiple_entries: bool
        :param enable_multiple_votes: This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        :type enable_multiple_votes: bool
        :param featured: This determines whether the tournament is \"featured\" or not
        :type featured: bool
        :param winner_tag: This sets what analytic tag is used when a winner is determined
        :type winner_tag: str
        :param tie_tag: This sets what analytic tag is used when a tie has occurred
        :type tie_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_tournament_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            title=title,
            cost_to_play=cost_to_play,
            start_date=start_date,
            sub_type=sub_type,
            image_asset_id=image_asset_id,
            seconds_between_levels=seconds_between_levels,
            seconds_for_tie_breaker=seconds_for_tie_breaker,
            seconds_between_packs=seconds_between_packs,
            maximum_level_length=maximum_level_length,
            cost_to_play_type=cost_to_play_type,
            minimum_to_play=minimum_to_play,
            starting_limit=starting_limit,
            available_limit=available_limit,
            description=description,
            meta_data=meta_data,
            audience_ids=audience_ids,
            active=active,
            enable_buy_back=enable_buy_back,
            offer_ids=offer_ids,
            offer_asset_id=offer_asset_id,
            fixed_reward=fixed_reward,
            split_reward=split_reward,
            allocate_tickets=allocate_tickets,
            tournament_data=tournament_data,
            mission_type=mission_type,
            visibility=visibility,
            preliminary_groups=preliminary_groups,
            preliminary_group_advancements=preliminary_group_advancements,
            enable_multiple_entries=enable_multiple_entries,
            enable_multiple_votes=enable_multiple_votes,
            featured=featured,
            winner_tag=winner_tag,
            tie_tag=tie_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_tournament_serialize(
        self,
        version,
        account_id,
        app_key,
        title,
        cost_to_play,
        start_date,
        sub_type,
        image_asset_id,
        seconds_between_levels,
        seconds_for_tie_breaker,
        seconds_between_packs,
        maximum_level_length,
        cost_to_play_type,
        minimum_to_play,
        starting_limit,
        available_limit,
        description,
        meta_data,
        audience_ids,
        active,
        enable_buy_back,
        offer_ids,
        offer_asset_id,
        fixed_reward,
        split_reward,
        allocate_tickets,
        tournament_data,
        mission_type,
        visibility,
        preliminary_groups,
        preliminary_group_advancements,
        enable_multiple_entries,
        enable_multiple_votes,
        featured,
        winner_tag,
        tie_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        if image_asset_id is not None:
            
            _query_params.append(('imageAssetId', image_asset_id))
            
        if seconds_between_levels is not None:
            
            _query_params.append(('secondsBetweenLevels', seconds_between_levels))
            
        if seconds_for_tie_breaker is not None:
            
            _query_params.append(('secondsForTieBreaker', seconds_for_tie_breaker))
            
        if seconds_between_packs is not None:
            
            _query_params.append(('secondsBetweenPacks', seconds_between_packs))
            
        if maximum_level_length is not None:
            
            _query_params.append(('maximumLevelLength', maximum_level_length))
            
        if cost_to_play is not None:
            
            _query_params.append(('costToPlay', cost_to_play))
            
        if cost_to_play_type is not None:
            
            _query_params.append(('costToPlayType', cost_to_play_type))
            
        if minimum_to_play is not None:
            
            _query_params.append(('minimumToPlay', minimum_to_play))
            
        if starting_limit is not None:
            
            _query_params.append(('startingLimit', starting_limit))
            
        if available_limit is not None:
            
            _query_params.append(('availableLimit', available_limit))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if enable_buy_back is not None:
            
            _query_params.append(('enableBuyBack', enable_buy_back))
            
        if offer_ids is not None:
            
            _query_params.append(('offerIds', offer_ids))
            
        if offer_asset_id is not None:
            
            _query_params.append(('offerAssetId', offer_asset_id))
            
        if fixed_reward is not None:
            
            _query_params.append(('fixedReward', fixed_reward))
            
        if split_reward is not None:
            
            _query_params.append(('splitReward', split_reward))
            
        if allocate_tickets is not None:
            
            _query_params.append(('allocateTickets', allocate_tickets))
            
        if tournament_data is not None:
            
            _query_params.append(('tournamentData', tournament_data))
            
        if mission_type is not None:
            
            _query_params.append(('missionType', mission_type))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if preliminary_groups is not None:
            
            _query_params.append(('preliminaryGroups', preliminary_groups))
            
        if preliminary_group_advancements is not None:
            
            _query_params.append(('preliminaryGroupAdvancements', preliminary_group_advancements))
            
        if enable_multiple_entries is not None:
            
            _query_params.append(('enableMultipleEntries', enable_multiple_entries))
            
        if enable_multiple_votes is not None:
            
            _query_params.append(('enableMultipleVotes', enable_multiple_votes))
            
        if featured is not None:
            
            _query_params.append(('featured', featured))
            
        if winner_tag is not None:
            
            _query_params.append(('winnerTag', winner_tag))
            
        if tie_tag is not None:
            
            _query_params.append(('tieTag', tie_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tournament/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_tournament(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        mission_id: Annotated[StrictInt, Field(description="the id of the mission to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Tournament

        Delete a tournament.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param mission_id: the id of the mission to delete (required)
        :type mission_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_tournament_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        mission_id: Annotated[StrictInt, Field(description="the id of the mission to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Tournament

        Delete a tournament.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param mission_id: the id of the mission to delete (required)
        :type mission_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_tournament_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        mission_id: Annotated[StrictInt, Field(description="the id of the mission to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Tournament

        Delete a tournament.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param mission_id: the id of the mission to delete (required)
        :type mission_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_tournament_serialize(
        self,
        version,
        account_id,
        mission_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tournament/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tournament(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The id of the logged in user")],
        mission_id: Annotated[Optional[StrictInt], Field(description="The id of the mission to return (either missionId or joinCode is required)")] = None,
        join_code: Annotated[Optional[StrictStr], Field(description="Optional identifier for getting the tournament (either missionId or joinCode is required)")] = None,
        include_scores: Annotated[Optional[StrictStr], Field(description="Determines which type of scores are returned. Possible values include: ALL, MINE")] = None,
        object_preview_size: Annotated[Optional[StrictInt], Field(description="Determines the max number of game objects that will get returned for each game level response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TournamentResponse:
        """Get Tournament

        Get a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The id of the logged in user (required)
        :type account_id: int
        :param mission_id: The id of the mission to return (either missionId or joinCode is required)
        :type mission_id: int
        :param join_code: Optional identifier for getting the tournament (either missionId or joinCode is required)
        :type join_code: str
        :param include_scores: Determines which type of scores are returned. Possible values include: ALL, MINE
        :type include_scores: str
        :param object_preview_size: Determines the max number of game objects that will get returned for each game level response
        :type object_preview_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            join_code=join_code,
            include_scores=include_scores,
            object_preview_size=object_preview_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tournament_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The id of the logged in user")],
        mission_id: Annotated[Optional[StrictInt], Field(description="The id of the mission to return (either missionId or joinCode is required)")] = None,
        join_code: Annotated[Optional[StrictStr], Field(description="Optional identifier for getting the tournament (either missionId or joinCode is required)")] = None,
        include_scores: Annotated[Optional[StrictStr], Field(description="Determines which type of scores are returned. Possible values include: ALL, MINE")] = None,
        object_preview_size: Annotated[Optional[StrictInt], Field(description="Determines the max number of game objects that will get returned for each game level response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TournamentResponse]:
        """Get Tournament

        Get a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The id of the logged in user (required)
        :type account_id: int
        :param mission_id: The id of the mission to return (either missionId or joinCode is required)
        :type mission_id: int
        :param join_code: Optional identifier for getting the tournament (either missionId or joinCode is required)
        :type join_code: str
        :param include_scores: Determines which type of scores are returned. Possible values include: ALL, MINE
        :type include_scores: str
        :param object_preview_size: Determines the max number of game objects that will get returned for each game level response
        :type object_preview_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            join_code=join_code,
            include_scores=include_scores,
            object_preview_size=object_preview_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tournament_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The id of the logged in user")],
        mission_id: Annotated[Optional[StrictInt], Field(description="The id of the mission to return (either missionId or joinCode is required)")] = None,
        join_code: Annotated[Optional[StrictStr], Field(description="Optional identifier for getting the tournament (either missionId or joinCode is required)")] = None,
        include_scores: Annotated[Optional[StrictStr], Field(description="Determines which type of scores are returned. Possible values include: ALL, MINE")] = None,
        object_preview_size: Annotated[Optional[StrictInt], Field(description="Determines the max number of game objects that will get returned for each game level response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Tournament

        Get a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The id of the logged in user (required)
        :type account_id: int
        :param mission_id: The id of the mission to return (either missionId or joinCode is required)
        :type mission_id: int
        :param join_code: Optional identifier for getting the tournament (either missionId or joinCode is required)
        :type join_code: str
        :param include_scores: Determines which type of scores are returned. Possible values include: ALL, MINE
        :type include_scores: str
        :param object_preview_size: Determines the max number of game objects that will get returned for each game level response
        :type object_preview_size: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            join_code=join_code,
            include_scores=include_scores,
            object_preview_size=object_preview_size,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tournament_serialize(
        self,
        version,
        account_id,
        mission_id,
        join_code,
        include_scores,
        object_preview_size,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if join_code is not None:
            
            _query_params.append(('joinCode', join_code))
            
        if include_scores is not None:
            
            _query_params.append(('includeScores', include_scores))
            
        if object_preview_size is not None:
            
            _query_params.append(('objectPreviewSize', object_preview_size))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tournament/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_objects(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account ID")],
        game_level_id: Annotated[StrictInt, Field(description="the game level id to filter results by")],
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Search Tournament Objects

        Search on game objects of tournaments

        :param version: (required)
        :type version: float
        :param account_id: the account ID (required)
        :type account_id: int
        :param game_level_id: the game level id to filter results by (required)
        :type game_level_id: int
        :param sort_field: the field to sort by
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_objects_serialize(
            version=version,
            account_id=account_id,
            game_level_id=game_level_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_objects_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account ID")],
        game_level_id: Annotated[StrictInt, Field(description="the game level id to filter results by")],
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Search Tournament Objects

        Search on game objects of tournaments

        :param version: (required)
        :type version: float
        :param account_id: the account ID (required)
        :type account_id: int
        :param game_level_id: the game level id to filter results by (required)
        :type game_level_id: int
        :param sort_field: the field to sort by
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_objects_serialize(
            version=version,
            account_id=account_id,
            game_level_id=game_level_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_objects_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account ID")],
        game_level_id: Annotated[StrictInt, Field(description="the game level id to filter results by")],
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Tournament Objects

        Search on game objects of tournaments

        :param version: (required)
        :type version: float
        :param account_id: the account ID (required)
        :type account_id: int
        :param game_level_id: the game level id to filter results by (required)
        :type game_level_id: int
        :param sort_field: the field to sort by
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_objects_serialize(
            version=version,
            account_id=account_id,
            game_level_id=game_level_id,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_objects_serialize(
        self,
        version,
        account_id,
        game_level_id,
        sort_field,
        descending,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if game_level_id is not None:
            
            _query_params.append(('gameLevelId', game_level_id))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tournament/object/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_rounds(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account ID")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        status: Annotated[Optional[StrictStr], Field(description="comma separated list of statuses to filter results by")] = None,
        mission_type: Annotated[Optional[StrictStr], Field(description="The style of tournament to search for, options are: TOURNAMENT, POOLPLAY")] = None,
        current_only: Annotated[Optional[StrictBool], Field(description="search for games that are flagged current only")] = None,
        visibilities: Annotated[Optional[StrictStr], Field(description="Filter tournament rounds by the mission visibility flag")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Search Tournament Rounds

        Search for the user's tournament games.

        :param version: (required)
        :type version: float
        :param account_id: the account ID (required)
        :type account_id: int
        :param app_key: the application key (required)
        :type app_key: str
        :param status: comma separated list of statuses to filter results by
        :type status: str
        :param mission_type: The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
        :type mission_type: str
        :param current_only: search for games that are flagged current only
        :type current_only: bool
        :param visibilities: Filter tournament rounds by the mission visibility flag
        :type visibilities: str
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_rounds_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            status=status,
            mission_type=mission_type,
            current_only=current_only,
            visibilities=visibilities,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_rounds_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account ID")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        status: Annotated[Optional[StrictStr], Field(description="comma separated list of statuses to filter results by")] = None,
        mission_type: Annotated[Optional[StrictStr], Field(description="The style of tournament to search for, options are: TOURNAMENT, POOLPLAY")] = None,
        current_only: Annotated[Optional[StrictBool], Field(description="search for games that are flagged current only")] = None,
        visibilities: Annotated[Optional[StrictStr], Field(description="Filter tournament rounds by the mission visibility flag")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Search Tournament Rounds

        Search for the user's tournament games.

        :param version: (required)
        :type version: float
        :param account_id: the account ID (required)
        :type account_id: int
        :param app_key: the application key (required)
        :type app_key: str
        :param status: comma separated list of statuses to filter results by
        :type status: str
        :param mission_type: The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
        :type mission_type: str
        :param current_only: search for games that are flagged current only
        :type current_only: bool
        :param visibilities: Filter tournament rounds by the mission visibility flag
        :type visibilities: str
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_rounds_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            status=status,
            mission_type=mission_type,
            current_only=current_only,
            visibilities=visibilities,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_rounds_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account ID")],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        status: Annotated[Optional[StrictStr], Field(description="comma separated list of statuses to filter results by")] = None,
        mission_type: Annotated[Optional[StrictStr], Field(description="The style of tournament to search for, options are: TOURNAMENT, POOLPLAY")] = None,
        current_only: Annotated[Optional[StrictBool], Field(description="search for games that are flagged current only")] = None,
        visibilities: Annotated[Optional[StrictStr], Field(description="Filter tournament rounds by the mission visibility flag")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Tournament Rounds

        Search for the user's tournament games.

        :param version: (required)
        :type version: float
        :param account_id: the account ID (required)
        :type account_id: int
        :param app_key: the application key (required)
        :type app_key: str
        :param status: comma separated list of statuses to filter results by
        :type status: str
        :param mission_type: The style of tournament to search for, options are: TOURNAMENT, POOLPLAY
        :type mission_type: str
        :param current_only: search for games that are flagged current only
        :type current_only: bool
        :param visibilities: Filter tournament rounds by the mission visibility flag
        :type visibilities: str
        :param start: the start index for pagination
        :type start: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_rounds_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            status=status,
            mission_type=mission_type,
            current_only=current_only,
            visibilities=visibilities,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_rounds_serialize(
        self,
        version,
        account_id,
        app_key,
        status,
        mission_type,
        current_only,
        visibilities,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if mission_type is not None:
            
            _query_params.append(('missionType', mission_type))
            
        if current_only is not None:
            
            _query_params.append(('currentOnly', current_only))
            
        if visibilities is not None:
            
            _query_params.append(('visibilities', visibilities))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tournament/round/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_tournaments(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword to search tournament on")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="filter results by subType")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="whether to include inactives in the search or not")] = None,
        mission_types: Annotated[Optional[StrictStr], Field(description="comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="filter tournaments by the tournament's current state")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="which field to sort on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> MissionShortResponse:
        """Search Tournaments

        Search for tournaments

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param keyword: the keyword to search tournament on
        :type keyword: str
        :param sub_type: filter results by subType
        :type sub_type: str
        :param include_inactive: whether to include inactives in the search or not
        :type include_inactive: bool
        :param mission_types: comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
        :type mission_types: str
        :param filter: filter tournaments by the tournament's current state
        :type filter: str
        :param sort_field: which field to sort on
        :type sort_field: str
        :param descending: Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
        :type descending: bool
        :param visibility: Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
        :type visibility: str
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tournaments_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            sub_type=sub_type,
            include_inactive=include_inactive,
            mission_types=mission_types,
            filter=filter,
            sort_field=sort_field,
            descending=descending,
            visibility=visibility,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MissionShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_tournaments_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword to search tournament on")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="filter results by subType")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="whether to include inactives in the search or not")] = None,
        mission_types: Annotated[Optional[StrictStr], Field(description="comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="filter tournaments by the tournament's current state")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="which field to sort on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[MissionShortResponse]:
        """Search Tournaments

        Search for tournaments

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param keyword: the keyword to search tournament on
        :type keyword: str
        :param sub_type: filter results by subType
        :type sub_type: str
        :param include_inactive: whether to include inactives in the search or not
        :type include_inactive: bool
        :param mission_types: comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
        :type mission_types: str
        :param filter: filter tournaments by the tournament's current state
        :type filter: str
        :param sort_field: which field to sort on
        :type sort_field: str
        :param descending: Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
        :type descending: bool
        :param visibility: Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
        :type visibility: str
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tournaments_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            sub_type=sub_type,
            include_inactive=include_inactive,
            mission_types=mission_types,
            filter=filter,
            sort_field=sort_field,
            descending=descending,
            visibility=visibility,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MissionShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_tournaments_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword to search tournament on")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="filter results by subType")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="whether to include inactives in the search or not")] = None,
        mission_types: Annotated[Optional[StrictStr], Field(description="comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE")] = None,
        filter: Annotated[Optional[StrictStr], Field(description="filter tournaments by the tournament's current state")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="which field to sort on")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Tournaments

        Search for tournaments

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param keyword: the keyword to search tournament on
        :type keyword: str
        :param sub_type: filter results by subType
        :type sub_type: str
        :param include_inactive: whether to include inactives in the search or not
        :type include_inactive: bool
        :param mission_types: comma separated list of mission types to filter results, possbile values include: TOURNAMENT, POOLPLAY, MULTISTAGE
        :type mission_types: str
        :param filter: filter tournaments by the tournament's current state
        :type filter: str
        :param sort_field: which field to sort on
        :type sort_field: str
        :param descending: Determines whether to return results in descending order. The default value will be true if the filter is \"PAST\", otherwise the default value will be false.
        :type descending: bool
        :param visibility: Comma separated list of visibility flags for search for, possible values include: PUBLIC, LISTABLE, REWARDABLE, TRIGGERABLE, PRIVATE
        :type visibility: str
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tournaments_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            sub_type=sub_type,
            include_inactive=include_inactive,
            mission_types=mission_types,
            filter=filter,
            sort_field=sort_field,
            descending=descending,
            visibility=visibility,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "MissionShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_tournaments_serialize(
        self,
        version,
        account_id,
        app_key,
        keyword,
        sub_type,
        include_inactive,
        mission_types,
        filter,
        sort_field,
        descending,
        visibility,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        if include_inactive is not None:
            
            _query_params.append(('includeInactive', include_inactive))
            
        if mission_types is not None:
            
            _query_params.append(('missionTypes', mission_types))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tournament/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def submit_tournament_score(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user account ID.")],
        app_key: Annotated[StrictStr, Field(description="The application key.")],
        mission_id: Annotated[StrictInt, Field(description="The missionId to score for")],
        game_id: Annotated[StrictInt, Field(description="The gameId to score for")],
        pack_id: Annotated[StrictInt, Field(description="The packId to score for")],
        scores: Annotated[StrictStr, Field(description="a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` ")],
        game_level_id: Annotated[Optional[StrictInt], Field(description="The gameLevelId to score for")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Submit Tournament Score

        Submit an array of scores for a tournament match. 

        :param version: (required)
        :type version: float
        :param account_id: The logged in user account ID. (required)
        :type account_id: int
        :param app_key: The application key. (required)
        :type app_key: str
        :param mission_id: The missionId to score for (required)
        :type mission_id: int
        :param game_id: The gameId to score for (required)
        :type game_id: int
        :param pack_id: The packId to score for (required)
        :type pack_id: int
        :param scores: a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ```  (required)
        :type scores: str
        :param game_level_id: The gameLevelId to score for
        :type game_level_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_tournament_score_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            scores=scores,
            game_level_id=game_level_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def submit_tournament_score_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user account ID.")],
        app_key: Annotated[StrictStr, Field(description="The application key.")],
        mission_id: Annotated[StrictInt, Field(description="The missionId to score for")],
        game_id: Annotated[StrictInt, Field(description="The gameId to score for")],
        pack_id: Annotated[StrictInt, Field(description="The packId to score for")],
        scores: Annotated[StrictStr, Field(description="a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` ")],
        game_level_id: Annotated[Optional[StrictInt], Field(description="The gameLevelId to score for")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Submit Tournament Score

        Submit an array of scores for a tournament match. 

        :param version: (required)
        :type version: float
        :param account_id: The logged in user account ID. (required)
        :type account_id: int
        :param app_key: The application key. (required)
        :type app_key: str
        :param mission_id: The missionId to score for (required)
        :type mission_id: int
        :param game_id: The gameId to score for (required)
        :type game_id: int
        :param pack_id: The packId to score for (required)
        :type pack_id: int
        :param scores: a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ```  (required)
        :type scores: str
        :param game_level_id: The gameLevelId to score for
        :type game_level_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_tournament_score_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            scores=scores,
            game_level_id=game_level_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def submit_tournament_score_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user account ID.")],
        app_key: Annotated[StrictStr, Field(description="The application key.")],
        mission_id: Annotated[StrictInt, Field(description="The missionId to score for")],
        game_id: Annotated[StrictInt, Field(description="The gameId to score for")],
        pack_id: Annotated[StrictInt, Field(description="The packId to score for")],
        scores: Annotated[StrictStr, Field(description="a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ``` ")],
        game_level_id: Annotated[Optional[StrictInt], Field(description="The gameLevelId to score for")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Submit Tournament Score

        Submit an array of scores for a tournament match. 

        :param version: (required)
        :type version: float
        :param account_id: The logged in user account ID. (required)
        :type account_id: int
        :param app_key: The application key. (required)
        :type app_key: str
        :param mission_id: The missionId to score for (required)
        :type mission_id: int
        :param game_id: The gameId to score for (required)
        :type game_id: int
        :param pack_id: The packId to score for (required)
        :type pack_id: int
        :param scores: a JSON Array of scores to submit for a tournament match ```json [   {     \"accountId\": 2,     \"points\": 3   },   {     \"accountId\": 1777662,     \"points\": 7   } ] ```  (required)
        :type scores: str
        :param game_level_id: The gameLevelId to score for
        :type game_level_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_tournament_score_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            scores=scores,
            game_level_id=game_level_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _submit_tournament_score_serialize(
        self,
        version,
        account_id,
        app_key,
        mission_id,
        game_id,
        pack_id,
        scores,
        game_level_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if game_id is not None:
            
            _query_params.append(('gameId', game_id))
            
        if pack_id is not None:
            
            _query_params.append(('packId', pack_id))
            
        if game_level_id is not None:
            
            _query_params.append(('gameLevelId', game_level_id))
            
        if scores is not None:
            
            _query_params.append(('scores', scores))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tournament/score',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def submit_tournament_vote(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application to target")],
        mission_id: Annotated[StrictInt, Field(description="The tournament's primary id")],
        game_object_id: Annotated[StrictInt, Field(description="The tournament game object the user wants to vote on")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (optional)")] = None,
        check_if_device_already_voted: Annotated[Optional[StrictBool], Field(description="When true, check if the device already voted to prevent duplicate votes from the same device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Submit a vote for a multi-stage album tournament.

        Submit a vote for a multi-stage album tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application to target (required)
        :type app_key: str
        :param mission_id: The tournament's primary id (required)
        :type mission_id: int
        :param game_object_id: The tournament game object the user wants to vote on (required)
        :type game_object_id: int
        :param device_id: The unique id of the device making the request (optional)
        :type device_id: str
        :param check_if_device_already_voted: When true, check if the device already voted to prevent duplicate votes from the same device
        :type check_if_device_already_voted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_tournament_vote_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            mission_id=mission_id,
            game_object_id=game_object_id,
            device_id=device_id,
            check_if_device_already_voted=check_if_device_already_voted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def submit_tournament_vote_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application to target")],
        mission_id: Annotated[StrictInt, Field(description="The tournament's primary id")],
        game_object_id: Annotated[StrictInt, Field(description="The tournament game object the user wants to vote on")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (optional)")] = None,
        check_if_device_already_voted: Annotated[Optional[StrictBool], Field(description="When true, check if the device already voted to prevent duplicate votes from the same device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Submit a vote for a multi-stage album tournament.

        Submit a vote for a multi-stage album tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application to target (required)
        :type app_key: str
        :param mission_id: The tournament's primary id (required)
        :type mission_id: int
        :param game_object_id: The tournament game object the user wants to vote on (required)
        :type game_object_id: int
        :param device_id: The unique id of the device making the request (optional)
        :type device_id: str
        :param check_if_device_already_voted: When true, check if the device already voted to prevent duplicate votes from the same device
        :type check_if_device_already_voted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_tournament_vote_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            mission_id=mission_id,
            game_object_id=game_object_id,
            device_id=device_id,
            check_if_device_already_voted=check_if_device_already_voted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def submit_tournament_vote_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        app_key: Annotated[StrictStr, Field(description="The application to target")],
        mission_id: Annotated[StrictInt, Field(description="The tournament's primary id")],
        game_object_id: Annotated[StrictInt, Field(description="The tournament game object the user wants to vote on")],
        device_id: Annotated[Optional[StrictStr], Field(description="The unique id of the device making the request (optional)")] = None,
        check_if_device_already_voted: Annotated[Optional[StrictBool], Field(description="When true, check if the device already voted to prevent duplicate votes from the same device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Submit a vote for a multi-stage album tournament.

        Submit a vote for a multi-stage album tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param app_key: The application to target (required)
        :type app_key: str
        :param mission_id: The tournament's primary id (required)
        :type mission_id: int
        :param game_object_id: The tournament game object the user wants to vote on (required)
        :type game_object_id: int
        :param device_id: The unique id of the device making the request (optional)
        :type device_id: str
        :param check_if_device_already_voted: When true, check if the device already voted to prevent duplicate votes from the same device
        :type check_if_device_already_voted: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._submit_tournament_vote_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            mission_id=mission_id,
            game_object_id=game_object_id,
            device_id=device_id,
            check_if_device_already_voted=check_if_device_already_voted,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _submit_tournament_vote_serialize(
        self,
        version,
        account_id,
        app_key,
        mission_id,
        game_object_id,
        device_id,
        check_if_device_already_voted,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if game_object_id is not None:
            
            _query_params.append(('gameObjectId', game_object_id))
            
        if check_if_device_already_voted is not None:
            
            _query_params.append(('checkIfDeviceAlreadyVoted', check_if_device_already_voted))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tournament/vote',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def substitute_tournament_player(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        mission_id: Annotated[StrictInt, Field(description="the id of the mission")],
        pack_id: Annotated[StrictInt, Field(description="the id of the pack")],
        game_level_id: Annotated[StrictInt, Field(description="the id of the game level")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Substitute Tournament Player

        Service to replace the user's opponent in the current level - pack - mission with an AI account.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param mission_id: the id of the mission (required)
        :type mission_id: int
        :param pack_id: the id of the pack (required)
        :type pack_id: int
        :param game_level_id: the id of the game level (required)
        :type game_level_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._substitute_tournament_player_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def substitute_tournament_player_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        mission_id: Annotated[StrictInt, Field(description="the id of the mission")],
        pack_id: Annotated[StrictInt, Field(description="the id of the pack")],
        game_level_id: Annotated[StrictInt, Field(description="the id of the game level")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Substitute Tournament Player

        Service to replace the user's opponent in the current level - pack - mission with an AI account.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param mission_id: the id of the mission (required)
        :type mission_id: int
        :param pack_id: the id of the pack (required)
        :type pack_id: int
        :param game_level_id: the id of the game level (required)
        :type game_level_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._substitute_tournament_player_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def substitute_tournament_player_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the id of the logged in user")],
        mission_id: Annotated[StrictInt, Field(description="the id of the mission")],
        pack_id: Annotated[StrictInt, Field(description="the id of the pack")],
        game_level_id: Annotated[StrictInt, Field(description="the id of the game level")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Substitute Tournament Player

        Service to replace the user's opponent in the current level - pack - mission with an AI account.

        :param version: (required)
        :type version: float
        :param account_id: the id of the logged in user (required)
        :type account_id: int
        :param mission_id: the id of the mission (required)
        :type mission_id: int
        :param pack_id: the id of the pack (required)
        :type pack_id: int
        :param game_level_id: the id of the game level (required)
        :type game_level_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._substitute_tournament_player_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _substitute_tournament_player_serialize(
        self,
        version,
        account_id,
        mission_id,
        pack_id,
        game_level_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if pack_id is not None:
            
            _query_params.append(('packId', pack_id))
            
        if game_level_id is not None:
            
            _query_params.append(('gameLevelId', game_level_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tournament/substitute',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_tournament(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        mission_id: Annotated[StrictInt, Field(description="The mission/tournament to update")],
        title: Annotated[Optional[StrictStr], Field(description="The title of the tournament")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="Custom string client apps can use for searching/filtering missions")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to attach to the tournament")] = None,
        seconds_between_levels: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament game")] = None,
        seconds_for_tie_breaker: Annotated[Optional[StrictInt], Field(description="The number of seconds to extend the round end time in the case of a tie breaker")] = None,
        seconds_between_packs: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament round")] = None,
        maximum_level_length: Annotated[Optional[StrictInt], Field(description="The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity")] = None,
        cost_to_play: Annotated[Optional[StrictInt], Field(description="The number of tickets required to pay to enter the tournament")] = None,
        cost_to_play_type: Annotated[Optional[StrictStr], Field(description="The type of ticket required to pay")] = None,
        minimum_to_play: Annotated[Optional[StrictInt], Field(description="The minimum number of players required to sign up for the tournament to be played")] = None,
        starting_limit: Annotated[Optional[StrictInt], Field(description="The starting number of players for a tournament (filled with AI's)")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The maximum number of players for a tournament (currently 128 but not enforced)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the tournament")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The date/time to start the tournament")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences associated with the tournament")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Activate/deactivate the mission")] = None,
        enable_buy_back: Annotated[Optional[StrictBool], Field(description="Determines whether to allow players to buy back into a tournament")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="The list of offers to give as a reward beyond the tickets")] = None,
        offer_asset_id: Annotated[Optional[StrictInt], Field(description="The artwork ID to attach to the reward offer")] = None,
        fixed_reward: Annotated[Optional[StrictBool], Field(description="If set then do not update the ticket reward, auto set to true if offerIds provided")] = None,
        split_reward: Annotated[Optional[StrictStr], Field(description="Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored")] = None,
        allocate_tickets: Annotated[Optional[StrictBool], Field(description="Flag to indicate owner should receive tickets for completed missions")] = None,
        tournament_data: Annotated[Optional[StrictStr], Field(description="A text based string that will be passed into each tournament setup to populate the content")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Sets the visibility flag for the tournament")] = None,
        preliminary_groups: Annotated[Optional[StrictInt], Field(description="The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)")] = None,
        preliminary_group_advancements: Annotated[Optional[StrictStr], Field(description="This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)")] = None,
        enable_multiple_entries: Annotated[Optional[StrictBool], Field(description="This determines if multiple submissions/entries are allowed in a multi-stage album tournament")] = None,
        enable_multiple_votes: Annotated[Optional[StrictBool], Field(description="This determines if users are allowed to vote multiple times per group in a multi-stage album tournament")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="This determines whether the tournament is \"featured\" or not")] = None,
        winner_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        tie_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> TournamentResponse:
        """Update Tournament

        Update a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param mission_id: The mission/tournament to update (required)
        :type mission_id: int
        :param title: The title of the tournament
        :type title: str
        :param sub_type: Custom string client apps can use for searching/filtering missions
        :type sub_type: str
        :param image_asset_id: The asset ID to attach to the tournament
        :type image_asset_id: int
        :param seconds_between_levels: The number of seconds in between the start of each tournament game
        :type seconds_between_levels: int
        :param seconds_for_tie_breaker: The number of seconds to extend the round end time in the case of a tie breaker
        :type seconds_for_tie_breaker: int
        :param seconds_between_packs: The number of seconds in between the start of each tournament round
        :type seconds_between_packs: int
        :param maximum_level_length: The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        :type maximum_level_length: int
        :param cost_to_play: The number of tickets required to pay to enter the tournament
        :type cost_to_play: int
        :param cost_to_play_type: The type of ticket required to pay
        :type cost_to_play_type: str
        :param minimum_to_play: The minimum number of players required to sign up for the tournament to be played
        :type minimum_to_play: int
        :param starting_limit: The starting number of players for a tournament (filled with AI's)
        :type starting_limit: int
        :param available_limit: The maximum number of players for a tournament (currently 128 but not enforced)
        :type available_limit: int
        :param description: The description of the tournament
        :type description: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param start_date: The date/time to start the tournament
        :type start_date: int
        :param audience_ids: The audiences associated with the tournament
        :type audience_ids: str
        :param active: Activate/deactivate the mission
        :type active: bool
        :param enable_buy_back: Determines whether to allow players to buy back into a tournament
        :type enable_buy_back: bool
        :param offer_ids: The list of offers to give as a reward beyond the tickets
        :type offer_ids: str
        :param offer_asset_id: The artwork ID to attach to the reward offer
        :type offer_asset_id: int
        :param fixed_reward: If set then do not update the ticket reward, auto set to true if offerIds provided
        :type fixed_reward: bool
        :param split_reward: Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        :type split_reward: str
        :param allocate_tickets: Flag to indicate owner should receive tickets for completed missions
        :type allocate_tickets: bool
        :param tournament_data: A text based string that will be passed into each tournament setup to populate the content
        :type tournament_data: str
        :param visibility: Sets the visibility flag for the tournament
        :type visibility: str
        :param preliminary_groups: The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        :type preliminary_groups: int
        :param preliminary_group_advancements: This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        :type preliminary_group_advancements: str
        :param enable_multiple_entries: This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        :type enable_multiple_entries: bool
        :param enable_multiple_votes: This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        :type enable_multiple_votes: bool
        :param featured: This determines whether the tournament is \"featured\" or not
        :type featured: bool
        :param winner_tag: This sets what analytic tag is used when a winner is determined
        :type winner_tag: str
        :param tie_tag: This sets what analytic tag is used when a winner is determined
        :type tie_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            title=title,
            sub_type=sub_type,
            image_asset_id=image_asset_id,
            seconds_between_levels=seconds_between_levels,
            seconds_for_tie_breaker=seconds_for_tie_breaker,
            seconds_between_packs=seconds_between_packs,
            maximum_level_length=maximum_level_length,
            cost_to_play=cost_to_play,
            cost_to_play_type=cost_to_play_type,
            minimum_to_play=minimum_to_play,
            starting_limit=starting_limit,
            available_limit=available_limit,
            description=description,
            meta_data=meta_data,
            start_date=start_date,
            audience_ids=audience_ids,
            active=active,
            enable_buy_back=enable_buy_back,
            offer_ids=offer_ids,
            offer_asset_id=offer_asset_id,
            fixed_reward=fixed_reward,
            split_reward=split_reward,
            allocate_tickets=allocate_tickets,
            tournament_data=tournament_data,
            visibility=visibility,
            preliminary_groups=preliminary_groups,
            preliminary_group_advancements=preliminary_group_advancements,
            enable_multiple_entries=enable_multiple_entries,
            enable_multiple_votes=enable_multiple_votes,
            featured=featured,
            winner_tag=winner_tag,
            tie_tag=tie_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_tournament_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        mission_id: Annotated[StrictInt, Field(description="The mission/tournament to update")],
        title: Annotated[Optional[StrictStr], Field(description="The title of the tournament")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="Custom string client apps can use for searching/filtering missions")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to attach to the tournament")] = None,
        seconds_between_levels: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament game")] = None,
        seconds_for_tie_breaker: Annotated[Optional[StrictInt], Field(description="The number of seconds to extend the round end time in the case of a tie breaker")] = None,
        seconds_between_packs: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament round")] = None,
        maximum_level_length: Annotated[Optional[StrictInt], Field(description="The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity")] = None,
        cost_to_play: Annotated[Optional[StrictInt], Field(description="The number of tickets required to pay to enter the tournament")] = None,
        cost_to_play_type: Annotated[Optional[StrictStr], Field(description="The type of ticket required to pay")] = None,
        minimum_to_play: Annotated[Optional[StrictInt], Field(description="The minimum number of players required to sign up for the tournament to be played")] = None,
        starting_limit: Annotated[Optional[StrictInt], Field(description="The starting number of players for a tournament (filled with AI's)")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The maximum number of players for a tournament (currently 128 but not enforced)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the tournament")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The date/time to start the tournament")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences associated with the tournament")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Activate/deactivate the mission")] = None,
        enable_buy_back: Annotated[Optional[StrictBool], Field(description="Determines whether to allow players to buy back into a tournament")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="The list of offers to give as a reward beyond the tickets")] = None,
        offer_asset_id: Annotated[Optional[StrictInt], Field(description="The artwork ID to attach to the reward offer")] = None,
        fixed_reward: Annotated[Optional[StrictBool], Field(description="If set then do not update the ticket reward, auto set to true if offerIds provided")] = None,
        split_reward: Annotated[Optional[StrictStr], Field(description="Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored")] = None,
        allocate_tickets: Annotated[Optional[StrictBool], Field(description="Flag to indicate owner should receive tickets for completed missions")] = None,
        tournament_data: Annotated[Optional[StrictStr], Field(description="A text based string that will be passed into each tournament setup to populate the content")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Sets the visibility flag for the tournament")] = None,
        preliminary_groups: Annotated[Optional[StrictInt], Field(description="The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)")] = None,
        preliminary_group_advancements: Annotated[Optional[StrictStr], Field(description="This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)")] = None,
        enable_multiple_entries: Annotated[Optional[StrictBool], Field(description="This determines if multiple submissions/entries are allowed in a multi-stage album tournament")] = None,
        enable_multiple_votes: Annotated[Optional[StrictBool], Field(description="This determines if users are allowed to vote multiple times per group in a multi-stage album tournament")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="This determines whether the tournament is \"featured\" or not")] = None,
        winner_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        tie_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[TournamentResponse]:
        """Update Tournament

        Update a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param mission_id: The mission/tournament to update (required)
        :type mission_id: int
        :param title: The title of the tournament
        :type title: str
        :param sub_type: Custom string client apps can use for searching/filtering missions
        :type sub_type: str
        :param image_asset_id: The asset ID to attach to the tournament
        :type image_asset_id: int
        :param seconds_between_levels: The number of seconds in between the start of each tournament game
        :type seconds_between_levels: int
        :param seconds_for_tie_breaker: The number of seconds to extend the round end time in the case of a tie breaker
        :type seconds_for_tie_breaker: int
        :param seconds_between_packs: The number of seconds in between the start of each tournament round
        :type seconds_between_packs: int
        :param maximum_level_length: The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        :type maximum_level_length: int
        :param cost_to_play: The number of tickets required to pay to enter the tournament
        :type cost_to_play: int
        :param cost_to_play_type: The type of ticket required to pay
        :type cost_to_play_type: str
        :param minimum_to_play: The minimum number of players required to sign up for the tournament to be played
        :type minimum_to_play: int
        :param starting_limit: The starting number of players for a tournament (filled with AI's)
        :type starting_limit: int
        :param available_limit: The maximum number of players for a tournament (currently 128 but not enforced)
        :type available_limit: int
        :param description: The description of the tournament
        :type description: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param start_date: The date/time to start the tournament
        :type start_date: int
        :param audience_ids: The audiences associated with the tournament
        :type audience_ids: str
        :param active: Activate/deactivate the mission
        :type active: bool
        :param enable_buy_back: Determines whether to allow players to buy back into a tournament
        :type enable_buy_back: bool
        :param offer_ids: The list of offers to give as a reward beyond the tickets
        :type offer_ids: str
        :param offer_asset_id: The artwork ID to attach to the reward offer
        :type offer_asset_id: int
        :param fixed_reward: If set then do not update the ticket reward, auto set to true if offerIds provided
        :type fixed_reward: bool
        :param split_reward: Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        :type split_reward: str
        :param allocate_tickets: Flag to indicate owner should receive tickets for completed missions
        :type allocate_tickets: bool
        :param tournament_data: A text based string that will be passed into each tournament setup to populate the content
        :type tournament_data: str
        :param visibility: Sets the visibility flag for the tournament
        :type visibility: str
        :param preliminary_groups: The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        :type preliminary_groups: int
        :param preliminary_group_advancements: This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        :type preliminary_group_advancements: str
        :param enable_multiple_entries: This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        :type enable_multiple_entries: bool
        :param enable_multiple_votes: This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        :type enable_multiple_votes: bool
        :param featured: This determines whether the tournament is \"featured\" or not
        :type featured: bool
        :param winner_tag: This sets what analytic tag is used when a winner is determined
        :type winner_tag: str
        :param tie_tag: This sets what analytic tag is used when a winner is determined
        :type tie_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            title=title,
            sub_type=sub_type,
            image_asset_id=image_asset_id,
            seconds_between_levels=seconds_between_levels,
            seconds_for_tie_breaker=seconds_for_tie_breaker,
            seconds_between_packs=seconds_between_packs,
            maximum_level_length=maximum_level_length,
            cost_to_play=cost_to_play,
            cost_to_play_type=cost_to_play_type,
            minimum_to_play=minimum_to_play,
            starting_limit=starting_limit,
            available_limit=available_limit,
            description=description,
            meta_data=meta_data,
            start_date=start_date,
            audience_ids=audience_ids,
            active=active,
            enable_buy_back=enable_buy_back,
            offer_ids=offer_ids,
            offer_asset_id=offer_asset_id,
            fixed_reward=fixed_reward,
            split_reward=split_reward,
            allocate_tickets=allocate_tickets,
            tournament_data=tournament_data,
            visibility=visibility,
            preliminary_groups=preliminary_groups,
            preliminary_group_advancements=preliminary_group_advancements,
            enable_multiple_entries=enable_multiple_entries,
            enable_multiple_votes=enable_multiple_votes,
            featured=featured,
            winner_tag=winner_tag,
            tie_tag=tie_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_tournament_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The logged in user.")],
        mission_id: Annotated[StrictInt, Field(description="The mission/tournament to update")],
        title: Annotated[Optional[StrictStr], Field(description="The title of the tournament")] = None,
        sub_type: Annotated[Optional[StrictStr], Field(description="Custom string client apps can use for searching/filtering missions")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to attach to the tournament")] = None,
        seconds_between_levels: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament game")] = None,
        seconds_for_tie_breaker: Annotated[Optional[StrictInt], Field(description="The number of seconds to extend the round end time in the case of a tie breaker")] = None,
        seconds_between_packs: Annotated[Optional[StrictInt], Field(description="The number of seconds in between the start of each tournament round")] = None,
        maximum_level_length: Annotated[Optional[StrictInt], Field(description="The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity")] = None,
        cost_to_play: Annotated[Optional[StrictInt], Field(description="The number of tickets required to pay to enter the tournament")] = None,
        cost_to_play_type: Annotated[Optional[StrictStr], Field(description="The type of ticket required to pay")] = None,
        minimum_to_play: Annotated[Optional[StrictInt], Field(description="The minimum number of players required to sign up for the tournament to be played")] = None,
        starting_limit: Annotated[Optional[StrictInt], Field(description="The starting number of players for a tournament (filled with AI's)")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The maximum number of players for a tournament (currently 128 but not enforced)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the tournament")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The date/time to start the tournament")] = None,
        audience_ids: Annotated[Optional[StrictStr], Field(description="The audiences associated with the tournament")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Activate/deactivate the mission")] = None,
        enable_buy_back: Annotated[Optional[StrictBool], Field(description="Determines whether to allow players to buy back into a tournament")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="The list of offers to give as a reward beyond the tickets")] = None,
        offer_asset_id: Annotated[Optional[StrictInt], Field(description="The artwork ID to attach to the reward offer")] = None,
        fixed_reward: Annotated[Optional[StrictBool], Field(description="If set then do not update the ticket reward, auto set to true if offerIds provided")] = None,
        split_reward: Annotated[Optional[StrictStr], Field(description="Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored")] = None,
        allocate_tickets: Annotated[Optional[StrictBool], Field(description="Flag to indicate owner should receive tickets for completed missions")] = None,
        tournament_data: Annotated[Optional[StrictStr], Field(description="A text based string that will be passed into each tournament setup to populate the content")] = None,
        visibility: Annotated[Optional[StrictStr], Field(description="Sets the visibility flag for the tournament")] = None,
        preliminary_groups: Annotated[Optional[StrictInt], Field(description="The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)")] = None,
        preliminary_group_advancements: Annotated[Optional[StrictStr], Field(description="This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)")] = None,
        enable_multiple_entries: Annotated[Optional[StrictBool], Field(description="This determines if multiple submissions/entries are allowed in a multi-stage album tournament")] = None,
        enable_multiple_votes: Annotated[Optional[StrictBool], Field(description="This determines if users are allowed to vote multiple times per group in a multi-stage album tournament")] = None,
        featured: Annotated[Optional[StrictBool], Field(description="This determines whether the tournament is \"featured\" or not")] = None,
        winner_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        tie_tag: Annotated[Optional[StrictStr], Field(description="This sets what analytic tag is used when a winner is determined")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Tournament

        Update a tournament.

        :param version: (required)
        :type version: float
        :param account_id: The logged in user. (required)
        :type account_id: int
        :param mission_id: The mission/tournament to update (required)
        :type mission_id: int
        :param title: The title of the tournament
        :type title: str
        :param sub_type: Custom string client apps can use for searching/filtering missions
        :type sub_type: str
        :param image_asset_id: The asset ID to attach to the tournament
        :type image_asset_id: int
        :param seconds_between_levels: The number of seconds in between the start of each tournament game
        :type seconds_between_levels: int
        :param seconds_for_tie_breaker: The number of seconds to extend the round end time in the case of a tie breaker
        :type seconds_for_tie_breaker: int
        :param seconds_between_packs: The number of seconds in between the start of each tournament round
        :type seconds_between_packs: int
        :param maximum_level_length: The maximum number of seconds the match is expected to end at, which gets used to determine when a match should end when there is no activity
        :type maximum_level_length: int
        :param cost_to_play: The number of tickets required to pay to enter the tournament
        :type cost_to_play: int
        :param cost_to_play_type: The type of ticket required to pay
        :type cost_to_play_type: str
        :param minimum_to_play: The minimum number of players required to sign up for the tournament to be played
        :type minimum_to_play: int
        :param starting_limit: The starting number of players for a tournament (filled with AI's)
        :type starting_limit: int
        :param available_limit: The maximum number of players for a tournament (currently 128 but not enforced)
        :type available_limit: int
        :param description: The description of the tournament
        :type description: str
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param start_date: The date/time to start the tournament
        :type start_date: int
        :param audience_ids: The audiences associated with the tournament
        :type audience_ids: str
        :param active: Activate/deactivate the mission
        :type active: bool
        :param enable_buy_back: Determines whether to allow players to buy back into a tournament
        :type enable_buy_back: bool
        :param offer_ids: The list of offers to give as a reward beyond the tickets
        :type offer_ids: str
        :param offer_asset_id: The artwork ID to attach to the reward offer
        :type offer_asset_id: int
        :param fixed_reward: If set then do not update the ticket reward, auto set to true if offerIds provided
        :type fixed_reward: bool
        :param split_reward: Set the rules for handling the reward in case of a tie, values: EVEN split the reward evenly ALL everyone gets the full reward value FIRST first score submitted RANDOM random player who scored
        :type split_reward: str
        :param allocate_tickets: Flag to indicate owner should receive tickets for completed missions
        :type allocate_tickets: bool
        :param tournament_data: A text based string that will be passed into each tournament setup to populate the content
        :type tournament_data: str
        :param visibility: Sets the visibility flag for the tournament
        :type visibility: str
        :param preliminary_groups: The number of initial preliminary groups in a multi-stage tournament (this is expected to be a power of two number)
        :type preliminary_groups: int
        :param preliminary_group_advancements: This determines how many people can advance per round in a preliminary group (this is a comma separated list of integers)
        :type preliminary_group_advancements: str
        :param enable_multiple_entries: This determines if multiple submissions/entries are allowed in a multi-stage album tournament
        :type enable_multiple_entries: bool
        :param enable_multiple_votes: This determines if users are allowed to vote multiple times per group in a multi-stage album tournament
        :type enable_multiple_votes: bool
        :param featured: This determines whether the tournament is \"featured\" or not
        :type featured: bool
        :param winner_tag: This sets what analytic tag is used when a winner is determined
        :type winner_tag: str
        :param tie_tag: This sets what analytic tag is used when a winner is determined
        :type tie_tag: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_tournament_serialize(
            version=version,
            account_id=account_id,
            mission_id=mission_id,
            title=title,
            sub_type=sub_type,
            image_asset_id=image_asset_id,
            seconds_between_levels=seconds_between_levels,
            seconds_for_tie_breaker=seconds_for_tie_breaker,
            seconds_between_packs=seconds_between_packs,
            maximum_level_length=maximum_level_length,
            cost_to_play=cost_to_play,
            cost_to_play_type=cost_to_play_type,
            minimum_to_play=minimum_to_play,
            starting_limit=starting_limit,
            available_limit=available_limit,
            description=description,
            meta_data=meta_data,
            start_date=start_date,
            audience_ids=audience_ids,
            active=active,
            enable_buy_back=enable_buy_back,
            offer_ids=offer_ids,
            offer_asset_id=offer_asset_id,
            fixed_reward=fixed_reward,
            split_reward=split_reward,
            allocate_tickets=allocate_tickets,
            tournament_data=tournament_data,
            visibility=visibility,
            preliminary_groups=preliminary_groups,
            preliminary_group_advancements=preliminary_group_advancements,
            enable_multiple_entries=enable_multiple_entries,
            enable_multiple_votes=enable_multiple_votes,
            featured=featured,
            winner_tag=winner_tag,
            tie_tag=tie_tag,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "TournamentResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_tournament_serialize(
        self,
        version,
        account_id,
        mission_id,
        title,
        sub_type,
        image_asset_id,
        seconds_between_levels,
        seconds_for_tie_breaker,
        seconds_between_packs,
        maximum_level_length,
        cost_to_play,
        cost_to_play_type,
        minimum_to_play,
        starting_limit,
        available_limit,
        description,
        meta_data,
        start_date,
        audience_ids,
        active,
        enable_buy_back,
        offer_ids,
        offer_asset_id,
        fixed_reward,
        split_reward,
        allocate_tickets,
        tournament_data,
        visibility,
        preliminary_groups,
        preliminary_group_advancements,
        enable_multiple_entries,
        enable_multiple_votes,
        featured,
        winner_tag,
        tie_tag,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if sub_type is not None:
            
            _query_params.append(('subType', sub_type))
            
        if image_asset_id is not None:
            
            _query_params.append(('imageAssetId', image_asset_id))
            
        if seconds_between_levels is not None:
            
            _query_params.append(('secondsBetweenLevels', seconds_between_levels))
            
        if seconds_for_tie_breaker is not None:
            
            _query_params.append(('secondsForTieBreaker', seconds_for_tie_breaker))
            
        if seconds_between_packs is not None:
            
            _query_params.append(('secondsBetweenPacks', seconds_between_packs))
            
        if maximum_level_length is not None:
            
            _query_params.append(('maximumLevelLength', maximum_level_length))
            
        if cost_to_play is not None:
            
            _query_params.append(('costToPlay', cost_to_play))
            
        if cost_to_play_type is not None:
            
            _query_params.append(('costToPlayType', cost_to_play_type))
            
        if minimum_to_play is not None:
            
            _query_params.append(('minimumToPlay', minimum_to_play))
            
        if starting_limit is not None:
            
            _query_params.append(('startingLimit', starting_limit))
            
        if available_limit is not None:
            
            _query_params.append(('availableLimit', available_limit))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if enable_buy_back is not None:
            
            _query_params.append(('enableBuyBack', enable_buy_back))
            
        if offer_ids is not None:
            
            _query_params.append(('offerIds', offer_ids))
            
        if offer_asset_id is not None:
            
            _query_params.append(('offerAssetId', offer_asset_id))
            
        if fixed_reward is not None:
            
            _query_params.append(('fixedReward', fixed_reward))
            
        if split_reward is not None:
            
            _query_params.append(('splitReward', split_reward))
            
        if allocate_tickets is not None:
            
            _query_params.append(('allocateTickets', allocate_tickets))
            
        if tournament_data is not None:
            
            _query_params.append(('tournamentData', tournament_data))
            
        if visibility is not None:
            
            _query_params.append(('visibility', visibility))
            
        if preliminary_groups is not None:
            
            _query_params.append(('preliminaryGroups', preliminary_groups))
            
        if preliminary_group_advancements is not None:
            
            _query_params.append(('preliminaryGroupAdvancements', preliminary_group_advancements))
            
        if enable_multiple_entries is not None:
            
            _query_params.append(('enableMultipleEntries', enable_multiple_entries))
            
        if enable_multiple_votes is not None:
            
            _query_params.append(('enableMultipleVotes', enable_multiple_votes))
            
        if featured is not None:
            
            _query_params.append(('featured', featured))
            
        if winner_tag is not None:
            
            _query_params.append(('winnerTag', winner_tag))
            
        if tie_tag is not None:
            
            _query_params.append(('tieTag', tie_tag))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tournament/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


