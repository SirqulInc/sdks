# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictInt, StrictStr
from typing import Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.leaderboard_response import LeaderboardResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class LeaderboardApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_leaderboard(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user creating the leaderboard.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword")] = None,
        icon_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard icon")] = None,
        banner_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)")] = None,
        banner_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard banner")] = None,
        limitation: Annotated[Optional[StrictInt], Field(description="limit number of rankings for each leaderboard")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST")] = None,
        title: Annotated[Optional[StrictStr], Field(description="leaderboard's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="leaderboard's description")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="custom meta data for the leaderboard")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LeaderboardResponse:
        """Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        :param account_id: The account id of the user creating the leaderboard.
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
        :type leaderboard_mode: str
        :param icon_media: a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        :type icon_media: bytearray
        :param icon_asset_id: The asset ID to set the leaderboard icon
        :type icon_asset_id: int
        :param banner_media: a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        :type banner_media: bytearray
        :param banner_asset_id: The asset ID to set the leaderboard banner
        :type banner_asset_id: int
        :param limitation: limit number of rankings for each leaderboard
        :type limitation: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param title: leaderboard's title
        :type title: str
        :param description: leaderboard's description
        :type description: str
        :param meta_data: custom meta data for the leaderboard
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_leaderboard_serialize(
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            icon_media=icon_media,
            icon_asset_id=icon_asset_id,
            banner_media=banner_media,
            banner_asset_id=banner_asset_id,
            limitation=limitation,
            sort_field=sort_field,
            title=title,
            description=description,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_leaderboard_with_http_info(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user creating the leaderboard.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword")] = None,
        icon_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard icon")] = None,
        banner_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)")] = None,
        banner_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard banner")] = None,
        limitation: Annotated[Optional[StrictInt], Field(description="limit number of rankings for each leaderboard")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST")] = None,
        title: Annotated[Optional[StrictStr], Field(description="leaderboard's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="leaderboard's description")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="custom meta data for the leaderboard")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LeaderboardResponse]:
        """Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        :param account_id: The account id of the user creating the leaderboard.
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
        :type leaderboard_mode: str
        :param icon_media: a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        :type icon_media: bytearray
        :param icon_asset_id: The asset ID to set the leaderboard icon
        :type icon_asset_id: int
        :param banner_media: a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        :type banner_media: bytearray
        :param banner_asset_id: The asset ID to set the leaderboard banner
        :type banner_asset_id: int
        :param limitation: limit number of rankings for each leaderboard
        :type limitation: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param title: leaderboard's title
        :type title: str
        :param description: leaderboard's description
        :type description: str
        :param meta_data: custom meta data for the leaderboard
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_leaderboard_serialize(
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            icon_media=icon_media,
            icon_asset_id=icon_asset_id,
            banner_media=banner_media,
            banner_asset_id=banner_asset_id,
            limitation=limitation,
            sort_field=sort_field,
            title=title,
            description=description,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_leaderboard_without_preload_content(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user creating the leaderboard.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword")] = None,
        icon_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard icon")] = None,
        banner_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)")] = None,
        banner_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard banner")] = None,
        limitation: Annotated[Optional[StrictInt], Field(description="limit number of rankings for each leaderboard")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST")] = None,
        title: Annotated[Optional[StrictStr], Field(description="leaderboard's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="leaderboard's description")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="custom meta data for the leaderboard")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        Create a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        :param account_id: The account id of the user creating the leaderboard.
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking); LOCAL - filters results by select users and on users that have logged into the same device; SEARCH - does a GLOBAL search by keyword; CUSTOM - does a LOCAL search by keyword
        :type leaderboard_mode: str
        :param icon_media: a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        :type icon_media: bytearray
        :param icon_asset_id: The asset ID to set the leaderboard icon
        :type icon_asset_id: int
        :param banner_media: a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        :type banner_media: bytearray
        :param banner_asset_id: The asset ID to set the leaderboard banner
        :type banner_asset_id: int
        :param limitation: limit number of rankings for each leaderboard
        :type limitation: int
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param title: leaderboard's title
        :type title: str
        :param description: leaderboard's description
        :type description: str
        :param meta_data: custom meta data for the leaderboard
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_leaderboard_serialize(
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            icon_media=icon_media,
            icon_asset_id=icon_asset_id,
            banner_media=banner_media,
            banner_asset_id=banner_asset_id,
            limitation=limitation,
            sort_field=sort_field,
            title=title,
            description=description,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_leaderboard_serialize(
        self,
        account_id,
        app_key,
        rank_type,
        leaderboard_mode,
        icon_media,
        icon_asset_id,
        banner_media,
        banner_asset_id,
        limitation,
        sort_field,
        title,
        description,
        meta_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if leaderboard_mode is not None:
            
            _query_params.append(('leaderboardMode', leaderboard_mode))
            
        if icon_media is not None:
            
            _query_params.append(('iconMedia', icon_media))
            
        if icon_asset_id is not None:
            
            _query_params.append(('iconAssetId', icon_asset_id))
            
        if banner_media is not None:
            
            _query_params.append(('bannerMedia', banner_media))
            
        if banner_asset_id is not None:
            
            _query_params.append(('bannerAssetId', banner_asset_id))
            
        if limitation is not None:
            
            _query_params.append(('limitation', limitation))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/leaderboard/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_leaderboard(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id to delete.")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user making the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete the Leader Board

        Removes a leader board id.

        :param leaderboard_id: The leaderboard id to delete. (required)
        :type leaderboard_id: int
        :param account_id: The account id of the user making the request.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_leaderboard_with_http_info(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id to delete.")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user making the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete the Leader Board

        Removes a leader board id.

        :param leaderboard_id: The leaderboard id to delete. (required)
        :type leaderboard_id: int
        :param account_id: The account id of the user making the request.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_leaderboard_without_preload_content(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id to delete.")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user making the request.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete the Leader Board

        Removes a leader board id.

        :param leaderboard_id: The leaderboard id to delete. (required)
        :type leaderboard_id: int
        :param account_id: The account id of the user making the request.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_leaderboard_serialize(
        self,
        leaderboard_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if leaderboard_id is not None:
            
            _query_params.append(('leaderboardId', leaderboard_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/leaderboard/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_leaderboard(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id.")],
        account_id: Annotated[Optional[StrictInt], Field(description="A valid account.")] = None,
        include_full_ranking_list: Annotated[Optional[StrictBool], Field(description="set to true if need to return the leaderboard's full ranking list")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LeaderboardResponse:
        """Read a leaderboard by id and retrieve the matching ranking list

        Read a leaderboard by id and retrieve the matching ranking list

        :param leaderboard_id: The leaderboard id. (required)
        :type leaderboard_id: int
        :param account_id: A valid account.
        :type account_id: int
        :param include_full_ranking_list: set to true if need to return the leaderboard's full ranking list
        :type include_full_ranking_list: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            include_full_ranking_list=include_full_ranking_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_leaderboard_with_http_info(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id.")],
        account_id: Annotated[Optional[StrictInt], Field(description="A valid account.")] = None,
        include_full_ranking_list: Annotated[Optional[StrictBool], Field(description="set to true if need to return the leaderboard's full ranking list")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LeaderboardResponse]:
        """Read a leaderboard by id and retrieve the matching ranking list

        Read a leaderboard by id and retrieve the matching ranking list

        :param leaderboard_id: The leaderboard id. (required)
        :type leaderboard_id: int
        :param account_id: A valid account.
        :type account_id: int
        :param include_full_ranking_list: set to true if need to return the leaderboard's full ranking list
        :type include_full_ranking_list: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            include_full_ranking_list=include_full_ranking_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_leaderboard_without_preload_content(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id.")],
        account_id: Annotated[Optional[StrictInt], Field(description="A valid account.")] = None,
        include_full_ranking_list: Annotated[Optional[StrictBool], Field(description="set to true if need to return the leaderboard's full ranking list")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Read a leaderboard by id and retrieve the matching ranking list

        Read a leaderboard by id and retrieve the matching ranking list

        :param leaderboard_id: The leaderboard id. (required)
        :type leaderboard_id: int
        :param account_id: A valid account.
        :type account_id: int
        :param include_full_ranking_list: set to true if need to return the leaderboard's full ranking list
        :type include_full_ranking_list: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            include_full_ranking_list=include_full_ranking_list,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_leaderboard_serialize(
        self,
        leaderboard_id,
        account_id,
        include_full_ranking_list,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if leaderboard_id is not None:
            
            _query_params.append(('leaderboardId', leaderboard_id))
            
        if include_full_ranking_list is not None:
            
            _query_params.append(('includeFullRankingList', include_full_ranking_list))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/leaderboard/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_leaderboards(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user requesting the search.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key.")] = None,
        global_only: Annotated[Optional[StrictBool], Field(description="only include global leaderboards (this overrides the appKey filter)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search by title")] = None,
        leaderboard_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of leaderboard ids to filter results with")] = None,
        rank_types: Annotated[Optional[StrictStr], Field(description="comma separated list of rankType to filter results with")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="include inactive in the result")] = None,
        include_app_response: Annotated[Optional[StrictBool], Field(description="determines whether to include the application response for each leaderboard")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LeaderboardResponse:
        """Search leaderboard and retrieve the matching ranking list

        Search leaderboard and retrieve the matching ranking list

        :param account_id: The account id of the user requesting the search.
        :type account_id: int
        :param app_key: The application key.
        :type app_key: str
        :param global_only: only include global leaderboards (this overrides the appKey filter)
        :type global_only: bool
        :param keyword: keyword to search by title
        :type keyword: str
        :param leaderboard_ids: comma separated list of leaderboard ids to filter results with
        :type leaderboard_ids: str
        :param rank_types: comma separated list of rankType to filter results with
        :type rank_types: str
        :param sort_field: sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param include_inactive: include inactive in the result
        :type include_inactive: bool
        :param include_app_response: determines whether to include the application response for each leaderboard
        :type include_app_response: bool
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_leaderboards_serialize(
            account_id=account_id,
            app_key=app_key,
            global_only=global_only,
            keyword=keyword,
            leaderboard_ids=leaderboard_ids,
            rank_types=rank_types,
            sort_field=sort_field,
            descending=descending,
            include_inactive=include_inactive,
            include_app_response=include_app_response,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_leaderboards_with_http_info(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user requesting the search.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key.")] = None,
        global_only: Annotated[Optional[StrictBool], Field(description="only include global leaderboards (this overrides the appKey filter)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search by title")] = None,
        leaderboard_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of leaderboard ids to filter results with")] = None,
        rank_types: Annotated[Optional[StrictStr], Field(description="comma separated list of rankType to filter results with")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="include inactive in the result")] = None,
        include_app_response: Annotated[Optional[StrictBool], Field(description="determines whether to include the application response for each leaderboard")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LeaderboardResponse]:
        """Search leaderboard and retrieve the matching ranking list

        Search leaderboard and retrieve the matching ranking list

        :param account_id: The account id of the user requesting the search.
        :type account_id: int
        :param app_key: The application key.
        :type app_key: str
        :param global_only: only include global leaderboards (this overrides the appKey filter)
        :type global_only: bool
        :param keyword: keyword to search by title
        :type keyword: str
        :param leaderboard_ids: comma separated list of leaderboard ids to filter results with
        :type leaderboard_ids: str
        :param rank_types: comma separated list of rankType to filter results with
        :type rank_types: str
        :param sort_field: sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param include_inactive: include inactive in the result
        :type include_inactive: bool
        :param include_app_response: determines whether to include the application response for each leaderboard
        :type include_app_response: bool
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_leaderboards_serialize(
            account_id=account_id,
            app_key=app_key,
            global_only=global_only,
            keyword=keyword,
            leaderboard_ids=leaderboard_ids,
            rank_types=rank_types,
            sort_field=sort_field,
            descending=descending,
            include_inactive=include_inactive,
            include_app_response=include_app_response,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_leaderboards_without_preload_content(
        self,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user requesting the search.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key.")] = None,
        global_only: Annotated[Optional[StrictBool], Field(description="only include global leaderboards (this overrides the appKey filter)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search by title")] = None,
        leaderboard_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of leaderboard ids to filter results with")] = None,
        rank_types: Annotated[Optional[StrictStr], Field(description="comma separated list of rankType to filter results with")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        include_inactive: Annotated[Optional[StrictBool], Field(description="include inactive in the result")] = None,
        include_app_response: Annotated[Optional[StrictBool], Field(description="determines whether to include the application response for each leaderboard")] = None,
        start: Annotated[Optional[StrictInt], Field(description="Start the result set at some index.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="Limit the result to some number.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search leaderboard and retrieve the matching ranking list

        Search leaderboard and retrieve the matching ranking list

        :param account_id: The account id of the user requesting the search.
        :type account_id: int
        :param app_key: The application key.
        :type app_key: str
        :param global_only: only include global leaderboards (this overrides the appKey filter)
        :type global_only: bool
        :param keyword: keyword to search by title
        :type keyword: str
        :param leaderboard_ids: comma separated list of leaderboard ids to filter results with
        :type leaderboard_ids: str
        :param rank_types: comma separated list of rankType to filter results with
        :type rank_types: str
        :param sort_field: sortField of the result, from LeaderboardApiMap (TITLE, DESCRIPTION, CREATED, UPDATED, RANK_TYPE, RANK_MODE)
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param include_inactive: include inactive in the result
        :type include_inactive: bool
        :param include_app_response: determines whether to include the application response for each leaderboard
        :type include_app_response: bool
        :param start: Start the result set at some index.
        :type start: int
        :param limit: Limit the result to some number.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_leaderboards_serialize(
            account_id=account_id,
            app_key=app_key,
            global_only=global_only,
            keyword=keyword,
            leaderboard_ids=leaderboard_ids,
            rank_types=rank_types,
            sort_field=sort_field,
            descending=descending,
            include_inactive=include_inactive,
            include_app_response=include_app_response,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_leaderboards_serialize(
        self,
        account_id,
        app_key,
        global_only,
        keyword,
        leaderboard_ids,
        rank_types,
        sort_field,
        descending,
        include_inactive,
        include_app_response,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if global_only is not None:
            
            _query_params.append(('globalOnly', global_only))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if leaderboard_ids is not None:
            
            _query_params.append(('leaderboardIds', leaderboard_ids))
            
        if rank_types is not None:
            
            _query_params.append(('rankTypes', rank_types))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if include_inactive is not None:
            
            _query_params.append(('includeInactive', include_inactive))
            
        if include_app_response is not None:
            
            _query_params.append(('includeAppResponse', include_app_response))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/leaderboard/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_leaderboard(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id to update.")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user updating the leaderboard.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST")] = None,
        icon_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard icon")] = None,
        banner_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)")] = None,
        banner_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard banner")] = None,
        limitation: Annotated[Optional[StrictInt], Field(description="limit number of rankings for each leaderboard")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Whether the leaderboard is active")] = None,
        title: Annotated[Optional[StrictStr], Field(description="leaderboard's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="leaderboard's description")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="custom meta data for the leaderboard")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LeaderboardResponse:
        """Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        :param leaderboard_id: The leaderboard id to update. (required)
        :type leaderboard_id: int
        :param account_id: The account id of the user updating the leaderboard.
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        :type leaderboard_mode: str
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param icon_media: a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        :type icon_media: bytearray
        :param icon_asset_id: The asset ID to set the leaderboard icon
        :type icon_asset_id: int
        :param banner_media: a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        :type banner_media: bytearray
        :param banner_asset_id: The asset ID to set the leaderboard banner
        :type banner_asset_id: int
        :param limitation: limit number of rankings for each leaderboard
        :type limitation: int
        :param active: Whether the leaderboard is active
        :type active: bool
        :param title: leaderboard's title
        :type title: str
        :param description: leaderboard's description
        :type description: str
        :param meta_data: custom meta data for the leaderboard
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            sort_field=sort_field,
            icon_media=icon_media,
            icon_asset_id=icon_asset_id,
            banner_media=banner_media,
            banner_asset_id=banner_asset_id,
            limitation=limitation,
            active=active,
            title=title,
            description=description,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_leaderboard_with_http_info(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id to update.")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user updating the leaderboard.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST")] = None,
        icon_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard icon")] = None,
        banner_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)")] = None,
        banner_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard banner")] = None,
        limitation: Annotated[Optional[StrictInt], Field(description="limit number of rankings for each leaderboard")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Whether the leaderboard is active")] = None,
        title: Annotated[Optional[StrictStr], Field(description="leaderboard's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="leaderboard's description")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="custom meta data for the leaderboard")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LeaderboardResponse]:
        """Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        :param leaderboard_id: The leaderboard id to update. (required)
        :type leaderboard_id: int
        :param account_id: The account id of the user updating the leaderboard.
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        :type leaderboard_mode: str
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param icon_media: a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        :type icon_media: bytearray
        :param icon_asset_id: The asset ID to set the leaderboard icon
        :type icon_asset_id: int
        :param banner_media: a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        :type banner_media: bytearray
        :param banner_asset_id: The asset ID to set the leaderboard banner
        :type banner_asset_id: int
        :param limitation: limit number of rankings for each leaderboard
        :type limitation: int
        :param active: Whether the leaderboard is active
        :type active: bool
        :param title: leaderboard's title
        :type title: str
        :param description: leaderboard's description
        :type description: str
        :param meta_data: custom meta data for the leaderboard
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            sort_field=sort_field,
            icon_media=icon_media,
            icon_asset_id=icon_asset_id,
            banner_media=banner_media,
            banner_asset_id=banner_asset_id,
            limitation=limitation,
            active=active,
            title=title,
            description=description,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_leaderboard_without_preload_content(
        self,
        leaderboard_id: Annotated[StrictInt, Field(description="The leaderboard id to update.")],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user updating the leaderboard.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.")] = None,
        leaderboard_mode: Annotated[Optional[StrictStr], Field(description="the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST")] = None,
        icon_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard icon")] = None,
        banner_media: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)")] = None,
        banner_asset_id: Annotated[Optional[StrictInt], Field(description="The asset ID to set the leaderboard banner")] = None,
        limitation: Annotated[Optional[StrictInt], Field(description="limit number of rankings for each leaderboard")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Whether the leaderboard is active")] = None,
        title: Annotated[Optional[StrictStr], Field(description="leaderboard's title")] = None,
        description: Annotated[Optional[StrictStr], Field(description="leaderboard's description")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="custom meta data for the leaderboard")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        Update a leaderboard based on the rankingType, rankMode(leaderboardMode), sortField and limitation

        :param leaderboard_id: The leaderboard id to update. (required)
        :type leaderboard_id: int
        :param account_id: The account id of the user updating the leaderboard.
        :type account_id: int
        :param app_key: The application key
        :type app_key: str
        :param rank_type: a unique label for identifying the ranking. This can be any alphanumeric string with a maximum length of 64 characters.
        :type rank_type: str
        :param leaderboard_mode: the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM
        :type leaderboard_mode: str
        :param sort_field: determines how to order and rank the results. Possible values include: TOTAL, WEEKLY, DAILY, TOP, LOWEST
        :type sort_field: str
        :param icon_media: a MultipartFile containing the icon image of the leaderboard (this will only be used if \"iconAssetId\" is empty)
        :type icon_media: bytearray
        :param icon_asset_id: The asset ID to set the leaderboard icon
        :type icon_asset_id: int
        :param banner_media: a MultipartFile containing the icon banner of the leaderboard (this will only be used if \"bannerAssetId\" is empty)
        :type banner_media: bytearray
        :param banner_asset_id: The asset ID to set the leaderboard banner
        :type banner_asset_id: int
        :param limitation: limit number of rankings for each leaderboard
        :type limitation: int
        :param active: Whether the leaderboard is active
        :type active: bool
        :param title: leaderboard's title
        :type title: str
        :param description: leaderboard's description
        :type description: str
        :param meta_data: custom meta data for the leaderboard
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_leaderboard_serialize(
            leaderboard_id=leaderboard_id,
            account_id=account_id,
            app_key=app_key,
            rank_type=rank_type,
            leaderboard_mode=leaderboard_mode,
            sort_field=sort_field,
            icon_media=icon_media,
            icon_asset_id=icon_asset_id,
            banner_media=banner_media,
            banner_asset_id=banner_asset_id,
            limitation=limitation,
            active=active,
            title=title,
            description=description,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LeaderboardResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_leaderboard_serialize(
        self,
        leaderboard_id,
        account_id,
        app_key,
        rank_type,
        leaderboard_mode,
        sort_field,
        icon_media,
        icon_asset_id,
        banner_media,
        banner_asset_id,
        limitation,
        active,
        title,
        description,
        meta_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if leaderboard_id is not None:
            
            _query_params.append(('leaderboardId', leaderboard_id))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if leaderboard_mode is not None:
            
            _query_params.append(('leaderboardMode', leaderboard_mode))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if icon_media is not None:
            
            _query_params.append(('iconMedia', icon_media))
            
        if icon_asset_id is not None:
            
            _query_params.append(('iconAssetId', icon_asset_id))
            
        if banner_media is not None:
            
            _query_params.append(('bannerMedia', banner_media))
            
        if banner_asset_id is not None:
            
            _query_params.append(('bannerAssetId', banner_asset_id))
            
        if limitation is not None:
            
            _query_params.append(('limitation', limitation))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/leaderboard/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


