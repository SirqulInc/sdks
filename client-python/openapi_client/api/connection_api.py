# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.connection_group_response import ConnectionGroupResponse
from openapi_client.models.connection_info_response import ConnectionInfoResponse
from openapi_client.models.connection_list_response import ConnectionListResponse
from openapi_client.models.connection_response import ConnectionResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class ConnectionApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def add_connection_to_group(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Add Connection

        Adds a connection to a group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id
        :type connection_id: int
        :param connection_account_id: the connection account id
        :type connection_account_id: int
        :param pending_id: the pending id
        :type pending_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_connection_to_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_connection_to_group_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Add Connection

        Adds a connection to a group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id
        :type connection_id: int
        :param connection_account_id: the connection account id
        :type connection_account_id: int
        :param pending_id: the pending id
        :type pending_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_connection_to_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_connection_to_group_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add Connection

        Adds a connection to a group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id
        :type connection_id: int
        :param connection_account_id: the connection account id
        :type connection_account_id: int
        :param pending_id: the pending id
        :type pending_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_connection_to_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_connection_to_group_serialize(
        self,
        return_nulls,
        group_id,
        device_id,
        account_id,
        connection_id,
        connection_account_id,
        pending_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_id is not None:
            
            _query_params.append(('connectionId', connection_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if pending_id is not None:
            
            _query_params.append(('pendingId', pending_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/group/addConnection',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_connections_to_group(
        self,
        connection_group_id: Annotated[StrictInt, Field(description="the connection group ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection ids")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection account ids")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Add Connections

        Adds a list of connections to a group.

        :param connection_group_id: the connection group ID (required)
        :type connection_group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: comma separated list of connection ids
        :type connection_ids: str
        :param connection_account_ids: comma separated list of connection account ids
        :type connection_account_ids: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_connections_to_group_serialize(
            connection_group_id=connection_group_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_connections_to_group_with_http_info(
        self,
        connection_group_id: Annotated[StrictInt, Field(description="the connection group ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection ids")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection account ids")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Add Connections

        Adds a list of connections to a group.

        :param connection_group_id: the connection group ID (required)
        :type connection_group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: comma separated list of connection ids
        :type connection_ids: str
        :param connection_account_ids: comma separated list of connection account ids
        :type connection_account_ids: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_connections_to_group_serialize(
            connection_group_id=connection_group_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_connections_to_group_without_preload_content(
        self,
        connection_group_id: Annotated[StrictInt, Field(description="the connection group ID")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection ids")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection account ids")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add Connections

        Adds a list of connections to a group.

        :param connection_group_id: the connection group ID (required)
        :type connection_group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: comma separated list of connection ids
        :type connection_ids: str
        :param connection_account_ids: comma separated list of connection account ids
        :type connection_account_ids: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_connections_to_group_serialize(
            connection_group_id=connection_group_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_connections_to_group_serialize(
        self,
        connection_group_id,
        device_id,
        account_id,
        connection_ids,
        connection_account_ids,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_ids is not None:
            
            _query_params.append(('connectionIds', connection_ids))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if connection_group_id is not None:
            
            _query_params.append(('connectionGroupId', connection_group_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/connection/group/addConnections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def add_sub_groups(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the parent group id")],
        sub_group_ids: Annotated[StrictStr, Field(description="comma separated list of group IDs to add to the parent group")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConnectionGroupResponse:
        """Add Connection Groups

        Add sub groups to a group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the parent group id (required)
        :type group_id: int
        :param sub_group_ids: comma separated list of group IDs to add to the parent group (required)
        :type sub_group_ids: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_sub_groups_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            sub_group_ids=sub_group_ids,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def add_sub_groups_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the parent group id")],
        sub_group_ids: Annotated[StrictStr, Field(description="comma separated list of group IDs to add to the parent group")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConnectionGroupResponse]:
        """Add Connection Groups

        Add sub groups to a group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the parent group id (required)
        :type group_id: int
        :param sub_group_ids: comma separated list of group IDs to add to the parent group (required)
        :type sub_group_ids: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_sub_groups_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            sub_group_ids=sub_group_ids,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def add_sub_groups_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the parent group id")],
        sub_group_ids: Annotated[StrictStr, Field(description="comma separated list of group IDs to add to the parent group")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Add Connection Groups

        Add sub groups to a group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the parent group id (required)
        :type group_id: int
        :param sub_group_ids: comma separated list of group IDs to add to the parent group (required)
        :type sub_group_ids: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._add_sub_groups_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            sub_group_ids=sub_group_ids,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _add_sub_groups_serialize(
        self,
        return_nulls,
        group_id,
        sub_group_ids,
        device_id,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if sub_group_ids is not None:
            
            _query_params.append(('subGroupIds', sub_group_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/group/addSubGroup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_or_update_connection(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id for editing")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id (i.e. the account id of another user)")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="optional group id if the user wants to add this person into a group")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        is_trusted: Annotated[Optional[StrictBool], Field(description="determines whether the user is trusting this account")] = None,
        ignore_friend_request: Annotated[Optional[StrictBool], Field(description="determines whether the user has set to ignore the user's friend request")] = None,
        is_contact: Annotated[Optional[StrictBool], Field(description="determines whether the user is a contact of this account")] = None,
        is_blocked: Annotated[Optional[StrictBool], Field(description="determines whether the user is blocking this account")] = None,
        is_following: Annotated[Optional[StrictBool], Field(description="determines whether the user is following this account")] = None,
        connection_response: Annotated[Optional[StrictBool], Field(description="whether to return the connection response or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConnectionResponse:
        """Create or Update Connection

        Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.

        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id for editing
        :type connection_id: int
        :param connection_account_id: the connection account id (i.e. the account id of another user)
        :type connection_account_id: int
        :param pending_id: the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
        :type pending_id: int
        :param group_id: optional group id if the user wants to add this person into a group
        :type group_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param is_trusted: determines whether the user is trusting this account
        :type is_trusted: bool
        :param ignore_friend_request: determines whether the user has set to ignore the user's friend request
        :type ignore_friend_request: bool
        :param is_contact: determines whether the user is a contact of this account
        :type is_contact: bool
        :param is_blocked: determines whether the user is blocking this account
        :type is_blocked: bool
        :param is_following: determines whether the user is following this account
        :type is_following: bool
        :param connection_response: whether to return the connection response or not
        :type connection_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_connection_serialize(
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            group_id=group_id,
            game_type=game_type,
            app_key=app_key,
            is_trusted=is_trusted,
            ignore_friend_request=ignore_friend_request,
            is_contact=is_contact,
            is_blocked=is_blocked,
            is_following=is_following,
            connection_response=connection_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_or_update_connection_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id for editing")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id (i.e. the account id of another user)")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="optional group id if the user wants to add this person into a group")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        is_trusted: Annotated[Optional[StrictBool], Field(description="determines whether the user is trusting this account")] = None,
        ignore_friend_request: Annotated[Optional[StrictBool], Field(description="determines whether the user has set to ignore the user's friend request")] = None,
        is_contact: Annotated[Optional[StrictBool], Field(description="determines whether the user is a contact of this account")] = None,
        is_blocked: Annotated[Optional[StrictBool], Field(description="determines whether the user is blocking this account")] = None,
        is_following: Annotated[Optional[StrictBool], Field(description="determines whether the user is following this account")] = None,
        connection_response: Annotated[Optional[StrictBool], Field(description="whether to return the connection response or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConnectionResponse]:
        """Create or Update Connection

        Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.

        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id for editing
        :type connection_id: int
        :param connection_account_id: the connection account id (i.e. the account id of another user)
        :type connection_account_id: int
        :param pending_id: the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
        :type pending_id: int
        :param group_id: optional group id if the user wants to add this person into a group
        :type group_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param is_trusted: determines whether the user is trusting this account
        :type is_trusted: bool
        :param ignore_friend_request: determines whether the user has set to ignore the user's friend request
        :type ignore_friend_request: bool
        :param is_contact: determines whether the user is a contact of this account
        :type is_contact: bool
        :param is_blocked: determines whether the user is blocking this account
        :type is_blocked: bool
        :param is_following: determines whether the user is following this account
        :type is_following: bool
        :param connection_response: whether to return the connection response or not
        :type connection_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_connection_serialize(
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            group_id=group_id,
            game_type=game_type,
            app_key=app_key,
            is_trusted=is_trusted,
            ignore_friend_request=ignore_friend_request,
            is_contact=is_contact,
            is_blocked=is_blocked,
            is_following=is_following,
            connection_response=connection_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_or_update_connection_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id for editing")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id (i.e. the account id of another user)")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="optional group id if the user wants to add this person into a group")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        is_trusted: Annotated[Optional[StrictBool], Field(description="determines whether the user is trusting this account")] = None,
        ignore_friend_request: Annotated[Optional[StrictBool], Field(description="determines whether the user has set to ignore the user's friend request")] = None,
        is_contact: Annotated[Optional[StrictBool], Field(description="determines whether the user is a contact of this account")] = None,
        is_blocked: Annotated[Optional[StrictBool], Field(description="determines whether the user is blocking this account")] = None,
        is_following: Annotated[Optional[StrictBool], Field(description="determines whether the user is following this account")] = None,
        connection_response: Annotated[Optional[StrictBool], Field(description="whether to return the connection response or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or Update Connection

        Creates or updates the connection of the user and another account. Allows a user to follow, block, mark as trusted, and/or add someone to a group.

        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id for editing
        :type connection_id: int
        :param connection_account_id: the connection account id (i.e. the account id of another user)
        :type connection_account_id: int
        :param pending_id: the pending id (usually for people who do not have a Sirqul account but are already friends via other third party apps)
        :type pending_id: int
        :param group_id: optional group id if the user wants to add this person into a group
        :type group_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param is_trusted: determines whether the user is trusting this account
        :type is_trusted: bool
        :param ignore_friend_request: determines whether the user has set to ignore the user's friend request
        :type ignore_friend_request: bool
        :param is_contact: determines whether the user is a contact of this account
        :type is_contact: bool
        :param is_blocked: determines whether the user is blocking this account
        :type is_blocked: bool
        :param is_following: determines whether the user is following this account
        :type is_following: bool
        :param connection_response: whether to return the connection response or not
        :type connection_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_connection_serialize(
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            group_id=group_id,
            game_type=game_type,
            app_key=app_key,
            is_trusted=is_trusted,
            ignore_friend_request=ignore_friend_request,
            is_contact=is_contact,
            is_blocked=is_blocked,
            is_following=is_following,
            connection_response=connection_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_or_update_connection_serialize(
        self,
        device_id,
        account_id,
        connection_id,
        connection_account_id,
        pending_id,
        group_id,
        game_type,
        app_key,
        is_trusted,
        ignore_friend_request,
        is_contact,
        is_blocked,
        is_following,
        connection_response,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_id is not None:
            
            _query_params.append(('connectionId', connection_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if pending_id is not None:
            
            _query_params.append(('pendingId', pending_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if is_trusted is not None:
            
            _query_params.append(('isTrusted', is_trusted))
            
        if ignore_friend_request is not None:
            
            _query_params.append(('ignoreFriendRequest', ignore_friend_request))
            
        if is_contact is not None:
            
            _query_params.append(('isContact', is_contact))
            
        if is_blocked is not None:
            
            _query_params.append(('isBlocked', is_blocked))
            
        if is_following is not None:
            
            _query_params.append(('isFollowing', is_following))
            
        if connection_response is not None:
            
            _query_params.append(('connectionResponse', connection_response))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/add',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_or_update_group(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the group")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="the group id to update a group (don't pass anything in if you want to create a new group)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the asset to attach to the group")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the group")] = None,
        can_view_profile_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's profile info")] = None,
        can_view_game_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's game info")] = None,
        can_view_friend_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's friends/connections")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the connection group is active or inactive")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the group")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the group")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create or Update Connection Group

        Creates a new private group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: the name of the group
        :type name: str
        :param group_id: the group id to update a group (don't pass anything in if you want to create a new group)
        :type group_id: int
        :param asset_id: the asset to attach to the group
        :type asset_id: int
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param description: the description of the group
        :type description: str
        :param can_view_profile_info: determines whether the connections in the group can see the user's profile info
        :type can_view_profile_info: bool
        :param can_view_game_info: determines whether the connections in the group can see the user's game info
        :type can_view_game_info: bool
        :param can_view_friend_info: determines whether the connections in the group can see the user's friends/connections
        :type can_view_friend_info: bool
        :param active: Sets whether the connection group is active or inactive
        :type active: bool
        :param latitude: the latitude of the group
        :type latitude: float
        :param longitude: the longitude of the group
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_group_serialize(
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            name=name,
            group_id=group_id,
            asset_id=asset_id,
            connections=connections,
            description=description,
            can_view_profile_info=can_view_profile_info,
            can_view_game_info=can_view_game_info,
            can_view_friend_info=can_view_friend_info,
            active=active,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_or_update_group_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the group")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="the group id to update a group (don't pass anything in if you want to create a new group)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the asset to attach to the group")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the group")] = None,
        can_view_profile_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's profile info")] = None,
        can_view_game_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's game info")] = None,
        can_view_friend_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's friends/connections")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the connection group is active or inactive")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the group")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the group")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create or Update Connection Group

        Creates a new private group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: the name of the group
        :type name: str
        :param group_id: the group id to update a group (don't pass anything in if you want to create a new group)
        :type group_id: int
        :param asset_id: the asset to attach to the group
        :type asset_id: int
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param description: the description of the group
        :type description: str
        :param can_view_profile_info: determines whether the connections in the group can see the user's profile info
        :type can_view_profile_info: bool
        :param can_view_game_info: determines whether the connections in the group can see the user's game info
        :type can_view_game_info: bool
        :param can_view_friend_info: determines whether the connections in the group can see the user's friends/connections
        :type can_view_friend_info: bool
        :param active: Sets whether the connection group is active or inactive
        :type active: bool
        :param latitude: the latitude of the group
        :type latitude: float
        :param longitude: the longitude of the group
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_group_serialize(
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            name=name,
            group_id=group_id,
            asset_id=asset_id,
            connections=connections,
            description=description,
            can_view_profile_info=can_view_profile_info,
            can_view_game_info=can_view_game_info,
            can_view_friend_info=can_view_friend_info,
            active=active,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_or_update_group_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        name: Annotated[Optional[StrictStr], Field(description="the name of the group")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="the group id to update a group (don't pass anything in if you want to create a new group)")] = None,
        asset_id: Annotated[Optional[StrictInt], Field(description="the asset to attach to the group")] = None,
        connections: Annotated[Optional[StrictStr], Field(description="comma separated list of connection IDs")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the group")] = None,
        can_view_profile_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's profile info")] = None,
        can_view_game_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's game info")] = None,
        can_view_friend_info: Annotated[Optional[StrictBool], Field(description="determines whether the connections in the group can see the user's friends/connections")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the connection group is active or inactive")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of the group")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of the group")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create or Update Connection Group

        Creates a new private group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param name: the name of the group
        :type name: str
        :param group_id: the group id to update a group (don't pass anything in if you want to create a new group)
        :type group_id: int
        :param asset_id: the asset to attach to the group
        :type asset_id: int
        :param connections: comma separated list of connection IDs
        :type connections: str
        :param description: the description of the group
        :type description: str
        :param can_view_profile_info: determines whether the connections in the group can see the user's profile info
        :type can_view_profile_info: bool
        :param can_view_game_info: determines whether the connections in the group can see the user's game info
        :type can_view_game_info: bool
        :param can_view_friend_info: determines whether the connections in the group can see the user's friends/connections
        :type can_view_friend_info: bool
        :param active: Sets whether the connection group is active or inactive
        :type active: bool
        :param latitude: the latitude of the group
        :type latitude: float
        :param longitude: the longitude of the group
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_or_update_group_serialize(
            return_nulls=return_nulls,
            device_id=device_id,
            account_id=account_id,
            name=name,
            group_id=group_id,
            asset_id=asset_id,
            connections=connections,
            description=description,
            can_view_profile_info=can_view_profile_info,
            can_view_game_info=can_view_game_info,
            can_view_friend_info=can_view_friend_info,
            active=active,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_or_update_group_serialize(
        self,
        return_nulls,
        device_id,
        account_id,
        name,
        group_id,
        asset_id,
        connections,
        description,
        can_view_profile_info,
        can_view_game_info,
        can_view_friend_info,
        active,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if asset_id is not None:
            
            _query_params.append(('assetId', asset_id))
            
        if connections is not None:
            
            _query_params.append(('connections', connections))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if can_view_profile_info is not None:
            
            _query_params.append(('canViewProfileInfo', can_view_profile_info))
            
        if can_view_game_info is not None:
            
            _query_params.append(('canViewGameInfo', can_view_game_info))
            
        if can_view_friend_info is not None:
            
            _query_params.append(('canViewFriendInfo', can_view_friend_info))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/group',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def follow_accept(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who initiated the follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Accept Follow Request

        Accept someone's follow request.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who initiated the follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_accept_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def follow_accept_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who initiated the follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Accept Follow Request

        Accept someone's follow request.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who initiated the follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_accept_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def follow_accept_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who initiated the follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Accept Follow Request

        Accept someone's follow request.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who initiated the follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_accept_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _follow_accept_serialize(
        self,
        account_id,
        connection_account_id,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/follow/accept',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def follow_reject(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who initiated the follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Reject Follow Request

        Reject someone's follow request or remove them as a follower.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who initiated the follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_reject_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def follow_reject_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who initiated the follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Reject Follow Request

        Reject someone's follow request or remove them as a follower.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who initiated the follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_reject_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def follow_reject_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who initiated the follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Reject Follow Request

        Reject someone's follow request or remove them as a follower.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who initiated the follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_reject_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _follow_reject_serialize(
        self,
        account_id,
        connection_account_id,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/follow/reject',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def follow_remove(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who you want to unfollow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Remove Follower / Unfollow

        Unfollow someone you are following or remove them as a follower.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who you want to unfollow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_remove_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def follow_remove_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who you want to unfollow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Remove Follower / Unfollow

        Unfollow someone you are following or remove them as a follower.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who you want to unfollow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_remove_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def follow_remove_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who you want to unfollow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove Follower / Unfollow

        Unfollow someone you are following or remove them as a follower.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who you want to unfollow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_remove_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _follow_remove_serialize(
        self,
        account_id,
        connection_account_id,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/follow/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def follow_request(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who you want to follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        approval_needed: Annotated[Optional[StrictBool], Field(description="determines if the other user needs to confirm the follow request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Send Follow Request

        Send a request to follow someone.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who you want to follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param approval_needed: determines if the other user needs to confirm the follow request
        :type approval_needed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_request_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            approval_needed=approval_needed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def follow_request_with_http_info(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who you want to follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        approval_needed: Annotated[Optional[StrictBool], Field(description="determines if the other user needs to confirm the follow request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Send Follow Request

        Send a request to follow someone.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who you want to follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param approval_needed: determines if the other user needs to confirm the follow request
        :type approval_needed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_request_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            approval_needed=approval_needed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def follow_request_without_preload_content(
        self,
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        connection_account_id: Annotated[StrictInt, Field(description="the account ID of the user who you want to follow")],
        app_key: Annotated[StrictStr, Field(description="the application key for sending notifications")],
        approval_needed: Annotated[Optional[StrictBool], Field(description="determines if the other user needs to confirm the follow request")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Send Follow Request

        Send a request to follow someone.

        :param account_id: the account id of the user (required)
        :type account_id: int
        :param connection_account_id: the account ID of the user who you want to follow (required)
        :type connection_account_id: int
        :param app_key: the application key for sending notifications (required)
        :type app_key: str
        :param approval_needed: determines if the other user needs to confirm the follow request
        :type approval_needed: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._follow_request_serialize(
            account_id=account_id,
            connection_account_id=connection_account_id,
            app_key=app_key,
            approval_needed=approval_needed,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _follow_request_serialize(
        self,
        account_id,
        connection_account_id,
        app_key,
        approval_needed,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if approval_needed is not None:
            
            _query_params.append(('approvalNeeded', approval_needed))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/follow/request',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def friend_accept(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        notify_friend: Annotated[StrictBool, Field(description="determines whether to send a notification to the afflicting party")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Accept Friend

        Accept a friend request and optionally sends a notification.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param notify_friend: determines whether to send a notification to the afflicting party (required)
        :type notify_friend: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_accept_serialize(
            friend_account_id=friend_account_id,
            notify_friend=notify_friend,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def friend_accept_with_http_info(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        notify_friend: Annotated[StrictBool, Field(description="determines whether to send a notification to the afflicting party")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Accept Friend

        Accept a friend request and optionally sends a notification.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param notify_friend: determines whether to send a notification to the afflicting party (required)
        :type notify_friend: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_accept_serialize(
            friend_account_id=friend_account_id,
            notify_friend=notify_friend,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def friend_accept_without_preload_content(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        notify_friend: Annotated[StrictBool, Field(description="determines whether to send a notification to the afflicting party")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Accept Friend

        Accept a friend request and optionally sends a notification.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param notify_friend: determines whether to send a notification to the afflicting party (required)
        :type notify_friend: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_accept_serialize(
            friend_account_id=friend_account_id,
            notify_friend=notify_friend,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _friend_accept_serialize(
        self,
        friend_account_id,
        notify_friend,
        device_id,
        account_id,
        game_type,
        app_key,
        notification_message,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if friend_account_id is not None:
            
            _query_params.append(('friendAccountId', friend_account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if notify_friend is not None:
            
            _query_params.append(('notifyFriend', notify_friend))
            
        if notification_message is not None:
            
            _query_params.append(('notificationMessage', notification_message))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/friend/accept',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def friend_reject(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notify_friend: Annotated[Optional[StrictBool], Field(description="determines whether to send a notification to the afflicting party")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Decline Friend

        Request a friend request and optionally sends a notification.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notify_friend: determines whether to send a notification to the afflicting party
        :type notify_friend: bool
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_reject_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notify_friend=notify_friend,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def friend_reject_with_http_info(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notify_friend: Annotated[Optional[StrictBool], Field(description="determines whether to send a notification to the afflicting party")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Decline Friend

        Request a friend request and optionally sends a notification.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notify_friend: determines whether to send a notification to the afflicting party
        :type notify_friend: bool
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_reject_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notify_friend=notify_friend,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def friend_reject_without_preload_content(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notify_friend: Annotated[Optional[StrictBool], Field(description="determines whether to send a notification to the afflicting party")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Decline Friend

        Request a friend request and optionally sends a notification.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notify_friend: determines whether to send a notification to the afflicting party
        :type notify_friend: bool
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_reject_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notify_friend=notify_friend,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _friend_reject_serialize(
        self,
        friend_account_id,
        device_id,
        account_id,
        game_type,
        app_key,
        notify_friend,
        notification_message,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if friend_account_id is not None:
            
            _query_params.append(('friendAccountId', friend_account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if notify_friend is not None:
            
            _query_params.append(('notifyFriend', notify_friend))
            
        if notification_message is not None:
            
            _query_params.append(('notificationMessage', notification_message))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/friend/reject',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def friend_remove(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the account ID of the friend to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        notify_friend: Annotated[Optional[StrictBool], Field(description="optionally notifies the connection that they have been removed as a friend")] = None,
        remove_from_groups: Annotated[Optional[StrictBool], Field(description="optionally removes the connection from the user's groups")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Friend

        Removes a friend from the user's friends list.

        :param friend_account_id: the account ID of the friend to remove (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param notify_friend: optionally notifies the connection that they have been removed as a friend
        :type notify_friend: bool
        :param remove_from_groups: optionally removes the connection from the user's groups
        :type remove_from_groups: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_remove_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            notify_friend=notify_friend,
            remove_from_groups=remove_from_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def friend_remove_with_http_info(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the account ID of the friend to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        notify_friend: Annotated[Optional[StrictBool], Field(description="optionally notifies the connection that they have been removed as a friend")] = None,
        remove_from_groups: Annotated[Optional[StrictBool], Field(description="optionally removes the connection from the user's groups")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Friend

        Removes a friend from the user's friends list.

        :param friend_account_id: the account ID of the friend to remove (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param notify_friend: optionally notifies the connection that they have been removed as a friend
        :type notify_friend: bool
        :param remove_from_groups: optionally removes the connection from the user's groups
        :type remove_from_groups: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_remove_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            notify_friend=notify_friend,
            remove_from_groups=remove_from_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def friend_remove_without_preload_content(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the account ID of the friend to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        notify_friend: Annotated[Optional[StrictBool], Field(description="optionally notifies the connection that they have been removed as a friend")] = None,
        remove_from_groups: Annotated[Optional[StrictBool], Field(description="optionally removes the connection from the user's groups")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Friend

        Removes a friend from the user's friends list.

        :param friend_account_id: the account ID of the friend to remove (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param notify_friend: optionally notifies the connection that they have been removed as a friend
        :type notify_friend: bool
        :param remove_from_groups: optionally removes the connection from the user's groups
        :type remove_from_groups: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_remove_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            notify_friend=notify_friend,
            remove_from_groups=remove_from_groups,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _friend_remove_serialize(
        self,
        friend_account_id,
        device_id,
        account_id,
        notify_friend,
        remove_from_groups,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if friend_account_id is not None:
            
            _query_params.append(('friendAccountId', friend_account_id))
            
        if notify_friend is not None:
            
            _query_params.append(('notifyFriend', notify_friend))
            
        if remove_from_groups is not None:
            
            _query_params.append(('removeFromGroups', remove_from_groups))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/friend/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def friend_request(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Request Friend

        Sends a friend request notification to another user.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_request_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def friend_request_with_http_info(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Request Friend

        Sends a friend request notification to another user.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_request_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def friend_request_without_preload_content(
        self,
        friend_account_id: Annotated[StrictInt, Field(description="the friend's account id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        notification_message: Annotated[Optional[StrictStr], Field(description="optional message to send in a notification")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Request Friend

        Sends a friend request notification to another user.

        :param friend_account_id: the friend's account id (required)
        :type friend_account_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the application key
        :type app_key: str
        :param notification_message: optional message to send in a notification
        :type notification_message: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._friend_request_serialize(
            friend_account_id=friend_account_id,
            device_id=device_id,
            account_id=account_id,
            game_type=game_type,
            app_key=app_key,
            notification_message=notification_message,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _friend_request_serialize(
        self,
        friend_account_id,
        device_id,
        account_id,
        game_type,
        app_key,
        notification_message,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if friend_account_id is not None:
            
            _query_params.append(('friendAccountId', friend_account_id))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if notification_message is not None:
            
            _query_params.append(('notificationMessage', notification_message))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/friend/request',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_connection_sent_friend_requests(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the ID of the device")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConnectionListResponse:
        """Get Sent Friend Requests

        Gets the connection sent friend requests.

        :param device_id: the ID of the device
        :type device_id: str
        :param account_id: the id of the account
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_connection_sent_friend_requests_serialize(
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_connection_sent_friend_requests_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the ID of the device")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConnectionListResponse]:
        """Get Sent Friend Requests

        Gets the connection sent friend requests.

        :param device_id: the ID of the device
        :type device_id: str
        :param account_id: the id of the account
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_connection_sent_friend_requests_serialize(
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_connection_sent_friend_requests_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="the ID of the device")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the id of the account")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Sent Friend Requests

        Gets the connection sent friend requests.

        :param device_id: the ID of the device
        :type device_id: str
        :param account_id: the id of the account
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_connection_sent_friend_requests_serialize(
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_connection_sent_friend_requests_serialize(
        self,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/consumer/connection/getRequested',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_connections(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        filter: Annotated[StrictStr, Field(description="a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)")],
        sort_field: Annotated[StrictStr, Field(description="sorts the response list by ConnectionApiMap")],
        descending: Annotated[StrictBool, Field(description="sorts the response list by descending order if true")],
        start: Annotated[StrictInt, Field(description="start index of the pagination")],
        limit: Annotated[StrictInt, Field(description="limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="optional parameter to search on other account's connections")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="an optional keyword to search on, this parameter is ignored if empty")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConnectionListResponse:
        """Search Connections

        Gets the connections.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param filter: a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following) (required)
        :type filter: str
        :param sort_field: sorts the response list by ConnectionApiMap (required)
        :type sort_field: str
        :param descending: sorts the response list by descending order if true (required)
        :type descending: bool
        :param start: start index of the pagination (required)
        :type start: int
        :param limit: limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: optional parameter to search on other account's connections
        :type connection_account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: an optional keyword to search on, this parameter is ignored if empty
        :type keyword: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_connections_serialize(
            return_nulls=return_nulls,
            filter=filter,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            q=q,
            keyword=keyword,
            i=i,
            l=l,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_connections_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        filter: Annotated[StrictStr, Field(description="a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)")],
        sort_field: Annotated[StrictStr, Field(description="sorts the response list by ConnectionApiMap")],
        descending: Annotated[StrictBool, Field(description="sorts the response list by descending order if true")],
        start: Annotated[StrictInt, Field(description="start index of the pagination")],
        limit: Annotated[StrictInt, Field(description="limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="optional parameter to search on other account's connections")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="an optional keyword to search on, this parameter is ignored if empty")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConnectionListResponse]:
        """Search Connections

        Gets the connections.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param filter: a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following) (required)
        :type filter: str
        :param sort_field: sorts the response list by ConnectionApiMap (required)
        :type sort_field: str
        :param descending: sorts the response list by descending order if true (required)
        :type descending: bool
        :param start: start index of the pagination (required)
        :type start: int
        :param limit: limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: optional parameter to search on other account's connections
        :type connection_account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: an optional keyword to search on, this parameter is ignored if empty
        :type keyword: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_connections_serialize(
            return_nulls=return_nulls,
            filter=filter,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            q=q,
            keyword=keyword,
            i=i,
            l=l,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_connections_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        filter: Annotated[StrictStr, Field(description="a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following)")],
        sort_field: Annotated[StrictStr, Field(description="sorts the response list by ConnectionApiMap")],
        descending: Annotated[StrictBool, Field(description="sorts the response list by descending order if true")],
        start: Annotated[StrictInt, Field(description="start index of the pagination")],
        limit: Annotated[StrictInt, Field(description="limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id (deviceId or accountId required)")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="optional parameter to search on other account's connections")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="an optional keyword to search on, this parameter is ignored if empty")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Connections

        Gets the connections.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param filter: a comma separated list of ConnectionApiMap. (NOTE on FOLLOWER vs FOLLOWING: FOLLOWER will get me a list of followers, FOLLOWING will get me a list of people I am following) (required)
        :type filter: str
        :param sort_field: sorts the response list by ConnectionApiMap (required)
        :type sort_field: str
        :param descending: sorts the response list by descending order if true (required)
        :type descending: bool
        :param start: start index of the pagination (required)
        :type start: int
        :param limit: limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id (deviceId or accountId required)
        :type account_id: int
        :param connection_account_id: optional parameter to search on other account's connections
        :type connection_account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: an optional keyword to search on, this parameter is ignored if empty
        :type keyword: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_connections_serialize(
            return_nulls=return_nulls,
            filter=filter,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            connection_account_id=connection_account_id,
            q=q,
            keyword=keyword,
            i=i,
            l=l,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_connections_serialize(
        self,
        return_nulls,
        filter,
        sort_field,
        descending,
        start,
        limit,
        device_id,
        account_id,
        connection_account_id,
        q,
        keyword,
        i,
        l,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if filter is not None:
            
            _query_params.append(('filter', filter))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/consumer/connection/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_group_details(
        self,
        combine_connections: Annotated[StrictBool, Field(description="whether to combine connections or not")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="the group id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConnectionGroupResponse:
        """Get Connection Group


        :param combine_connections: whether to combine connections or not (required)
        :type combine_connections: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param group_id: the group id
        :type group_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_details_serialize(
            combine_connections=combine_connections,
            device_id=device_id,
            account_id=account_id,
            group_id=group_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_group_details_with_http_info(
        self,
        combine_connections: Annotated[StrictBool, Field(description="whether to combine connections or not")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="the group id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConnectionGroupResponse]:
        """Get Connection Group


        :param combine_connections: whether to combine connections or not (required)
        :type combine_connections: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param group_id: the group id
        :type group_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_details_serialize(
            combine_connections=combine_connections,
            device_id=device_id,
            account_id=account_id,
            group_id=group_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_group_details_without_preload_content(
        self,
        combine_connections: Annotated[StrictBool, Field(description="whether to combine connections or not")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        group_id: Annotated[Optional[StrictInt], Field(description="the group id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Connection Group


        :param combine_connections: whether to combine connections or not (required)
        :type combine_connections: bool
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param group_id: the group id
        :type group_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_group_details_serialize(
            combine_connections=combine_connections,
            device_id=device_id,
            account_id=account_id,
            group_id=group_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionGroupResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_group_details_serialize(
        self,
        combine_connections,
        device_id,
        account_id,
        group_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if combine_connections is not None:
            
            _query_params.append(('combineConnections', combine_connections))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/consumer/connection/group/details/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def group_search(
        self,
        sort_field: Annotated[StrictStr, Field(description="the field to sort by")],
        descending: Annotated[StrictBool, Field(description="whether to return results in descending or ascending order")],
        active_only: Annotated[StrictBool, Field(description="to search on active only or not")],
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="the limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[ConnectionInfoResponse]:
        """Search Connection Groups

        Gets a user's private groups and default groups.

        :param sort_field: the field to sort by (required)
        :type sort_field: str
        :param descending: whether to return results in descending or ascending order (required)
        :type descending: bool
        :param active_only: to search on active only or not (required)
        :type active_only: bool
        :param start: The start of the pagination (required)
        :type start: int
        :param limit: the limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param keyword: keyword search string
        :type keyword: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._group_search_serialize(
            sort_field=sort_field,
            descending=descending,
            active_only=active_only,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            keyword=keyword,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ConnectionInfoResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def group_search_with_http_info(
        self,
        sort_field: Annotated[StrictStr, Field(description="the field to sort by")],
        descending: Annotated[StrictBool, Field(description="whether to return results in descending or ascending order")],
        active_only: Annotated[StrictBool, Field(description="to search on active only or not")],
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="the limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[ConnectionInfoResponse]]:
        """Search Connection Groups

        Gets a user's private groups and default groups.

        :param sort_field: the field to sort by (required)
        :type sort_field: str
        :param descending: whether to return results in descending or ascending order (required)
        :type descending: bool
        :param active_only: to search on active only or not (required)
        :type active_only: bool
        :param start: The start of the pagination (required)
        :type start: int
        :param limit: the limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param keyword: keyword search string
        :type keyword: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._group_search_serialize(
            sort_field=sort_field,
            descending=descending,
            active_only=active_only,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            keyword=keyword,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ConnectionInfoResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def group_search_without_preload_content(
        self,
        sort_field: Annotated[StrictStr, Field(description="the field to sort by")],
        descending: Annotated[StrictBool, Field(description="whether to return results in descending or ascending order")],
        active_only: Annotated[StrictBool, Field(description="to search on active only or not")],
        start: Annotated[StrictInt, Field(description="The start of the pagination")],
        limit: Annotated[StrictInt, Field(description="the limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword search string")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Connection Groups

        Gets a user's private groups and default groups.

        :param sort_field: the field to sort by (required)
        :type sort_field: str
        :param descending: whether to return results in descending or ascending order (required)
        :type descending: bool
        :param active_only: to search on active only or not (required)
        :type active_only: bool
        :param start: The start of the pagination (required)
        :type start: int
        :param limit: the limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param keyword: keyword search string
        :type keyword: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._group_search_serialize(
            sort_field=sort_field,
            descending=descending,
            active_only=active_only,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            keyword=keyword,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[ConnectionInfoResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _group_search_serialize(
        self,
        sort_field,
        descending,
        active_only,
        start,
        limit,
        device_id,
        account_id,
        latitude,
        longitude,
        keyword,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/connection/group/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_connection_from_group(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Connection

        Removes the connection from group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id
        :type connection_id: int
        :param connection_account_id: the connection account id
        :type connection_account_id: int
        :param pending_id: the pending id
        :type pending_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_connection_from_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_connection_from_group_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Connection

        Removes the connection from group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id
        :type connection_id: int
        :param connection_account_id: the connection account id
        :type connection_account_id: int
        :param pending_id: the pending id
        :type pending_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_connection_from_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_connection_from_group_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_id: Annotated[Optional[StrictInt], Field(description="the connection id")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the connection account id")] = None,
        pending_id: Annotated[Optional[StrictInt], Field(description="the pending id")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Connection

        Removes the connection from group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_id: the connection id
        :type connection_id: int
        :param connection_account_id: the connection account id
        :type connection_account_id: int
        :param pending_id: the pending id
        :type pending_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_connection_from_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            connection_id=connection_id,
            connection_account_id=connection_account_id,
            pending_id=pending_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_connection_from_group_serialize(
        self,
        return_nulls,
        group_id,
        device_id,
        account_id,
        connection_id,
        connection_account_id,
        pending_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_id is not None:
            
            _query_params.append(('connectionId', connection_id))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if pending_id is not None:
            
            _query_params.append(('pendingId', pending_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/group/removeConnection',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_connections_from_group(
        self,
        connection_group_id: Annotated[StrictInt, Field(description="connection group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection ids")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection account ids")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Remove Connections

        Remove a list of connections from a group.

        :param connection_group_id: connection group id (required)
        :type connection_group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: comma separated list of connection ids
        :type connection_ids: str
        :param connection_account_ids: comma separated list of connection account ids
        :type connection_account_ids: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_connections_from_group_serialize(
            connection_group_id=connection_group_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_connections_from_group_with_http_info(
        self,
        connection_group_id: Annotated[StrictInt, Field(description="connection group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection ids")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection account ids")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Remove Connections

        Remove a list of connections from a group.

        :param connection_group_id: connection group id (required)
        :type connection_group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: comma separated list of connection ids
        :type connection_ids: str
        :param connection_account_ids: comma separated list of connection account ids
        :type connection_account_ids: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_connections_from_group_serialize(
            connection_group_id=connection_group_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_connections_from_group_without_preload_content(
        self,
        connection_group_id: Annotated[StrictInt, Field(description="connection group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection ids")] = None,
        connection_account_ids: Annotated[Optional[StrictStr], Field(description="comma separated list of connection account ids")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove Connections

        Remove a list of connections from a group.

        :param connection_group_id: connection group id (required)
        :type connection_group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_ids: comma separated list of connection ids
        :type connection_ids: str
        :param connection_account_ids: comma separated list of connection account ids
        :type connection_account_ids: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_connections_from_group_serialize(
            connection_group_id=connection_group_id,
            device_id=device_id,
            account_id=account_id,
            connection_ids=connection_ids,
            connection_account_ids=connection_account_ids,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_connections_from_group_serialize(
        self,
        connection_group_id,
        device_id,
        account_id,
        connection_ids,
        connection_account_ids,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_ids is not None:
            
            _query_params.append(('connectionIds', connection_ids))
            
        if connection_account_ids is not None:
            
            _query_params.append(('connectionAccountIds', connection_account_ids))
            
        if connection_group_id is not None:
            
            _query_params.append(('connectionGroupId', connection_group_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/connection/group/removeConnections',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_group(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Connection Group

        Remove a user's group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_group_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Connection Group

        Remove a user's group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_group_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the group id")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Connection Group

        Remove a user's group.

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the group id (required)
        :type group_id: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_group_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_group_serialize(
        self,
        return_nulls,
        group_id,
        device_id,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/group/remove',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def remove_sub_groups(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the parent group id")],
        sub_group_ids: Annotated[StrictStr, Field(description="comma separated list of group IDs to remove from the parent group")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Remove Connection Groups

        Remove sub groups from a group

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the parent group id (required)
        :type group_id: int
        :param sub_group_ids: comma separated list of group IDs to remove from the parent group (required)
        :type sub_group_ids: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_sub_groups_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            sub_group_ids=sub_group_ids,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def remove_sub_groups_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the parent group id")],
        sub_group_ids: Annotated[StrictStr, Field(description="comma separated list of group IDs to remove from the parent group")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Remove Connection Groups

        Remove sub groups from a group

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the parent group id (required)
        :type group_id: int
        :param sub_group_ids: comma separated list of group IDs to remove from the parent group (required)
        :type sub_group_ids: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_sub_groups_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            sub_group_ids=sub_group_ids,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def remove_sub_groups_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="whether to return nulls or not")],
        group_id: Annotated[StrictInt, Field(description="the parent group id")],
        sub_group_ids: Annotated[StrictStr, Field(description="comma separated list of group IDs to remove from the parent group")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Remove Connection Groups

        Remove sub groups from a group

        :param return_nulls: whether to return nulls or not (required)
        :type return_nulls: bool
        :param group_id: the parent group id (required)
        :type group_id: int
        :param sub_group_ids: comma separated list of group IDs to remove from the parent group (required)
        :type sub_group_ids: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._remove_sub_groups_serialize(
            return_nulls=return_nulls,
            group_id=group_id,
            sub_group_ids=sub_group_ids,
            device_id=device_id,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _remove_sub_groups_serialize(
        self,
        return_nulls,
        group_id,
        sub_group_ids,
        device_id,
        account_id,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if group_id is not None:
            
            _query_params.append(('groupId', group_id))
            
        if sub_group_ids is not None:
            
            _query_params.append(('subGroupIds', sub_group_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/consumer/connection/group/removeSubGroup',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_connections(
        self,
        return_nulls: Annotated[StrictBool, Field(description="return all json attributes if true. defualt is true.")],
        start: Annotated[StrictInt, Field(description="start index of the pagination")],
        limit: Annotated[StrictInt, Field(description="limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search on, optional and this parameter is ignored if empt")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the public application key, if provided only looks for users of that application")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort on")] = None,
        has_location: Annotated[Optional[StrictBool], Field(description="whether the search has location or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ConnectionListResponse:
        """Search Possible Connections

        Search for accounts that the user may not have a connection with.

        :param return_nulls: return all json attributes if true. defualt is true. (required)
        :type return_nulls: bool
        :param start: start index of the pagination (required)
        :type start: int
        :param limit: limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: keyword to search on, optional and this parameter is ignored if empt
        :type keyword: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the public application key, if provided only looks for users of that application
        :type app_key: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param sort_field: the field to sort on
        :type sort_field: str
        :param has_location: whether the search has location or not
        :type has_location: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_connections_serialize(
            return_nulls=return_nulls,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            game_type=game_type,
            app_key=app_key,
            i=i,
            l=l,
            sort_field=sort_field,
            has_location=has_location,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_connections_with_http_info(
        self,
        return_nulls: Annotated[StrictBool, Field(description="return all json attributes if true. defualt is true.")],
        start: Annotated[StrictInt, Field(description="start index of the pagination")],
        limit: Annotated[StrictInt, Field(description="limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search on, optional and this parameter is ignored if empt")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the public application key, if provided only looks for users of that application")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort on")] = None,
        has_location: Annotated[Optional[StrictBool], Field(description="whether the search has location or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ConnectionListResponse]:
        """Search Possible Connections

        Search for accounts that the user may not have a connection with.

        :param return_nulls: return all json attributes if true. defualt is true. (required)
        :type return_nulls: bool
        :param start: start index of the pagination (required)
        :type start: int
        :param limit: limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: keyword to search on, optional and this parameter is ignored if empt
        :type keyword: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the public application key, if provided only looks for users of that application
        :type app_key: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param sort_field: the field to sort on
        :type sort_field: str
        :param has_location: whether the search has location or not
        :type has_location: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_connections_serialize(
            return_nulls=return_nulls,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            game_type=game_type,
            app_key=app_key,
            i=i,
            l=l,
            sort_field=sort_field,
            has_location=has_location,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_connections_without_preload_content(
        self,
        return_nulls: Annotated[StrictBool, Field(description="return all json attributes if true. defualt is true.")],
        start: Annotated[StrictInt, Field(description="start index of the pagination")],
        limit: Annotated[StrictInt, Field(description="limit of the pagination")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="keyword to search on, optional and this parameter is ignored if empt")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        game_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the public application key, if provided only looks for users of that application")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort on")] = None,
        has_location: Annotated[Optional[StrictBool], Field(description="whether the search has location or not")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Possible Connections

        Search for accounts that the user may not have a connection with.

        :param return_nulls: return all json attributes if true. defualt is true. (required)
        :type return_nulls: bool
        :param start: start index of the pagination (required)
        :type start: int
        :param limit: limit of the pagination (required)
        :type limit: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: keyword to search on, optional and this parameter is ignored if empt
        :type keyword: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param game_type: This parameter is deprecated.
        :type game_type: str
        :param app_key: the public application key, if provided only looks for users of that application
        :type app_key: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param sort_field: the field to sort on
        :type sort_field: str
        :param has_location: whether the search has location or not
        :type has_location: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_connections_serialize(
            return_nulls=return_nulls,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            latitude=latitude,
            longitude=longitude,
            game_type=game_type,
            app_key=app_key,
            i=i,
            l=l,
            sort_field=sort_field,
            has_location=has_location,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ConnectionListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_connections_serialize(
        self,
        return_nulls,
        start,
        limit,
        device_id,
        account_id,
        q,
        keyword,
        latitude,
        longitude,
        game_type,
        app_key,
        i,
        l,
        sort_field,
        has_location,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if game_type is not None:
            
            _query_params.append(('gameType', game_type))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if has_location is not None:
            
            _query_params.append(('hasLocation', has_location))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/connection/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


