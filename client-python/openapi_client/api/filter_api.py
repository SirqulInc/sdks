# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.filter_response import FilterResponse
from openapi_client.models.filter_tree_response import FilterTreeResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class FilterApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_filter(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user (must have permissions to the target application)")],
        name: Annotated[StrictStr, Field(description="The name of the filter")],
        app_key: Annotated[Optional[StrictStr], Field(description="The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)")] = None,
        parent_filter_id: Annotated[Optional[StrictInt], Field(description="The ID of the parent filter, if not provided then the parent filter will be null")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the filter")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="A string identifier used by client applications to store external information")] = None,
        external_type: Annotated[Optional[StrictStr], Field(description="A string type used by client applications to store external information")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the filter is active or inactive (hidden from consumers)")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="external custom client defined data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilterTreeResponse:
        """Create Filter

        Create a filter

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (must have permissions to the target application) (required)
        :type account_id: int
        :param name: The name of the filter (required)
        :type name: str
        :param app_key: The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
        :type app_key: str
        :param parent_filter_id: The ID of the parent filter, if not provided then the parent filter will be null
        :type parent_filter_id: int
        :param description: The description of the filter
        :type description: str
        :param external_id: A string identifier used by client applications to store external information
        :type external_id: str
        :param external_type: A string type used by client applications to store external information
        :type external_type: str
        :param active: Sets whether the filter is active or inactive (hidden from consumers)
        :type active: bool
        :param meta_data: external custom client defined data
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_filter_serialize(
            version=version,
            account_id=account_id,
            name=name,
            app_key=app_key,
            parent_filter_id=parent_filter_id,
            description=description,
            external_id=external_id,
            external_type=external_type,
            active=active,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_filter_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user (must have permissions to the target application)")],
        name: Annotated[StrictStr, Field(description="The name of the filter")],
        app_key: Annotated[Optional[StrictStr], Field(description="The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)")] = None,
        parent_filter_id: Annotated[Optional[StrictInt], Field(description="The ID of the parent filter, if not provided then the parent filter will be null")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the filter")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="A string identifier used by client applications to store external information")] = None,
        external_type: Annotated[Optional[StrictStr], Field(description="A string type used by client applications to store external information")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the filter is active or inactive (hidden from consumers)")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="external custom client defined data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilterTreeResponse]:
        """Create Filter

        Create a filter

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (must have permissions to the target application) (required)
        :type account_id: int
        :param name: The name of the filter (required)
        :type name: str
        :param app_key: The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
        :type app_key: str
        :param parent_filter_id: The ID of the parent filter, if not provided then the parent filter will be null
        :type parent_filter_id: int
        :param description: The description of the filter
        :type description: str
        :param external_id: A string identifier used by client applications to store external information
        :type external_id: str
        :param external_type: A string type used by client applications to store external information
        :type external_type: str
        :param active: Sets whether the filter is active or inactive (hidden from consumers)
        :type active: bool
        :param meta_data: external custom client defined data
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_filter_serialize(
            version=version,
            account_id=account_id,
            name=name,
            app_key=app_key,
            parent_filter_id=parent_filter_id,
            description=description,
            external_id=external_id,
            external_type=external_type,
            active=active,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_filter_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user (must have permissions to the target application)")],
        name: Annotated[StrictStr, Field(description="The name of the filter")],
        app_key: Annotated[Optional[StrictStr], Field(description="The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)")] = None,
        parent_filter_id: Annotated[Optional[StrictInt], Field(description="The ID of the parent filter, if not provided then the parent filter will be null")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the filter")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="A string identifier used by client applications to store external information")] = None,
        external_type: Annotated[Optional[StrictStr], Field(description="A string type used by client applications to store external information")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the filter is active or inactive (hidden from consumers)")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="external custom client defined data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Filter

        Create a filter

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (must have permissions to the target application) (required)
        :type account_id: int
        :param name: The name of the filter (required)
        :type name: str
        :param app_key: The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
        :type app_key: str
        :param parent_filter_id: The ID of the parent filter, if not provided then the parent filter will be null
        :type parent_filter_id: int
        :param description: The description of the filter
        :type description: str
        :param external_id: A string identifier used by client applications to store external information
        :type external_id: str
        :param external_type: A string type used by client applications to store external information
        :type external_type: str
        :param active: Sets whether the filter is active or inactive (hidden from consumers)
        :type active: bool
        :param meta_data: external custom client defined data
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_filter_serialize(
            version=version,
            account_id=account_id,
            name=name,
            app_key=app_key,
            parent_filter_id=parent_filter_id,
            description=description,
            external_id=external_id,
            external_type=external_type,
            active=active,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_filter_serialize(
        self,
        version,
        account_id,
        name,
        app_key,
        parent_filter_id,
        description,
        external_id,
        external_type,
        active,
        meta_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if parent_filter_id is not None:
            
            _query_params.append(('parentFilterId', parent_filter_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if external_id is not None:
            
            _query_params.append(('externalId', external_id))
            
        if external_type is not None:
            
            _query_params.append(('externalType', external_type))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/filter/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_filter(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user (must have permissions to the filter's assigned application)")],
        filter_id: Annotated[StrictInt, Field(description="The ID of the filter to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Filter

        Delete a filter.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (must have permissions to the filter's assigned application) (required)
        :type account_id: int
        :param filter_id: The ID of the filter to delete (required)
        :type filter_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_filter_serialize(
            version=version,
            account_id=account_id,
            filter_id=filter_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_filter_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user (must have permissions to the filter's assigned application)")],
        filter_id: Annotated[StrictInt, Field(description="The ID of the filter to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Filter

        Delete a filter.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (must have permissions to the filter's assigned application) (required)
        :type account_id: int
        :param filter_id: The ID of the filter to delete (required)
        :type filter_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_filter_serialize(
            version=version,
            account_id=account_id,
            filter_id=filter_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_filter_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user (must have permissions to the filter's assigned application)")],
        filter_id: Annotated[StrictInt, Field(description="The ID of the filter to delete")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Filter

        Delete a filter.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (must have permissions to the filter's assigned application) (required)
        :type account_id: int
        :param filter_id: The ID of the filter to delete (required)
        :type filter_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_filter_serialize(
            version=version,
            account_id=account_id,
            filter_id=filter_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_filter_serialize(
        self,
        version,
        account_id,
        filter_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if filter_id is not None:
            
            _query_params.append(('filterId', filter_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/filter/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_filter(
        self,
        version: Union[StrictFloat, StrictInt],
        filter_id: Annotated[StrictInt, Field(description="the id of the filter to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilterTreeResponse:
        """Get Filter

        Get the details of a specific filter. Recursively include all child filters and their children.

        :param version: (required)
        :type version: float
        :param filter_id: the id of the filter to get (required)
        :type filter_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_filter_serialize(
            version=version,
            filter_id=filter_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_filter_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        filter_id: Annotated[StrictInt, Field(description="the id of the filter to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilterTreeResponse]:
        """Get Filter

        Get the details of a specific filter. Recursively include all child filters and their children.

        :param version: (required)
        :type version: float
        :param filter_id: the id of the filter to get (required)
        :type filter_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_filter_serialize(
            version=version,
            filter_id=filter_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_filter_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        filter_id: Annotated[StrictInt, Field(description="the id of the filter to get")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Filter

        Get the details of a specific filter. Recursively include all child filters and their children.

        :param version: (required)
        :type version: float
        :param filter_id: the id of the filter to get (required)
        :type filter_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_filter_serialize(
            version=version,
            filter_id=filter_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_filter_serialize(
        self,
        version,
        filter_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if filter_id is not None:
            
            _query_params.append(('filterId', filter_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/filter/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_filters(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The string to search on")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the appKey of the application to retrieve filters for")] = None,
        response_group: Annotated[Optional[StrictStr], Field(description="The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.")] = None,
        root_only: Annotated[Optional[StrictBool], Field(description="Restrict the search to only those filters with no parent filter assigned.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active categories")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[FilterResponse]:
        """Search Filters

        Search for filters.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user
        :type account_id: int
        :param keyword: The string to search on
        :type keyword: str
        :param app_key: the appKey of the application to retrieve filters for
        :type app_key: str
        :param response_group: The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
        :type response_group: str
        :param root_only: Restrict the search to only those filters with no parent filter assigned.
        :type root_only: bool
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param active_only: Determines whether to return only active categories
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_filters_serialize(
            version=version,
            account_id=account_id,
            keyword=keyword,
            app_key=app_key,
            response_group=response_group,
            root_only=root_only,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FilterResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_filters_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The string to search on")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the appKey of the application to retrieve filters for")] = None,
        response_group: Annotated[Optional[StrictStr], Field(description="The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.")] = None,
        root_only: Annotated[Optional[StrictBool], Field(description="Restrict the search to only those filters with no parent filter assigned.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active categories")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[FilterResponse]]:
        """Search Filters

        Search for filters.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user
        :type account_id: int
        :param keyword: The string to search on
        :type keyword: str
        :param app_key: the appKey of the application to retrieve filters for
        :type app_key: str
        :param response_group: The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
        :type response_group: str
        :param root_only: Restrict the search to only those filters with no parent filter assigned.
        :type root_only: bool
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param active_only: Determines whether to return only active categories
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_filters_serialize(
            version=version,
            account_id=account_id,
            keyword=keyword,
            app_key=app_key,
            response_group=response_group,
            root_only=root_only,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FilterResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_filters_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The string to search on")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the appKey of the application to retrieve filters for")] = None,
        response_group: Annotated[Optional[StrictStr], Field(description="The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.")] = None,
        root_only: Annotated[Optional[StrictBool], Field(description="Restrict the search to only those filters with no parent filter assigned.")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the search results")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The record to begin the return set on")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The number of records to return")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active categories")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Filters

        Search for filters.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user
        :type account_id: int
        :param keyword: The string to search on
        :type keyword: str
        :param app_key: the appKey of the application to retrieve filters for
        :type app_key: str
        :param response_group: The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
        :type response_group: str
        :param root_only: Restrict the search to only those filters with no parent filter assigned.
        :type root_only: bool
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY
        :type sort_field: str
        :param descending: The order to return the search results
        :type descending: bool
        :param start: The record to begin the return set on
        :type start: int
        :param limit: The number of records to return
        :type limit: int
        :param active_only: Determines whether to return only active categories
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_filters_serialize(
            version=version,
            account_id=account_id,
            keyword=keyword,
            app_key=app_key,
            response_group=response_group,
            root_only=root_only,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[FilterResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_filters_serialize(
        self,
        version,
        account_id,
        keyword,
        app_key,
        response_group,
        root_only,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if response_group is not None:
            
            _query_params.append(('responseGroup', response_group))
            
        if root_only is not None:
            
            _query_params.append(('rootOnly', root_only))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/filter/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_filter(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        filter_id: Annotated[StrictInt, Field(description="The ID of the filter to edit")],
        parent_filter_id: Annotated[Optional[StrictInt], Field(description="The ID of the parent filter, if not provided then the parent filter will be null")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the filter")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the filter")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="A string identifier used by client applications to store external information")] = None,
        external_type: Annotated[Optional[StrictStr], Field(description="A string type used by client applications to store external information")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the filter is active or inactive (hidden from consumers)")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="external custom client defined data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> FilterTreeResponse:
        """Update Filter

        Update a filter.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param filter_id: The ID of the filter to edit (required)
        :type filter_id: int
        :param parent_filter_id: The ID of the parent filter, if not provided then the parent filter will be null
        :type parent_filter_id: int
        :param name: The name of the filter
        :type name: str
        :param description: The description of the filter
        :type description: str
        :param external_id: A string identifier used by client applications to store external information
        :type external_id: str
        :param external_type: A string type used by client applications to store external information
        :type external_type: str
        :param active: Sets whether the filter is active or inactive (hidden from consumers)
        :type active: bool
        :param meta_data: external custom client defined data
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_filter_serialize(
            version=version,
            account_id=account_id,
            filter_id=filter_id,
            parent_filter_id=parent_filter_id,
            name=name,
            description=description,
            external_id=external_id,
            external_type=external_type,
            active=active,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_filter_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        filter_id: Annotated[StrictInt, Field(description="The ID of the filter to edit")],
        parent_filter_id: Annotated[Optional[StrictInt], Field(description="The ID of the parent filter, if not provided then the parent filter will be null")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the filter")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the filter")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="A string identifier used by client applications to store external information")] = None,
        external_type: Annotated[Optional[StrictStr], Field(description="A string type used by client applications to store external information")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the filter is active or inactive (hidden from consumers)")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="external custom client defined data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[FilterTreeResponse]:
        """Update Filter

        Update a filter.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param filter_id: The ID of the filter to edit (required)
        :type filter_id: int
        :param parent_filter_id: The ID of the parent filter, if not provided then the parent filter will be null
        :type parent_filter_id: int
        :param name: The name of the filter
        :type name: str
        :param description: The description of the filter
        :type description: str
        :param external_id: A string identifier used by client applications to store external information
        :type external_id: str
        :param external_type: A string type used by client applications to store external information
        :type external_type: str
        :param active: Sets whether the filter is active or inactive (hidden from consumers)
        :type active: bool
        :param meta_data: external custom client defined data
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_filter_serialize(
            version=version,
            account_id=account_id,
            filter_id=filter_id,
            parent_filter_id=parent_filter_id,
            name=name,
            description=description,
            external_id=external_id,
            external_type=external_type,
            active=active,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_filter_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        filter_id: Annotated[StrictInt, Field(description="The ID of the filter to edit")],
        parent_filter_id: Annotated[Optional[StrictInt], Field(description="The ID of the parent filter, if not provided then the parent filter will be null")] = None,
        name: Annotated[Optional[StrictStr], Field(description="The name of the filter")] = None,
        description: Annotated[Optional[StrictStr], Field(description="The description of the filter")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="A string identifier used by client applications to store external information")] = None,
        external_type: Annotated[Optional[StrictStr], Field(description="A string type used by client applications to store external information")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets whether the filter is active or inactive (hidden from consumers)")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="external custom client defined data")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Filter

        Update a filter.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param filter_id: The ID of the filter to edit (required)
        :type filter_id: int
        :param parent_filter_id: The ID of the parent filter, if not provided then the parent filter will be null
        :type parent_filter_id: int
        :param name: The name of the filter
        :type name: str
        :param description: The description of the filter
        :type description: str
        :param external_id: A string identifier used by client applications to store external information
        :type external_id: str
        :param external_type: A string type used by client applications to store external information
        :type external_type: str
        :param active: Sets whether the filter is active or inactive (hidden from consumers)
        :type active: bool
        :param meta_data: external custom client defined data
        :type meta_data: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_filter_serialize(
            version=version,
            account_id=account_id,
            filter_id=filter_id,
            parent_filter_id=parent_filter_id,
            name=name,
            description=description,
            external_id=external_id,
            external_type=external_type,
            active=active,
            meta_data=meta_data,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "FilterTreeResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_filter_serialize(
        self,
        version,
        account_id,
        filter_id,
        parent_filter_id,
        name,
        description,
        external_id,
        external_type,
        active,
        meta_data,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if filter_id is not None:
            
            _query_params.append(('filterId', filter_id))
            
        if parent_filter_id is not None:
            
            _query_params.append(('parentFilterId', parent_filter_id))
            
        if name is not None:
            
            _query_params.append(('name', name))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if external_id is not None:
            
            _query_params.append(('externalId', external_id))
            
        if external_type is not None:
            
            _query_params.append(('externalType', external_type))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/filter/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


