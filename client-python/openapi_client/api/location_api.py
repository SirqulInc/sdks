# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr
from typing import Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.coords_response import CoordsResponse
from openapi_client.models.geo_point_response import GeoPointResponse
from openapi_client.models.location_search_response import LocationSearchResponse
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.trilat_cache_request import TrilatCacheRequest

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class LocationApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def cache_trilateration_data(
        self,
        version: Union[StrictFloat, StrictInt],
        udid: Annotated[StrictStr, Field(description="The unique identifier of the source device")],
        source_time: Annotated[Optional[StrictInt], Field(description="The current timestamp of the source device")] = None,
        minimum_sample_size: Annotated[Optional[StrictInt], Field(description="the minimum number of Edysen devices that must be used to be able to trilaterate a device")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` ")] = None,
        data_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Binary file containing data (multipart upload)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Trilateration Data with File

        Creates trilateration samples for a source device (i.e. a router).

        :param version: (required)
        :type version: float
        :param udid: The unique identifier of the source device (required)
        :type udid: str
        :param source_time: The current timestamp of the source device
        :type source_time: int
        :param minimum_sample_size: the minimum number of Edysen devices that must be used to be able to trilaterate a device
        :type minimum_sample_size: int
        :param data: The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` 
        :type data: str
        :param data_file: Binary file containing data (multipart upload)
        :type data_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cache_trilateration_data_serialize(
            version=version,
            udid=udid,
            source_time=source_time,
            minimum_sample_size=minimum_sample_size,
            data=data,
            data_file=data_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cache_trilateration_data_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        udid: Annotated[StrictStr, Field(description="The unique identifier of the source device")],
        source_time: Annotated[Optional[StrictInt], Field(description="The current timestamp of the source device")] = None,
        minimum_sample_size: Annotated[Optional[StrictInt], Field(description="the minimum number of Edysen devices that must be used to be able to trilaterate a device")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` ")] = None,
        data_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Binary file containing data (multipart upload)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Trilateration Data with File

        Creates trilateration samples for a source device (i.e. a router).

        :param version: (required)
        :type version: float
        :param udid: The unique identifier of the source device (required)
        :type udid: str
        :param source_time: The current timestamp of the source device
        :type source_time: int
        :param minimum_sample_size: the minimum number of Edysen devices that must be used to be able to trilaterate a device
        :type minimum_sample_size: int
        :param data: The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` 
        :type data: str
        :param data_file: Binary file containing data (multipart upload)
        :type data_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cache_trilateration_data_serialize(
            version=version,
            udid=udid,
            source_time=source_time,
            minimum_sample_size=minimum_sample_size,
            data=data,
            data_file=data_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cache_trilateration_data_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        udid: Annotated[StrictStr, Field(description="The unique identifier of the source device")],
        source_time: Annotated[Optional[StrictInt], Field(description="The current timestamp of the source device")] = None,
        minimum_sample_size: Annotated[Optional[StrictInt], Field(description="the minimum number of Edysen devices that must be used to be able to trilaterate a device")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` ")] = None,
        data_file: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="Binary file containing data (multipart upload)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Trilateration Data with File

        Creates trilateration samples for a source device (i.e. a router).

        :param version: (required)
        :type version: float
        :param udid: The unique identifier of the source device (required)
        :type udid: str
        :param source_time: The current timestamp of the source device
        :type source_time: int
        :param minimum_sample_size: the minimum number of Edysen devices that must be used to be able to trilaterate a device
        :type minimum_sample_size: int
        :param data: The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\":\"adc123\",        \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"randomizedId\": true,        \"deviceSignature\": \"probe:xyz...\",        \"alternativeId\": \"adc123\",        \"rssi\": [-83, -79]     }   ] } ``` 
        :type data: str
        :param data_file: Binary file containing data (multipart upload)
        :type data_file: bytearray
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cache_trilateration_data_serialize(
            version=version,
            udid=udid,
            source_time=source_time,
            minimum_sample_size=minimum_sample_size,
            data=data,
            data_file=data_file,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cache_trilateration_data_serialize(
        self,
        version,
        udid,
        source_time,
        minimum_sample_size,
        data,
        data_file,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        if source_time is not None:
            
            _query_params.append(('sourceTime', source_time))
            
        if minimum_sample_size is not None:
            
            _query_params.append(('minimumSampleSize', minimum_sample_size))
            
        if data is not None:
            
            _query_params.append(('data', data))
            
        if data_file is not None:
            
            _query_params.append(('dataFile', data_file))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/location/trilaterate/cache',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def cache_trilateration_data_gzip(
        self,
        version: Union[StrictFloat, StrictInt],
        body: Optional[TrilatCacheRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Trilateration Data with Rest

        Creates trilateration samples for a source device (i.e. a router).

        :param version: (required)
        :type version: float
        :param body:
        :type body: TrilatCacheRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cache_trilateration_data_gzip_serialize(
            version=version,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def cache_trilateration_data_gzip_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        body: Optional[TrilatCacheRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Trilateration Data with Rest

        Creates trilateration samples for a source device (i.e. a router).

        :param version: (required)
        :type version: float
        :param body:
        :type body: TrilatCacheRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cache_trilateration_data_gzip_serialize(
            version=version,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def cache_trilateration_data_gzip_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        body: Optional[TrilatCacheRequest] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Trilateration Data with Rest

        Creates trilateration samples for a source device (i.e. a router).

        :param version: (required)
        :type version: float
        :param body:
        :type body: TrilatCacheRequest
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._cache_trilateration_data_gzip_serialize(
            version=version,
            body=body,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _cache_trilateration_data_gzip_serialize(
        self,
        version,
        body,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter
        if body is not None:
            _body_params = body


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/location/trilaterate/cache/submit',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_location_by_ip(
        self,
        version: Union[StrictFloat, StrictInt],
        ip: Annotated[Optional[StrictStr], Field(description="the ip address of the client device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CoordsResponse:
        """Get Location by IP

        Get location information based on an IP address.

        :param version: (required)
        :type version: float
        :param ip: the ip address of the client device
        :type ip: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_location_by_ip_serialize(
            version=version,
            ip=ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoordsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_location_by_ip_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        ip: Annotated[Optional[StrictStr], Field(description="the ip address of the client device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CoordsResponse]:
        """Get Location by IP

        Get location information based on an IP address.

        :param version: (required)
        :type version: float
        :param ip: the ip address of the client device
        :type ip: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_location_by_ip_serialize(
            version=version,
            ip=ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoordsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_location_by_ip_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        ip: Annotated[Optional[StrictStr], Field(description="the ip address of the client device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Location by IP

        Get location information based on an IP address.

        :param version: (required)
        :type version: float
        :param ip: the ip address of the client device
        :type ip: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_location_by_ip_serialize(
            version=version,
            ip=ip,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CoordsResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_location_by_ip_serialize(
        self,
        version,
        ip,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if ip is not None:
            
            _query_params.append(('ip', ip))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/location/ip',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_location_by_trilateration(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account making the request, if provided the last know location will be updated")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The known GPS latitude to compare to the calculated version")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The known GPS longitude to compare to the calculated version")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` ")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="Optional response filters (not used currently)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> GeoPointResponse:
        """Get Location by Trilateration

        Send in device data and calculate a position based on signal strengths.

        :param version: (required)
        :type version: float
        :param account_id: The account making the request, if provided the last know location will be updated
        :type account_id: int
        :param latitude: The known GPS latitude to compare to the calculated version
        :type latitude: float
        :param longitude: The known GPS longitude to compare to the calculated version
        :type longitude: float
        :param data: The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` 
        :type data: str
        :param response_filters: Optional response filters (not used currently)
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_location_by_trilateration_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            data=data,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeoPointResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_location_by_trilateration_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account making the request, if provided the last know location will be updated")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The known GPS latitude to compare to the calculated version")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The known GPS longitude to compare to the calculated version")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` ")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="Optional response filters (not used currently)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[GeoPointResponse]:
        """Get Location by Trilateration

        Send in device data and calculate a position based on signal strengths.

        :param version: (required)
        :type version: float
        :param account_id: The account making the request, if provided the last know location will be updated
        :type account_id: int
        :param latitude: The known GPS latitude to compare to the calculated version
        :type latitude: float
        :param longitude: The known GPS longitude to compare to the calculated version
        :type longitude: float
        :param data: The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` 
        :type data: str
        :param response_filters: Optional response filters (not used currently)
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_location_by_trilateration_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            data=data,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeoPointResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_location_by_trilateration_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[Optional[StrictInt], Field(description="The account making the request, if provided the last know location will be updated")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The known GPS latitude to compare to the calculated version")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The known GPS longitude to compare to the calculated version")] = None,
        data: Annotated[Optional[StrictStr], Field(description="The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` ")] = None,
        response_filters: Annotated[Optional[StrictStr], Field(description="Optional response filters (not used currently)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Location by Trilateration

        Send in device data and calculate a position based on signal strengths.

        :param version: (required)
        :type version: float
        :param account_id: The account making the request, if provided the last know location will be updated
        :type account_id: int
        :param latitude: The known GPS latitude to compare to the calculated version
        :type latitude: float
        :param longitude: The known GPS longitude to compare to the calculated version
        :type longitude: float
        :param data: The json formated sample data:  ```json {    \"count\": 2,   \"timespan\": 10,    \"samples\": [     {       \"deviceId\": \"device1\",       \"rssi\": [-63, -75]     },      {       \"deviceId\": \"device2\",       \"rssi\": [-83, -79]     }   ] } ``` 
        :type data: str
        :param response_filters: Optional response filters (not used currently)
        :type response_filters: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_location_by_trilateration_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            data=data,
            response_filters=response_filters,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "GeoPointResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_location_by_trilateration_serialize(
        self,
        version,
        account_id,
        latitude,
        longitude,
        data,
        response_filters,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if data is not None:
            
            _query_params.append(('data', data))
            
        if response_filters is not None:
            
            _query_params.append(('responseFilters', response_filters))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/account/location/trilaterate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_locations(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id")] = None,
        currentlatitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        currentlongitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        current_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        current_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        query: Annotated[Optional[StrictStr], Field(description="the query results by keyword or address")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        zip_code: Annotated[Optional[StrictStr], Field(description="the zip code to filter results")] = None,
        selected_maplatitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        selected_maplongitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        selected_map_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of where the search should originate from")] = None,
        selected_map_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of where the search should originate from")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the search range of the search in miles")] = None,
        use_geocode: Annotated[Optional[StrictBool], Field(description="determines whether to allow searches via address")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> LocationSearchResponse:
        """Search Regions or Postal Codes

        Searches geographic locations by proximity via address or keyword.

        :param version: (required)
        :type version: float
        :param device_id: the device id
        :type device_id: str
        :param account_id: the account id
        :type account_id: int
        :param currentlatitude: This parameter is deprecated.
        :type currentlatitude: float
        :param currentlongitude: This parameter is deprecated.
        :type currentlongitude: float
        :param current_latitude: the current latitude of the user
        :type current_latitude: float
        :param current_longitude: the current longitude of the user
        :type current_longitude: float
        :param query: the query results by keyword or address
        :type query: str
        :param zipcode: This parameter is deprecated.
        :type zipcode: str
        :param zip_code: the zip code to filter results
        :type zip_code: str
        :param selected_maplatitude: This parameter is deprecated.
        :type selected_maplatitude: float
        :param selected_maplongitude: This parameter is deprecated.
        :type selected_maplongitude: float
        :param selected_map_latitude: the latitude of where the search should originate from
        :type selected_map_latitude: float
        :param selected_map_longitude: the longitude of where the search should originate from
        :type selected_map_longitude: float
        :param search_range: the search range of the search in miles
        :type search_range: float
        :param use_geocode: determines whether to allow searches via address
        :type use_geocode: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: the start index for pagination
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_locations_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            currentlatitude=currentlatitude,
            currentlongitude=currentlongitude,
            current_latitude=current_latitude,
            current_longitude=current_longitude,
            query=query,
            zipcode=zipcode,
            zip_code=zip_code,
            selected_maplatitude=selected_maplatitude,
            selected_maplongitude=selected_maplongitude,
            selected_map_latitude=selected_map_latitude,
            selected_map_longitude=selected_map_longitude,
            search_range=search_range,
            use_geocode=use_geocode,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocationSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_locations_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id")] = None,
        currentlatitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        currentlongitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        current_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        current_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        query: Annotated[Optional[StrictStr], Field(description="the query results by keyword or address")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        zip_code: Annotated[Optional[StrictStr], Field(description="the zip code to filter results")] = None,
        selected_maplatitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        selected_maplongitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        selected_map_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of where the search should originate from")] = None,
        selected_map_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of where the search should originate from")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the search range of the search in miles")] = None,
        use_geocode: Annotated[Optional[StrictBool], Field(description="determines whether to allow searches via address")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[LocationSearchResponse]:
        """Search Regions or Postal Codes

        Searches geographic locations by proximity via address or keyword.

        :param version: (required)
        :type version: float
        :param device_id: the device id
        :type device_id: str
        :param account_id: the account id
        :type account_id: int
        :param currentlatitude: This parameter is deprecated.
        :type currentlatitude: float
        :param currentlongitude: This parameter is deprecated.
        :type currentlongitude: float
        :param current_latitude: the current latitude of the user
        :type current_latitude: float
        :param current_longitude: the current longitude of the user
        :type current_longitude: float
        :param query: the query results by keyword or address
        :type query: str
        :param zipcode: This parameter is deprecated.
        :type zipcode: str
        :param zip_code: the zip code to filter results
        :type zip_code: str
        :param selected_maplatitude: This parameter is deprecated.
        :type selected_maplatitude: float
        :param selected_maplongitude: This parameter is deprecated.
        :type selected_maplongitude: float
        :param selected_map_latitude: the latitude of where the search should originate from
        :type selected_map_latitude: float
        :param selected_map_longitude: the longitude of where the search should originate from
        :type selected_map_longitude: float
        :param search_range: the search range of the search in miles
        :type search_range: float
        :param use_geocode: determines whether to allow searches via address
        :type use_geocode: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: the start index for pagination
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_locations_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            currentlatitude=currentlatitude,
            currentlongitude=currentlongitude,
            current_latitude=current_latitude,
            current_longitude=current_longitude,
            query=query,
            zipcode=zipcode,
            zip_code=zip_code,
            selected_maplatitude=selected_maplatitude,
            selected_maplongitude=selected_maplongitude,
            selected_map_latitude=selected_map_latitude,
            selected_map_longitude=selected_map_longitude,
            search_range=search_range,
            use_geocode=use_geocode,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocationSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_locations_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id")] = None,
        currentlatitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        currentlongitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        current_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        current_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        query: Annotated[Optional[StrictStr], Field(description="the query results by keyword or address")] = None,
        zipcode: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        zip_code: Annotated[Optional[StrictStr], Field(description="the zip code to filter results")] = None,
        selected_maplatitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        selected_maplongitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="This parameter is deprecated.")] = None,
        selected_map_latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the latitude of where the search should originate from")] = None,
        selected_map_longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the longitude of where the search should originate from")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the search range of the search in miles")] = None,
        use_geocode: Annotated[Optional[StrictBool], Field(description="determines whether to allow searches via address")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="the start index for pagination")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Regions or Postal Codes

        Searches geographic locations by proximity via address or keyword.

        :param version: (required)
        :type version: float
        :param device_id: the device id
        :type device_id: str
        :param account_id: the account id
        :type account_id: int
        :param currentlatitude: This parameter is deprecated.
        :type currentlatitude: float
        :param currentlongitude: This parameter is deprecated.
        :type currentlongitude: float
        :param current_latitude: the current latitude of the user
        :type current_latitude: float
        :param current_longitude: the current longitude of the user
        :type current_longitude: float
        :param query: the query results by keyword or address
        :type query: str
        :param zipcode: This parameter is deprecated.
        :type zipcode: str
        :param zip_code: the zip code to filter results
        :type zip_code: str
        :param selected_maplatitude: This parameter is deprecated.
        :type selected_maplatitude: float
        :param selected_maplongitude: This parameter is deprecated.
        :type selected_maplongitude: float
        :param selected_map_latitude: the latitude of where the search should originate from
        :type selected_map_latitude: float
        :param selected_map_longitude: the longitude of where the search should originate from
        :type selected_map_longitude: float
        :param search_range: the search range of the search in miles
        :type search_range: float
        :param use_geocode: determines whether to allow searches via address
        :type use_geocode: bool
        :param i: This parameter is deprecated.
        :type i: int
        :param start: the start index for pagination
        :type start: int
        :param l: This parameter is deprecated.
        :type l: int
        :param limit: the limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_locations_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            currentlatitude=currentlatitude,
            currentlongitude=currentlongitude,
            current_latitude=current_latitude,
            current_longitude=current_longitude,
            query=query,
            zipcode=zipcode,
            zip_code=zip_code,
            selected_maplatitude=selected_maplatitude,
            selected_maplongitude=selected_maplongitude,
            selected_map_latitude=selected_map_latitude,
            selected_map_longitude=selected_map_longitude,
            search_range=search_range,
            use_geocode=use_geocode,
            i=i,
            start=start,
            l=l,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "LocationSearchResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_locations_serialize(
        self,
        version,
        device_id,
        account_id,
        currentlatitude,
        currentlongitude,
        current_latitude,
        current_longitude,
        query,
        zipcode,
        zip_code,
        selected_maplatitude,
        selected_maplongitude,
        selected_map_latitude,
        selected_map_longitude,
        search_range,
        use_geocode,
        i,
        start,
        l,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if currentlatitude is not None:
            
            _query_params.append(('currentlatitude', currentlatitude))
            
        if currentlongitude is not None:
            
            _query_params.append(('currentlongitude', currentlongitude))
            
        if current_latitude is not None:
            
            _query_params.append(('currentLatitude', current_latitude))
            
        if current_longitude is not None:
            
            _query_params.append(('currentLongitude', current_longitude))
            
        if query is not None:
            
            _query_params.append(('query', query))
            
        if zipcode is not None:
            
            _query_params.append(('zipcode', zipcode))
            
        if zip_code is not None:
            
            _query_params.append(('zipCode', zip_code))
            
        if selected_maplatitude is not None:
            
            _query_params.append(('selectedMaplatitude', selected_maplatitude))
            
        if selected_maplongitude is not None:
            
            _query_params.append(('selectedMaplongitude', selected_maplongitude))
            
        if selected_map_latitude is not None:
            
            _query_params.append(('selectedMapLatitude', selected_map_latitude))
            
        if selected_map_longitude is not None:
            
            _query_params.append(('selectedMapLongitude', selected_map_longitude))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if use_geocode is not None:
            
            _query_params.append(('useGeocode', use_geocode))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/location/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


