# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.list_count_response import ListCountResponse
from openapi_client.models.offer_list_response import OfferListResponse
from openapi_client.models.offer_response import OfferResponse
from openapi_client.models.offer_short_response import OfferShortResponse
from openapi_client.models.offer_transaction_response import OfferTransactionResponse
from openapi_client.models.retailer_offer_response import RetailerOfferResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class OfferApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def batch_update_offer_locations(
        self,
        data: Annotated[StrictStr, Field(description="JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Offer Locations

        Batch update offer locations.

        :param data: JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ```  (required)
        :type data: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_update_offer_locations_serialize(
            data=data,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def batch_update_offer_locations_with_http_info(
        self,
        data: Annotated[StrictStr, Field(description="JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Offer Locations

        Batch update offer locations.

        :param data: JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ```  (required)
        :type data: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_update_offer_locations_serialize(
            data=data,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def batch_update_offer_locations_without_preload_content(
        self,
        data: Annotated[StrictStr, Field(description="JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Offer Locations

        Batch update offer locations.

        :param data: JSON string in the following format: ```json [{   \"offerLocationId\": 1705,   \"latitude\": 54.0,   \"longitude\": -122.0,   \"altitude\": 1.0,   \"locationDetail\": \"floor 1\",   \"locationDescription\": \"behind the Coke sign\" }, {   \"offerLocationId\": 1704,   \"latitude\": 54.1,   \"longitude\": -122.1 }] ```  (required)
        :type data: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_update_offer_locations_serialize(
            data=data,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _batch_update_offer_locations_serialize(
        self,
        data,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if data is not None:
            
            _query_params.append(('data', data))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/location/batchUpdate',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_offer(
        self,
        include_offer_locations: Annotated[StrictBool, Field(description="If true return all the offer locations associated with the offer")],
        title: Annotated[StrictStr, Field(description="The title (255 char limit)")],
        barcode_type: Annotated[StrictStr, Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")],
        no_expiration: Annotated[StrictBool, Field(description="Overrides the expiration date so that the offer does not expire")],
        available_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be used by consumers")],
        available_limit_per_user: Annotated[StrictInt, Field(description="The limit of how many times a user can used the same offer")],
        added_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be added to consumer wallets")],
        view_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be viewed")],
        max_prints: Annotated[StrictInt, Field(description="The maximum number of times the offer can be printed")],
        ticket_price: Annotated[StrictInt, Field(description="The cost of the offer in tickets")],
        full_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The retail/full price cost of the offer in real currency")],
        discount_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The cost of the offer at a discounted price (what the consumer pays)")],
        offer_type: Annotated[StrictStr, Field(description="The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}")],
        special_offer_type: Annotated[StrictStr, Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")],
        offer_visibility: Annotated[StrictStr, Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")],
        active: Annotated[StrictBool, Field(description="Sets the active flag")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id (deviceId or accountId required)")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        parent_offer_id: Annotated[Optional[StrictInt], Field(description="the parent offer id")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy offer")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show remaining offers available")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many offers have been redeemed")] = None,
        replaced: Optional[StrictBool] = None,
        featured: Annotated[Optional[StrictBool], Field(description="flag if offer is featured or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        brand: Annotated[Optional[StrictStr], Field(description="The brand. OfferType PRODUCT only.")] = None,
        product_type: Annotated[Optional[StrictStr], Field(description="The product type. OfferType PRODUCT only.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        department: Annotated[Optional[StrictStr], Field(description="The department name. The OfferType PRODUCT only.")] = None,
        features: Annotated[Optional[StrictStr], Field(description="The list of features, comma seperated. OfferType PRODUCT only.")] = None,
        minimum_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The MAP price. OfferType PRODUCT only.")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The width of the item. OfferType PRODUCT only.")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The height of the item. OfferType PRODUCT only.")] = None,
        depth: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The depth of the item. OfferType PRODUCT only.")] = None,
        weight: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The weight of the item. OfferType PRODUCT only.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit of measurement. OfferType PRODUCT only.")] = None,
        studio: Annotated[Optional[StrictStr], Field(description="The studio name. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        publish_date: Annotated[Optional[StrictInt], Field(description="The date published. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        size_id: Optional[StrictInt] = None,
        listing_id: Annotated[Optional[StrictInt], Field(description="The ID of the event listing")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="the media type of the offer")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        reboot_time_hour: Annotated[Optional[StrictInt], Field(description="The reboot hour time ranging from 0 to 23")] = None,
        reboot_time_minute: Annotated[Optional[StrictInt], Field(description="The reboot minute time ranging from 0 to 59")] = None,
        idle_timeout_in_second: Annotated[Optional[StrictInt], Field(description="If the device is idle for idleTimeoutInSecond then the device should timeout")] = None,
        serial_number: Annotated[Optional[StrictStr], Field(description="The serial number on the device")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The unique device id for the device")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of the device, for example: \"Kiosk\", \"Beacon\".")] = None,
        device_power: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Edysen device power level setting")] = None,
        device_interference: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Edysen device inteference setting")] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerOfferResponse:
        """Create Offer

        Create an offer and assign it to the provided retailer locations.

        :param include_offer_locations: If true return all the offer locations associated with the offer (required)
        :type include_offer_locations: bool
        :param title: The title (255 char limit) (required)
        :type title: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
        :type barcode_type: str
        :param no_expiration: Overrides the expiration date so that the offer does not expire (required)
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers (required)
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer (required)
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets (required)
        :type added_limit: int
        :param view_limit: The limit of how many times the offer can be viewed (required)
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed (required)
        :type max_prints: int
        :param ticket_price: The cost of the offer in tickets (required)
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency (required)
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays) (required)
        :type discount_price: float
        :param offer_type: The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE} (required)
        :type offer_type: str
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
        :type offer_visibility: str
        :param active: Sets the active flag (required)
        :type active: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id (deviceId or accountId required)
        :type account_id: int
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param parent_offer_id: the parent offer id
        :type parent_offer_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param external_id: an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_id: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param ticket_price_type: the type of ticket needed to buy offer
        :type ticket_price_type: str
        :param show_remaining: show remaining offers available
        :type show_remaining: bool
        :param show_redeemed: show how many offers have been redeemed
        :type show_redeemed: bool
        :param replaced: 
        :type replaced: bool
        :param featured: flag if offer is featured or not
        :type featured: bool
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param brand: The brand. OfferType PRODUCT only.
        :type brand: str
        :param product_type: The product type. OfferType PRODUCT only.
        :type product_type: str
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param department: The department name. The OfferType PRODUCT only.
        :type department: str
        :param features: The list of features, comma seperated. OfferType PRODUCT only.
        :type features: str
        :param minimum_price: The MAP price. OfferType PRODUCT only.
        :type minimum_price: float
        :param width: The width of the item. OfferType PRODUCT only.
        :type width: float
        :param height: The height of the item. OfferType PRODUCT only.
        :type height: float
        :param depth: The depth of the item. OfferType PRODUCT only.
        :type depth: float
        :param weight: The weight of the item. OfferType PRODUCT only.
        :type weight: float
        :param unit: The unit of measurement. OfferType PRODUCT only.
        :type unit: str
        :param studio: The studio name. OfferType PRODUCT only.
        :type studio: str
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param publish_date: The date published. OfferType PRODUCT only.
        :type publish_date: int
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param size_id: 
        :type size_id: int
        :param listing_id: The ID of the event listing
        :type listing_id: int
        :param media_type: the media type of the offer
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param reboot_time_hour: The reboot hour time ranging from 0 to 23
        :type reboot_time_hour: int
        :param reboot_time_minute: The reboot minute time ranging from 0 to 59
        :type reboot_time_minute: int
        :param idle_timeout_in_second: If the device is idle for idleTimeoutInSecond then the device should timeout
        :type idle_timeout_in_second: int
        :param serial_number: The serial number on the device
        :type serial_number: str
        :param udid: The unique device id for the device
        :type udid: str
        :param device_type: The type of the device, for example: \"Kiosk\", \"Beacon\".
        :type device_type: str
        :param device_power: Edysen device power level setting
        :type device_power: float
        :param device_interference: Edysen device inteference setting
        :type device_interference: float
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_offer_serialize(
            include_offer_locations=include_offer_locations,
            title=title,
            barcode_type=barcode_type,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            active=active,
            device_id=device_id,
            account_id=account_id,
            tags=tags,
            parent_offer_id=parent_offer_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            external_id=external_id,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            ticket_price_type=ticket_price_type,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            category_ids=category_ids,
            filter_ids=filter_ids,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            brand=brand,
            product_type=product_type,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            department=department,
            features=features,
            minimum_price=minimum_price,
            width=width,
            height=height,
            depth=depth,
            weight=weight,
            unit=unit,
            studio=studio,
            parental_rating=parental_rating,
            publish_date=publish_date,
            availability_date=availability_date,
            size_id=size_id,
            listing_id=listing_id,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            reboot_time_hour=reboot_time_hour,
            reboot_time_minute=reboot_time_minute,
            idle_timeout_in_second=idle_timeout_in_second,
            serial_number=serial_number,
            udid=udid,
            device_type=device_type,
            device_power=device_power,
            device_interference=device_interference,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_offer_with_http_info(
        self,
        include_offer_locations: Annotated[StrictBool, Field(description="If true return all the offer locations associated with the offer")],
        title: Annotated[StrictStr, Field(description="The title (255 char limit)")],
        barcode_type: Annotated[StrictStr, Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")],
        no_expiration: Annotated[StrictBool, Field(description="Overrides the expiration date so that the offer does not expire")],
        available_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be used by consumers")],
        available_limit_per_user: Annotated[StrictInt, Field(description="The limit of how many times a user can used the same offer")],
        added_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be added to consumer wallets")],
        view_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be viewed")],
        max_prints: Annotated[StrictInt, Field(description="The maximum number of times the offer can be printed")],
        ticket_price: Annotated[StrictInt, Field(description="The cost of the offer in tickets")],
        full_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The retail/full price cost of the offer in real currency")],
        discount_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The cost of the offer at a discounted price (what the consumer pays)")],
        offer_type: Annotated[StrictStr, Field(description="The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}")],
        special_offer_type: Annotated[StrictStr, Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")],
        offer_visibility: Annotated[StrictStr, Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")],
        active: Annotated[StrictBool, Field(description="Sets the active flag")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id (deviceId or accountId required)")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        parent_offer_id: Annotated[Optional[StrictInt], Field(description="the parent offer id")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy offer")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show remaining offers available")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many offers have been redeemed")] = None,
        replaced: Optional[StrictBool] = None,
        featured: Annotated[Optional[StrictBool], Field(description="flag if offer is featured or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        brand: Annotated[Optional[StrictStr], Field(description="The brand. OfferType PRODUCT only.")] = None,
        product_type: Annotated[Optional[StrictStr], Field(description="The product type. OfferType PRODUCT only.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        department: Annotated[Optional[StrictStr], Field(description="The department name. The OfferType PRODUCT only.")] = None,
        features: Annotated[Optional[StrictStr], Field(description="The list of features, comma seperated. OfferType PRODUCT only.")] = None,
        minimum_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The MAP price. OfferType PRODUCT only.")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The width of the item. OfferType PRODUCT only.")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The height of the item. OfferType PRODUCT only.")] = None,
        depth: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The depth of the item. OfferType PRODUCT only.")] = None,
        weight: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The weight of the item. OfferType PRODUCT only.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit of measurement. OfferType PRODUCT only.")] = None,
        studio: Annotated[Optional[StrictStr], Field(description="The studio name. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        publish_date: Annotated[Optional[StrictInt], Field(description="The date published. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        size_id: Optional[StrictInt] = None,
        listing_id: Annotated[Optional[StrictInt], Field(description="The ID of the event listing")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="the media type of the offer")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        reboot_time_hour: Annotated[Optional[StrictInt], Field(description="The reboot hour time ranging from 0 to 23")] = None,
        reboot_time_minute: Annotated[Optional[StrictInt], Field(description="The reboot minute time ranging from 0 to 59")] = None,
        idle_timeout_in_second: Annotated[Optional[StrictInt], Field(description="If the device is idle for idleTimeoutInSecond then the device should timeout")] = None,
        serial_number: Annotated[Optional[StrictStr], Field(description="The serial number on the device")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The unique device id for the device")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of the device, for example: \"Kiosk\", \"Beacon\".")] = None,
        device_power: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Edysen device power level setting")] = None,
        device_interference: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Edysen device inteference setting")] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerOfferResponse]:
        """Create Offer

        Create an offer and assign it to the provided retailer locations.

        :param include_offer_locations: If true return all the offer locations associated with the offer (required)
        :type include_offer_locations: bool
        :param title: The title (255 char limit) (required)
        :type title: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
        :type barcode_type: str
        :param no_expiration: Overrides the expiration date so that the offer does not expire (required)
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers (required)
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer (required)
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets (required)
        :type added_limit: int
        :param view_limit: The limit of how many times the offer can be viewed (required)
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed (required)
        :type max_prints: int
        :param ticket_price: The cost of the offer in tickets (required)
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency (required)
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays) (required)
        :type discount_price: float
        :param offer_type: The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE} (required)
        :type offer_type: str
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
        :type offer_visibility: str
        :param active: Sets the active flag (required)
        :type active: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id (deviceId or accountId required)
        :type account_id: int
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param parent_offer_id: the parent offer id
        :type parent_offer_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param external_id: an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_id: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param ticket_price_type: the type of ticket needed to buy offer
        :type ticket_price_type: str
        :param show_remaining: show remaining offers available
        :type show_remaining: bool
        :param show_redeemed: show how many offers have been redeemed
        :type show_redeemed: bool
        :param replaced: 
        :type replaced: bool
        :param featured: flag if offer is featured or not
        :type featured: bool
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param brand: The brand. OfferType PRODUCT only.
        :type brand: str
        :param product_type: The product type. OfferType PRODUCT only.
        :type product_type: str
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param department: The department name. The OfferType PRODUCT only.
        :type department: str
        :param features: The list of features, comma seperated. OfferType PRODUCT only.
        :type features: str
        :param minimum_price: The MAP price. OfferType PRODUCT only.
        :type minimum_price: float
        :param width: The width of the item. OfferType PRODUCT only.
        :type width: float
        :param height: The height of the item. OfferType PRODUCT only.
        :type height: float
        :param depth: The depth of the item. OfferType PRODUCT only.
        :type depth: float
        :param weight: The weight of the item. OfferType PRODUCT only.
        :type weight: float
        :param unit: The unit of measurement. OfferType PRODUCT only.
        :type unit: str
        :param studio: The studio name. OfferType PRODUCT only.
        :type studio: str
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param publish_date: The date published. OfferType PRODUCT only.
        :type publish_date: int
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param size_id: 
        :type size_id: int
        :param listing_id: The ID of the event listing
        :type listing_id: int
        :param media_type: the media type of the offer
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param reboot_time_hour: The reboot hour time ranging from 0 to 23
        :type reboot_time_hour: int
        :param reboot_time_minute: The reboot minute time ranging from 0 to 59
        :type reboot_time_minute: int
        :param idle_timeout_in_second: If the device is idle for idleTimeoutInSecond then the device should timeout
        :type idle_timeout_in_second: int
        :param serial_number: The serial number on the device
        :type serial_number: str
        :param udid: The unique device id for the device
        :type udid: str
        :param device_type: The type of the device, for example: \"Kiosk\", \"Beacon\".
        :type device_type: str
        :param device_power: Edysen device power level setting
        :type device_power: float
        :param device_interference: Edysen device inteference setting
        :type device_interference: float
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_offer_serialize(
            include_offer_locations=include_offer_locations,
            title=title,
            barcode_type=barcode_type,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            active=active,
            device_id=device_id,
            account_id=account_id,
            tags=tags,
            parent_offer_id=parent_offer_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            external_id=external_id,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            ticket_price_type=ticket_price_type,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            category_ids=category_ids,
            filter_ids=filter_ids,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            brand=brand,
            product_type=product_type,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            department=department,
            features=features,
            minimum_price=minimum_price,
            width=width,
            height=height,
            depth=depth,
            weight=weight,
            unit=unit,
            studio=studio,
            parental_rating=parental_rating,
            publish_date=publish_date,
            availability_date=availability_date,
            size_id=size_id,
            listing_id=listing_id,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            reboot_time_hour=reboot_time_hour,
            reboot_time_minute=reboot_time_minute,
            idle_timeout_in_second=idle_timeout_in_second,
            serial_number=serial_number,
            udid=udid,
            device_type=device_type,
            device_power=device_power,
            device_interference=device_interference,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_offer_without_preload_content(
        self,
        include_offer_locations: Annotated[StrictBool, Field(description="If true return all the offer locations associated with the offer")],
        title: Annotated[StrictStr, Field(description="The title (255 char limit)")],
        barcode_type: Annotated[StrictStr, Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")],
        no_expiration: Annotated[StrictBool, Field(description="Overrides the expiration date so that the offer does not expire")],
        available_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be used by consumers")],
        available_limit_per_user: Annotated[StrictInt, Field(description="The limit of how many times a user can used the same offer")],
        added_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be added to consumer wallets")],
        view_limit: Annotated[StrictInt, Field(description="The limit of how many times the offer can be viewed")],
        max_prints: Annotated[StrictInt, Field(description="The maximum number of times the offer can be printed")],
        ticket_price: Annotated[StrictInt, Field(description="The cost of the offer in tickets")],
        full_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The retail/full price cost of the offer in real currency")],
        discount_price: Annotated[Union[StrictFloat, StrictInt], Field(description="The cost of the offer at a discounted price (what the consumer pays)")],
        offer_type: Annotated[StrictStr, Field(description="The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE}")],
        special_offer_type: Annotated[StrictStr, Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")],
        offer_visibility: Annotated[StrictStr, Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")],
        active: Annotated[StrictBool, Field(description="Sets the active flag")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id (deviceId or accountId required)")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        parent_offer_id: Annotated[Optional[StrictInt], Field(description="the parent offer id")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        external_id: Annotated[Optional[StrictStr], Field(description="an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer")] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy offer")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show remaining offers available")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many offers have been redeemed")] = None,
        replaced: Optional[StrictBool] = None,
        featured: Annotated[Optional[StrictBool], Field(description="flag if offer is featured or not")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        brand: Annotated[Optional[StrictStr], Field(description="The brand. OfferType PRODUCT only.")] = None,
        product_type: Annotated[Optional[StrictStr], Field(description="The product type. OfferType PRODUCT only.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        department: Annotated[Optional[StrictStr], Field(description="The department name. The OfferType PRODUCT only.")] = None,
        features: Annotated[Optional[StrictStr], Field(description="The list of features, comma seperated. OfferType PRODUCT only.")] = None,
        minimum_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The MAP price. OfferType PRODUCT only.")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The width of the item. OfferType PRODUCT only.")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The height of the item. OfferType PRODUCT only.")] = None,
        depth: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The depth of the item. OfferType PRODUCT only.")] = None,
        weight: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The weight of the item. OfferType PRODUCT only.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit of measurement. OfferType PRODUCT only.")] = None,
        studio: Annotated[Optional[StrictStr], Field(description="The studio name. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        publish_date: Annotated[Optional[StrictInt], Field(description="The date published. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        size_id: Optional[StrictInt] = None,
        listing_id: Annotated[Optional[StrictInt], Field(description="The ID of the event listing")] = None,
        media_type: Annotated[Optional[StrictStr], Field(description="the media type of the offer")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        reboot_time_hour: Annotated[Optional[StrictInt], Field(description="The reboot hour time ranging from 0 to 23")] = None,
        reboot_time_minute: Annotated[Optional[StrictInt], Field(description="The reboot minute time ranging from 0 to 59")] = None,
        idle_timeout_in_second: Annotated[Optional[StrictInt], Field(description="If the device is idle for idleTimeoutInSecond then the device should timeout")] = None,
        serial_number: Annotated[Optional[StrictStr], Field(description="The serial number on the device")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The unique device id for the device")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of the device, for example: \"Kiosk\", \"Beacon\".")] = None,
        device_power: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Edysen device power level setting")] = None,
        device_interference: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Edysen device inteference setting")] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Offer

        Create an offer and assign it to the provided retailer locations.

        :param include_offer_locations: If true return all the offer locations associated with the offer (required)
        :type include_offer_locations: bool
        :param title: The title (255 char limit) (required)
        :type title: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA} (required)
        :type barcode_type: str
        :param no_expiration: Overrides the expiration date so that the offer does not expire (required)
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers (required)
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer (required)
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets (required)
        :type added_limit: int
        :param view_limit: The limit of how many times the offer can be viewed (required)
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed (required)
        :type max_prints: int
        :param ticket_price: The cost of the offer in tickets (required)
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency (required)
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays) (required)
        :type discount_price: float
        :param offer_type: The offer type {VOUCHER, COUPON, PRODUCT, EVENT, MEDIA, DEVICE} (required)
        :type offer_type: str
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW} (required)
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE} (required)
        :type offer_visibility: str
        :param active: Sets the active flag (required)
        :type active: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id (deviceId or accountId required)
        :type account_id: int
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param parent_offer_id: the parent offer id
        :type parent_offer_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param external_id: an external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer
        :type external_id: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param ticket_price_type: the type of ticket needed to buy offer
        :type ticket_price_type: str
        :param show_remaining: show remaining offers available
        :type show_remaining: bool
        :param show_redeemed: show how many offers have been redeemed
        :type show_redeemed: bool
        :param replaced: 
        :type replaced: bool
        :param featured: flag if offer is featured or not
        :type featured: bool
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param brand: The brand. OfferType PRODUCT only.
        :type brand: str
        :param product_type: The product type. OfferType PRODUCT only.
        :type product_type: str
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param department: The department name. The OfferType PRODUCT only.
        :type department: str
        :param features: The list of features, comma seperated. OfferType PRODUCT only.
        :type features: str
        :param minimum_price: The MAP price. OfferType PRODUCT only.
        :type minimum_price: float
        :param width: The width of the item. OfferType PRODUCT only.
        :type width: float
        :param height: The height of the item. OfferType PRODUCT only.
        :type height: float
        :param depth: The depth of the item. OfferType PRODUCT only.
        :type depth: float
        :param weight: The weight of the item. OfferType PRODUCT only.
        :type weight: float
        :param unit: The unit of measurement. OfferType PRODUCT only.
        :type unit: str
        :param studio: The studio name. OfferType PRODUCT only.
        :type studio: str
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param publish_date: The date published. OfferType PRODUCT only.
        :type publish_date: int
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param size_id: 
        :type size_id: int
        :param listing_id: The ID of the event listing
        :type listing_id: int
        :param media_type: the media type of the offer
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param reboot_time_hour: The reboot hour time ranging from 0 to 23
        :type reboot_time_hour: int
        :param reboot_time_minute: The reboot minute time ranging from 0 to 59
        :type reboot_time_minute: int
        :param idle_timeout_in_second: If the device is idle for idleTimeoutInSecond then the device should timeout
        :type idle_timeout_in_second: int
        :param serial_number: The serial number on the device
        :type serial_number: str
        :param udid: The unique device id for the device
        :type udid: str
        :param device_type: The type of the device, for example: \"Kiosk\", \"Beacon\".
        :type device_type: str
        :param device_power: Edysen device power level setting
        :type device_power: float
        :param device_interference: Edysen device inteference setting
        :type device_interference: float
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_offer_serialize(
            include_offer_locations=include_offer_locations,
            title=title,
            barcode_type=barcode_type,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            active=active,
            device_id=device_id,
            account_id=account_id,
            tags=tags,
            parent_offer_id=parent_offer_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            external_id=external_id,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            ticket_price_type=ticket_price_type,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            category_ids=category_ids,
            filter_ids=filter_ids,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            brand=brand,
            product_type=product_type,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            department=department,
            features=features,
            minimum_price=minimum_price,
            width=width,
            height=height,
            depth=depth,
            weight=weight,
            unit=unit,
            studio=studio,
            parental_rating=parental_rating,
            publish_date=publish_date,
            availability_date=availability_date,
            size_id=size_id,
            listing_id=listing_id,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            reboot_time_hour=reboot_time_hour,
            reboot_time_minute=reboot_time_minute,
            idle_timeout_in_second=idle_timeout_in_second,
            serial_number=serial_number,
            udid=udid,
            device_type=device_type,
            device_power=device_power,
            device_interference=device_interference,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_offer_serialize(
        self,
        include_offer_locations,
        title,
        barcode_type,
        no_expiration,
        available_limit,
        available_limit_per_user,
        added_limit,
        view_limit,
        max_prints,
        ticket_price,
        full_price,
        discount_price,
        offer_type,
        special_offer_type,
        offer_visibility,
        active,
        device_id,
        account_id,
        tags,
        parent_offer_id,
        retailer_location_ids,
        offer_locations,
        sub_title,
        details,
        sub_details,
        fine_print,
        barcode_entry,
        external_redeem_options,
        external_url,
        external_id,
        tickets_reward_type,
        tickets_reward,
        activated,
        expires,
        ticket_price_type,
        show_remaining,
        show_redeemed,
        replaced,
        featured,
        category_ids,
        filter_ids,
        barcode_asset_id,
        image_asset_id,
        image_asset_id1,
        image_asset_id2,
        image_asset_id3,
        image_asset_id4,
        image_asset_id5,
        publisher,
        redeemable_start,
        redeemable_end,
        brand,
        product_type,
        condition_type,
        isbn,
        asin,
        catalog_numbers,
        department,
        features,
        minimum_price,
        width,
        height,
        depth,
        weight,
        unit,
        studio,
        parental_rating,
        publish_date,
        availability_date,
        size_id,
        listing_id,
        media_type,
        duration,
        author,
        release_date,
        collection_ids,
        reboot_time_hour,
        reboot_time_minute,
        idle_timeout_in_second,
        serial_number,
        udid,
        device_type,
        device_power,
        device_interference,
        availability,
        availability_summary,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if parent_offer_id is not None:
            
            _query_params.append(('parentOfferId', parent_offer_id))
            
        if include_offer_locations is not None:
            
            _query_params.append(('includeOfferLocations', include_offer_locations))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if offer_locations is not None:
            
            _query_params.append(('offerLocations', offer_locations))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if sub_title is not None:
            
            _query_params.append(('subTitle', sub_title))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if sub_details is not None:
            
            _query_params.append(('subDetails', sub_details))
            
        if fine_print is not None:
            
            _query_params.append(('finePrint', fine_print))
            
        if barcode_type is not None:
            
            _query_params.append(('barcodeType', barcode_type))
            
        if barcode_entry is not None:
            
            _query_params.append(('barcodeEntry', barcode_entry))
            
        if external_redeem_options is not None:
            
            _query_params.append(('externalRedeemOptions', external_redeem_options))
            
        if external_url is not None:
            
            _query_params.append(('externalUrl', external_url))
            
        if external_id is not None:
            
            _query_params.append(('externalId', external_id))
            
        if tickets_reward_type is not None:
            
            _query_params.append(('ticketsRewardType', tickets_reward_type))
            
        if tickets_reward is not None:
            
            _query_params.append(('ticketsReward', tickets_reward))
            
        if activated is not None:
            
            _query_params.append(('activated', activated))
            
        if expires is not None:
            
            _query_params.append(('expires', expires))
            
        if no_expiration is not None:
            
            _query_params.append(('noExpiration', no_expiration))
            
        if available_limit is not None:
            
            _query_params.append(('availableLimit', available_limit))
            
        if available_limit_per_user is not None:
            
            _query_params.append(('availableLimitPerUser', available_limit_per_user))
            
        if added_limit is not None:
            
            _query_params.append(('addedLimit', added_limit))
            
        if view_limit is not None:
            
            _query_params.append(('viewLimit', view_limit))
            
        if max_prints is not None:
            
            _query_params.append(('maxPrints', max_prints))
            
        if ticket_price_type is not None:
            
            _query_params.append(('ticketPriceType', ticket_price_type))
            
        if ticket_price is not None:
            
            _query_params.append(('ticketPrice', ticket_price))
            
        if full_price is not None:
            
            _query_params.append(('fullPrice', full_price))
            
        if discount_price is not None:
            
            _query_params.append(('discountPrice', discount_price))
            
        if show_remaining is not None:
            
            _query_params.append(('showRemaining', show_remaining))
            
        if show_redeemed is not None:
            
            _query_params.append(('showRedeemed', show_redeemed))
            
        if replaced is not None:
            
            _query_params.append(('replaced', replaced))
            
        if featured is not None:
            
            _query_params.append(('featured', featured))
            
        if offer_type is not None:
            
            _query_params.append(('offerType', offer_type))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if offer_visibility is not None:
            
            _query_params.append(('offerVisibility', offer_visibility))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if barcode_asset_id is not None:
            
            _query_params.append(('barcodeAssetId', barcode_asset_id))
            
        if image_asset_id is not None:
            
            _query_params.append(('imageAssetId', image_asset_id))
            
        if image_asset_id1 is not None:
            
            _query_params.append(('imageAssetId1', image_asset_id1))
            
        if image_asset_id2 is not None:
            
            _query_params.append(('imageAssetId2', image_asset_id2))
            
        if image_asset_id3 is not None:
            
            _query_params.append(('imageAssetId3', image_asset_id3))
            
        if image_asset_id4 is not None:
            
            _query_params.append(('imageAssetId4', image_asset_id4))
            
        if image_asset_id5 is not None:
            
            _query_params.append(('imageAssetId5', image_asset_id5))
            
        if publisher is not None:
            
            _query_params.append(('publisher', publisher))
            
        if redeemable_start is not None:
            
            _query_params.append(('redeemableStart', redeemable_start))
            
        if redeemable_end is not None:
            
            _query_params.append(('redeemableEnd', redeemable_end))
            
        if brand is not None:
            
            _query_params.append(('brand', brand))
            
        if product_type is not None:
            
            _query_params.append(('productType', product_type))
            
        if condition_type is not None:
            
            _query_params.append(('conditionType', condition_type))
            
        if isbn is not None:
            
            _query_params.append(('isbn', isbn))
            
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if catalog_numbers is not None:
            
            _query_params.append(('catalogNumbers', catalog_numbers))
            
        if department is not None:
            
            _query_params.append(('department', department))
            
        if features is not None:
            
            _query_params.append(('features', features))
            
        if minimum_price is not None:
            
            _query_params.append(('minimumPrice', minimum_price))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if weight is not None:
            
            _query_params.append(('weight', weight))
            
        if unit is not None:
            
            _query_params.append(('unit', unit))
            
        if studio is not None:
            
            _query_params.append(('studio', studio))
            
        if parental_rating is not None:
            
            _query_params.append(('parentalRating', parental_rating))
            
        if publish_date is not None:
            
            _query_params.append(('publishDate', publish_date))
            
        if availability_date is not None:
            
            _query_params.append(('availabilityDate', availability_date))
            
        if size_id is not None:
            
            _query_params.append(('sizeId', size_id))
            
        if listing_id is not None:
            
            _query_params.append(('listingId', listing_id))
            
        if media_type is not None:
            
            _query_params.append(('mediaType', media_type))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if author is not None:
            
            _query_params.append(('author', author))
            
        if release_date is not None:
            
            _query_params.append(('releaseDate', release_date))
            
        if collection_ids is not None:
            
            _query_params.append(('collectionIds', collection_ids))
            
        if reboot_time_hour is not None:
            
            _query_params.append(('rebootTimeHour', reboot_time_hour))
            
        if reboot_time_minute is not None:
            
            _query_params.append(('rebootTimeMinute', reboot_time_minute))
            
        if idle_timeout_in_second is not None:
            
            _query_params.append(('idleTimeoutInSecond', idle_timeout_in_second))
            
        if serial_number is not None:
            
            _query_params.append(('serialNumber', serial_number))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        if device_type is not None:
            
            _query_params.append(('deviceType', device_type))
            
        if device_power is not None:
            
            _query_params.append(('devicePower', device_power))
            
        if device_interference is not None:
            
            _query_params.append(('deviceInterference', device_interference))
            
        if availability is not None:
            
            _query_params.append(('availability', availability))
            
        if availability_summary is not None:
            
            _query_params.append(('availabilitySummary', availability_summary))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_offer(
        self,
        offer_id: Annotated[StrictInt, Field(description="The ID of the offer to be deleted")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the offer.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Offer

        Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.

        :param offer_id: The ID of the offer to be deleted (required)
        :type offer_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the offer.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_serialize(
            offer_id=offer_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_offer_with_http_info(
        self,
        offer_id: Annotated[StrictInt, Field(description="The ID of the offer to be deleted")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the offer.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Offer

        Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.

        :param offer_id: The ID of the offer to be deleted (required)
        :type offer_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the offer.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_serialize(
            offer_id=offer_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_offer_without_preload_content(
        self,
        offer_id: Annotated[StrictInt, Field(description="The ID of the offer to be deleted")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the offer.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Offer

        Set the deleted timestamp to current time. This effectively deletes the offer since all queries should ignore any records with a deleted time stamp.

        :param offer_id: The ID of the offer to be deleted (required)
        :type offer_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the offer.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_serialize(
            offer_id=offer_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_offer_serialize(
        self,
        offer_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_offer_location(
        self,
        offer_location_id: Annotated[StrictInt, Field(description="The ID of the offer location to be deleted")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the offer location.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Offer Location

        Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.

        :param offer_location_id: The ID of the offer location to be deleted (required)
        :type offer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the offer location.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_location_serialize(
            offer_location_id=offer_location_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_offer_location_with_http_info(
        self,
        offer_location_id: Annotated[StrictInt, Field(description="The ID of the offer location to be deleted")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the offer location.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Offer Location

        Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.

        :param offer_location_id: The ID of the offer location to be deleted (required)
        :type offer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the offer location.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_location_serialize(
            offer_location_id=offer_location_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_offer_location_without_preload_content(
        self,
        offer_location_id: Annotated[StrictInt, Field(description="The ID of the offer location to be deleted")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the delete, must have rights to edit the offer location.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Offer Location

        Set the deleted timestamp to current time. This effectively deletes the offer location since all queries should ignore any records with a deleted time stamp.

        :param offer_location_id: The ID of the offer location to be deleted (required)
        :type offer_location_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the delete, must have rights to edit the offer location.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_location_serialize(
            offer_location_id=offer_location_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_offer_location_serialize(
        self,
        offer_location_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/location/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offer(
        self,
        offer_id: Annotated[StrictInt, Field(description="The id of the offer")],
        include_offer_locations: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerOfferResponse:
        """Get Offer

        Gets the details of an offer that the user has access to.

        :param offer_id: The id of the offer (required)
        :type offer_id: int
        :param include_offer_locations:  (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_serialize(
            offer_id=offer_id,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offer_with_http_info(
        self,
        offer_id: Annotated[StrictInt, Field(description="The id of the offer")],
        include_offer_locations: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerOfferResponse]:
        """Get Offer

        Gets the details of an offer that the user has access to.

        :param offer_id: The id of the offer (required)
        :type offer_id: int
        :param include_offer_locations:  (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_serialize(
            offer_id=offer_id,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offer_without_preload_content(
        self,
        offer_id: Annotated[StrictInt, Field(description="The id of the offer")],
        include_offer_locations: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Offer

        Gets the details of an offer that the user has access to.

        :param offer_id: The id of the offer (required)
        :type offer_id: int
        :param include_offer_locations:  (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_serialize(
            offer_id=offer_id,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offer_serialize(
        self,
        offer_id,
        include_offer_locations,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if include_offer_locations is not None:
            
            _query_params.append(('includeOfferLocations', include_offer_locations))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/retailer/offer/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offer_details(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. favorites)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. favorites)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The offer id (either offeLocationId or offerId must be provided)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The offer location id (either offeLocationId or offerId must be provided)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The distance of the offer from the user's current location (this is returned when the offer is searched)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude to calculate distance from the offer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude to calculate distance from the offer")] = None,
        include_offer_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to return offer locations for the offer")] = None,
        include_retailer_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)")] = None,
        include_child_offers: Annotated[Optional[StrictBool], Field(description="Determines whether to include child offers in the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferResponse:
        """Get Offer

        Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.

        :param device_id: The device id for returning account information (i.e. favorites)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. favorites)
        :type account_id: int
        :param offer_id: The offer id (either offeLocationId or offerId must be provided)
        :type offer_id: int
        :param offer_location_id: The offer location id (either offeLocationId or offerId must be provided)
        :type offer_location_id: int
        :param distance: The distance of the offer from the user's current location (this is returned when the offer is searched)
        :type distance: float
        :param latitude: The latitude to calculate distance from the offer
        :type latitude: float
        :param longitude: The longitude to calculate distance from the offer
        :type longitude: float
        :param include_offer_locations: Determines whether to return offer locations for the offer
        :type include_offer_locations: bool
        :param include_retailer_locations: Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)
        :type include_retailer_locations: bool
        :param include_child_offers: Determines whether to include child offers in the response
        :type include_child_offers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_details_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            distance=distance,
            latitude=latitude,
            longitude=longitude,
            include_offer_locations=include_offer_locations,
            include_retailer_locations=include_retailer_locations,
            include_child_offers=include_child_offers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offer_details_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. favorites)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. favorites)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The offer id (either offeLocationId or offerId must be provided)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The offer location id (either offeLocationId or offerId must be provided)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The distance of the offer from the user's current location (this is returned when the offer is searched)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude to calculate distance from the offer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude to calculate distance from the offer")] = None,
        include_offer_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to return offer locations for the offer")] = None,
        include_retailer_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)")] = None,
        include_child_offers: Annotated[Optional[StrictBool], Field(description="Determines whether to include child offers in the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferResponse]:
        """Get Offer

        Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.

        :param device_id: The device id for returning account information (i.e. favorites)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. favorites)
        :type account_id: int
        :param offer_id: The offer id (either offeLocationId or offerId must be provided)
        :type offer_id: int
        :param offer_location_id: The offer location id (either offeLocationId or offerId must be provided)
        :type offer_location_id: int
        :param distance: The distance of the offer from the user's current location (this is returned when the offer is searched)
        :type distance: float
        :param latitude: The latitude to calculate distance from the offer
        :type latitude: float
        :param longitude: The longitude to calculate distance from the offer
        :type longitude: float
        :param include_offer_locations: Determines whether to return offer locations for the offer
        :type include_offer_locations: bool
        :param include_retailer_locations: Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)
        :type include_retailer_locations: bool
        :param include_child_offers: Determines whether to include child offers in the response
        :type include_child_offers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_details_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            distance=distance,
            latitude=latitude,
            longitude=longitude,
            include_offer_locations=include_offer_locations,
            include_retailer_locations=include_retailer_locations,
            include_child_offers=include_child_offers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offer_details_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. favorites)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. favorites)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The offer id (either offeLocationId or offerId must be provided)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The offer location id (either offeLocationId or offerId must be provided)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The distance of the offer from the user's current location (this is returned when the offer is searched)")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude to calculate distance from the offer")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The longitude to calculate distance from the offer")] = None,
        include_offer_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to return offer locations for the offer")] = None,
        include_retailer_locations: Annotated[Optional[StrictBool], Field(description="Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)")] = None,
        include_child_offers: Annotated[Optional[StrictBool], Field(description="Determines whether to include child offers in the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Offer

        Gets offer or offer location details as a consumer.  Will check if it is a favorite if the deviceId/accountId is provided.  If the offerId is provided it will look up the main offer and ignore the the offerLocationId. If no offerId is provided then an offerLocationId must be specified.

        :param device_id: The device id for returning account information (i.e. favorites)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. favorites)
        :type account_id: int
        :param offer_id: The offer id (either offeLocationId or offerId must be provided)
        :type offer_id: int
        :param offer_location_id: The offer location id (either offeLocationId or offerId must be provided)
        :type offer_location_id: int
        :param distance: The distance of the offer from the user's current location (this is returned when the offer is searched)
        :type distance: float
        :param latitude: The latitude to calculate distance from the offer
        :type latitude: float
        :param longitude: The longitude to calculate distance from the offer
        :type longitude: float
        :param include_offer_locations: Determines whether to return offer locations for the offer
        :type include_offer_locations: bool
        :param include_retailer_locations: Determines whether to return the retailer location info for each offer location response (includeOfferLocations must also be true for this to work)
        :type include_retailer_locations: bool
        :param include_child_offers: Determines whether to include child offers in the response
        :type include_child_offers: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_details_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            distance=distance,
            latitude=latitude,
            longitude=longitude,
            include_offer_locations=include_offer_locations,
            include_retailer_locations=include_retailer_locations,
            include_child_offers=include_child_offers,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offer_details_serialize(
        self,
        device_id,
        account_id,
        offer_id,
        offer_location_id,
        distance,
        latitude,
        longitude,
        include_offer_locations,
        include_retailer_locations,
        include_child_offers,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if distance is not None:
            
            _query_params.append(('distance', distance))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if include_offer_locations is not None:
            
            _query_params.append(('includeOfferLocations', include_offer_locations))
            
        if include_retailer_locations is not None:
            
            _query_params.append(('includeRetailerLocations', include_retailer_locations))
            
        if include_child_offers is not None:
            
            _query_params.append(('includeChildOffers', include_child_offers))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offer/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offer_list_counts(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of where the search will center at")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of where the search will center at")],
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range of the search")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="The units to use for distance calculations (e.g. MILES, KILOMETERS)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ListCountResponse:
        """Get Offers (Counts)

        Gets the offer list counts.

        :param latitude: The latitude of where the search will center at (required)
        :type latitude: float
        :param longitude: The longitude of where the search will center at (required)
        :type longitude: float
        :param search_range: The range of the search
        :type search_range: float
        :param distance_unit: The units to use for distance calculations (e.g. MILES, KILOMETERS)
        :type distance_unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_list_counts_serialize(
            latitude=latitude,
            longitude=longitude,
            search_range=search_range,
            distance_unit=distance_unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCountResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offer_list_counts_with_http_info(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of where the search will center at")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of where the search will center at")],
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range of the search")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="The units to use for distance calculations (e.g. MILES, KILOMETERS)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[ListCountResponse]:
        """Get Offers (Counts)

        Gets the offer list counts.

        :param latitude: The latitude of where the search will center at (required)
        :type latitude: float
        :param longitude: The longitude of where the search will center at (required)
        :type longitude: float
        :param search_range: The range of the search
        :type search_range: float
        :param distance_unit: The units to use for distance calculations (e.g. MILES, KILOMETERS)
        :type distance_unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_list_counts_serialize(
            latitude=latitude,
            longitude=longitude,
            search_range=search_range,
            distance_unit=distance_unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCountResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offer_list_counts_without_preload_content(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of where the search will center at")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of where the search will center at")],
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range of the search")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="The units to use for distance calculations (e.g. MILES, KILOMETERS)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Offers (Counts)

        Gets the offer list counts.

        :param latitude: The latitude of where the search will center at (required)
        :type latitude: float
        :param longitude: The longitude of where the search will center at (required)
        :type longitude: float
        :param search_range: The range of the search
        :type search_range: float
        :param distance_unit: The units to use for distance calculations (e.g. MILES, KILOMETERS)
        :type distance_unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_list_counts_serialize(
            latitude=latitude,
            longitude=longitude,
            search_range=search_range,
            distance_unit=distance_unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "ListCountResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offer_list_counts_serialize(
        self,
        latitude,
        longitude,
        search_range,
        distance_unit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if distance_unit is not None:
            
            _query_params.append(('distanceUnit', distance_unit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offer/lists/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offer_location(
        self,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the offer location to get")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="the UDID of the device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferShortResponse:
        """Get Offer Location

        Gets the offer location by offer location id or udid (of a device)

        :param offer_location_id: the id of the offer location to get
        :type offer_location_id: int
        :param udid: the UDID of the device
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_location_serialize(
            offer_location_id=offer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offer_location_with_http_info(
        self,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the offer location to get")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="the UDID of the device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferShortResponse]:
        """Get Offer Location

        Gets the offer location by offer location id or udid (of a device)

        :param offer_location_id: the id of the offer location to get
        :type offer_location_id: int
        :param udid: the UDID of the device
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_location_serialize(
            offer_location_id=offer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offer_location_without_preload_content(
        self,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the offer location to get")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="the UDID of the device")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Offer Location

        Gets the offer location by offer location id or udid (of a device)

        :param offer_location_id: the id of the offer location to get
        :type offer_location_id: int
        :param udid: the UDID of the device
        :type udid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_location_serialize(
            offer_location_id=offer_location_id,
            udid=udid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferShortResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offer_location_serialize(
        self,
        offer_location_id,
        udid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offer/location/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offer_locations_for_retailers(
        self,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}")],
        descending: Annotated[StrictBool, Field(description="The order to return the results. Default is false, which will return the results in ascending order.")],
        start: Annotated[StrictInt, Field(description="The index into the record set to start with. Default is 0.")],
        limit: Annotated[StrictInt, Field(description="The total number of records to return. Default is 20.")],
        active_only: Annotated[StrictBool, Field(description="Determines whether to return only active results. Default is false.")],
        include_retailer_location: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific retailer location")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        barcode_type: Optional[StrictStr] = None,
        barcode_entry: Optional[StrictStr] = None,
        isbn: Optional[StrictStr] = None,
        asin: Optional[StrictStr] = None,
        device_status: Annotated[Optional[StrictStr], Field(description="Edysen device status, running, warning, or down")] = None,
        needs_notification_sent: Optional[StrictBool] = None,
        last_notification_sent: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OfferShortResponse]:
        """Search Offer Locations

        Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.

        :param sort_field: The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order. (required)
        :type descending: bool
        :param start: The index into the record set to start with. Default is 0. (required)
        :type start: int
        :param limit: The total number of records to return. Default is 20. (required)
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false. (required)
        :type active_only: bool
        :param include_retailer_location:  (required)
        :type include_retailer_location: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_id: Filter results for a specific retailer
        :type retailer_id: int
        :param retailer_location_id: Filter results for a specific retailer location
        :type retailer_location_id: int
        :param offer_type: Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param barcode_type: 
        :type barcode_type: str
        :param barcode_entry: 
        :type barcode_entry: str
        :param isbn: 
        :type isbn: str
        :param asin: 
        :type asin: str
        :param device_status: Edysen device status, running, warning, or down
        :type device_status: str
        :param needs_notification_sent: 
        :type needs_notification_sent: bool
        :param last_notification_sent: 
        :type last_notification_sent: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_locations_for_retailers_serialize(
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            include_retailer_location=include_retailer_location,
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            isbn=isbn,
            asin=asin,
            device_status=device_status,
            needs_notification_sent=needs_notification_sent,
            last_notification_sent=last_notification_sent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offer_locations_for_retailers_with_http_info(
        self,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}")],
        descending: Annotated[StrictBool, Field(description="The order to return the results. Default is false, which will return the results in ascending order.")],
        start: Annotated[StrictInt, Field(description="The index into the record set to start with. Default is 0.")],
        limit: Annotated[StrictInt, Field(description="The total number of records to return. Default is 20.")],
        active_only: Annotated[StrictBool, Field(description="Determines whether to return only active results. Default is false.")],
        include_retailer_location: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific retailer location")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        barcode_type: Optional[StrictStr] = None,
        barcode_entry: Optional[StrictStr] = None,
        isbn: Optional[StrictStr] = None,
        asin: Optional[StrictStr] = None,
        device_status: Annotated[Optional[StrictStr], Field(description="Edysen device status, running, warning, or down")] = None,
        needs_notification_sent: Optional[StrictBool] = None,
        last_notification_sent: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OfferShortResponse]]:
        """Search Offer Locations

        Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.

        :param sort_field: The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order. (required)
        :type descending: bool
        :param start: The index into the record set to start with. Default is 0. (required)
        :type start: int
        :param limit: The total number of records to return. Default is 20. (required)
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false. (required)
        :type active_only: bool
        :param include_retailer_location:  (required)
        :type include_retailer_location: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_id: Filter results for a specific retailer
        :type retailer_id: int
        :param retailer_location_id: Filter results for a specific retailer location
        :type retailer_location_id: int
        :param offer_type: Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param barcode_type: 
        :type barcode_type: str
        :param barcode_entry: 
        :type barcode_entry: str
        :param isbn: 
        :type isbn: str
        :param asin: 
        :type asin: str
        :param device_status: Edysen device status, running, warning, or down
        :type device_status: str
        :param needs_notification_sent: 
        :type needs_notification_sent: bool
        :param last_notification_sent: 
        :type last_notification_sent: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_locations_for_retailers_serialize(
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            include_retailer_location=include_retailer_location,
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            isbn=isbn,
            asin=asin,
            device_status=device_status,
            needs_notification_sent=needs_notification_sent,
            last_notification_sent=last_notification_sent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offer_locations_for_retailers_without_preload_content(
        self,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}")],
        descending: Annotated[StrictBool, Field(description="The order to return the results. Default is false, which will return the results in ascending order.")],
        start: Annotated[StrictInt, Field(description="The index into the record set to start with. Default is 0.")],
        limit: Annotated[StrictInt, Field(description="The total number of records to return. Default is 20.")],
        active_only: Annotated[StrictBool, Field(description="Determines whether to return only active results. Default is false.")],
        include_retailer_location: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for a specific retailer location")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        barcode_type: Optional[StrictStr] = None,
        barcode_entry: Optional[StrictStr] = None,
        isbn: Optional[StrictStr] = None,
        asin: Optional[StrictStr] = None,
        device_status: Annotated[Optional[StrictStr], Field(description="Edysen device status, running, warning, or down")] = None,
        needs_notification_sent: Optional[StrictBool] = None,
        last_notification_sent: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Offer Locations

        Searches on offer locations, which are records that represent an offer that has been assigned to a retailer location. If an offer does not have any locations assigned, then it will NOT be returned.

        :param sort_field: The column to sort the results on. Default is \"TITLE\", which will sort the results by the offer title. Possible input values: {CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, RETAILER_ID,RETAILER_LOCATION_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order. (required)
        :type descending: bool
        :param start: The index into the record set to start with. Default is 0. (required)
        :type start: int
        :param limit: The total number of records to return. Default is 20. (required)
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false. (required)
        :type active_only: bool
        :param include_retailer_location:  (required)
        :type include_retailer_location: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_id: Filter results for a specific retailer
        :type retailer_id: int
        :param retailer_location_id: Filter results for a specific retailer location
        :type retailer_location_id: int
        :param offer_type: Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param barcode_type: 
        :type barcode_type: str
        :param barcode_entry: 
        :type barcode_entry: str
        :param isbn: 
        :type isbn: str
        :param asin: 
        :type asin: str
        :param device_status: Edysen device status, running, warning, or down
        :type device_status: str
        :param needs_notification_sent: 
        :type needs_notification_sent: bool
        :param last_notification_sent: 
        :type last_notification_sent: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_locations_for_retailers_serialize(
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            include_retailer_location=include_retailer_location,
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            isbn=isbn,
            asin=asin,
            device_status=device_status,
            needs_notification_sent=needs_notification_sent,
            last_notification_sent=last_notification_sent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offer_locations_for_retailers_serialize(
        self,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        include_retailer_location,
        device_id,
        account_id,
        keyword,
        retailer_id,
        retailer_location_id,
        offer_type,
        special_offer_type,
        barcode_type,
        barcode_entry,
        isbn,
        asin,
        device_status,
        needs_notification_sent,
        last_notification_sent,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if offer_type is not None:
            
            _query_params.append(('offerType', offer_type))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if include_retailer_location is not None:
            
            _query_params.append(('includeRetailerLocation', include_retailer_location))
            
        if barcode_type is not None:
            
            _query_params.append(('barcodeType', barcode_type))
            
        if barcode_entry is not None:
            
            _query_params.append(('barcodeEntry', barcode_entry))
            
        if isbn is not None:
            
            _query_params.append(('isbn', isbn))
            
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if device_status is not None:
            
            _query_params.append(('deviceStatus', device_status))
            
        if needs_notification_sent is not None:
            
            _query_params.append(('needsNotificationSent', needs_notification_sent))
            
        if last_notification_sent is not None:
            
            _query_params.append(('lastNotificationSent', last_notification_sent))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/retailer/offer/location/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offers_for_retailers(
        self,
        offer_visibility: StrictStr,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The record to begin the return set on")],
        limit: Annotated[StrictInt, Field(description="The number of records to return")],
        available_only: Annotated[StrictBool, Field(description="Return only results that are currently being promoted (is activated and not expired)")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        include_categories: StrictBool,
        include_filters: StrictBool,
        include_offer_locations: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        category_ids: Optional[StrictStr] = None,
        filter_ids: Optional[StrictStr] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location")] = None,
        coupon_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        barcode_type: Optional[StrictStr] = None,
        barcode_entry: Optional[StrictStr] = None,
        isbn: Optional[StrictStr] = None,
        asin: Optional[StrictStr] = None,
        device_status: Annotated[Optional[StrictStr], Field(description="Edysen device status")] = None,
        needs_notification_sent: Optional[StrictBool] = None,
        last_notification_sent: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OfferResponse]:
        """Search Offers

        Searches on offers that the account has access to.

        :param offer_visibility:  (required)
        :type offer_visibility: str
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The record to begin the return set on (required)
        :type start: int
        :param limit: The number of records to return (required)
        :type limit: int
        :param available_only: Return only results that are currently being promoted (is activated and not expired) (required)
        :type available_only: bool
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param include_categories:  (required)
        :type include_categories: bool
        :param include_filters:  (required)
        :type include_filters: bool
        :param include_offer_locations:  (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param category_ids: 
        :type category_ids: str
        :param filter_ids: 
        :type filter_ids: str
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_id: the id of the retailer
        :type retailer_id: int
        :param retailer_location_id: the id of the retailer location
        :type retailer_location_id: int
        :param coupon_type: This parameter is deprecated.
        :type coupon_type: str
        :param offer_type: This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param offer_types: Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        :type offer_types: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param barcode_type: 
        :type barcode_type: str
        :param barcode_entry: 
        :type barcode_entry: str
        :param isbn: 
        :type isbn: str
        :param asin: 
        :type asin: str
        :param device_status: Edysen device status
        :type device_status: str
        :param needs_notification_sent: 
        :type needs_notification_sent: bool
        :param last_notification_sent: 
        :type last_notification_sent: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offers_for_retailers_serialize(
            offer_visibility=offer_visibility,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            available_only=available_only,
            active_only=active_only,
            include_categories=include_categories,
            include_filters=include_filters,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            q=q,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            coupon_type=coupon_type,
            offer_type=offer_type,
            offer_types=offer_types,
            special_offer_type=special_offer_type,
            i=i,
            l=l,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            isbn=isbn,
            asin=asin,
            device_status=device_status,
            needs_notification_sent=needs_notification_sent,
            last_notification_sent=last_notification_sent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offers_for_retailers_with_http_info(
        self,
        offer_visibility: StrictStr,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The record to begin the return set on")],
        limit: Annotated[StrictInt, Field(description="The number of records to return")],
        available_only: Annotated[StrictBool, Field(description="Return only results that are currently being promoted (is activated and not expired)")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        include_categories: StrictBool,
        include_filters: StrictBool,
        include_offer_locations: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        category_ids: Optional[StrictStr] = None,
        filter_ids: Optional[StrictStr] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location")] = None,
        coupon_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        barcode_type: Optional[StrictStr] = None,
        barcode_entry: Optional[StrictStr] = None,
        isbn: Optional[StrictStr] = None,
        asin: Optional[StrictStr] = None,
        device_status: Annotated[Optional[StrictStr], Field(description="Edysen device status")] = None,
        needs_notification_sent: Optional[StrictBool] = None,
        last_notification_sent: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OfferResponse]]:
        """Search Offers

        Searches on offers that the account has access to.

        :param offer_visibility:  (required)
        :type offer_visibility: str
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The record to begin the return set on (required)
        :type start: int
        :param limit: The number of records to return (required)
        :type limit: int
        :param available_only: Return only results that are currently being promoted (is activated and not expired) (required)
        :type available_only: bool
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param include_categories:  (required)
        :type include_categories: bool
        :param include_filters:  (required)
        :type include_filters: bool
        :param include_offer_locations:  (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param category_ids: 
        :type category_ids: str
        :param filter_ids: 
        :type filter_ids: str
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_id: the id of the retailer
        :type retailer_id: int
        :param retailer_location_id: the id of the retailer location
        :type retailer_location_id: int
        :param coupon_type: This parameter is deprecated.
        :type coupon_type: str
        :param offer_type: This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param offer_types: Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        :type offer_types: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param barcode_type: 
        :type barcode_type: str
        :param barcode_entry: 
        :type barcode_entry: str
        :param isbn: 
        :type isbn: str
        :param asin: 
        :type asin: str
        :param device_status: Edysen device status
        :type device_status: str
        :param needs_notification_sent: 
        :type needs_notification_sent: bool
        :param last_notification_sent: 
        :type last_notification_sent: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offers_for_retailers_serialize(
            offer_visibility=offer_visibility,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            available_only=available_only,
            active_only=active_only,
            include_categories=include_categories,
            include_filters=include_filters,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            q=q,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            coupon_type=coupon_type,
            offer_type=offer_type,
            offer_types=offer_types,
            special_offer_type=special_offer_type,
            i=i,
            l=l,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            isbn=isbn,
            asin=asin,
            device_status=device_status,
            needs_notification_sent=needs_notification_sent,
            last_notification_sent=last_notification_sent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offers_for_retailers_without_preload_content(
        self,
        offer_visibility: StrictStr,
        sort_field: Annotated[StrictStr, Field(description="The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY")],
        descending: Annotated[StrictBool, Field(description="The order to return the search results")],
        start: Annotated[StrictInt, Field(description="The record to begin the return set on")],
        limit: Annotated[StrictInt, Field(description="The number of records to return")],
        available_only: Annotated[StrictBool, Field(description="Return only results that are currently being promoted (is activated and not expired)")],
        active_only: Annotated[StrictBool, Field(description="Return only active results")],
        include_categories: StrictBool,
        include_filters: StrictBool,
        include_offer_locations: StrictBool,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        category_ids: Optional[StrictStr] = None,
        filter_ids: Optional[StrictStr] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword used to search")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="the id of the retailer location")] = None,
        coupon_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        barcode_type: Optional[StrictStr] = None,
        barcode_entry: Optional[StrictStr] = None,
        isbn: Optional[StrictStr] = None,
        asin: Optional[StrictStr] = None,
        device_status: Annotated[Optional[StrictStr], Field(description="Edysen device status")] = None,
        needs_notification_sent: Optional[StrictBool] = None,
        last_notification_sent: Optional[StrictInt] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Offers

        Searches on offers that the account has access to.

        :param offer_visibility:  (required)
        :type offer_visibility: str
        :param sort_field: The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, DETAILS, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, ESTIMATED_VALUE, VOUCHER_PRICE, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY (required)
        :type sort_field: str
        :param descending: The order to return the search results (required)
        :type descending: bool
        :param start: The record to begin the return set on (required)
        :type start: int
        :param limit: The number of records to return (required)
        :type limit: int
        :param available_only: Return only results that are currently being promoted (is activated and not expired) (required)
        :type available_only: bool
        :param active_only: Return only active results (required)
        :type active_only: bool
        :param include_categories:  (required)
        :type include_categories: bool
        :param include_filters:  (required)
        :type include_filters: bool
        :param include_offer_locations:  (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param category_ids: 
        :type category_ids: str
        :param filter_ids: 
        :type filter_ids: str
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword used to search
        :type keyword: str
        :param retailer_id: the id of the retailer
        :type retailer_id: int
        :param retailer_location_id: the id of the retailer location
        :type retailer_location_id: int
        :param coupon_type: This parameter is deprecated.
        :type coupon_type: str
        :param offer_type: This parameter is deprecated. Use offer types. Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param offer_types: Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        :type offer_types: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param barcode_type: 
        :type barcode_type: str
        :param barcode_entry: 
        :type barcode_entry: str
        :param isbn: 
        :type isbn: str
        :param asin: 
        :type asin: str
        :param device_status: Edysen device status
        :type device_status: str
        :param needs_notification_sent: 
        :type needs_notification_sent: bool
        :param last_notification_sent: 
        :type last_notification_sent: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offers_for_retailers_serialize(
            offer_visibility=offer_visibility,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            available_only=available_only,
            active_only=active_only,
            include_categories=include_categories,
            include_filters=include_filters,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            category_ids=category_ids,
            filter_ids=filter_ids,
            q=q,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            coupon_type=coupon_type,
            offer_type=offer_type,
            offer_types=offer_types,
            special_offer_type=special_offer_type,
            i=i,
            l=l,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            isbn=isbn,
            asin=asin,
            device_status=device_status,
            needs_notification_sent=needs_notification_sent,
            last_notification_sent=last_notification_sent,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offers_for_retailers_serialize(
        self,
        offer_visibility,
        sort_field,
        descending,
        start,
        limit,
        available_only,
        active_only,
        include_categories,
        include_filters,
        include_offer_locations,
        device_id,
        account_id,
        category_ids,
        filter_ids,
        q,
        keyword,
        retailer_id,
        retailer_location_id,
        coupon_type,
        offer_type,
        offer_types,
        special_offer_type,
        i,
        l,
        barcode_type,
        barcode_entry,
        isbn,
        asin,
        device_status,
        needs_notification_sent,
        last_notification_sent,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if coupon_type is not None:
            
            _query_params.append(('couponType', coupon_type))
            
        if offer_type is not None:
            
            _query_params.append(('offerType', offer_type))
            
        if offer_types is not None:
            
            _query_params.append(('offerTypes', offer_types))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if offer_visibility is not None:
            
            _query_params.append(('offerVisibility', offer_visibility))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if available_only is not None:
            
            _query_params.append(('availableOnly', available_only))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if include_categories is not None:
            
            _query_params.append(('includeCategories', include_categories))
            
        if include_filters is not None:
            
            _query_params.append(('includeFilters', include_filters))
            
        if include_offer_locations is not None:
            
            _query_params.append(('includeOfferLocations', include_offer_locations))
            
        if barcode_type is not None:
            
            _query_params.append(('barcodeType', barcode_type))
            
        if barcode_entry is not None:
            
            _query_params.append(('barcodeEntry', barcode_entry))
            
        if isbn is not None:
            
            _query_params.append(('isbn', isbn))
            
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if device_status is not None:
            
            _query_params.append(('deviceStatus', device_status))
            
        if needs_notification_sent is not None:
            
            _query_params.append(('needsNotificationSent', needs_notification_sent))
            
        if last_notification_sent is not None:
            
            _query_params.append(('lastNotificationSent', last_notification_sent))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/retailer/offer/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def redeem_offer_transaction(
        self,
        offer_transaction_id: Annotated[StrictInt, Field(description="the OfferTransaction ID of the transaction being redeemed")],
        status: Annotated[StrictInt, Field(description="the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="the OfferLocation ID where the offer is being redeemed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Offer Transaction

        Redeems an offer.

        :param offer_transaction_id: the OfferTransaction ID of the transaction being redeemed (required)
        :type offer_transaction_id: int
        :param status: the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed (required)
        :type status: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_location_id: the OfferLocation ID where the offer is being redeemed
        :type offer_location_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._redeem_offer_transaction_serialize(
            offer_transaction_id=offer_transaction_id,
            status=status,
            device_id=device_id,
            account_id=account_id,
            offer_location_id=offer_location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def redeem_offer_transaction_with_http_info(
        self,
        offer_transaction_id: Annotated[StrictInt, Field(description="the OfferTransaction ID of the transaction being redeemed")],
        status: Annotated[StrictInt, Field(description="the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="the OfferLocation ID where the offer is being redeemed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Offer Transaction

        Redeems an offer.

        :param offer_transaction_id: the OfferTransaction ID of the transaction being redeemed (required)
        :type offer_transaction_id: int
        :param status: the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed (required)
        :type status: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_location_id: the OfferLocation ID where the offer is being redeemed
        :type offer_location_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._redeem_offer_transaction_serialize(
            offer_transaction_id=offer_transaction_id,
            status=status,
            device_id=device_id,
            account_id=account_id,
            offer_location_id=offer_location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def redeem_offer_transaction_without_preload_content(
        self,
        offer_transaction_id: Annotated[StrictInt, Field(description="the OfferTransaction ID of the transaction being redeemed")],
        status: Annotated[StrictInt, Field(description="the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="the OfferLocation ID where the offer is being redeemed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Offer Transaction

        Redeems an offer.

        :param offer_transaction_id: the OfferTransaction ID of the transaction being redeemed (required)
        :type offer_transaction_id: int
        :param status: the status to set the offer transaction to - 1 sets it to redeemable and 2 sets it to redeemed (required)
        :type status: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_location_id: the OfferLocation ID where the offer is being redeemed
        :type offer_location_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._redeem_offer_transaction_serialize(
            offer_transaction_id=offer_transaction_id,
            status=status,
            device_id=device_id,
            account_id=account_id,
            offer_location_id=offer_location_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _redeem_offer_transaction_serialize(
        self,
        offer_transaction_id,
        status,
        device_id,
        account_id,
        offer_location_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_transaction_id is not None:
            
            _query_params.append(('offerTransactionId', offer_transaction_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/transaction/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_offer_transactions_for_retailers(
        self,
        sort_field: Annotated[StrictStr, Field(description="Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}")],
        descending: Annotated[StrictBool, Field(description="Determines whether the results are in descending order")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        active_only: Annotated[StrictBool, Field(description="Determines whether to only return active offer transactions")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer location")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer location")] = None,
        redeemed: Annotated[Optional[StrictBool], Field(description="if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)")] = None,
        reservations_only: Annotated[Optional[StrictBool], Field(description="returns only reservation transactions if true")] = None,
        coupon_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        customer_account_ids: Annotated[Optional[StrictStr], Field(description="Filter results by accounts")] = None,
        category_ids: Optional[StrictStr] = None,
        redeemable_start_date: Optional[StrictInt] = None,
        redeemable_end_date: Optional[StrictInt] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OfferTransactionResponse]:
        """Search Offer Transactions

        Searches on offer transactions for offers that the account has access to.

        :param sort_field: Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
        :type sort_field: str
        :param descending: Determines whether the results are in descending order (required)
        :type descending: bool
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param active_only: Determines whether to only return active offer transactions (required)
        :type active_only: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword to search for
        :type keyword: str
        :param retailer_id: Filter results for this retailer
        :type retailer_id: int
        :param retailer_location_id: Filter results for this retailer location
        :type retailer_location_id: int
        :param offer_id: Filter results for this offer
        :type offer_id: int
        :param offer_location_id: Filter results for this offer location
        :type offer_location_id: int
        :param redeemed: if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)
        :type redeemed: bool
        :param reservations_only: returns only reservation transactions if true
        :type reservations_only: bool
        :param coupon_type: This parameter is deprecated.
        :type coupon_type: str
        :param offer_type: Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param customer_account_ids: Filter results by accounts
        :type customer_account_ids: str
        :param category_ids: 
        :type category_ids: str
        :param redeemable_start_date: 
        :type redeemable_start_date: int
        :param redeemable_end_date: 
        :type redeemable_end_date: int
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offer_transactions_for_retailers_serialize(
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            redeemed=redeemed,
            reservations_only=reservations_only,
            coupon_type=coupon_type,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            customer_account_ids=customer_account_ids,
            category_ids=category_ids,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            i=i,
            l=l,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_offer_transactions_for_retailers_with_http_info(
        self,
        sort_field: Annotated[StrictStr, Field(description="Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}")],
        descending: Annotated[StrictBool, Field(description="Determines whether the results are in descending order")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        active_only: Annotated[StrictBool, Field(description="Determines whether to only return active offer transactions")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer location")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer location")] = None,
        redeemed: Annotated[Optional[StrictBool], Field(description="if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)")] = None,
        reservations_only: Annotated[Optional[StrictBool], Field(description="returns only reservation transactions if true")] = None,
        coupon_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        customer_account_ids: Annotated[Optional[StrictStr], Field(description="Filter results by accounts")] = None,
        category_ids: Optional[StrictStr] = None,
        redeemable_start_date: Optional[StrictInt] = None,
        redeemable_end_date: Optional[StrictInt] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OfferTransactionResponse]]:
        """Search Offer Transactions

        Searches on offer transactions for offers that the account has access to.

        :param sort_field: Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
        :type sort_field: str
        :param descending: Determines whether the results are in descending order (required)
        :type descending: bool
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param active_only: Determines whether to only return active offer transactions (required)
        :type active_only: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword to search for
        :type keyword: str
        :param retailer_id: Filter results for this retailer
        :type retailer_id: int
        :param retailer_location_id: Filter results for this retailer location
        :type retailer_location_id: int
        :param offer_id: Filter results for this offer
        :type offer_id: int
        :param offer_location_id: Filter results for this offer location
        :type offer_location_id: int
        :param redeemed: if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)
        :type redeemed: bool
        :param reservations_only: returns only reservation transactions if true
        :type reservations_only: bool
        :param coupon_type: This parameter is deprecated.
        :type coupon_type: str
        :param offer_type: Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param customer_account_ids: Filter results by accounts
        :type customer_account_ids: str
        :param category_ids: 
        :type category_ids: str
        :param redeemable_start_date: 
        :type redeemable_start_date: int
        :param redeemable_end_date: 
        :type redeemable_end_date: int
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offer_transactions_for_retailers_serialize(
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            redeemed=redeemed,
            reservations_only=reservations_only,
            coupon_type=coupon_type,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            customer_account_ids=customer_account_ids,
            category_ids=category_ids,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            i=i,
            l=l,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_offer_transactions_for_retailers_without_preload_content(
        self,
        sort_field: Annotated[StrictStr, Field(description="Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY}")],
        descending: Annotated[StrictBool, Field(description="Determines whether the results are in descending order")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        active_only: Annotated[StrictBool, Field(description="Determines whether to only return active offer transactions")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        q: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer location")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer location")] = None,
        redeemed: Annotated[Optional[StrictBool], Field(description="if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)")] = None,
        reservations_only: Annotated[Optional[StrictBool], Field(description="returns only reservation transactions if true")] = None,
        coupon_type: Annotated[Optional[StrictStr], Field(description="This parameter is deprecated.")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials")] = None,
        customer_account_ids: Annotated[Optional[StrictStr], Field(description="Filter results by accounts")] = None,
        category_ids: Optional[StrictStr] = None,
        redeemable_start_date: Optional[StrictInt] = None,
        redeemable_end_date: Optional[StrictInt] = None,
        i: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        l: Annotated[Optional[StrictInt], Field(description="This parameter is deprecated.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Offer Transactions

        Searches on offer transactions for offers that the account has access to.

        :param sort_field: Determines what to sort the results by {CREATED, UPDATED, SEARCH_TAGS, ACTIVE, ACTIVATED, EXPIRES, TITLE, SUBTITLE, OFFER_TYPE, SPECIAL_OFFER_TYPE, OFFER_VISIBILITY, CUSTOMER_ID, CUSTOMER_DISPLAY, RETAILER_ID, RETAILER_NAME, RETAILER_LOCATION_ID, RETAILER_LOCATION_NAME, BILLABLE_ENTITY_ID, BILLABLE_ENTITY_NAME, RESPONSIBLE_DISPLAY} (required)
        :type sort_field: str
        :param descending: Determines whether the results are in descending order (required)
        :type descending: bool
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param active_only: Determines whether to only return active offer transactions (required)
        :type active_only: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param q: This parameter is deprecated.
        :type q: str
        :param keyword: The keyword to search for
        :type keyword: str
        :param retailer_id: Filter results for this retailer
        :type retailer_id: int
        :param retailer_location_id: Filter results for this retailer location
        :type retailer_location_id: int
        :param offer_id: Filter results for this offer
        :type offer_id: int
        :param offer_location_id: Filter results for this offer location
        :type offer_location_id: int
        :param redeemed: if true return redeemed transactions (status 2), if false return active transactions (status 0 or 1)
        :type redeemed: bool
        :param reservations_only: returns only reservation transactions if true
        :type reservations_only: bool
        :param coupon_type: This parameter is deprecated.
        :type coupon_type: str
        :param offer_type: Filter results to only return COUPON, VOUCHER, PRODUCT, MEDIA, or EVENT offers
        :type offer_type: str
        :param special_offer_type: Filter results to only return REGULAR_OFFER, ACT_NOW, GET_THERE_NOW offer specials
        :type special_offer_type: str
        :param customer_account_ids: Filter results by accounts
        :type customer_account_ids: str
        :param category_ids: 
        :type category_ids: str
        :param redeemable_start_date: 
        :type redeemable_start_date: int
        :param redeemable_end_date: 
        :type redeemable_end_date: int
        :param i: This parameter is deprecated.
        :type i: int
        :param l: This parameter is deprecated.
        :type l: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offer_transactions_for_retailers_serialize(
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            q=q,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_location_id=retailer_location_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            redeemed=redeemed,
            reservations_only=reservations_only,
            coupon_type=coupon_type,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            customer_account_ids=customer_account_ids,
            category_ids=category_ids,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            i=i,
            l=l,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_offer_transactions_for_retailers_serialize(
        self,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        device_id,
        account_id,
        q,
        keyword,
        retailer_id,
        retailer_location_id,
        offer_id,
        offer_location_id,
        redeemed,
        reservations_only,
        coupon_type,
        offer_type,
        special_offer_type,
        customer_account_ids,
        category_ids,
        redeemable_start_date,
        redeemable_end_date,
        i,
        l,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if q is not None:
            
            _query_params.append(('q', q))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if redeemed is not None:
            
            _query_params.append(('redeemed', redeemed))
            
        if reservations_only is not None:
            
            _query_params.append(('reservationsOnly', reservations_only))
            
        if coupon_type is not None:
            
            _query_params.append(('couponType', coupon_type))
            
        if offer_type is not None:
            
            _query_params.append(('offerType', offer_type))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if customer_account_ids is not None:
            
            _query_params.append(('customerAccountIds', customer_account_ids))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if redeemable_start_date is not None:
            
            _query_params.append(('redeemableStartDate', redeemable_start_date))
            
        if redeemable_end_date is not None:
            
            _query_params.append(('redeemableEndDate', redeemable_end_date))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if i is not None:
            
            _query_params.append(('_i', i))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if l is not None:
            
            _query_params.append(('_l', l))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/retailer/offer/transaction/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_offers_for_consumer(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of where the search will center at")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of where the search will center at")],
        recommendation_type: Annotated[StrictStr, Field(description="The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available")],
        location_id: Annotated[StrictInt, Field(description="This parameter is deprecated. The location id")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        max_recommendations: StrictInt,
        distance_unit: StrictStr,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. offer transactions made by the user)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. offer transactions made by the user)")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range of the search")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        supported_postal_codes: Annotated[Optional[StrictStr], Field(description="supported postal codes")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to filter results by")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations")] = None,
        recommend_offer_ids: Annotated[Optional[StrictStr], Field(description="Return recommendations based on these offers IDs")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Only return offer locations for the specific retailer locations.")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Only return offer locations for the specific offer.")] = None,
        include_mission: Annotated[Optional[StrictBool], Field(description="If true include the mission response as part of the offer. Default is false.")] = None,
        include_categories: Annotated[Optional[StrictBool], Field(description="If true include the category list response as part of the offer. Default is false.")] = None,
        include_filters: Annotated[Optional[StrictBool], Field(description="If true include the filter list response as part of the offer. Default is false.")] = None,
        include_expired: Annotated[Optional[StrictBool], Field(description="If true then ignore the expired dates. Default is false.")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="If true then ignore the favorite. Default is false.")] = None,
        closest_offer_only: Annotated[Optional[StrictBool], Field(description="This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon")] = None,
        search_expression: Optional[StrictStr] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferListResponse:
        """Search Offers

        Searches for offers as a consumer.

        :param latitude: The latitude of where the search will center at (required)
        :type latitude: float
        :param longitude: The longitude of where the search will center at (required)
        :type longitude: float
        :param recommendation_type: The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available (required)
        :type recommendation_type: str
        :param location_id: This parameter is deprecated. The location id (required)
        :type location_id: int
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param max_recommendations:  (required)
        :type max_recommendations: int
        :param distance_unit:  (required)
        :type distance_unit: str
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param device_id: The device id for returning account information (i.e. offer transactions made by the user)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. offer transactions made by the user)
        :type account_id: int
        :param search_range: The range of the search
        :type search_range: float
        :param tags: Does a full-text search on tags
        :type tags: str
        :param supported_postal_codes: supported postal codes
        :type supported_postal_codes: str
        :param keyword: The keyword to filter results by
        :type keyword: str
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param offer_types: Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        :type offer_types: str
        :param type: The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type type: str
        :param sort_field: The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations
        :type sort_field: str
        :param recommend_offer_ids: Return recommendations based on these offers IDs
        :type recommend_offer_ids: str
        :param retailer_location_ids: Only return offer locations for the specific retailer locations.
        :type retailer_location_ids: str
        :param offer_id: Only return offer locations for the specific offer.
        :type offer_id: int
        :param include_mission: If true include the mission response as part of the offer. Default is false.
        :type include_mission: bool
        :param include_categories: If true include the category list response as part of the offer. Default is false.
        :type include_categories: bool
        :param include_filters: If true include the filter list response as part of the offer. Default is false.
        :type include_filters: bool
        :param include_expired: If true then ignore the expired dates. Default is false.
        :type include_expired: bool
        :param include_favorite: If true then ignore the favorite. Default is false.
        :type include_favorite: bool
        :param closest_offer_only: This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon
        :type closest_offer_only: bool
        :param search_expression: 
        :type search_expression: str
        :param group_by: groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).
        :type group_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offers_for_consumer_serialize(
            latitude=latitude,
            longitude=longitude,
            recommendation_type=recommendation_type,
            location_id=location_id,
            start=start,
            limit=limit,
            max_recommendations=max_recommendations,
            distance_unit=distance_unit,
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            search_range=search_range,
            tags=tags,
            supported_postal_codes=supported_postal_codes,
            keyword=keyword,
            categories=categories,
            filters=filters,
            offer_types=offer_types,
            type=type,
            sort_field=sort_field,
            recommend_offer_ids=recommend_offer_ids,
            retailer_location_ids=retailer_location_ids,
            offer_id=offer_id,
            include_mission=include_mission,
            include_categories=include_categories,
            include_filters=include_filters,
            include_expired=include_expired,
            include_favorite=include_favorite,
            closest_offer_only=closest_offer_only,
            search_expression=search_expression,
            group_by=group_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_offers_for_consumer_with_http_info(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of where the search will center at")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of where the search will center at")],
        recommendation_type: Annotated[StrictStr, Field(description="The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available")],
        location_id: Annotated[StrictInt, Field(description="This parameter is deprecated. The location id")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        max_recommendations: StrictInt,
        distance_unit: StrictStr,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. offer transactions made by the user)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. offer transactions made by the user)")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range of the search")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        supported_postal_codes: Annotated[Optional[StrictStr], Field(description="supported postal codes")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to filter results by")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations")] = None,
        recommend_offer_ids: Annotated[Optional[StrictStr], Field(description="Return recommendations based on these offers IDs")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Only return offer locations for the specific retailer locations.")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Only return offer locations for the specific offer.")] = None,
        include_mission: Annotated[Optional[StrictBool], Field(description="If true include the mission response as part of the offer. Default is false.")] = None,
        include_categories: Annotated[Optional[StrictBool], Field(description="If true include the category list response as part of the offer. Default is false.")] = None,
        include_filters: Annotated[Optional[StrictBool], Field(description="If true include the filter list response as part of the offer. Default is false.")] = None,
        include_expired: Annotated[Optional[StrictBool], Field(description="If true then ignore the expired dates. Default is false.")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="If true then ignore the favorite. Default is false.")] = None,
        closest_offer_only: Annotated[Optional[StrictBool], Field(description="This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon")] = None,
        search_expression: Optional[StrictStr] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferListResponse]:
        """Search Offers

        Searches for offers as a consumer.

        :param latitude: The latitude of where the search will center at (required)
        :type latitude: float
        :param longitude: The longitude of where the search will center at (required)
        :type longitude: float
        :param recommendation_type: The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available (required)
        :type recommendation_type: str
        :param location_id: This parameter is deprecated. The location id (required)
        :type location_id: int
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param max_recommendations:  (required)
        :type max_recommendations: int
        :param distance_unit:  (required)
        :type distance_unit: str
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param device_id: The device id for returning account information (i.e. offer transactions made by the user)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. offer transactions made by the user)
        :type account_id: int
        :param search_range: The range of the search
        :type search_range: float
        :param tags: Does a full-text search on tags
        :type tags: str
        :param supported_postal_codes: supported postal codes
        :type supported_postal_codes: str
        :param keyword: The keyword to filter results by
        :type keyword: str
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param offer_types: Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        :type offer_types: str
        :param type: The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type type: str
        :param sort_field: The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations
        :type sort_field: str
        :param recommend_offer_ids: Return recommendations based on these offers IDs
        :type recommend_offer_ids: str
        :param retailer_location_ids: Only return offer locations for the specific retailer locations.
        :type retailer_location_ids: str
        :param offer_id: Only return offer locations for the specific offer.
        :type offer_id: int
        :param include_mission: If true include the mission response as part of the offer. Default is false.
        :type include_mission: bool
        :param include_categories: If true include the category list response as part of the offer. Default is false.
        :type include_categories: bool
        :param include_filters: If true include the filter list response as part of the offer. Default is false.
        :type include_filters: bool
        :param include_expired: If true then ignore the expired dates. Default is false.
        :type include_expired: bool
        :param include_favorite: If true then ignore the favorite. Default is false.
        :type include_favorite: bool
        :param closest_offer_only: This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon
        :type closest_offer_only: bool
        :param search_expression: 
        :type search_expression: str
        :param group_by: groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).
        :type group_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offers_for_consumer_serialize(
            latitude=latitude,
            longitude=longitude,
            recommendation_type=recommendation_type,
            location_id=location_id,
            start=start,
            limit=limit,
            max_recommendations=max_recommendations,
            distance_unit=distance_unit,
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            search_range=search_range,
            tags=tags,
            supported_postal_codes=supported_postal_codes,
            keyword=keyword,
            categories=categories,
            filters=filters,
            offer_types=offer_types,
            type=type,
            sort_field=sort_field,
            recommend_offer_ids=recommend_offer_ids,
            retailer_location_ids=retailer_location_ids,
            offer_id=offer_id,
            include_mission=include_mission,
            include_categories=include_categories,
            include_filters=include_filters,
            include_expired=include_expired,
            include_favorite=include_favorite,
            closest_offer_only=closest_offer_only,
            search_expression=search_expression,
            group_by=group_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_offers_for_consumer_without_preload_content(
        self,
        latitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The latitude of where the search will center at")],
        longitude: Annotated[Union[StrictFloat, StrictInt], Field(description="The longitude of where the search will center at")],
        recommendation_type: Annotated[StrictStr, Field(description="The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available")],
        location_id: Annotated[StrictInt, Field(description="This parameter is deprecated. The location id")],
        start: Annotated[StrictInt, Field(description="The start index for pagination")],
        limit: Annotated[StrictInt, Field(description="The limit for pagination")],
        max_recommendations: StrictInt,
        distance_unit: StrictStr,
        app_key: Annotated[Optional[StrictStr], Field(description="The application key used to identify the application")] = None,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id for returning account information (i.e. offer transactions made by the user)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id for returning account information (i.e. offer transactions made by the user)")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The range of the search")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Does a full-text search on tags")] = None,
        supported_postal_codes: Annotated[Optional[StrictStr], Field(description="supported postal codes")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to filter results by")] = None,
        categories: Annotated[Optional[StrictStr], Field(description="Comma separate list of category ids")] = None,
        filters: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}")] = None,
        type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations")] = None,
        recommend_offer_ids: Annotated[Optional[StrictStr], Field(description="Return recommendations based on these offers IDs")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Only return offer locations for the specific retailer locations.")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Only return offer locations for the specific offer.")] = None,
        include_mission: Annotated[Optional[StrictBool], Field(description="If true include the mission response as part of the offer. Default is false.")] = None,
        include_categories: Annotated[Optional[StrictBool], Field(description="If true include the category list response as part of the offer. Default is false.")] = None,
        include_filters: Annotated[Optional[StrictBool], Field(description="If true include the filter list response as part of the offer. Default is false.")] = None,
        include_expired: Annotated[Optional[StrictBool], Field(description="If true then ignore the expired dates. Default is false.")] = None,
        include_favorite: Annotated[Optional[StrictBool], Field(description="If true then ignore the favorite. Default is false.")] = None,
        closest_offer_only: Annotated[Optional[StrictBool], Field(description="This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon")] = None,
        search_expression: Optional[StrictStr] = None,
        group_by: Annotated[Optional[StrictStr], Field(description="groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Offers

        Searches for offers as a consumer.

        :param latitude: The latitude of where the search will center at (required)
        :type latitude: float
        :param longitude: The longitude of where the search will center at (required)
        :type longitude: float
        :param recommendation_type: The method to use to gather recommendations: WALLET base relevance on items in users wallets CLICKS base relevance on items users have clicked on BLENDED blend using all methods available (required)
        :type recommendation_type: str
        :param location_id: This parameter is deprecated. The location id (required)
        :type location_id: int
        :param start: The start index for pagination (required)
        :type start: int
        :param limit: The limit for pagination (required)
        :type limit: int
        :param max_recommendations:  (required)
        :type max_recommendations: int
        :param distance_unit:  (required)
        :type distance_unit: str
        :param app_key: The application key used to identify the application
        :type app_key: str
        :param device_id: The device id for returning account information (i.e. offer transactions made by the user)
        :type device_id: str
        :param account_id: The account id for returning account information (i.e. offer transactions made by the user)
        :type account_id: int
        :param search_range: The range of the search
        :type search_range: float
        :param tags: Does a full-text search on tags
        :type tags: str
        :param supported_postal_codes: supported postal codes
        :type supported_postal_codes: str
        :param keyword: The keyword to filter results by
        :type keyword: str
        :param categories: Comma separate list of category ids
        :type categories: str
        :param filters: Comma separated list of filter ids
        :type filters: str
        :param offer_types: Comma separated list of offer types {COUPON, VOUCHER, PRODUCT, MEDIA, EVENT, DEVICE}
        :type offer_types: str
        :param type: The special offer type {ALL, RESERVABLE, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type type: str
        :param sort_field: The field to sort the result set on:DISTANCE Sort the offers nearest to farthest BUSINESS_NAME Sort the offers alphabetically by location name SHUFFLE Sort the nearest offers randomly USERPREFS accountId must accompany this parameter. Gives the first X recommendations where X equals the parameter maxRecommendations
        :type sort_field: str
        :param recommend_offer_ids: Return recommendations based on these offers IDs
        :type recommend_offer_ids: str
        :param retailer_location_ids: Only return offer locations for the specific retailer locations.
        :type retailer_location_ids: str
        :param offer_id: Only return offer locations for the specific offer.
        :type offer_id: int
        :param include_mission: If true include the mission response as part of the offer. Default is false.
        :type include_mission: bool
        :param include_categories: If true include the category list response as part of the offer. Default is false.
        :type include_categories: bool
        :param include_filters: If true include the filter list response as part of the offer. Default is false.
        :type include_filters: bool
        :param include_expired: If true then ignore the expired dates. Default is false.
        :type include_expired: bool
        :param include_favorite: If true then ignore the favorite. Default is false.
        :type include_favorite: bool
        :param closest_offer_only: This parameter is deprecated. see groupBy. If true then it only returns the offer location for an offer closest to the given lat/lon
        :type closest_offer_only: bool
        :param search_expression: 
        :type search_expression: str
        :param group_by: groups the results by a certain field. For example, if you want to return the closest offer location of an offer, then pass in groupBy=OFFER_ID and sortField=DISTANCE (to sort by distance).
        :type group_by: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offers_for_consumer_serialize(
            latitude=latitude,
            longitude=longitude,
            recommendation_type=recommendation_type,
            location_id=location_id,
            start=start,
            limit=limit,
            max_recommendations=max_recommendations,
            distance_unit=distance_unit,
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            search_range=search_range,
            tags=tags,
            supported_postal_codes=supported_postal_codes,
            keyword=keyword,
            categories=categories,
            filters=filters,
            offer_types=offer_types,
            type=type,
            sort_field=sort_field,
            recommend_offer_ids=recommend_offer_ids,
            retailer_location_ids=retailer_location_ids,
            offer_id=offer_id,
            include_mission=include_mission,
            include_categories=include_categories,
            include_filters=include_filters,
            include_expired=include_expired,
            include_favorite=include_favorite,
            closest_offer_only=closest_offer_only,
            search_expression=search_expression,
            group_by=group_by,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_offers_for_consumer_serialize(
        self,
        latitude,
        longitude,
        recommendation_type,
        location_id,
        start,
        limit,
        max_recommendations,
        distance_unit,
        app_key,
        device_id,
        account_id,
        search_range,
        tags,
        supported_postal_codes,
        keyword,
        categories,
        filters,
        offer_types,
        type,
        sort_field,
        recommend_offer_ids,
        retailer_location_ids,
        offer_id,
        include_mission,
        include_categories,
        include_filters,
        include_expired,
        include_favorite,
        closest_offer_only,
        search_expression,
        group_by,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if supported_postal_codes is not None:
            
            _query_params.append(('supportedPostalCodes', supported_postal_codes))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if categories is not None:
            
            _query_params.append(('categories', categories))
            
        if filters is not None:
            
            _query_params.append(('filters', filters))
            
        if offer_types is not None:
            
            _query_params.append(('offerTypes', offer_types))
            
        if type is not None:
            
            _query_params.append(('type', type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if recommend_offer_ids is not None:
            
            _query_params.append(('recommendOfferIds', recommend_offer_ids))
            
        if recommendation_type is not None:
            
            _query_params.append(('recommendationType', recommendation_type))
            
        if location_id is not None:
            
            _query_params.append(('locationId', location_id))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if include_mission is not None:
            
            _query_params.append(('includeMission', include_mission))
            
        if include_categories is not None:
            
            _query_params.append(('includeCategories', include_categories))
            
        if include_filters is not None:
            
            _query_params.append(('includeFilters', include_filters))
            
        if include_expired is not None:
            
            _query_params.append(('includeExpired', include_expired))
            
        if include_favorite is not None:
            
            _query_params.append(('includeFavorite', include_favorite))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if max_recommendations is not None:
            
            _query_params.append(('maxRecommendations', max_recommendations))
            
        if distance_unit is not None:
            
            _query_params.append(('distanceUnit', distance_unit))
            
        if closest_offer_only is not None:
            
            _query_params.append(('closestOfferOnly', closest_offer_only))
            
        if search_expression is not None:
            
            _query_params.append(('searchExpression', search_expression))
            
        if group_by is not None:
            
            _query_params.append(('groupBy', group_by))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offer/lists',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def top_offer_transactions(
        self,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with. Default is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return. Default id 20.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferListResponse:
        """Get Offers (Top)

        Gets the top active offers.

        :param start: The index into the record set to start with. Default is 0.
        :type start: int
        :param limit: The total number of record to return. Default id 20.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_offer_transactions_serialize(
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def top_offer_transactions_with_http_info(
        self,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with. Default is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return. Default id 20.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferListResponse]:
        """Get Offers (Top)

        Gets the top active offers.

        :param start: The index into the record set to start with. Default is 0.
        :type start: int
        :param limit: The total number of record to return. Default id 20.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_offer_transactions_serialize(
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def top_offer_transactions_without_preload_content(
        self,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with. Default is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of record to return. Default id 20.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Offers (Top)

        Gets the top active offers.

        :param start: The index into the record set to start with. Default is 0.
        :type start: int
        :param limit: The total number of record to return. Default id 20.
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._top_offer_transactions_serialize(
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferListResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _top_offer_transactions_serialize(
        self,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/offer/top',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_offer(
        self,
        offer_id: Annotated[StrictInt, Field(description="The offer to update")],
        include_offer_locations: Annotated[StrictBool, Field(description="If true return all the offer locations associated with the offer")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)")] = None,
        parent_offer_id: Optional[StrictInt] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The title (255 char limit)")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_type: Annotated[Optional[StrictStr], Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        external_id: Optional[StrictStr] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        no_expiration: Annotated[Optional[StrictBool], Field(description="Overrides the expiration date so that the offer does not expire")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be used by consumers")] = None,
        available_limit_per_user: Annotated[Optional[StrictInt], Field(description="The limit of how many times a user can used the same offer")] = None,
        added_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be added to consumer wallets")] = None,
        view_limit: Optional[StrictInt] = None,
        max_prints: Annotated[Optional[StrictInt], Field(description="The maximum number of times the offer can be printed")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy the offer")] = None,
        ticket_price: Annotated[Optional[StrictInt], Field(description="The cost of the offer in tickets")] = None,
        full_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The retail/full price cost of the offer in real currency")] = None,
        discount_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The cost of the offer at a discounted price (what the consumer pays)")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show remaining offers available")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many offers have been redeemed")] = None,
        replaced: Optional[StrictBool] = None,
        featured: Annotated[Optional[StrictBool], Field(description="whether the offer is featured or not")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        offer_visibility: Annotated[Optional[StrictStr], Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        brand: Annotated[Optional[StrictStr], Field(description="The brand. OfferType PRODUCT only.")] = None,
        product_type: Annotated[Optional[StrictStr], Field(description="The product type. OfferType PRODUCT only.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        department: Annotated[Optional[StrictStr], Field(description="The department name. The OfferType PRODUCT only.")] = None,
        features: Annotated[Optional[StrictStr], Field(description="The list of features, comma seperated. OfferType PRODUCT only.")] = None,
        minimum_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The MAP price. OfferType PRODUCT only.")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The width of the item. OfferType PRODUCT only.")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The height of the item. OfferType PRODUCT only.")] = None,
        depth: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The depth of the item. OfferType PRODUCT only.")] = None,
        weight: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The weight of the item. OfferType PRODUCT only.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit of measurement. OfferType PRODUCT only.")] = None,
        studio: Annotated[Optional[StrictStr], Field(description="The studio name. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        publish_date: Annotated[Optional[StrictInt], Field(description="The date published. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        size_id: Annotated[Optional[StrictInt], Field(description="The size Id. OfferType PRODUCT only.")] = None,
        listing_id: Annotated[Optional[StrictInt], Field(description="The ID of the event listing")] = None,
        media_type: Optional[StrictStr] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        reboot_time_hour: Annotated[Optional[StrictInt], Field(description="The reboot hour time ranging from 0 to 23")] = None,
        reboot_time_minute: Annotated[Optional[StrictInt], Field(description="The reboot minute time ranging from 0 to 59")] = None,
        idle_timeout_in_second: Annotated[Optional[StrictInt], Field(description="If the device is idle for idleTimeoutInSecond then the device should timeout")] = None,
        serial_number: Annotated[Optional[StrictStr], Field(description="The serial number on the device")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The unique device id for the device")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of the device, for example: \"Kiosk\", \"Beacon\".")] = None,
        device_power: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="RSSI reading at 1 meter from device (-10 to -140)")] = None,
        device_interference: Optional[Union[StrictFloat, StrictInt]] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RetailerOfferResponse:
        """Update Offer

        Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.

        :param offer_id: The offer to update (required)
        :type offer_id: int
        :param include_offer_locations: If true return all the offer locations associated with the offer (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
        :type account_id: int
        :param parent_offer_id: 
        :type parent_offer_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param title: The title (255 char limit)
        :type title: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        :type barcode_type: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param external_id: 
        :type external_id: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param no_expiration: Overrides the expiration date so that the offer does not expire
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets
        :type added_limit: int
        :param view_limit: 
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed
        :type max_prints: int
        :param ticket_price_type: the type of ticket needed to buy the offer
        :type ticket_price_type: str
        :param ticket_price: The cost of the offer in tickets
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays)
        :type discount_price: float
        :param show_remaining: show remaining offers available
        :type show_remaining: bool
        :param show_redeemed: show how many offers have been redeemed
        :type show_redeemed: bool
        :param replaced: 
        :type replaced: bool
        :param featured: whether the offer is featured or not
        :type featured: bool
        :param offer_type: The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}
        :type offer_type: str
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        :type offer_visibility: str
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param active: Sets the active flag
        :type active: bool
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param brand: The brand. OfferType PRODUCT only.
        :type brand: str
        :param product_type: The product type. OfferType PRODUCT only.
        :type product_type: str
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param department: The department name. The OfferType PRODUCT only.
        :type department: str
        :param features: The list of features, comma seperated. OfferType PRODUCT only.
        :type features: str
        :param minimum_price: The MAP price. OfferType PRODUCT only.
        :type minimum_price: float
        :param width: The width of the item. OfferType PRODUCT only.
        :type width: float
        :param height: The height of the item. OfferType PRODUCT only.
        :type height: float
        :param depth: The depth of the item. OfferType PRODUCT only.
        :type depth: float
        :param weight: The weight of the item. OfferType PRODUCT only.
        :type weight: float
        :param unit: The unit of measurement. OfferType PRODUCT only.
        :type unit: str
        :param studio: The studio name. OfferType PRODUCT only.
        :type studio: str
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param publish_date: The date published. OfferType PRODUCT only.
        :type publish_date: int
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param size_id: The size Id. OfferType PRODUCT only.
        :type size_id: int
        :param listing_id: The ID of the event listing
        :type listing_id: int
        :param media_type: 
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param reboot_time_hour: The reboot hour time ranging from 0 to 23
        :type reboot_time_hour: int
        :param reboot_time_minute: The reboot minute time ranging from 0 to 59
        :type reboot_time_minute: int
        :param idle_timeout_in_second: If the device is idle for idleTimeoutInSecond then the device should timeout
        :type idle_timeout_in_second: int
        :param serial_number: The serial number on the device
        :type serial_number: str
        :param udid: The unique device id for the device
        :type udid: str
        :param device_type: The type of the device, for example: \"Kiosk\", \"Beacon\".
        :type device_type: str
        :param device_power: RSSI reading at 1 meter from device (-10 to -140)
        :type device_power: float
        :param device_interference: 
        :type device_interference: float
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_serialize(
            offer_id=offer_id,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            parent_offer_id=parent_offer_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            tags=tags,
            title=title,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            external_id=external_id,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price_type=ticket_price_type,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            active=active,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            brand=brand,
            product_type=product_type,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            department=department,
            features=features,
            minimum_price=minimum_price,
            width=width,
            height=height,
            depth=depth,
            weight=weight,
            unit=unit,
            studio=studio,
            parental_rating=parental_rating,
            publish_date=publish_date,
            availability_date=availability_date,
            size_id=size_id,
            listing_id=listing_id,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            reboot_time_hour=reboot_time_hour,
            reboot_time_minute=reboot_time_minute,
            idle_timeout_in_second=idle_timeout_in_second,
            serial_number=serial_number,
            udid=udid,
            device_type=device_type,
            device_power=device_power,
            device_interference=device_interference,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_offer_with_http_info(
        self,
        offer_id: Annotated[StrictInt, Field(description="The offer to update")],
        include_offer_locations: Annotated[StrictBool, Field(description="If true return all the offer locations associated with the offer")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)")] = None,
        parent_offer_id: Optional[StrictInt] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The title (255 char limit)")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_type: Annotated[Optional[StrictStr], Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        external_id: Optional[StrictStr] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        no_expiration: Annotated[Optional[StrictBool], Field(description="Overrides the expiration date so that the offer does not expire")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be used by consumers")] = None,
        available_limit_per_user: Annotated[Optional[StrictInt], Field(description="The limit of how many times a user can used the same offer")] = None,
        added_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be added to consumer wallets")] = None,
        view_limit: Optional[StrictInt] = None,
        max_prints: Annotated[Optional[StrictInt], Field(description="The maximum number of times the offer can be printed")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy the offer")] = None,
        ticket_price: Annotated[Optional[StrictInt], Field(description="The cost of the offer in tickets")] = None,
        full_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The retail/full price cost of the offer in real currency")] = None,
        discount_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The cost of the offer at a discounted price (what the consumer pays)")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show remaining offers available")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many offers have been redeemed")] = None,
        replaced: Optional[StrictBool] = None,
        featured: Annotated[Optional[StrictBool], Field(description="whether the offer is featured or not")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        offer_visibility: Annotated[Optional[StrictStr], Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        brand: Annotated[Optional[StrictStr], Field(description="The brand. OfferType PRODUCT only.")] = None,
        product_type: Annotated[Optional[StrictStr], Field(description="The product type. OfferType PRODUCT only.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        department: Annotated[Optional[StrictStr], Field(description="The department name. The OfferType PRODUCT only.")] = None,
        features: Annotated[Optional[StrictStr], Field(description="The list of features, comma seperated. OfferType PRODUCT only.")] = None,
        minimum_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The MAP price. OfferType PRODUCT only.")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The width of the item. OfferType PRODUCT only.")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The height of the item. OfferType PRODUCT only.")] = None,
        depth: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The depth of the item. OfferType PRODUCT only.")] = None,
        weight: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The weight of the item. OfferType PRODUCT only.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit of measurement. OfferType PRODUCT only.")] = None,
        studio: Annotated[Optional[StrictStr], Field(description="The studio name. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        publish_date: Annotated[Optional[StrictInt], Field(description="The date published. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        size_id: Annotated[Optional[StrictInt], Field(description="The size Id. OfferType PRODUCT only.")] = None,
        listing_id: Annotated[Optional[StrictInt], Field(description="The ID of the event listing")] = None,
        media_type: Optional[StrictStr] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        reboot_time_hour: Annotated[Optional[StrictInt], Field(description="The reboot hour time ranging from 0 to 23")] = None,
        reboot_time_minute: Annotated[Optional[StrictInt], Field(description="The reboot minute time ranging from 0 to 59")] = None,
        idle_timeout_in_second: Annotated[Optional[StrictInt], Field(description="If the device is idle for idleTimeoutInSecond then the device should timeout")] = None,
        serial_number: Annotated[Optional[StrictStr], Field(description="The serial number on the device")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The unique device id for the device")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of the device, for example: \"Kiosk\", \"Beacon\".")] = None,
        device_power: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="RSSI reading at 1 meter from device (-10 to -140)")] = None,
        device_interference: Optional[Union[StrictFloat, StrictInt]] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[RetailerOfferResponse]:
        """Update Offer

        Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.

        :param offer_id: The offer to update (required)
        :type offer_id: int
        :param include_offer_locations: If true return all the offer locations associated with the offer (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
        :type account_id: int
        :param parent_offer_id: 
        :type parent_offer_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param title: The title (255 char limit)
        :type title: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        :type barcode_type: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param external_id: 
        :type external_id: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param no_expiration: Overrides the expiration date so that the offer does not expire
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets
        :type added_limit: int
        :param view_limit: 
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed
        :type max_prints: int
        :param ticket_price_type: the type of ticket needed to buy the offer
        :type ticket_price_type: str
        :param ticket_price: The cost of the offer in tickets
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays)
        :type discount_price: float
        :param show_remaining: show remaining offers available
        :type show_remaining: bool
        :param show_redeemed: show how many offers have been redeemed
        :type show_redeemed: bool
        :param replaced: 
        :type replaced: bool
        :param featured: whether the offer is featured or not
        :type featured: bool
        :param offer_type: The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}
        :type offer_type: str
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        :type offer_visibility: str
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param active: Sets the active flag
        :type active: bool
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param brand: The brand. OfferType PRODUCT only.
        :type brand: str
        :param product_type: The product type. OfferType PRODUCT only.
        :type product_type: str
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param department: The department name. The OfferType PRODUCT only.
        :type department: str
        :param features: The list of features, comma seperated. OfferType PRODUCT only.
        :type features: str
        :param minimum_price: The MAP price. OfferType PRODUCT only.
        :type minimum_price: float
        :param width: The width of the item. OfferType PRODUCT only.
        :type width: float
        :param height: The height of the item. OfferType PRODUCT only.
        :type height: float
        :param depth: The depth of the item. OfferType PRODUCT only.
        :type depth: float
        :param weight: The weight of the item. OfferType PRODUCT only.
        :type weight: float
        :param unit: The unit of measurement. OfferType PRODUCT only.
        :type unit: str
        :param studio: The studio name. OfferType PRODUCT only.
        :type studio: str
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param publish_date: The date published. OfferType PRODUCT only.
        :type publish_date: int
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param size_id: The size Id. OfferType PRODUCT only.
        :type size_id: int
        :param listing_id: The ID of the event listing
        :type listing_id: int
        :param media_type: 
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param reboot_time_hour: The reboot hour time ranging from 0 to 23
        :type reboot_time_hour: int
        :param reboot_time_minute: The reboot minute time ranging from 0 to 59
        :type reboot_time_minute: int
        :param idle_timeout_in_second: If the device is idle for idleTimeoutInSecond then the device should timeout
        :type idle_timeout_in_second: int
        :param serial_number: The serial number on the device
        :type serial_number: str
        :param udid: The unique device id for the device
        :type udid: str
        :param device_type: The type of the device, for example: \"Kiosk\", \"Beacon\".
        :type device_type: str
        :param device_power: RSSI reading at 1 meter from device (-10 to -140)
        :type device_power: float
        :param device_interference: 
        :type device_interference: float
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_serialize(
            offer_id=offer_id,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            parent_offer_id=parent_offer_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            tags=tags,
            title=title,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            external_id=external_id,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price_type=ticket_price_type,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            active=active,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            brand=brand,
            product_type=product_type,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            department=department,
            features=features,
            minimum_price=minimum_price,
            width=width,
            height=height,
            depth=depth,
            weight=weight,
            unit=unit,
            studio=studio,
            parental_rating=parental_rating,
            publish_date=publish_date,
            availability_date=availability_date,
            size_id=size_id,
            listing_id=listing_id,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            reboot_time_hour=reboot_time_hour,
            reboot_time_minute=reboot_time_minute,
            idle_timeout_in_second=idle_timeout_in_second,
            serial_number=serial_number,
            udid=udid,
            device_type=device_type,
            device_power=device_power,
            device_interference=device_interference,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_offer_without_preload_content(
        self,
        offer_id: Annotated[StrictInt, Field(description="The offer to update")],
        include_offer_locations: Annotated[StrictBool, Field(description="If true return all the offer locations associated with the offer")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)")] = None,
        parent_offer_id: Optional[StrictInt] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of retailer location ids. This will assign the offer to these retailer locations.")] = None,
        offer_locations: Annotated[Optional[StrictStr], Field(description="A list of json data that has offer location specific values.")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Custom string field for doing full-text searches")] = None,
        title: Annotated[Optional[StrictStr], Field(description="The title (255 char limit)")] = None,
        sub_title: Annotated[Optional[StrictStr], Field(description="The sub title (255 char limit)")] = None,
        details: Annotated[Optional[StrictStr], Field(description="The details")] = None,
        sub_details: Annotated[Optional[StrictStr], Field(description="A string for custom details (255 char limit)")] = None,
        fine_print: Annotated[Optional[StrictStr], Field(description="The fine print")] = None,
        barcode_type: Annotated[Optional[StrictStr], Field(description="The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}")] = None,
        barcode_entry: Annotated[Optional[StrictStr], Field(description="The bar code entry string")] = None,
        external_redeem_options: Annotated[Optional[StrictStr], Field(description="An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.")] = None,
        external_url: Annotated[Optional[StrictStr], Field(description="The clickUrl of the offer")] = None,
        external_id: Optional[StrictStr] = None,
        tickets_reward_type: Annotated[Optional[StrictStr], Field(description="The type of ticket to reward, null means default type")] = None,
        tickets_reward: Annotated[Optional[StrictInt], Field(description="Determines how many tickets are awarded")] = None,
        activated: Annotated[Optional[StrictInt], Field(description="The date of when the offer will be visible to consumers")] = None,
        expires: Annotated[Optional[StrictInt], Field(description="The date of when the offer expires")] = None,
        no_expiration: Annotated[Optional[StrictBool], Field(description="Overrides the expiration date so that the offer does not expire")] = None,
        available_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be used by consumers")] = None,
        available_limit_per_user: Annotated[Optional[StrictInt], Field(description="The limit of how many times a user can used the same offer")] = None,
        added_limit: Annotated[Optional[StrictInt], Field(description="The limit of how many times the offer can be added to consumer wallets")] = None,
        view_limit: Optional[StrictInt] = None,
        max_prints: Annotated[Optional[StrictInt], Field(description="The maximum number of times the offer can be printed")] = None,
        ticket_price_type: Annotated[Optional[StrictStr], Field(description="the type of ticket needed to buy the offer")] = None,
        ticket_price: Annotated[Optional[StrictInt], Field(description="The cost of the offer in tickets")] = None,
        full_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The retail/full price cost of the offer in real currency")] = None,
        discount_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The cost of the offer at a discounted price (what the consumer pays)")] = None,
        show_remaining: Annotated[Optional[StrictBool], Field(description="show remaining offers available")] = None,
        show_redeemed: Annotated[Optional[StrictBool], Field(description="show how many offers have been redeemed")] = None,
        replaced: Optional[StrictBool] = None,
        featured: Annotated[Optional[StrictBool], Field(description="whether the offer is featured or not")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}")] = None,
        offer_visibility: Annotated[Optional[StrictStr], Field(description="The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of category ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Comma separated list of filter ids")] = None,
        active: Annotated[Optional[StrictBool], Field(description="Sets the active flag")] = None,
        barcode_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the barcode asset")] = None,
        image_asset_id: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id1: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id2: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id3: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id4: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        image_asset_id5: Annotated[Optional[StrictInt], Field(description="The id of the an offer asset")] = None,
        publisher: Annotated[Optional[StrictStr], Field(description="The maker of the item.")] = None,
        redeemable_start: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        redeemable_end: Annotated[Optional[StrictInt], Field(description="The redeemable start date/time of the offer.")] = None,
        brand: Annotated[Optional[StrictStr], Field(description="The brand. OfferType PRODUCT only.")] = None,
        product_type: Annotated[Optional[StrictStr], Field(description="The product type. OfferType PRODUCT only.")] = None,
        condition_type: Annotated[Optional[StrictStr], Field(description="The condition. OfferType PRODUCT only.")] = None,
        isbn: Annotated[Optional[StrictStr], Field(description="The ISBN id. OfferType PRODUCT only.")] = None,
        asin: Annotated[Optional[StrictStr], Field(description="The ASIN id. OfferType PRODUCT only.")] = None,
        catalog_numbers: Annotated[Optional[StrictStr], Field(description="The list of catelog numbers, comma seperated. OfferType PRODUCT only.")] = None,
        department: Annotated[Optional[StrictStr], Field(description="The department name. The OfferType PRODUCT only.")] = None,
        features: Annotated[Optional[StrictStr], Field(description="The list of features, comma seperated. OfferType PRODUCT only.")] = None,
        minimum_price: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The MAP price. OfferType PRODUCT only.")] = None,
        width: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The width of the item. OfferType PRODUCT only.")] = None,
        height: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The height of the item. OfferType PRODUCT only.")] = None,
        depth: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The depth of the item. OfferType PRODUCT only.")] = None,
        weight: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The weight of the item. OfferType PRODUCT only.")] = None,
        unit: Annotated[Optional[StrictStr], Field(description="The unit of measurement. OfferType PRODUCT only.")] = None,
        studio: Annotated[Optional[StrictStr], Field(description="The studio name. OfferType PRODUCT only.")] = None,
        parental_rating: Annotated[Optional[StrictStr], Field(description="The parental control rating. OfferType PRODUCT only.")] = None,
        publish_date: Annotated[Optional[StrictInt], Field(description="The date published. OfferType PRODUCT only.")] = None,
        availability_date: Annotated[Optional[StrictInt], Field(description="The date available. OfferType PRODUCT only.")] = None,
        size_id: Annotated[Optional[StrictInt], Field(description="The size Id. OfferType PRODUCT only.")] = None,
        listing_id: Annotated[Optional[StrictInt], Field(description="The ID of the event listing")] = None,
        media_type: Optional[StrictStr] = None,
        duration: Annotated[Optional[StrictInt], Field(description="The total playing time of the media item. OfferType MEDIA only.")] = None,
        author: Annotated[Optional[StrictStr], Field(description="The created/author of the media item. OfferType MEDIA only.")] = None,
        release_date: Annotated[Optional[StrictInt], Field(description="The date/time of when the media item was originally released. OfferType MEDIA only.")] = None,
        collection_ids: Optional[StrictStr] = None,
        reboot_time_hour: Annotated[Optional[StrictInt], Field(description="The reboot hour time ranging from 0 to 23")] = None,
        reboot_time_minute: Annotated[Optional[StrictInt], Field(description="The reboot minute time ranging from 0 to 59")] = None,
        idle_timeout_in_second: Annotated[Optional[StrictInt], Field(description="If the device is idle for idleTimeoutInSecond then the device should timeout")] = None,
        serial_number: Annotated[Optional[StrictStr], Field(description="The serial number on the device")] = None,
        udid: Annotated[Optional[StrictStr], Field(description="The unique device id for the device")] = None,
        device_type: Annotated[Optional[StrictStr], Field(description="The type of the device, for example: \"Kiosk\", \"Beacon\".")] = None,
        device_power: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="RSSI reading at 1 meter from device (-10 to -140)")] = None,
        device_interference: Optional[Union[StrictFloat, StrictInt]] = None,
        availability: Optional[StrictStr] = None,
        availability_summary: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Offer

        Update an offer, must provide a current list of retailer locations or the current offer locations will be marked as deleted.

        :param offer_id: The offer to update (required)
        :type offer_id: int
        :param include_offer_locations: If true return all the offer locations associated with the offer (required)
        :type include_offer_locations: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the update, must have rights to edit the offer (deviceId or accountId required)
        :type account_id: int
        :param parent_offer_id: 
        :type parent_offer_id: int
        :param retailer_location_ids: Comma separated list of retailer location ids. This will assign the offer to these retailer locations.
        :type retailer_location_ids: str
        :param offer_locations: A list of json data that has offer location specific values.
        :type offer_locations: str
        :param tags: Custom string field for doing full-text searches
        :type tags: str
        :param title: The title (255 char limit)
        :type title: str
        :param sub_title: The sub title (255 char limit)
        :type sub_title: str
        :param details: The details
        :type details: str
        :param sub_details: A string for custom details (255 char limit)
        :type sub_details: str
        :param fine_print: The fine print
        :type fine_print: str
        :param barcode_type: The bar code type {NONE, UPC, CODE_128, QR, CUSTOM_MEDIA}
        :type barcode_type: str
        :param barcode_entry: The bar code entry string
        :type barcode_entry: str
        :param external_redeem_options: An external identifier. What the identifier will be used for and how it is formatted is up to the frontend developer.
        :type external_redeem_options: str
        :param external_url: The clickUrl of the offer
        :type external_url: str
        :param external_id: 
        :type external_id: str
        :param tickets_reward_type: The type of ticket to reward, null means default type
        :type tickets_reward_type: str
        :param tickets_reward: Determines how many tickets are awarded
        :type tickets_reward: int
        :param activated: The date of when the offer will be visible to consumers
        :type activated: int
        :param expires: The date of when the offer expires
        :type expires: int
        :param no_expiration: Overrides the expiration date so that the offer does not expire
        :type no_expiration: bool
        :param available_limit: The limit of how many times the offer can be used by consumers
        :type available_limit: int
        :param available_limit_per_user: The limit of how many times a user can used the same offer
        :type available_limit_per_user: int
        :param added_limit: The limit of how many times the offer can be added to consumer wallets
        :type added_limit: int
        :param view_limit: 
        :type view_limit: int
        :param max_prints: The maximum number of times the offer can be printed
        :type max_prints: int
        :param ticket_price_type: the type of ticket needed to buy the offer
        :type ticket_price_type: str
        :param ticket_price: The cost of the offer in tickets
        :type ticket_price: int
        :param full_price: The retail/full price cost of the offer in real currency
        :type full_price: float
        :param discount_price: The cost of the offer at a discounted price (what the consumer pays)
        :type discount_price: float
        :param show_remaining: show remaining offers available
        :type show_remaining: bool
        :param show_redeemed: show how many offers have been redeemed
        :type show_redeemed: bool
        :param replaced: 
        :type replaced: bool
        :param featured: whether the offer is featured or not
        :type featured: bool
        :param offer_type: The offer type {VOUCHER, COUPON, PRODUCT, MEDIA, EVENT}
        :type offer_type: str
        :param special_offer_type: The special offer type {ALL, REGULAR_OFFER, ACT_NOW, GET_THERE_NOW}
        :type special_offer_type: str
        :param offer_visibility: The offer visibility {PUBLIC, REWARDABLE, TRIGGERABLE}
        :type offer_visibility: str
        :param category_ids: Comma separated list of category ids
        :type category_ids: str
        :param filter_ids: Comma separated list of filter ids
        :type filter_ids: str
        :param active: Sets the active flag
        :type active: bool
        :param barcode_asset_id: The id of the barcode asset
        :type barcode_asset_id: int
        :param image_asset_id: The id of the an offer asset
        :type image_asset_id: int
        :param image_asset_id1: The id of the an offer asset
        :type image_asset_id1: int
        :param image_asset_id2: The id of the an offer asset
        :type image_asset_id2: int
        :param image_asset_id3: The id of the an offer asset
        :type image_asset_id3: int
        :param image_asset_id4: The id of the an offer asset
        :type image_asset_id4: int
        :param image_asset_id5: The id of the an offer asset
        :type image_asset_id5: int
        :param publisher: The maker of the item.
        :type publisher: str
        :param redeemable_start: The redeemable start date/time of the offer.
        :type redeemable_start: int
        :param redeemable_end: The redeemable start date/time of the offer.
        :type redeemable_end: int
        :param brand: The brand. OfferType PRODUCT only.
        :type brand: str
        :param product_type: The product type. OfferType PRODUCT only.
        :type product_type: str
        :param condition_type: The condition. OfferType PRODUCT only.
        :type condition_type: str
        :param isbn: The ISBN id. OfferType PRODUCT only.
        :type isbn: str
        :param asin: The ASIN id. OfferType PRODUCT only.
        :type asin: str
        :param catalog_numbers: The list of catelog numbers, comma seperated. OfferType PRODUCT only.
        :type catalog_numbers: str
        :param department: The department name. The OfferType PRODUCT only.
        :type department: str
        :param features: The list of features, comma seperated. OfferType PRODUCT only.
        :type features: str
        :param minimum_price: The MAP price. OfferType PRODUCT only.
        :type minimum_price: float
        :param width: The width of the item. OfferType PRODUCT only.
        :type width: float
        :param height: The height of the item. OfferType PRODUCT only.
        :type height: float
        :param depth: The depth of the item. OfferType PRODUCT only.
        :type depth: float
        :param weight: The weight of the item. OfferType PRODUCT only.
        :type weight: float
        :param unit: The unit of measurement. OfferType PRODUCT only.
        :type unit: str
        :param studio: The studio name. OfferType PRODUCT only.
        :type studio: str
        :param parental_rating: The parental control rating. OfferType PRODUCT only.
        :type parental_rating: str
        :param publish_date: The date published. OfferType PRODUCT only.
        :type publish_date: int
        :param availability_date: The date available. OfferType PRODUCT only.
        :type availability_date: int
        :param size_id: The size Id. OfferType PRODUCT only.
        :type size_id: int
        :param listing_id: The ID of the event listing
        :type listing_id: int
        :param media_type: 
        :type media_type: str
        :param duration: The total playing time of the media item. OfferType MEDIA only.
        :type duration: int
        :param author: The created/author of the media item. OfferType MEDIA only.
        :type author: str
        :param release_date: The date/time of when the media item was originally released. OfferType MEDIA only.
        :type release_date: int
        :param collection_ids: 
        :type collection_ids: str
        :param reboot_time_hour: The reboot hour time ranging from 0 to 23
        :type reboot_time_hour: int
        :param reboot_time_minute: The reboot minute time ranging from 0 to 59
        :type reboot_time_minute: int
        :param idle_timeout_in_second: If the device is idle for idleTimeoutInSecond then the device should timeout
        :type idle_timeout_in_second: int
        :param serial_number: The serial number on the device
        :type serial_number: str
        :param udid: The unique device id for the device
        :type udid: str
        :param device_type: The type of the device, for example: \"Kiosk\", \"Beacon\".
        :type device_type: str
        :param device_power: RSSI reading at 1 meter from device (-10 to -140)
        :type device_power: float
        :param device_interference: 
        :type device_interference: float
        :param availability: 
        :type availability: str
        :param availability_summary: 
        :type availability_summary: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_serialize(
            offer_id=offer_id,
            include_offer_locations=include_offer_locations,
            device_id=device_id,
            account_id=account_id,
            parent_offer_id=parent_offer_id,
            retailer_location_ids=retailer_location_ids,
            offer_locations=offer_locations,
            tags=tags,
            title=title,
            sub_title=sub_title,
            details=details,
            sub_details=sub_details,
            fine_print=fine_print,
            barcode_type=barcode_type,
            barcode_entry=barcode_entry,
            external_redeem_options=external_redeem_options,
            external_url=external_url,
            external_id=external_id,
            tickets_reward_type=tickets_reward_type,
            tickets_reward=tickets_reward,
            activated=activated,
            expires=expires,
            no_expiration=no_expiration,
            available_limit=available_limit,
            available_limit_per_user=available_limit_per_user,
            added_limit=added_limit,
            view_limit=view_limit,
            max_prints=max_prints,
            ticket_price_type=ticket_price_type,
            ticket_price=ticket_price,
            full_price=full_price,
            discount_price=discount_price,
            show_remaining=show_remaining,
            show_redeemed=show_redeemed,
            replaced=replaced,
            featured=featured,
            offer_type=offer_type,
            special_offer_type=special_offer_type,
            offer_visibility=offer_visibility,
            category_ids=category_ids,
            filter_ids=filter_ids,
            active=active,
            barcode_asset_id=barcode_asset_id,
            image_asset_id=image_asset_id,
            image_asset_id1=image_asset_id1,
            image_asset_id2=image_asset_id2,
            image_asset_id3=image_asset_id3,
            image_asset_id4=image_asset_id4,
            image_asset_id5=image_asset_id5,
            publisher=publisher,
            redeemable_start=redeemable_start,
            redeemable_end=redeemable_end,
            brand=brand,
            product_type=product_type,
            condition_type=condition_type,
            isbn=isbn,
            asin=asin,
            catalog_numbers=catalog_numbers,
            department=department,
            features=features,
            minimum_price=minimum_price,
            width=width,
            height=height,
            depth=depth,
            weight=weight,
            unit=unit,
            studio=studio,
            parental_rating=parental_rating,
            publish_date=publish_date,
            availability_date=availability_date,
            size_id=size_id,
            listing_id=listing_id,
            media_type=media_type,
            duration=duration,
            author=author,
            release_date=release_date,
            collection_ids=collection_ids,
            reboot_time_hour=reboot_time_hour,
            reboot_time_minute=reboot_time_minute,
            idle_timeout_in_second=idle_timeout_in_second,
            serial_number=serial_number,
            udid=udid,
            device_type=device_type,
            device_power=device_power,
            device_interference=device_interference,
            availability=availability,
            availability_summary=availability_summary,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "RetailerOfferResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_offer_serialize(
        self,
        offer_id,
        include_offer_locations,
        device_id,
        account_id,
        parent_offer_id,
        retailer_location_ids,
        offer_locations,
        tags,
        title,
        sub_title,
        details,
        sub_details,
        fine_print,
        barcode_type,
        barcode_entry,
        external_redeem_options,
        external_url,
        external_id,
        tickets_reward_type,
        tickets_reward,
        activated,
        expires,
        no_expiration,
        available_limit,
        available_limit_per_user,
        added_limit,
        view_limit,
        max_prints,
        ticket_price_type,
        ticket_price,
        full_price,
        discount_price,
        show_remaining,
        show_redeemed,
        replaced,
        featured,
        offer_type,
        special_offer_type,
        offer_visibility,
        category_ids,
        filter_ids,
        active,
        barcode_asset_id,
        image_asset_id,
        image_asset_id1,
        image_asset_id2,
        image_asset_id3,
        image_asset_id4,
        image_asset_id5,
        publisher,
        redeemable_start,
        redeemable_end,
        brand,
        product_type,
        condition_type,
        isbn,
        asin,
        catalog_numbers,
        department,
        features,
        minimum_price,
        width,
        height,
        depth,
        weight,
        unit,
        studio,
        parental_rating,
        publish_date,
        availability_date,
        size_id,
        listing_id,
        media_type,
        duration,
        author,
        release_date,
        collection_ids,
        reboot_time_hour,
        reboot_time_minute,
        idle_timeout_in_second,
        serial_number,
        udid,
        device_type,
        device_power,
        device_interference,
        availability,
        availability_summary,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if parent_offer_id is not None:
            
            _query_params.append(('parentOfferId', parent_offer_id))
            
        if include_offer_locations is not None:
            
            _query_params.append(('includeOfferLocations', include_offer_locations))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if offer_locations is not None:
            
            _query_params.append(('offerLocations', offer_locations))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if sub_title is not None:
            
            _query_params.append(('subTitle', sub_title))
            
        if details is not None:
            
            _query_params.append(('details', details))
            
        if sub_details is not None:
            
            _query_params.append(('subDetails', sub_details))
            
        if fine_print is not None:
            
            _query_params.append(('finePrint', fine_print))
            
        if barcode_type is not None:
            
            _query_params.append(('barcodeType', barcode_type))
            
        if barcode_entry is not None:
            
            _query_params.append(('barcodeEntry', barcode_entry))
            
        if external_redeem_options is not None:
            
            _query_params.append(('externalRedeemOptions', external_redeem_options))
            
        if external_url is not None:
            
            _query_params.append(('externalUrl', external_url))
            
        if external_id is not None:
            
            _query_params.append(('externalId', external_id))
            
        if tickets_reward_type is not None:
            
            _query_params.append(('ticketsRewardType', tickets_reward_type))
            
        if tickets_reward is not None:
            
            _query_params.append(('ticketsReward', tickets_reward))
            
        if activated is not None:
            
            _query_params.append(('activated', activated))
            
        if expires is not None:
            
            _query_params.append(('expires', expires))
            
        if no_expiration is not None:
            
            _query_params.append(('noExpiration', no_expiration))
            
        if available_limit is not None:
            
            _query_params.append(('availableLimit', available_limit))
            
        if available_limit_per_user is not None:
            
            _query_params.append(('availableLimitPerUser', available_limit_per_user))
            
        if added_limit is not None:
            
            _query_params.append(('addedLimit', added_limit))
            
        if view_limit is not None:
            
            _query_params.append(('viewLimit', view_limit))
            
        if max_prints is not None:
            
            _query_params.append(('maxPrints', max_prints))
            
        if ticket_price_type is not None:
            
            _query_params.append(('ticketPriceType', ticket_price_type))
            
        if ticket_price is not None:
            
            _query_params.append(('ticketPrice', ticket_price))
            
        if full_price is not None:
            
            _query_params.append(('fullPrice', full_price))
            
        if discount_price is not None:
            
            _query_params.append(('discountPrice', discount_price))
            
        if show_remaining is not None:
            
            _query_params.append(('showRemaining', show_remaining))
            
        if show_redeemed is not None:
            
            _query_params.append(('showRedeemed', show_redeemed))
            
        if replaced is not None:
            
            _query_params.append(('replaced', replaced))
            
        if featured is not None:
            
            _query_params.append(('featured', featured))
            
        if offer_type is not None:
            
            _query_params.append(('offerType', offer_type))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if offer_visibility is not None:
            
            _query_params.append(('offerVisibility', offer_visibility))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if barcode_asset_id is not None:
            
            _query_params.append(('barcodeAssetId', barcode_asset_id))
            
        if image_asset_id is not None:
            
            _query_params.append(('imageAssetId', image_asset_id))
            
        if image_asset_id1 is not None:
            
            _query_params.append(('imageAssetId1', image_asset_id1))
            
        if image_asset_id2 is not None:
            
            _query_params.append(('imageAssetId2', image_asset_id2))
            
        if image_asset_id3 is not None:
            
            _query_params.append(('imageAssetId3', image_asset_id3))
            
        if image_asset_id4 is not None:
            
            _query_params.append(('imageAssetId4', image_asset_id4))
            
        if image_asset_id5 is not None:
            
            _query_params.append(('imageAssetId5', image_asset_id5))
            
        if publisher is not None:
            
            _query_params.append(('publisher', publisher))
            
        if redeemable_start is not None:
            
            _query_params.append(('redeemableStart', redeemable_start))
            
        if redeemable_end is not None:
            
            _query_params.append(('redeemableEnd', redeemable_end))
            
        if brand is not None:
            
            _query_params.append(('brand', brand))
            
        if product_type is not None:
            
            _query_params.append(('productType', product_type))
            
        if condition_type is not None:
            
            _query_params.append(('conditionType', condition_type))
            
        if isbn is not None:
            
            _query_params.append(('isbn', isbn))
            
        if asin is not None:
            
            _query_params.append(('asin', asin))
            
        if catalog_numbers is not None:
            
            _query_params.append(('catalogNumbers', catalog_numbers))
            
        if department is not None:
            
            _query_params.append(('department', department))
            
        if features is not None:
            
            _query_params.append(('features', features))
            
        if minimum_price is not None:
            
            _query_params.append(('minimumPrice', minimum_price))
            
        if width is not None:
            
            _query_params.append(('width', width))
            
        if height is not None:
            
            _query_params.append(('height', height))
            
        if depth is not None:
            
            _query_params.append(('depth', depth))
            
        if weight is not None:
            
            _query_params.append(('weight', weight))
            
        if unit is not None:
            
            _query_params.append(('unit', unit))
            
        if studio is not None:
            
            _query_params.append(('studio', studio))
            
        if parental_rating is not None:
            
            _query_params.append(('parentalRating', parental_rating))
            
        if publish_date is not None:
            
            _query_params.append(('publishDate', publish_date))
            
        if availability_date is not None:
            
            _query_params.append(('availabilityDate', availability_date))
            
        if size_id is not None:
            
            _query_params.append(('sizeId', size_id))
            
        if listing_id is not None:
            
            _query_params.append(('listingId', listing_id))
            
        if media_type is not None:
            
            _query_params.append(('mediaType', media_type))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if author is not None:
            
            _query_params.append(('author', author))
            
        if release_date is not None:
            
            _query_params.append(('releaseDate', release_date))
            
        if collection_ids is not None:
            
            _query_params.append(('collectionIds', collection_ids))
            
        if reboot_time_hour is not None:
            
            _query_params.append(('rebootTimeHour', reboot_time_hour))
            
        if reboot_time_minute is not None:
            
            _query_params.append(('rebootTimeMinute', reboot_time_minute))
            
        if idle_timeout_in_second is not None:
            
            _query_params.append(('idleTimeoutInSecond', idle_timeout_in_second))
            
        if serial_number is not None:
            
            _query_params.append(('serialNumber', serial_number))
            
        if udid is not None:
            
            _query_params.append(('udid', udid))
            
        if device_type is not None:
            
            _query_params.append(('deviceType', device_type))
            
        if device_power is not None:
            
            _query_params.append(('devicePower', device_power))
            
        if device_interference is not None:
            
            _query_params.append(('deviceInterference', device_interference))
            
        if availability is not None:
            
            _query_params.append(('availability', availability))
            
        if availability_summary is not None:
            
            _query_params.append(('availabilitySummary', availability_summary))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_offer_status(
        self,
        offer_ids: Annotated[StrictStr, Field(description="Comma separated list of offer ids")],
        active: Annotated[StrictBool, Field(description="Determines whether to make the offer active as well")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the activation, must have rights to edit the offer.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Activate Offer

        Sets the activated date on offers. This will make offers visible for consumers.

        :param offer_ids: Comma separated list of offer ids (required)
        :type offer_ids: str
        :param active: Determines whether to make the offer active as well (required)
        :type active: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the activation, must have rights to edit the offer.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_status_serialize(
            offer_ids=offer_ids,
            active=active,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_offer_status_with_http_info(
        self,
        offer_ids: Annotated[StrictStr, Field(description="Comma separated list of offer ids")],
        active: Annotated[StrictBool, Field(description="Determines whether to make the offer active as well")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the activation, must have rights to edit the offer.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Activate Offer

        Sets the activated date on offers. This will make offers visible for consumers.

        :param offer_ids: Comma separated list of offer ids (required)
        :type offer_ids: str
        :param active: Determines whether to make the offer active as well (required)
        :type active: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the activation, must have rights to edit the offer.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_status_serialize(
            offer_ids=offer_ids,
            active=active,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_offer_status_without_preload_content(
        self,
        offer_ids: Annotated[StrictStr, Field(description="Comma separated list of offer ids")],
        active: Annotated[StrictBool, Field(description="Determines whether to make the offer active as well")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account used to perform the activation, must have rights to edit the offer.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Activate Offer

        Sets the activated date on offers. This will make offers visible for consumers.

        :param offer_ids: Comma separated list of offer ids (required)
        :type offer_ids: str
        :param active: Determines whether to make the offer active as well (required)
        :type active: bool
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account used to perform the activation, must have rights to edit the offer.
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_status_serialize(
            offer_ids=offer_ids,
            active=active,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_offer_status_serialize(
        self,
        offer_ids,
        active,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_ids is not None:
            
            _query_params.append(('offerIds', offer_ids))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/retailer/offer/status',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


