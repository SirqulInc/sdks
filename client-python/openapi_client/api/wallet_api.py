# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.offer_transaction_response import OfferTransactionResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class WalletApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_offer_transaction(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The id of the offer being added (offerId or offeLocationId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The id of the offer location being added (offerId or offeLocationId required)")] = None,
        offer_cart: Annotated[Optional[StrictStr], Field(description="A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` ")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The promoCode")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Sets the currencyType to POINTS")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application requesting the purchase, required when currencyType is TICKETS")] = None,
        status: Annotated[Optional[StrictInt], Field(description="Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OfferTransactionResponse]:
        """Create Wallet Offers

        Adds offers to the wallet

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_id: The id of the offer being added (offerId or offeLocationId required)
        :type offer_id: int
        :param offer_location_id: The id of the offer location being added (offerId or offeLocationId required)
        :type offer_location_id: int
        :param offer_cart: A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` 
        :type offer_cart: str
        :param promo_code: The promoCode
        :type promo_code: str
        :param currency_type: Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        :type currency_type: str
        :param use_points: Sets the currencyType to POINTS
        :type use_points: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param app_key: The application requesting the purchase, required when currencyType is TICKETS
        :type app_key: str
        :param status: Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        :type status: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_offer_transaction_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            offer_cart=offer_cart,
            promo_code=promo_code,
            currency_type=currency_type,
            use_points=use_points,
            meta_data=meta_data,
            app_key=app_key,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_offer_transaction_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The id of the offer being added (offerId or offeLocationId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The id of the offer location being added (offerId or offeLocationId required)")] = None,
        offer_cart: Annotated[Optional[StrictStr], Field(description="A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` ")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The promoCode")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Sets the currencyType to POINTS")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application requesting the purchase, required when currencyType is TICKETS")] = None,
        status: Annotated[Optional[StrictInt], Field(description="Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OfferTransactionResponse]]:
        """Create Wallet Offers

        Adds offers to the wallet

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_id: The id of the offer being added (offerId or offeLocationId required)
        :type offer_id: int
        :param offer_location_id: The id of the offer location being added (offerId or offeLocationId required)
        :type offer_location_id: int
        :param offer_cart: A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` 
        :type offer_cart: str
        :param promo_code: The promoCode
        :type promo_code: str
        :param currency_type: Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        :type currency_type: str
        :param use_points: Sets the currencyType to POINTS
        :type use_points: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param app_key: The application requesting the purchase, required when currencyType is TICKETS
        :type app_key: str
        :param status: Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        :type status: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_offer_transaction_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            offer_cart=offer_cart,
            promo_code=promo_code,
            currency_type=currency_type,
            use_points=use_points,
            meta_data=meta_data,
            app_key=app_key,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_offer_transaction_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The id of the offer being added (offerId or offeLocationId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The id of the offer location being added (offerId or offeLocationId required)")] = None,
        offer_cart: Annotated[Optional[StrictStr], Field(description="A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` ")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The promoCode")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Sets the currencyType to POINTS")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application requesting the purchase, required when currencyType is TICKETS")] = None,
        status: Annotated[Optional[StrictInt], Field(description="Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Wallet Offers

        Adds offers to the wallet

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_id: The id of the offer being added (offerId or offeLocationId required)
        :type offer_id: int
        :param offer_location_id: The id of the offer location being added (offerId or offeLocationId required)
        :type offer_location_id: int
        :param offer_cart: A JSON list of offers to purchase. ```json [   {     \"offerId\": 123,     \"offerLocationId\": 234,     \"quantity\": 2   },   {     \"offerId\": 456,     \"offerLocationId\": 567,     \"quantity\": 1   } ] ``` 
        :type offer_cart: str
        :param promo_code: The promoCode
        :type promo_code: str
        :param currency_type: Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        :type currency_type: str
        :param use_points: Sets the currencyType to POINTS
        :type use_points: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param app_key: The application requesting the purchase, required when currencyType is TICKETS
        :type app_key: str
        :param status: Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        :type status: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_offer_transaction_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            offer_cart=offer_cart,
            promo_code=promo_code,
            currency_type=currency_type,
            use_points=use_points,
            meta_data=meta_data,
            app_key=app_key,
            status=status,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_offer_transaction_serialize(
        self,
        device_id,
        account_id,
        offer_id,
        offer_location_id,
        offer_cart,
        promo_code,
        currency_type,
        use_points,
        meta_data,
        app_key,
        status,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if offer_cart is not None:
            
            _query_params.append(('offerCart', offer_cart))
            
        if promo_code is not None:
            
            _query_params.append(('promoCode', promo_code))
            
        if currency_type is not None:
            
            _query_params.append(('currencyType', currency_type))
            
        if use_points is not None:
            
            _query_params.append(('usePoints', use_points))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/wallet/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_offer_transaction(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Wallet Offer

        Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

        :param transaction_id: The offer transaction id to remove (required)
        :type transaction_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_transaction_serialize(
            transaction_id=transaction_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_offer_transaction_with_http_info(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Wallet Offer

        Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

        :param transaction_id: The offer transaction id to remove (required)
        :type transaction_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_transaction_serialize(
            transaction_id=transaction_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_offer_transaction_without_preload_content(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to remove")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Wallet Offer

        Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

        :param transaction_id: The offer transaction id to remove (required)
        :type transaction_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_offer_transaction_serialize(
            transaction_id=transaction_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_offer_transaction_serialize(
        self,
        transaction_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if transaction_id is not None:
            
            _query_params.append(('transactionId', transaction_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/wallet/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_offer_transaction(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to get details of")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        include_mission: Annotated[Optional[StrictBool], Field(description="If true then include mission data, false to not include")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferTransactionResponse:
        """Get Wallet Offer


        :param transaction_id: The offer transaction id to get details of (required)
        :type transaction_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param include_mission: If true then include mission data, false to not include
        :type include_mission: bool
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_transaction_serialize(
            transaction_id=transaction_id,
            device_id=device_id,
            account_id=account_id,
            include_mission=include_mission,
            latitude=latitude,
            longitude=longitude,
            return_full_response=return_full_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferTransactionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_offer_transaction_with_http_info(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to get details of")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        include_mission: Annotated[Optional[StrictBool], Field(description="If true then include mission data, false to not include")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferTransactionResponse]:
        """Get Wallet Offer


        :param transaction_id: The offer transaction id to get details of (required)
        :type transaction_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param include_mission: If true then include mission data, false to not include
        :type include_mission: bool
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_transaction_serialize(
            transaction_id=transaction_id,
            device_id=device_id,
            account_id=account_id,
            include_mission=include_mission,
            latitude=latitude,
            longitude=longitude,
            return_full_response=return_full_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferTransactionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_offer_transaction_without_preload_content(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to get details of")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        include_mission: Annotated[Optional[StrictBool], Field(description="If true then include mission data, false to not include")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Wallet Offer


        :param transaction_id: The offer transaction id to get details of (required)
        :type transaction_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param include_mission: If true then include mission data, false to not include
        :type include_mission: bool
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_offer_transaction_serialize(
            transaction_id=transaction_id,
            device_id=device_id,
            account_id=account_id,
            include_mission=include_mission,
            latitude=latitude,
            longitude=longitude,
            return_full_response=return_full_response,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferTransactionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_offer_transaction_serialize(
        self,
        transaction_id,
        device_id,
        account_id,
        include_mission,
        latitude,
        longitude,
        return_full_response,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if transaction_id is not None:
            
            _query_params.append(('transactionId', transaction_id))
            
        if include_mission is not None:
            
            _query_params.append(('includeMission', include_mission))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/wallet/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def preview_offer_transaction(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The id of the offer being added (offerId or offeLocationId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The id of the offer location being added (offerId or offeLocationId required)")] = None,
        offer_cart: Annotated[Optional[StrictStr], Field(description="A JSON list of offers to purchase.")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The promoCode")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Sets the currencyType to POINTS")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application requesting the purchase, required when currencyType is TICKETS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OfferTransactionResponse]:
        """Preview Wallet Offers

        Preview the final cost of a transaction without charging the user

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_id: The id of the offer being added (offerId or offeLocationId required)
        :type offer_id: int
        :param offer_location_id: The id of the offer location being added (offerId or offeLocationId required)
        :type offer_location_id: int
        :param offer_cart: A JSON list of offers to purchase.
        :type offer_cart: str
        :param promo_code: The promoCode
        :type promo_code: str
        :param currency_type: Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        :type currency_type: str
        :param use_points: Sets the currencyType to POINTS
        :type use_points: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param app_key: The application requesting the purchase, required when currencyType is TICKETS
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_offer_transaction_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            offer_cart=offer_cart,
            promo_code=promo_code,
            currency_type=currency_type,
            use_points=use_points,
            meta_data=meta_data,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def preview_offer_transaction_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The id of the offer being added (offerId or offeLocationId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The id of the offer location being added (offerId or offeLocationId required)")] = None,
        offer_cart: Annotated[Optional[StrictStr], Field(description="A JSON list of offers to purchase.")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The promoCode")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Sets the currencyType to POINTS")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application requesting the purchase, required when currencyType is TICKETS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OfferTransactionResponse]]:
        """Preview Wallet Offers

        Preview the final cost of a transaction without charging the user

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_id: The id of the offer being added (offerId or offeLocationId required)
        :type offer_id: int
        :param offer_location_id: The id of the offer location being added (offerId or offeLocationId required)
        :type offer_location_id: int
        :param offer_cart: A JSON list of offers to purchase.
        :type offer_cart: str
        :param promo_code: The promoCode
        :type promo_code: str
        :param currency_type: Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        :type currency_type: str
        :param use_points: Sets the currencyType to POINTS
        :type use_points: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param app_key: The application requesting the purchase, required when currencyType is TICKETS
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_offer_transaction_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            offer_cart=offer_cart,
            promo_code=promo_code,
            currency_type=currency_type,
            use_points=use_points,
            meta_data=meta_data,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def preview_offer_transaction_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="The id of the offer being added (offerId or offeLocationId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="The id of the offer location being added (offerId or offeLocationId required)")] = None,
        offer_cart: Annotated[Optional[StrictStr], Field(description="A JSON list of offers to purchase.")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The promoCode")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Sets the currencyType to POINTS")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="The application requesting the purchase, required when currencyType is TICKETS")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Preview Wallet Offers

        Preview the final cost of a transaction without charging the user

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_id: The id of the offer being added (offerId or offeLocationId required)
        :type offer_id: int
        :param offer_location_id: The id of the offer location being added (offerId or offeLocationId required)
        :type offer_location_id: int
        :param offer_cart: A JSON list of offers to purchase.
        :type offer_cart: str
        :param promo_code: The promoCode
        :type promo_code: str
        :param currency_type: Determines the method of purchasing offer. CASH = use card on file, POINTS = use points, TICKETS = use tickets
        :type currency_type: str
        :param use_points: Sets the currencyType to POINTS
        :type use_points: bool
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param app_key: The application requesting the purchase, required when currencyType is TICKETS
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_offer_transaction_serialize(
            device_id=device_id,
            account_id=account_id,
            offer_id=offer_id,
            offer_location_id=offer_location_id,
            offer_cart=offer_cart,
            promo_code=promo_code,
            currency_type=currency_type,
            use_points=use_points,
            meta_data=meta_data,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _preview_offer_transaction_serialize(
        self,
        device_id,
        account_id,
        offer_id,
        offer_location_id,
        offer_cart,
        promo_code,
        currency_type,
        use_points,
        meta_data,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if offer_cart is not None:
            
            _query_params.append(('offerCart', offer_cart))
            
        if promo_code is not None:
            
            _query_params.append(('promoCode', promo_code))
            
        if currency_type is not None:
            
            _query_params.append(('currencyType', currency_type))
            
        if use_points is not None:
            
            _query_params.append(('usePoints', use_points))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/wallet/preview',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_offer_transactions(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of retailers")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer location")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of retailer locations")] = None,
        exclude_retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results to exclude retailer locations")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of offer")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer location")] = None,
        offer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of offer locations")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to return a specific offer type")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Filter results to return specific offer types")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to return a specific special offer type")] = None,
        special_offer_types: Annotated[Optional[StrictStr], Field(description="Filter results to return specific special offer types")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Category Ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Filter Ids")] = None,
        offer_audience_ids: Annotated[Optional[StrictStr], Field(description="Offer Audience Ids")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what to sort the results by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the results are in descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        redeemable_start_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        redeemable_end_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        filter_by_parent_offer: Annotated[Optional[StrictBool], Field(description="Apply params to offer's parent")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        redeemed: Annotated[Optional[StrictBool], Field(description="If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)")] = None,
        reservations_only: Annotated[Optional[StrictBool], Field(description="Returns only reservation transactions if true")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Active Only")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        recurring_started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing start date")] = None,
        recurring_started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing start date")] = None,
        recurring_expiration_since: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing expiration date")] = None,
        recurring_expiration_before: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing expiration date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OfferTransactionResponse]:
        """Search Wallet Offers

        Search on active offers currently in the user's wallet, or past offers the user has already redeemed.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: The keyword to search for
        :type keyword: str
        :param retailer_id: Filter results for this retailer
        :type retailer_id: int
        :param retailer_ids: Filter results for a list of retailers
        :type retailer_ids: str
        :param retailer_location_id: Filter results for this retailer location
        :type retailer_location_id: int
        :param retailer_location_ids: Filter results for a list of retailer locations
        :type retailer_location_ids: str
        :param exclude_retailer_location_ids: Filter results to exclude retailer locations
        :type exclude_retailer_location_ids: str
        :param offer_id: Filter results for this offer
        :type offer_id: int
        :param offer_ids: Filter results for a list of offer
        :type offer_ids: str
        :param offer_location_id: Filter results for this offer location
        :type offer_location_id: int
        :param offer_location_ids: Filter results for a list of offer locations
        :type offer_location_ids: str
        :param offer_type: Filter results to return a specific offer type
        :type offer_type: str
        :param offer_types: Filter results to return specific offer types
        :type offer_types: str
        :param special_offer_type: Filter results to return a specific special offer type
        :type special_offer_type: str
        :param special_offer_types: Filter results to return specific special offer types
        :type special_offer_types: str
        :param category_ids: Category Ids
        :type category_ids: str
        :param filter_ids: Filter Ids
        :type filter_ids: str
        :param offer_audience_ids: Offer Audience Ids
        :type offer_audience_ids: str
        :param sort_field: Determines what to sort the results by
        :type sort_field: str
        :param descending: Determines whether the results are in descending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param redeemable_start_date: Filter results by the offer redeemable date
        :type redeemable_start_date: int
        :param redeemable_end_date: Filter results by the offer redeemable date
        :type redeemable_end_date: int
        :param filter_by_parent_offer: Apply params to offer's parent
        :type filter_by_parent_offer: bool
        :param started_since: Filter results by the offer start date
        :type started_since: int
        :param started_before: Filter results by the offer start date
        :type started_before: int
        :param ended_since: Filter results by the offer end date
        :type ended_since: int
        :param ended_before: Filter results by the offer end date
        :type ended_before: int
        :param redeemed: If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
        :type redeemed: bool
        :param statuses: Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        :type statuses: str
        :param reservations_only: Returns only reservation transactions if true
        :type reservations_only: bool
        :param active_only: Active Only
        :type active_only: bool
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param recurring_started_since: Filter results by the recurring billing start date
        :type recurring_started_since: int
        :param recurring_started_before: Filter results by the recurring billing start date
        :type recurring_started_before: int
        :param recurring_expiration_since: Filter results by the recurring billing expiration date
        :type recurring_expiration_since: int
        :param recurring_expiration_before: Filter results by the recurring billing expiration date
        :type recurring_expiration_before: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offer_transactions_serialize(
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_ids=retailer_ids,
            retailer_location_id=retailer_location_id,
            retailer_location_ids=retailer_location_ids,
            exclude_retailer_location_ids=exclude_retailer_location_ids,
            offer_id=offer_id,
            offer_ids=offer_ids,
            offer_location_id=offer_location_id,
            offer_location_ids=offer_location_ids,
            offer_type=offer_type,
            offer_types=offer_types,
            special_offer_type=special_offer_type,
            special_offer_types=special_offer_types,
            category_ids=category_ids,
            filter_ids=filter_ids,
            offer_audience_ids=offer_audience_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            filter_by_parent_offer=filter_by_parent_offer,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            redeemed=redeemed,
            statuses=statuses,
            reservations_only=reservations_only,
            active_only=active_only,
            return_full_response=return_full_response,
            recurring_started_since=recurring_started_since,
            recurring_started_before=recurring_started_before,
            recurring_expiration_since=recurring_expiration_since,
            recurring_expiration_before=recurring_expiration_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_offer_transactions_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of retailers")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer location")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of retailer locations")] = None,
        exclude_retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results to exclude retailer locations")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of offer")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer location")] = None,
        offer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of offer locations")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to return a specific offer type")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Filter results to return specific offer types")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to return a specific special offer type")] = None,
        special_offer_types: Annotated[Optional[StrictStr], Field(description="Filter results to return specific special offer types")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Category Ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Filter Ids")] = None,
        offer_audience_ids: Annotated[Optional[StrictStr], Field(description="Offer Audience Ids")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what to sort the results by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the results are in descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        redeemable_start_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        redeemable_end_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        filter_by_parent_offer: Annotated[Optional[StrictBool], Field(description="Apply params to offer's parent")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        redeemed: Annotated[Optional[StrictBool], Field(description="If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)")] = None,
        reservations_only: Annotated[Optional[StrictBool], Field(description="Returns only reservation transactions if true")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Active Only")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        recurring_started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing start date")] = None,
        recurring_started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing start date")] = None,
        recurring_expiration_since: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing expiration date")] = None,
        recurring_expiration_before: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing expiration date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OfferTransactionResponse]]:
        """Search Wallet Offers

        Search on active offers currently in the user's wallet, or past offers the user has already redeemed.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: The keyword to search for
        :type keyword: str
        :param retailer_id: Filter results for this retailer
        :type retailer_id: int
        :param retailer_ids: Filter results for a list of retailers
        :type retailer_ids: str
        :param retailer_location_id: Filter results for this retailer location
        :type retailer_location_id: int
        :param retailer_location_ids: Filter results for a list of retailer locations
        :type retailer_location_ids: str
        :param exclude_retailer_location_ids: Filter results to exclude retailer locations
        :type exclude_retailer_location_ids: str
        :param offer_id: Filter results for this offer
        :type offer_id: int
        :param offer_ids: Filter results for a list of offer
        :type offer_ids: str
        :param offer_location_id: Filter results for this offer location
        :type offer_location_id: int
        :param offer_location_ids: Filter results for a list of offer locations
        :type offer_location_ids: str
        :param offer_type: Filter results to return a specific offer type
        :type offer_type: str
        :param offer_types: Filter results to return specific offer types
        :type offer_types: str
        :param special_offer_type: Filter results to return a specific special offer type
        :type special_offer_type: str
        :param special_offer_types: Filter results to return specific special offer types
        :type special_offer_types: str
        :param category_ids: Category Ids
        :type category_ids: str
        :param filter_ids: Filter Ids
        :type filter_ids: str
        :param offer_audience_ids: Offer Audience Ids
        :type offer_audience_ids: str
        :param sort_field: Determines what to sort the results by
        :type sort_field: str
        :param descending: Determines whether the results are in descending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param redeemable_start_date: Filter results by the offer redeemable date
        :type redeemable_start_date: int
        :param redeemable_end_date: Filter results by the offer redeemable date
        :type redeemable_end_date: int
        :param filter_by_parent_offer: Apply params to offer's parent
        :type filter_by_parent_offer: bool
        :param started_since: Filter results by the offer start date
        :type started_since: int
        :param started_before: Filter results by the offer start date
        :type started_before: int
        :param ended_since: Filter results by the offer end date
        :type ended_since: int
        :param ended_before: Filter results by the offer end date
        :type ended_before: int
        :param redeemed: If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
        :type redeemed: bool
        :param statuses: Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        :type statuses: str
        :param reservations_only: Returns only reservation transactions if true
        :type reservations_only: bool
        :param active_only: Active Only
        :type active_only: bool
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param recurring_started_since: Filter results by the recurring billing start date
        :type recurring_started_since: int
        :param recurring_started_before: Filter results by the recurring billing start date
        :type recurring_started_before: int
        :param recurring_expiration_since: Filter results by the recurring billing expiration date
        :type recurring_expiration_since: int
        :param recurring_expiration_before: Filter results by the recurring billing expiration date
        :type recurring_expiration_before: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offer_transactions_serialize(
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_ids=retailer_ids,
            retailer_location_id=retailer_location_id,
            retailer_location_ids=retailer_location_ids,
            exclude_retailer_location_ids=exclude_retailer_location_ids,
            offer_id=offer_id,
            offer_ids=offer_ids,
            offer_location_id=offer_location_id,
            offer_location_ids=offer_location_ids,
            offer_type=offer_type,
            offer_types=offer_types,
            special_offer_type=special_offer_type,
            special_offer_types=special_offer_types,
            category_ids=category_ids,
            filter_ids=filter_ids,
            offer_audience_ids=offer_audience_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            filter_by_parent_offer=filter_by_parent_offer,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            redeemed=redeemed,
            statuses=statuses,
            reservations_only=reservations_only,
            active_only=active_only,
            return_full_response=return_full_response,
            recurring_started_since=recurring_started_since,
            recurring_started_before=recurring_started_before,
            recurring_expiration_since=recurring_expiration_since,
            recurring_expiration_before=recurring_expiration_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_offer_transactions_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        retailer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of retailers")] = None,
        retailer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this retailer location")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of retailer locations")] = None,
        exclude_retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results to exclude retailer locations")] = None,
        offer_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of offer")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Filter results for this offer location")] = None,
        offer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results for a list of offer locations")] = None,
        offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to return a specific offer type")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Filter results to return specific offer types")] = None,
        special_offer_type: Annotated[Optional[StrictStr], Field(description="Filter results to return a specific special offer type")] = None,
        special_offer_types: Annotated[Optional[StrictStr], Field(description="Filter results to return specific special offer types")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Category Ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Filter Ids")] = None,
        offer_audience_ids: Annotated[Optional[StrictStr], Field(description="Offer Audience Ids")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what to sort the results by")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the results are in descending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        redeemable_start_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        redeemable_end_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        filter_by_parent_offer: Annotated[Optional[StrictBool], Field(description="Apply params to offer's parent")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        redeemed: Annotated[Optional[StrictBool], Field(description="If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)")] = None,
        reservations_only: Annotated[Optional[StrictBool], Field(description="Returns only reservation transactions if true")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Active Only")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        recurring_started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing start date")] = None,
        recurring_started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing start date")] = None,
        recurring_expiration_since: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing expiration date")] = None,
        recurring_expiration_before: Annotated[Optional[StrictInt], Field(description="Filter results by the recurring billing expiration date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Wallet Offers

        Search on active offers currently in the user's wallet, or past offers the user has already redeemed.

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: The keyword to search for
        :type keyword: str
        :param retailer_id: Filter results for this retailer
        :type retailer_id: int
        :param retailer_ids: Filter results for a list of retailers
        :type retailer_ids: str
        :param retailer_location_id: Filter results for this retailer location
        :type retailer_location_id: int
        :param retailer_location_ids: Filter results for a list of retailer locations
        :type retailer_location_ids: str
        :param exclude_retailer_location_ids: Filter results to exclude retailer locations
        :type exclude_retailer_location_ids: str
        :param offer_id: Filter results for this offer
        :type offer_id: int
        :param offer_ids: Filter results for a list of offer
        :type offer_ids: str
        :param offer_location_id: Filter results for this offer location
        :type offer_location_id: int
        :param offer_location_ids: Filter results for a list of offer locations
        :type offer_location_ids: str
        :param offer_type: Filter results to return a specific offer type
        :type offer_type: str
        :param offer_types: Filter results to return specific offer types
        :type offer_types: str
        :param special_offer_type: Filter results to return a specific special offer type
        :type special_offer_type: str
        :param special_offer_types: Filter results to return specific special offer types
        :type special_offer_types: str
        :param category_ids: Category Ids
        :type category_ids: str
        :param filter_ids: Filter Ids
        :type filter_ids: str
        :param offer_audience_ids: Offer Audience Ids
        :type offer_audience_ids: str
        :param sort_field: Determines what to sort the results by
        :type sort_field: str
        :param descending: Determines whether the results are in descending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param redeemable_start_date: Filter results by the offer redeemable date
        :type redeemable_start_date: int
        :param redeemable_end_date: Filter results by the offer redeemable date
        :type redeemable_end_date: int
        :param filter_by_parent_offer: Apply params to offer's parent
        :type filter_by_parent_offer: bool
        :param started_since: Filter results by the offer start date
        :type started_since: int
        :param started_before: Filter results by the offer start date
        :type started_before: int
        :param ended_since: Filter results by the offer end date
        :type ended_since: int
        :param ended_before: Filter results by the offer end date
        :type ended_before: int
        :param redeemed: If true return redeemed transactions (status 2), otherwise return active transactions (status 0 or 1)
        :type redeemed: bool
        :param statuses: Custom status value to change to (0 or 1 for redeem, 5 or 6 for membership)
        :type statuses: str
        :param reservations_only: Returns only reservation transactions if true
        :type reservations_only: bool
        :param active_only: Active Only
        :type active_only: bool
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param recurring_started_since: Filter results by the recurring billing start date
        :type recurring_started_since: int
        :param recurring_started_before: Filter results by the recurring billing start date
        :type recurring_started_before: int
        :param recurring_expiration_since: Filter results by the recurring billing expiration date
        :type recurring_expiration_since: int
        :param recurring_expiration_before: Filter results by the recurring billing expiration date
        :type recurring_expiration_before: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_offer_transactions_serialize(
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            retailer_id=retailer_id,
            retailer_ids=retailer_ids,
            retailer_location_id=retailer_location_id,
            retailer_location_ids=retailer_location_ids,
            exclude_retailer_location_ids=exclude_retailer_location_ids,
            offer_id=offer_id,
            offer_ids=offer_ids,
            offer_location_id=offer_location_id,
            offer_location_ids=offer_location_ids,
            offer_type=offer_type,
            offer_types=offer_types,
            special_offer_type=special_offer_type,
            special_offer_types=special_offer_types,
            category_ids=category_ids,
            filter_ids=filter_ids,
            offer_audience_ids=offer_audience_ids,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            latitude=latitude,
            longitude=longitude,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            filter_by_parent_offer=filter_by_parent_offer,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            redeemed=redeemed,
            statuses=statuses,
            reservations_only=reservations_only,
            active_only=active_only,
            return_full_response=return_full_response,
            recurring_started_since=recurring_started_since,
            recurring_started_before=recurring_started_before,
            recurring_expiration_since=recurring_expiration_since,
            recurring_expiration_before=recurring_expiration_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OfferTransactionResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_offer_transactions_serialize(
        self,
        device_id,
        account_id,
        keyword,
        retailer_id,
        retailer_ids,
        retailer_location_id,
        retailer_location_ids,
        exclude_retailer_location_ids,
        offer_id,
        offer_ids,
        offer_location_id,
        offer_location_ids,
        offer_type,
        offer_types,
        special_offer_type,
        special_offer_types,
        category_ids,
        filter_ids,
        offer_audience_ids,
        sort_field,
        descending,
        start,
        limit,
        latitude,
        longitude,
        redeemable_start_date,
        redeemable_end_date,
        filter_by_parent_offer,
        started_since,
        started_before,
        ended_since,
        ended_before,
        redeemed,
        statuses,
        reservations_only,
        active_only,
        return_full_response,
        recurring_started_since,
        recurring_started_before,
        recurring_expiration_since,
        recurring_expiration_before,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if retailer_id is not None:
            
            _query_params.append(('retailerId', retailer_id))
            
        if retailer_ids is not None:
            
            _query_params.append(('retailerIds', retailer_ids))
            
        if retailer_location_id is not None:
            
            _query_params.append(('retailerLocationId', retailer_location_id))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if exclude_retailer_location_ids is not None:
            
            _query_params.append(('excludeRetailerLocationIds', exclude_retailer_location_ids))
            
        if offer_id is not None:
            
            _query_params.append(('offerId', offer_id))
            
        if offer_ids is not None:
            
            _query_params.append(('offerIds', offer_ids))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if offer_location_ids is not None:
            
            _query_params.append(('offerLocationIds', offer_location_ids))
            
        if offer_type is not None:
            
            _query_params.append(('offerType', offer_type))
            
        if offer_types is not None:
            
            _query_params.append(('offerTypes', offer_types))
            
        if special_offer_type is not None:
            
            _query_params.append(('specialOfferType', special_offer_type))
            
        if special_offer_types is not None:
            
            _query_params.append(('specialOfferTypes', special_offer_types))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if offer_audience_ids is not None:
            
            _query_params.append(('offerAudienceIds', offer_audience_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if redeemable_start_date is not None:
            
            _query_params.append(('redeemableStartDate', redeemable_start_date))
            
        if redeemable_end_date is not None:
            
            _query_params.append(('redeemableEndDate', redeemable_end_date))
            
        if filter_by_parent_offer is not None:
            
            _query_params.append(('filterByParentOffer', filter_by_parent_offer))
            
        if started_since is not None:
            
            _query_params.append(('startedSince', started_since))
            
        if started_before is not None:
            
            _query_params.append(('startedBefore', started_before))
            
        if ended_since is not None:
            
            _query_params.append(('endedSince', ended_since))
            
        if ended_before is not None:
            
            _query_params.append(('endedBefore', ended_before))
            
        if redeemed is not None:
            
            _query_params.append(('redeemed', redeemed))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        if reservations_only is not None:
            
            _query_params.append(('reservationsOnly', reservations_only))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        if recurring_started_since is not None:
            
            _query_params.append(('recurringStartedSince', recurring_started_since))
            
        if recurring_started_before is not None:
            
            _query_params.append(('recurringStartedBefore', recurring_started_before))
            
        if recurring_expiration_since is not None:
            
            _query_params.append(('recurringExpirationSince', recurring_expiration_since))
            
        if recurring_expiration_before is not None:
            
            _query_params.append(('recurringExpirationBefore', recurring_expiration_before))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/wallet/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_offer_transaction(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to remove")],
        status: Annotated[StrictInt, Field(description="The status value to change to (0 or 1)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Offer Location Id")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Currency Type")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Use Points")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="App Key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        exception_membership_offer_ids: Annotated[Optional[StrictStr], Field(description="Exception Offers, transaction audiences of these offers won't be removed out of the account when up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OfferTransactionResponse:
        """Update Wallet Offer

        Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.

        :param transaction_id: The offer transaction id to remove (required)
        :type transaction_id: int
        :param status: The status value to change to (0 or 1) (required)
        :type status: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_location_id: Offer Location Id
        :type offer_location_id: int
        :param currency_type: Currency Type
        :type currency_type: str
        :param use_points: Use Points
        :type use_points: bool
        :param app_key: App Key
        :type app_key: str
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param exception_membership_offer_ids: Exception Offers, transaction audiences of these offers won't be removed out of the account when up
        :type exception_membership_offer_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_transaction_serialize(
            transaction_id=transaction_id,
            status=status,
            device_id=device_id,
            account_id=account_id,
            offer_location_id=offer_location_id,
            currency_type=currency_type,
            use_points=use_points,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            return_full_response=return_full_response,
            exception_membership_offer_ids=exception_membership_offer_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferTransactionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_offer_transaction_with_http_info(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to remove")],
        status: Annotated[StrictInt, Field(description="The status value to change to (0 or 1)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Offer Location Id")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Currency Type")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Use Points")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="App Key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        exception_membership_offer_ids: Annotated[Optional[StrictStr], Field(description="Exception Offers, transaction audiences of these offers won't be removed out of the account when up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OfferTransactionResponse]:
        """Update Wallet Offer

        Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.

        :param transaction_id: The offer transaction id to remove (required)
        :type transaction_id: int
        :param status: The status value to change to (0 or 1) (required)
        :type status: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_location_id: Offer Location Id
        :type offer_location_id: int
        :param currency_type: Currency Type
        :type currency_type: str
        :param use_points: Use Points
        :type use_points: bool
        :param app_key: App Key
        :type app_key: str
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param exception_membership_offer_ids: Exception Offers, transaction audiences of these offers won't be removed out of the account when up
        :type exception_membership_offer_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_transaction_serialize(
            transaction_id=transaction_id,
            status=status,
            device_id=device_id,
            account_id=account_id,
            offer_location_id=offer_location_id,
            currency_type=currency_type,
            use_points=use_points,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            return_full_response=return_full_response,
            exception_membership_offer_ids=exception_membership_offer_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferTransactionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_offer_transaction_without_preload_content(
        self,
        transaction_id: Annotated[StrictInt, Field(description="The offer transaction id to remove")],
        status: Annotated[StrictInt, Field(description="The status value to change to (0 or 1)")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        offer_location_id: Annotated[Optional[StrictInt], Field(description="Offer Location Id")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Currency Type")] = None,
        use_points: Annotated[Optional[StrictBool], Field(description="Use Points")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="App Key")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The latitude location of the user")] = None,
        meta_data: Annotated[Optional[StrictStr], Field(description="External custom client defined data")] = None,
        return_full_response: Annotated[Optional[StrictBool], Field(description="Determines whether to return a detailed version of the response")] = None,
        exception_membership_offer_ids: Annotated[Optional[StrictStr], Field(description="Exception Offers, transaction audiences of these offers won't be removed out of the account when up")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Wallet Offer

        Update offer status. The status values are: 0 - not redeemable, 1 - redeemable.  Not redeemable means the customer has received the offer but has not decided to use (or print) it yet.  Until they choose to do this the merchant cannot redeem the offer (has not been given permission yet).   Redeemable means the customer has chosen to use the offer and wishes to redeem it.  Redeemed means the merchant has accepted the offer and the given the customer its value, then marked it a used in the system.  This status change is handled by a merchant end point.

        :param transaction_id: The offer transaction id to remove (required)
        :type transaction_id: int
        :param status: The status value to change to (0 or 1) (required)
        :type status: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param offer_location_id: Offer Location Id
        :type offer_location_id: int
        :param currency_type: Currency Type
        :type currency_type: str
        :param use_points: Use Points
        :type use_points: bool
        :param app_key: App Key
        :type app_key: str
        :param latitude: The latitude location of the user
        :type latitude: float
        :param longitude: The latitude location of the user
        :type longitude: float
        :param meta_data: External custom client defined data
        :type meta_data: str
        :param return_full_response: Determines whether to return a detailed version of the response
        :type return_full_response: bool
        :param exception_membership_offer_ids: Exception Offers, transaction audiences of these offers won't be removed out of the account when up
        :type exception_membership_offer_ids: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_offer_transaction_serialize(
            transaction_id=transaction_id,
            status=status,
            device_id=device_id,
            account_id=account_id,
            offer_location_id=offer_location_id,
            currency_type=currency_type,
            use_points=use_points,
            app_key=app_key,
            latitude=latitude,
            longitude=longitude,
            meta_data=meta_data,
            return_full_response=return_full_response,
            exception_membership_offer_ids=exception_membership_offer_ids,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OfferTransactionResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_offer_transaction_serialize(
        self,
        transaction_id,
        status,
        device_id,
        account_id,
        offer_location_id,
        currency_type,
        use_points,
        app_key,
        latitude,
        longitude,
        meta_data,
        return_full_response,
        exception_membership_offer_ids,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if transaction_id is not None:
            
            _query_params.append(('transactionId', transaction_id))
            
        if offer_location_id is not None:
            
            _query_params.append(('offerLocationId', offer_location_id))
            
        if currency_type is not None:
            
            _query_params.append(('currencyType', currency_type))
            
        if use_points is not None:
            
            _query_params.append(('usePoints', use_points))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if status is not None:
            
            _query_params.append(('status', status))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if meta_data is not None:
            
            _query_params.append(('metaData', meta_data))
            
        if return_full_response is not None:
            
            _query_params.append(('returnFullResponse', return_full_response))
            
        if exception_membership_offer_ids is not None:
            
            _query_params.append(('exceptionMembershipOfferIds', exception_membership_offer_ids))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/wallet/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


