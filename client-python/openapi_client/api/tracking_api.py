# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Union
from typing_extensions import Annotated
from openapi_client.models.account_mini_response import AccountMiniResponse
from openapi_client.models.leg import Leg
from openapi_client.models.leg_response import LegResponse
from openapi_client.models.predicted_location_response import PredictedLocationResponse
from openapi_client.models.preferred_location_response import PreferredLocationResponse
from openapi_client.models.sirqul_response import SirqulResponse
from openapi_client.models.step_response import StepResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class TrackingApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def batch_save_tracking(
        self,
        version: Union[StrictFloat, StrictInt],
        data: Annotated[StrictStr, Field(description="JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        generate_accounts: Annotated[Optional[StrictBool], Field(description="Whether to generate accounts for tracking entries when the owner does not exist")] = None,
        update_account_locations: Annotated[Optional[StrictBool], Field(description="Whether to update the account's current location from the incoming tracking data")] = None,
        default_tag: Annotated[Optional[StrictStr], Field(description="The default tag to apply to incoming legs when no tag is provided")] = None,
        slave_uid: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[Leg]:
        """Create Batch Tracking

        Batch create tracking legs

        :param version: (required)
        :type version: float
        :param data: JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ```  (required)
        :type data: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param generate_accounts: Whether to generate accounts for tracking entries when the owner does not exist
        :type generate_accounts: bool
        :param update_account_locations: Whether to update the account's current location from the incoming tracking data
        :type update_account_locations: bool
        :param default_tag: The default tag to apply to incoming legs when no tag is provided
        :type default_tag: str
        :param slave_uid: 
        :type slave_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_save_tracking_serialize(
            version=version,
            data=data,
            device_id=device_id,
            account_id=account_id,
            generate_accounts=generate_accounts,
            update_account_locations=update_account_locations,
            default_tag=default_tag,
            slave_uid=slave_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Leg]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def batch_save_tracking_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        data: Annotated[StrictStr, Field(description="JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        generate_accounts: Annotated[Optional[StrictBool], Field(description="Whether to generate accounts for tracking entries when the owner does not exist")] = None,
        update_account_locations: Annotated[Optional[StrictBool], Field(description="Whether to update the account's current location from the incoming tracking data")] = None,
        default_tag: Annotated[Optional[StrictStr], Field(description="The default tag to apply to incoming legs when no tag is provided")] = None,
        slave_uid: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[Leg]]:
        """Create Batch Tracking

        Batch create tracking legs

        :param version: (required)
        :type version: float
        :param data: JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ```  (required)
        :type data: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param generate_accounts: Whether to generate accounts for tracking entries when the owner does not exist
        :type generate_accounts: bool
        :param update_account_locations: Whether to update the account's current location from the incoming tracking data
        :type update_account_locations: bool
        :param default_tag: The default tag to apply to incoming legs when no tag is provided
        :type default_tag: str
        :param slave_uid: 
        :type slave_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_save_tracking_serialize(
            version=version,
            data=data,
            device_id=device_id,
            account_id=account_id,
            generate_accounts=generate_accounts,
            update_account_locations=update_account_locations,
            default_tag=default_tag,
            slave_uid=slave_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Leg]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def batch_save_tracking_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        data: Annotated[StrictStr, Field(description="JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        generate_accounts: Annotated[Optional[StrictBool], Field(description="Whether to generate accounts for tracking entries when the owner does not exist")] = None,
        update_account_locations: Annotated[Optional[StrictBool], Field(description="Whether to update the account's current location from the incoming tracking data")] = None,
        default_tag: Annotated[Optional[StrictStr], Field(description="The default tag to apply to incoming legs when no tag is provided")] = None,
        slave_uid: Optional[StrictStr] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Batch Tracking

        Batch create tracking legs

        :param version: (required)
        :type version: float
        :param data: JSON array of tracking legs ```json [   \"distance\": \"0.08\",   \"duration\": \"10000\",   \"startLatitude\": \"47.614603\",   \"startLongitude\": \"-122.350518\",   \"endLatitude\": \"47.614384\",   \"endLongitude\": \"-122.349161\",   \"startDate\": \"1361924010000\",   \"endDate\": \"1361924020000\",   \"steps\": [     {       \"distance\": \"0.03\",       \"duration\": \"5000\",       \"startLat\": \"47.614603\",       \"startLng\": \"-122.350518\",       \"startDate\": \"1361924010000\",       \"endLat\": \"47.614941\",       \"endLng\": \"-122.350062\",       \"endDate\": \"1361924015000\"     },{       \"distance\": \"0.05\",       \"duration\": \"5000\",       \"startLat\": \"47.614941\",       \"startLng\": \"-122.350062\",       \"startDate\": \"1361924015000\",       \"endLat\": \"47.614384\",       \"endLng\": \"-122.349161\",       \"endDate\": \"1361924020000\"     }   ] ] ```  (required)
        :type data: str
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param generate_accounts: Whether to generate accounts for tracking entries when the owner does not exist
        :type generate_accounts: bool
        :param update_account_locations: Whether to update the account's current location from the incoming tracking data
        :type update_account_locations: bool
        :param default_tag: The default tag to apply to incoming legs when no tag is provided
        :type default_tag: str
        :param slave_uid: 
        :type slave_uid: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._batch_save_tracking_serialize(
            version=version,
            data=data,
            device_id=device_id,
            account_id=account_id,
            generate_accounts=generate_accounts,
            update_account_locations=update_account_locations,
            default_tag=default_tag,
            slave_uid=slave_uid,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[Leg]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _batch_save_tracking_serialize(
        self,
        version,
        data,
        device_id,
        account_id,
        generate_accounts,
        update_account_locations,
        default_tag,
        slave_uid,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if data is not None:
            
            _query_params.append(('data', data))
            
        if generate_accounts is not None:
            
            _query_params.append(('generateAccounts', generate_accounts))
            
        if update_account_locations is not None:
            
            _query_params.append(('updateAccountLocations', update_account_locations))
            
        if default_tag is not None:
            
            _query_params.append(('defaultTag', default_tag))
            
        if slave_uid is not None:
            
            _query_params.append(('slaveUID', slave_uid))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tracking/batch/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_predicted_locations(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude to return a more likely result set based on the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude to return a more likely result set based on the user's current location")] = None,
        date_check: Annotated[Optional[StrictInt], Field(description="Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.")] = None,
        hour_check: Annotated[Optional[StrictStr], Field(description="Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".")] = None,
        threshold: Annotated[Optional[StrictInt], Field(description="The minimum number matches in 1 hour to be considered a likely location.")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> PredictedLocationResponse:
        """Get Predicted Locations

        Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param latitude: latitude to return a more likely result set based on the user's current location
        :type latitude: float
        :param longitude: longitude to return a more likely result set based on the user's current location
        :type longitude: float
        :param date_check: Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
        :type date_check: int
        :param hour_check: Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        :type hour_check: str
        :param threshold: The minimum number matches in 1 hour to be considered a likely location.
        :type threshold: int
        :param distance_unit: Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        :type distance_unit: str
        :param search_range: Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        :type search_range: float
        :param sort_order: The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predicted_locations_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            date_check=date_check,
            hour_check=hour_check,
            threshold=threshold,
            distance_unit=distance_unit,
            search_range=search_range,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PredictedLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_predicted_locations_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude to return a more likely result set based on the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude to return a more likely result set based on the user's current location")] = None,
        date_check: Annotated[Optional[StrictInt], Field(description="Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.")] = None,
        hour_check: Annotated[Optional[StrictStr], Field(description="Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".")] = None,
        threshold: Annotated[Optional[StrictInt], Field(description="The minimum number matches in 1 hour to be considered a likely location.")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[PredictedLocationResponse]:
        """Get Predicted Locations

        Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param latitude: latitude to return a more likely result set based on the user's current location
        :type latitude: float
        :param longitude: longitude to return a more likely result set based on the user's current location
        :type longitude: float
        :param date_check: Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
        :type date_check: int
        :param hour_check: Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        :type hour_check: str
        :param threshold: The minimum number matches in 1 hour to be considered a likely location.
        :type threshold: int
        :param distance_unit: Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        :type distance_unit: str
        :param search_range: Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        :type search_range: float
        :param sort_order: The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predicted_locations_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            date_check=date_check,
            hour_check=hour_check,
            threshold=threshold,
            distance_unit=distance_unit,
            search_range=search_range,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PredictedLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_predicted_locations_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude to return a more likely result set based on the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude to return a more likely result set based on the user's current location")] = None,
        date_check: Annotated[Optional[StrictInt], Field(description="Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.")] = None,
        hour_check: Annotated[Optional[StrictStr], Field(description="Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".")] = None,
        threshold: Annotated[Optional[StrictInt], Field(description="The minimum number matches in 1 hour to be considered a likely location.")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.")] = None,
        sort_order: Annotated[Optional[StrictStr], Field(description="The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Predicted Locations

        Get the predicted location for a customer based on previous behavior.  If a customer resides in a place for a period of time this is marked as a preferred location.  We look back over the previous few days and the previous days of the week from the day specified.  If for instance the day was a Wednesday then this would check the days before, including: Tuesday, Monday, Sunday, etc. It will also check some number of previous Wednesdays in the past few weeks.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param latitude: latitude to return a more likely result set based on the user's current location
        :type latitude: float
        :param longitude: longitude to return a more likely result set based on the user's current location
        :type longitude: float
        :param date_check: Used to specify which day to get predicted locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, the current date will be used.
        :type date_check: int
        :param hour_check: Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see predicted locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        :type hour_check: str
        :param threshold: The minimum number matches in 1 hour to be considered a likely location.
        :type threshold: int
        :param distance_unit: Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        :type distance_unit: str
        :param search_range: Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        :type search_range: float
        :param sort_order: The ordering algorithm for sorting the returned results: {MATCHES, DISTANCE, WEIGHTED}
        :type sort_order: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predicted_locations_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            date_check=date_check,
            hour_check=hour_check,
            threshold=threshold,
            distance_unit=distance_unit,
            search_range=search_range,
            sort_order=sort_order,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "PredictedLocationResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_predicted_locations_serialize(
        self,
        version,
        account_id,
        latitude,
        longitude,
        date_check,
        hour_check,
        threshold,
        distance_unit,
        search_range,
        sort_order,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if date_check is not None:
            
            _query_params.append(('dateCheck', date_check))
            
        if hour_check is not None:
            
            _query_params.append(('hourCheck', hour_check))
            
        if threshold is not None:
            
            _query_params.append(('threshold', threshold))
            
        if distance_unit is not None:
            
            _query_params.append(('distanceUnit', distance_unit))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if sort_order is not None:
            
            _query_params.append(('sortOrder', sort_order))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tracking/predicted/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_predicted_path(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        start_step_id: Annotated[StrictInt, Field(description="The stepId to begin from")],
        end_step_id: Annotated[StrictInt, Field(description="The stepId to end with")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[StepResponse]:
        """Get Tracking Path

        Get the path (lat/long coordinates) between 2 steps previously logged for a customer.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param start_step_id: The stepId to begin from (required)
        :type start_step_id: int
        :param end_step_id: The stepId to end with (required)
        :type end_step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predicted_path_serialize(
            version=version,
            account_id=account_id,
            start_step_id=start_step_id,
            end_step_id=end_step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StepResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_predicted_path_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        start_step_id: Annotated[StrictInt, Field(description="The stepId to begin from")],
        end_step_id: Annotated[StrictInt, Field(description="The stepId to end with")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[StepResponse]]:
        """Get Tracking Path

        Get the path (lat/long coordinates) between 2 steps previously logged for a customer.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param start_step_id: The stepId to begin from (required)
        :type start_step_id: int
        :param end_step_id: The stepId to end with (required)
        :type end_step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predicted_path_serialize(
            version=version,
            account_id=account_id,
            start_step_id=start_step_id,
            end_step_id=end_step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StepResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_predicted_path_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        start_step_id: Annotated[StrictInt, Field(description="The stepId to begin from")],
        end_step_id: Annotated[StrictInt, Field(description="The stepId to end with")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Tracking Path

        Get the path (lat/long coordinates) between 2 steps previously logged for a customer.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param start_step_id: The stepId to begin from (required)
        :type start_step_id: int
        :param end_step_id: The stepId to end with (required)
        :type end_step_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_predicted_path_serialize(
            version=version,
            account_id=account_id,
            start_step_id=start_step_id,
            end_step_id=end_step_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[StepResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_predicted_path_serialize(
        self,
        version,
        account_id,
        start_step_id,
        end_step_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if start_step_id is not None:
            
            _query_params.append(('startStepId', start_step_id))
            
        if end_step_id is not None:
            
            _query_params.append(('endStepId', end_step_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tracking/path/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_preferred_locations(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude to return a more likely result set based on the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude to return a more likely result set based on the user's current location")] = None,
        date_check: Annotated[Optional[StrictInt], Field(description="Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.")] = None,
        hour_check: Annotated[Optional[StrictStr], Field(description="Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[PreferredLocationResponse]:
        """Search Preferred Locations

        Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param latitude: latitude to return a more likely result set based on the user's current location
        :type latitude: float
        :param longitude: longitude to return a more likely result set based on the user's current location
        :type longitude: float
        :param date_check: Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
        :type date_check: int
        :param hour_check: Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        :type hour_check: str
        :param sort_field: Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param search_range: Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        :type search_range: float
        :param distance_unit: Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        :type distance_unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_preferred_locations_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            date_check=date_check,
            hour_check=hour_check,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            search_range=search_range,
            distance_unit=distance_unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PreferredLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_preferred_locations_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude to return a more likely result set based on the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude to return a more likely result set based on the user's current location")] = None,
        date_check: Annotated[Optional[StrictInt], Field(description="Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.")] = None,
        hour_check: Annotated[Optional[StrictStr], Field(description="Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[PreferredLocationResponse]]:
        """Search Preferred Locations

        Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param latitude: latitude to return a more likely result set based on the user's current location
        :type latitude: float
        :param longitude: longitude to return a more likely result set based on the user's current location
        :type longitude: float
        :param date_check: Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
        :type date_check: int
        :param hour_check: Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        :type hour_check: str
        :param sort_field: Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param search_range: Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        :type search_range: float
        :param distance_unit: Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        :type distance_unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_preferred_locations_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            date_check=date_check,
            hour_check=hour_check,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            search_range=search_range,
            distance_unit=distance_unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PreferredLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_preferred_locations_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the customer")],
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="latitude to return a more likely result set based on the user's current location")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="longitude to return a more likely result set based on the user's current location")] = None,
        date_check: Annotated[Optional[StrictInt], Field(description="Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.")] = None,
        hour_check: Annotated[Optional[StrictStr], Field(description="Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether the sorted list is in descending or ascending order")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        search_range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.")] = None,
        distance_unit: Annotated[Optional[StrictStr], Field(description="Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Preferred Locations

        Search on preferred locations for a user, which is created when a customer resides in a place for a period of time.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the customer (required)
        :type account_id: int
        :param latitude: latitude to return a more likely result set based on the user's current location
        :type latitude: float
        :param longitude: longitude to return a more likely result set based on the user's current location
        :type longitude: float
        :param date_check: Used to specify which day to get preferred locations for. So if you want to look at where they might be tomorrow, pass in tomorrow's date (timestamp in milliseconds). If no value is passed in, results from all time will be returned.
        :type date_check: int
        :param hour_check: Comma separated list of hours that will filter the results on the hours specified. For example, if you want to see preferred locations for the mornings and evening you can pass in \"8,9,10,11,17,18,19,20\".
        :type hour_check: str
        :param sort_field: Specifies how the results will be ordered. Supported values include: CREATED - the time of when the preferred location data was processed. PREFERRED_DATE - the time of when the user sent in the tracking data. HOUR - the hour of when the user sent in the tracking data. DURATION - the duration of the preferred location
        :type sort_field: str
        :param descending: Determines whether the sorted list is in descending or ascending order
        :type descending: bool
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param search_range: Filter results so only locations within the specified radius will be returned. The distance can either be in miles or kilometers as specified in the distanceUnit parameter. A value of \"0\" (zero) will ignore the radius restriction.
        :type search_range: float
        :param distance_unit: Determines which unit of measurement gets returned for distances: {MILES, KILOMETERS}
        :type distance_unit: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_preferred_locations_serialize(
            version=version,
            account_id=account_id,
            latitude=latitude,
            longitude=longitude,
            date_check=date_check,
            hour_check=hour_check,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            search_range=search_range,
            distance_unit=distance_unit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[PreferredLocationResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_preferred_locations_serialize(
        self,
        version,
        account_id,
        latitude,
        longitude,
        date_check,
        hour_check,
        sort_field,
        descending,
        start,
        limit,
        search_range,
        distance_unit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if date_check is not None:
            
            _query_params.append(('dateCheck', date_check))
            
        if hour_check is not None:
            
            _query_params.append(('hourCheck', hour_check))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if search_range is not None:
            
            _query_params.append(('searchRange', search_range))
            
        if distance_unit is not None:
            
            _query_params.append(('distanceUnit', distance_unit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tracking/preferred/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_tracking_legs(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="the account id of the person the user wants to tracking data for")] = None,
        tracking_device_id: Annotated[Optional[StrictStr], Field(description="the id of the tracking device")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date in (UTC milliseconds) to filter the tracking results")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="filter results by tag")] = None,
        get_last_point: Annotated[Optional[StrictBool], Field(description="gets the last known location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LegResponse]:
        """Search Tracking

        Retrieve tracking data to be able to show where a user has been.

        :param version: (required)
        :type version: float
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param owner_id: the account id of the person the user wants to tracking data for
        :type owner_id: int
        :param tracking_device_id: the id of the tracking device
        :type tracking_device_id: str
        :param start_date: the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
        :type start_date: int
        :param end_date: the end date in (UTC milliseconds) to filter the tracking results
        :type end_date: int
        :param tags: filter results by tag
        :type tags: str
        :param get_last_point: gets the last known location of the user
        :type get_last_point: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tracking_legs_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            owner_id=owner_id,
            tracking_device_id=tracking_device_id,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            get_last_point=get_last_point,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LegResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_tracking_legs_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="the account id of the person the user wants to tracking data for")] = None,
        tracking_device_id: Annotated[Optional[StrictStr], Field(description="the id of the tracking device")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date in (UTC milliseconds) to filter the tracking results")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="filter results by tag")] = None,
        get_last_point: Annotated[Optional[StrictBool], Field(description="gets the last known location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LegResponse]]:
        """Search Tracking

        Retrieve tracking data to be able to show where a user has been.

        :param version: (required)
        :type version: float
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param owner_id: the account id of the person the user wants to tracking data for
        :type owner_id: int
        :param tracking_device_id: the id of the tracking device
        :type tracking_device_id: str
        :param start_date: the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
        :type start_date: int
        :param end_date: the end date in (UTC milliseconds) to filter the tracking results
        :type end_date: int
        :param tags: filter results by tag
        :type tags: str
        :param get_last_point: gets the last known location of the user
        :type get_last_point: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tracking_legs_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            owner_id=owner_id,
            tracking_device_id=tracking_device_id,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            get_last_point=get_last_point,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LegResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_tracking_legs_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        owner_id: Annotated[Optional[StrictInt], Field(description="the account id of the person the user wants to tracking data for")] = None,
        tracking_device_id: Annotated[Optional[StrictStr], Field(description="the id of the tracking device")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="the end date in (UTC milliseconds) to filter the tracking results")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="filter results by tag")] = None,
        get_last_point: Annotated[Optional[StrictBool], Field(description="gets the last known location of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Tracking

        Retrieve tracking data to be able to show where a user has been.

        :param version: (required)
        :type version: float
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param owner_id: the account id of the person the user wants to tracking data for
        :type owner_id: int
        :param tracking_device_id: the id of the tracking device
        :type tracking_device_id: str
        :param start_date: the start date in (UTC milliseconds) to filter the tracking results. If no startDate is passed in, the last 30 days will be returned.
        :type start_date: int
        :param end_date: the end date in (UTC milliseconds) to filter the tracking results
        :type end_date: int
        :param tags: filter results by tag
        :type tags: str
        :param get_last_point: gets the last known location of the user
        :type get_last_point: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_tracking_legs_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            owner_id=owner_id,
            tracking_device_id=tracking_device_id,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            get_last_point=get_last_point,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LegResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_tracking_legs_serialize(
        self,
        version,
        device_id,
        account_id,
        owner_id,
        tracking_device_id,
        start_date,
        end_date,
        tags,
        get_last_point,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if owner_id is not None:
            
            _query_params.append(('ownerId', owner_id))
            
        if tracking_device_id is not None:
            
            _query_params.append(('trackingDeviceId', tracking_device_id))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if get_last_point is not None:
            
            _query_params.append(('getLastPoint', get_last_point))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tracking/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_tracking_leg(
        self,
        version: Union[StrictFloat, StrictInt],
        start_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the first point")],
        start_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the first point")],
        start_date: Annotated[StrictInt, Field(description="the start date (in UTC milliseconds) of the first point")],
        end_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the last point")],
        end_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the last point")],
        end_date: Annotated[StrictInt, Field(description="the end date (in UTC milliseconds) of the last point")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the total distance")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="the total duration")] = None,
        steps: Annotated[Optional[StrictStr], Field(description="JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` ")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="name the leg for searching")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Tracking Leg

        Send tracking points to be able to generate pathing data

        :param version: (required)
        :type version: float
        :param start_lat: the latitude of the first point (required)
        :type start_lat: float
        :param start_lng: the longitude of the first point (required)
        :type start_lng: float
        :param start_date: the start date (in UTC milliseconds) of the first point (required)
        :type start_date: int
        :param end_lat: the latitude of the last point (required)
        :type end_lat: float
        :param end_lng: the longitude of the last point (required)
        :type end_lng: float
        :param end_date: the end date (in UTC milliseconds) of the last point (required)
        :type end_date: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param distance: the total distance
        :type distance: float
        :param duration: the total duration
        :type duration: int
        :param steps: JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
        :type steps: str
        :param tags: name the leg for searching
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_tracking_leg_serialize(
            version=version,
            start_lat=start_lat,
            start_lng=start_lng,
            start_date=start_date,
            end_lat=end_lat,
            end_lng=end_lng,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            distance=distance,
            duration=duration,
            steps=steps,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_tracking_leg_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        start_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the first point")],
        start_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the first point")],
        start_date: Annotated[StrictInt, Field(description="the start date (in UTC milliseconds) of the first point")],
        end_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the last point")],
        end_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the last point")],
        end_date: Annotated[StrictInt, Field(description="the end date (in UTC milliseconds) of the last point")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the total distance")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="the total duration")] = None,
        steps: Annotated[Optional[StrictStr], Field(description="JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` ")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="name the leg for searching")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Tracking Leg

        Send tracking points to be able to generate pathing data

        :param version: (required)
        :type version: float
        :param start_lat: the latitude of the first point (required)
        :type start_lat: float
        :param start_lng: the longitude of the first point (required)
        :type start_lng: float
        :param start_date: the start date (in UTC milliseconds) of the first point (required)
        :type start_date: int
        :param end_lat: the latitude of the last point (required)
        :type end_lat: float
        :param end_lng: the longitude of the last point (required)
        :type end_lng: float
        :param end_date: the end date (in UTC milliseconds) of the last point (required)
        :type end_date: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param distance: the total distance
        :type distance: float
        :param duration: the total duration
        :type duration: int
        :param steps: JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
        :type steps: str
        :param tags: name the leg for searching
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_tracking_leg_serialize(
            version=version,
            start_lat=start_lat,
            start_lng=start_lng,
            start_date=start_date,
            end_lat=end_lat,
            end_lng=end_lng,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            distance=distance,
            duration=duration,
            steps=steps,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_tracking_leg_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        start_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the first point")],
        start_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the first point")],
        start_date: Annotated[StrictInt, Field(description="the start date (in UTC milliseconds) of the first point")],
        end_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the last point")],
        end_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the last point")],
        end_date: Annotated[StrictInt, Field(description="the end date (in UTC milliseconds) of the last point")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the total distance")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="the total duration")] = None,
        steps: Annotated[Optional[StrictStr], Field(description="JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` ")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="name the leg for searching")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Tracking Leg

        Send tracking points to be able to generate pathing data

        :param version: (required)
        :type version: float
        :param start_lat: the latitude of the first point (required)
        :type start_lat: float
        :param start_lng: the longitude of the first point (required)
        :type start_lng: float
        :param start_date: the start date (in UTC milliseconds) of the first point (required)
        :type start_date: int
        :param end_lat: the latitude of the last point (required)
        :type end_lat: float
        :param end_lng: the longitude of the last point (required)
        :type end_lng: float
        :param end_date: the end date (in UTC milliseconds) of the last point (required)
        :type end_date: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param distance: the total distance
        :type distance: float
        :param duration: the total duration
        :type duration: int
        :param steps: JSON array of tracking vectors used for smoother pathing data. If null then the leg data will be used to generate a single step, if an empty array then no steps will be generated. ```json [{   \"distance\": \"0.03\",   \"duration\": \"5000\",   \"startLat\": \"47.614603\",   \"startLng\": \"-122.350518\",   \"startDate\": \"1361924010000\",   \"endLat\": \"47.614941\",   \"endLng\": \"-122.350062\",   \"endDate\": \"1361924015000\" }] ``` 
        :type steps: str
        :param tags: name the leg for searching
        :type tags: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_tracking_leg_serialize(
            version=version,
            start_lat=start_lat,
            start_lng=start_lng,
            start_date=start_date,
            end_lat=end_lat,
            end_lng=end_lng,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            distance=distance,
            duration=duration,
            steps=steps,
            tags=tags,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_tracking_leg_serialize(
        self,
        version,
        start_lat,
        start_lng,
        start_date,
        end_lat,
        end_lng,
        end_date,
        device_id,
        account_id,
        distance,
        duration,
        steps,
        tags,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if distance is not None:
            
            _query_params.append(('distance', distance))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if start_lat is not None:
            
            _query_params.append(('startLat', start_lat))
            
        if start_lng is not None:
            
            _query_params.append(('startLng', start_lng))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_lat is not None:
            
            _query_params.append(('endLat', end_lat))
            
        if end_lng is not None:
            
            _query_params.append(('endLng', end_lng))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if steps is not None:
            
            _query_params.append(('steps', steps))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tracking/leg/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def save_tracking_step(
        self,
        version: Union[StrictFloat, StrictInt],
        leg_id: Annotated[StrictInt, Field(description="the leg to add the step to")],
        start_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the first point")],
        start_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the first point")],
        start_date: Annotated[StrictInt, Field(description="the start date (in UTC milliseconds) of the first point")],
        end_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the last point")],
        end_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the last point")],
        end_date: Annotated[StrictInt, Field(description="the end date (in UTC milliseconds) of the last point")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the total distance")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="the total duration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Create Tracking Step

        Send tracking points to be able to generate pathing data

        :param version: (required)
        :type version: float
        :param leg_id: the leg to add the step to (required)
        :type leg_id: int
        :param start_lat: the latitude of the first point (required)
        :type start_lat: float
        :param start_lng: the longitude of the first point (required)
        :type start_lng: float
        :param start_date: the start date (in UTC milliseconds) of the first point (required)
        :type start_date: int
        :param end_lat: the latitude of the last point (required)
        :type end_lat: float
        :param end_lng: the longitude of the last point (required)
        :type end_lng: float
        :param end_date: the end date (in UTC milliseconds) of the last point (required)
        :type end_date: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param distance: the total distance
        :type distance: float
        :param duration: the total duration
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_tracking_step_serialize(
            version=version,
            leg_id=leg_id,
            start_lat=start_lat,
            start_lng=start_lng,
            start_date=start_date,
            end_lat=end_lat,
            end_lng=end_lng,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            distance=distance,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def save_tracking_step_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        leg_id: Annotated[StrictInt, Field(description="the leg to add the step to")],
        start_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the first point")],
        start_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the first point")],
        start_date: Annotated[StrictInt, Field(description="the start date (in UTC milliseconds) of the first point")],
        end_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the last point")],
        end_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the last point")],
        end_date: Annotated[StrictInt, Field(description="the end date (in UTC milliseconds) of the last point")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the total distance")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="the total duration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Create Tracking Step

        Send tracking points to be able to generate pathing data

        :param version: (required)
        :type version: float
        :param leg_id: the leg to add the step to (required)
        :type leg_id: int
        :param start_lat: the latitude of the first point (required)
        :type start_lat: float
        :param start_lng: the longitude of the first point (required)
        :type start_lng: float
        :param start_date: the start date (in UTC milliseconds) of the first point (required)
        :type start_date: int
        :param end_lat: the latitude of the last point (required)
        :type end_lat: float
        :param end_lng: the longitude of the last point (required)
        :type end_lng: float
        :param end_date: the end date (in UTC milliseconds) of the last point (required)
        :type end_date: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param distance: the total distance
        :type distance: float
        :param duration: the total duration
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_tracking_step_serialize(
            version=version,
            leg_id=leg_id,
            start_lat=start_lat,
            start_lng=start_lng,
            start_date=start_date,
            end_lat=end_lat,
            end_lng=end_lng,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            distance=distance,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def save_tracking_step_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        leg_id: Annotated[StrictInt, Field(description="the leg to add the step to")],
        start_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the first point")],
        start_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the first point")],
        start_date: Annotated[StrictInt, Field(description="the start date (in UTC milliseconds) of the first point")],
        end_lat: Annotated[Union[StrictFloat, StrictInt], Field(description="the latitude of the last point")],
        end_lng: Annotated[Union[StrictFloat, StrictInt], Field(description="the longitude of the last point")],
        end_date: Annotated[StrictInt, Field(description="the end date (in UTC milliseconds) of the last point")],
        device_id: Annotated[Optional[StrictStr], Field(description="the device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        distance: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the total distance")] = None,
        duration: Annotated[Optional[StrictInt], Field(description="the total duration")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Tracking Step

        Send tracking points to be able to generate pathing data

        :param version: (required)
        :type version: float
        :param leg_id: the leg to add the step to (required)
        :type leg_id: int
        :param start_lat: the latitude of the first point (required)
        :type start_lat: float
        :param start_lng: the longitude of the first point (required)
        :type start_lng: float
        :param start_date: the start date (in UTC milliseconds) of the first point (required)
        :type start_date: int
        :param end_lat: the latitude of the last point (required)
        :type end_lat: float
        :param end_lng: the longitude of the last point (required)
        :type end_lng: float
        :param end_date: the end date (in UTC milliseconds) of the last point (required)
        :type end_date: int
        :param device_id: the device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param distance: the total distance
        :type distance: float
        :param duration: the total duration
        :type duration: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._save_tracking_step_serialize(
            version=version,
            leg_id=leg_id,
            start_lat=start_lat,
            start_lng=start_lng,
            start_date=start_date,
            end_lat=end_lat,
            end_lng=end_lng,
            end_date=end_date,
            device_id=device_id,
            account_id=account_id,
            distance=distance,
            duration=duration,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _save_tracking_step_serialize(
        self,
        version,
        leg_id,
        start_lat,
        start_lng,
        start_date,
        end_lat,
        end_lng,
        end_date,
        device_id,
        account_id,
        distance,
        duration,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if leg_id is not None:
            
            _query_params.append(('legId', leg_id))
            
        if distance is not None:
            
            _query_params.append(('distance', distance))
            
        if duration is not None:
            
            _query_params.append(('duration', duration))
            
        if start_lat is not None:
            
            _query_params.append(('startLat', start_lat))
            
        if start_lng is not None:
            
            _query_params.append(('startLng', start_lng))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_lat is not None:
            
            _query_params.append(('endLat', end_lat))
            
        if end_lng is not None:
            
            _query_params.append(('endLng', end_lng))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/tracking/step/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_accounts_with_tracking_legs(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        keyword: Annotated[Optional[StrictStr], Field(description="Used for LIKE search of first or last name on the acocunt")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Range to begin in UTC milliseconds")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Range to end in UTC milliseconds")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Exact match on tag field of Legs's searchTag")] = None,
        audience_ids: Optional[StrictStr] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Origin latitude to perform searching constraints with given range")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Origin longitude to perform searching constraints with given range")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius, in miles, to perform the search for")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with. Default is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of records to return. Default is 20.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AccountMiniResponse]:
        """List Tracking

        Search for all accounts that have tracking legs data by the given constraints.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param keyword: Used for LIKE search of first or last name on the acocunt
        :type keyword: str
        :param start_date: Range to begin in UTC milliseconds
        :type start_date: int
        :param end_date: Range to end in UTC milliseconds
        :type end_date: int
        :param tags: Exact match on tag field of Legs's searchTag
        :type tags: str
        :param audience_ids: 
        :type audience_ids: str
        :param latitude: Origin latitude to perform searching constraints with given range
        :type latitude: float
        :param longitude: Origin longitude to perform searching constraints with given range
        :type longitude: float
        :param range: The radius, in miles, to perform the search for
        :type range: float
        :param sort_field: The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with. Default is 0.
        :type start: int
        :param limit: The total number of records to return. Default is 20.
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_accounts_with_tracking_legs_serialize(
            version=version,
            account_id=account_id,
            keyword=keyword,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            audience_ids=audience_ids,
            latitude=latitude,
            longitude=longitude,
            range=range,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AccountMiniResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_accounts_with_tracking_legs_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        keyword: Annotated[Optional[StrictStr], Field(description="Used for LIKE search of first or last name on the acocunt")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Range to begin in UTC milliseconds")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Range to end in UTC milliseconds")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Exact match on tag field of Legs's searchTag")] = None,
        audience_ids: Optional[StrictStr] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Origin latitude to perform searching constraints with given range")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Origin longitude to perform searching constraints with given range")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius, in miles, to perform the search for")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with. Default is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of records to return. Default is 20.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AccountMiniResponse]]:
        """List Tracking

        Search for all accounts that have tracking legs data by the given constraints.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param keyword: Used for LIKE search of first or last name on the acocunt
        :type keyword: str
        :param start_date: Range to begin in UTC milliseconds
        :type start_date: int
        :param end_date: Range to end in UTC milliseconds
        :type end_date: int
        :param tags: Exact match on tag field of Legs's searchTag
        :type tags: str
        :param audience_ids: 
        :type audience_ids: str
        :param latitude: Origin latitude to perform searching constraints with given range
        :type latitude: float
        :param longitude: Origin longitude to perform searching constraints with given range
        :type longitude: float
        :param range: The radius, in miles, to perform the search for
        :type range: float
        :param sort_field: The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with. Default is 0.
        :type start: int
        :param limit: The total number of records to return. Default is 20.
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_accounts_with_tracking_legs_serialize(
            version=version,
            account_id=account_id,
            keyword=keyword,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            audience_ids=audience_ids,
            latitude=latitude,
            longitude=longitude,
            range=range,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AccountMiniResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_accounts_with_tracking_legs_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id of the user")],
        keyword: Annotated[Optional[StrictStr], Field(description="Used for LIKE search of first or last name on the acocunt")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="Range to begin in UTC milliseconds")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="Range to end in UTC milliseconds")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Exact match on tag field of Legs's searchTag")] = None,
        audience_ids: Optional[StrictStr] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Origin latitude to perform searching constraints with given range")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="Origin longitude to perform searching constraints with given range")] = None,
        range: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="The radius, in miles, to perform the search for")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="The order to return the results. Default is false, which will return the results in ascending order.")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The index into the record set to start with. Default is 0.")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The total number of records to return. Default is 20.")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Determines whether to return only active results. Default is false.")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Tracking

        Search for all accounts that have tracking legs data by the given constraints.

        :param version: (required)
        :type version: float
        :param account_id: The account id of the user (required)
        :type account_id: int
        :param keyword: Used for LIKE search of first or last name on the acocunt
        :type keyword: str
        :param start_date: Range to begin in UTC milliseconds
        :type start_date: int
        :param end_date: Range to end in UTC milliseconds
        :type end_date: int
        :param tags: Exact match on tag field of Legs's searchTag
        :type tags: str
        :param audience_ids: 
        :type audience_ids: str
        :param latitude: Origin latitude to perform searching constraints with given range
        :type latitude: float
        :param longitude: Origin longitude to perform searching constraints with given range
        :type longitude: float
        :param range: The radius, in miles, to perform the search for
        :type range: float
        :param sort_field: The column to sort the search on. Possible values include: {LEG_START_DATE, ACCOUNT_DISPLAY}
        :type sort_field: str
        :param descending: The order to return the results. Default is false, which will return the results in ascending order.
        :type descending: bool
        :param start: The index into the record set to start with. Default is 0.
        :type start: int
        :param limit: The total number of records to return. Default is 20.
        :type limit: int
        :param active_only: Determines whether to return only active results. Default is false.
        :type active_only: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_accounts_with_tracking_legs_serialize(
            version=version,
            account_id=account_id,
            keyword=keyword,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            audience_ids=audience_ids,
            latitude=latitude,
            longitude=longitude,
            range=range,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AccountMiniResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_accounts_with_tracking_legs_serialize(
        self,
        version,
        account_id,
        keyword,
        start_date,
        end_date,
        tags,
        audience_ids,
        latitude,
        longitude,
        range,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if audience_ids is not None:
            
            _query_params.append(('audienceIds', audience_ids))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        if range is not None:
            
            _query_params.append(('range', range))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tracking/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_tracking_legs(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id to search tracking for")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        tracking_device_id: Annotated[Optional[StrictStr], Field(description="The id of the tracking device")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start date in (UTC milliseconds) to filter the tracking results")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end date in (UTC milliseconds) to filter the tracking results")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Filter results by tag")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[LegResponse]:
        """Search Tracking (Billable)

        Retrieve tracking data for billable/account scoped queries.

        :param version: (required)
        :type version: float
        :param account_id: The account id to search tracking for (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param tracking_device_id: The id of the tracking device
        :type tracking_device_id: str
        :param start_date: The start date in (UTC milliseconds) to filter the tracking results
        :type start_date: int
        :param end_date: The end date in (UTC milliseconds) to filter the tracking results
        :type end_date: int
        :param tags: Filter results by tag
        :type tags: str
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tracking_legs_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            tracking_device_id=tracking_device_id,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LegResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_tracking_legs_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id to search tracking for")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        tracking_device_id: Annotated[Optional[StrictStr], Field(description="The id of the tracking device")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start date in (UTC milliseconds) to filter the tracking results")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end date in (UTC milliseconds) to filter the tracking results")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Filter results by tag")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[LegResponse]]:
        """Search Tracking (Billable)

        Retrieve tracking data for billable/account scoped queries.

        :param version: (required)
        :type version: float
        :param account_id: The account id to search tracking for (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param tracking_device_id: The id of the tracking device
        :type tracking_device_id: str
        :param start_date: The start date in (UTC milliseconds) to filter the tracking results
        :type start_date: int
        :param end_date: The end date in (UTC milliseconds) to filter the tracking results
        :type end_date: int
        :param tags: Filter results by tag
        :type tags: str
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tracking_legs_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            tracking_device_id=tracking_device_id,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LegResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_tracking_legs_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="The account id to search tracking for")],
        app_key: Annotated[StrictStr, Field(description="The application key")],
        tracking_device_id: Annotated[Optional[StrictStr], Field(description="The id of the tracking device")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="The start date in (UTC milliseconds) to filter the tracking results")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="The end date in (UTC milliseconds) to filter the tracking results")] = None,
        tags: Annotated[Optional[StrictStr], Field(description="Filter results by tag")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Tracking (Billable)

        Retrieve tracking data for billable/account scoped queries.

        :param version: (required)
        :type version: float
        :param account_id: The account id to search tracking for (required)
        :type account_id: int
        :param app_key: The application key (required)
        :type app_key: str
        :param tracking_device_id: The id of the tracking device
        :type tracking_device_id: str
        :param start_date: The start date in (UTC milliseconds) to filter the tracking results
        :type start_date: int
        :param end_date: The end date in (UTC milliseconds) to filter the tracking results
        :type end_date: int
        :param tags: Filter results by tag
        :type tags: str
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_tracking_legs_serialize(
            version=version,
            account_id=account_id,
            app_key=app_key,
            tracking_device_id=tracking_device_id,
            start_date=start_date,
            end_date=end_date,
            tags=tags,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[LegResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_tracking_legs_serialize(
        self,
        version,
        account_id,
        app_key,
        tracking_device_id,
        start_date,
        end_date,
        tags,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if tracking_device_id is not None:
            
            _query_params.append(('trackingDeviceId', tracking_device_id))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if tags is not None:
            
            _query_params.append(('tags', tags))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/tracking/searchByBillable',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


