# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictBytes, StrictFloat, StrictInt, StrictStr, field_validator
from typing import List, Optional, Tuple, Union
from typing_extensions import Annotated
from openapi_client.models.achievement_progress_response import AchievementProgressResponse
from openapi_client.models.achievement_response import AchievementResponse
from openapi_client.models.achievement_short_response import AchievementShortResponse
from openapi_client.models.achievement_tier_response import AchievementTierResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class AchievementApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def api_version_achievement_tier_search_post(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)")] = None,
        achievement_type: Annotated[Optional[StrictInt], Field(description="filter results by achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are the exact case sensitive matches)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by. See {@link AchievementApiMap}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sort list is in descending or ascending order (of the achievement)")] = None,
        descending_goal: Annotated[Optional[StrictBool], Field(description="determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination (has a hard limit of 1000)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementTierResponse:
        """Searches an Achievement Tier

        Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: the application key
        :type app_key: str
        :param keyword: the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
        :type keyword: str
        :param achievement_type: filter results by achievementType (these are exact case sensitive matches)
        :type achievement_type: int
        :param rank_type: filter results by the rankType (these are the exact case sensitive matches)
        :type rank_type: str
        :param sort_field: the field to sort by. See {@link AchievementApiMap}
        :type sort_field: str
        :param descending: determines whether the sort list is in descending or ascending order (of the achievement)
        :type descending: bool
        :param descending_goal: determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
        :type descending_goal: bool
        :param start: The start of the index for pagination
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_version_achievement_tier_search_post_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            sort_field=sort_field,
            descending=descending,
            descending_goal=descending_goal,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def api_version_achievement_tier_search_post_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)")] = None,
        achievement_type: Annotated[Optional[StrictInt], Field(description="filter results by achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are the exact case sensitive matches)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by. See {@link AchievementApiMap}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sort list is in descending or ascending order (of the achievement)")] = None,
        descending_goal: Annotated[Optional[StrictBool], Field(description="determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination (has a hard limit of 1000)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementTierResponse]:
        """Searches an Achievement Tier

        Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: the application key
        :type app_key: str
        :param keyword: the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
        :type keyword: str
        :param achievement_type: filter results by achievementType (these are exact case sensitive matches)
        :type achievement_type: int
        :param rank_type: filter results by the rankType (these are the exact case sensitive matches)
        :type rank_type: str
        :param sort_field: the field to sort by. See {@link AchievementApiMap}
        :type sort_field: str
        :param descending: determines whether the sort list is in descending or ascending order (of the achievement)
        :type descending: bool
        :param descending_goal: determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
        :type descending_goal: bool
        :param start: The start of the index for pagination
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_version_achievement_tier_search_post_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            sort_field=sort_field,
            descending=descending,
            descending_goal=descending_goal,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def api_version_achievement_tier_search_post_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)")] = None,
        achievement_type: Annotated[Optional[StrictInt], Field(description="filter results by achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are the exact case sensitive matches)")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="the field to sort by. See {@link AchievementApiMap}")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="determines whether the sort list is in descending or ascending order (of the achievement)")] = None,
        descending_goal: Annotated[Optional[StrictBool], Field(description="determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start of the index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="the limit for pagination (has a hard limit of 1000)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Searches an Achievement Tier

        Searches a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: the application key
        :type app_key: str
        :param keyword: the keyword used to filter resutls with (this returns results that have the keyword in the title or the description of the achievement tier)
        :type keyword: str
        :param achievement_type: filter results by achievementType (these are exact case sensitive matches)
        :type achievement_type: int
        :param rank_type: filter results by the rankType (these are the exact case sensitive matches)
        :type rank_type: str
        :param sort_field: the field to sort by. See {@link AchievementApiMap}
        :type sort_field: str
        :param descending: determines whether the sort list is in descending or ascending order (of the achievement)
        :type descending: bool
        :param descending_goal: determines whether the results are in descending or ascending order by the tier goal count (after the initial sort on the achievement)
        :type descending_goal: bool
        :param start: The start of the index for pagination
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._api_version_achievement_tier_search_post_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            sort_field=sort_field,
            descending=descending,
            descending_goal=descending_goal,
            start=start,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _api_version_achievement_tier_search_post_serialize(
        self,
        version,
        device_id,
        account_id,
        app_key,
        keyword,
        achievement_type,
        rank_type,
        sort_field,
        descending,
        descending_goal,
        start,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if achievement_type is not None:
            
            _query_params.append(('achievementType', achievement_type))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if descending_goal is not None:
            
            _query_params.append(('descendingGoal', descending_goal))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/tier/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_achievement(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key the achievement is for")],
        title: Annotated[StrictStr, Field(description="the title of the achievement (255 character limit)")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        analytics_tag: Annotated[Optional[StrictStr], Field(description="the analytics tag that will trigger when a user's achievement count gets updated")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="the rank type for updating leader boards")] = None,
        rank_increment: Annotated[Optional[StrictInt], Field(description="determines how much the rank count is incremented")] = None,
        min_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be above or equal to this minimum value")] = None,
        max_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be below or equal to this maximum value")] = None,
        validate: Annotated[Optional[StrictBool], Field(description="determines whether the customId on analytics are used to validate a user's achievement progress.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="achievement is active or inactive")] = None,
        trigger_definition: Annotated[Optional[StrictStr], Field(description="if provided will define what triggers to run after a tier is completed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementResponse:
        """Create Achievement

        Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param app_key: the application key the achievement is for (required)
        :type app_key: str
        :param title: the title of the achievement (255 character limit) (required)
        :type title: str
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param analytics_tag: the analytics tag that will trigger when a user's achievement count gets updated
        :type analytics_tag: str
        :param description: the description of the achievement
        :type description: str
        :param rank_type: the rank type for updating leader boards
        :type rank_type: str
        :param rank_increment: determines how much the rank count is incremented
        :type rank_increment: int
        :param min_increment: restrict scores to be above or equal to this minimum value
        :type min_increment: int
        :param max_increment: restrict scores to be below or equal to this maximum value
        :type max_increment: int
        :param validate: determines whether the customId on analytics are used to validate a user's achievement progress.
        :type validate: bool
        :param active: achievement is active or inactive
        :type active: bool
        :param trigger_definition: if provided will define what triggers to run after a tier is completed
        :type trigger_definition: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_achievement_serialize(
            version=version,
            app_key=app_key,
            title=title,
            device_id=device_id,
            account_id=account_id,
            analytics_tag=analytics_tag,
            description=description,
            rank_type=rank_type,
            rank_increment=rank_increment,
            min_increment=min_increment,
            max_increment=max_increment,
            validate=validate,
            active=active,
            trigger_definition=trigger_definition,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_achievement_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key the achievement is for")],
        title: Annotated[StrictStr, Field(description="the title of the achievement (255 character limit)")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        analytics_tag: Annotated[Optional[StrictStr], Field(description="the analytics tag that will trigger when a user's achievement count gets updated")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="the rank type for updating leader boards")] = None,
        rank_increment: Annotated[Optional[StrictInt], Field(description="determines how much the rank count is incremented")] = None,
        min_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be above or equal to this minimum value")] = None,
        max_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be below or equal to this maximum value")] = None,
        validate: Annotated[Optional[StrictBool], Field(description="determines whether the customId on analytics are used to validate a user's achievement progress.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="achievement is active or inactive")] = None,
        trigger_definition: Annotated[Optional[StrictStr], Field(description="if provided will define what triggers to run after a tier is completed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementResponse]:
        """Create Achievement

        Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param app_key: the application key the achievement is for (required)
        :type app_key: str
        :param title: the title of the achievement (255 character limit) (required)
        :type title: str
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param analytics_tag: the analytics tag that will trigger when a user's achievement count gets updated
        :type analytics_tag: str
        :param description: the description of the achievement
        :type description: str
        :param rank_type: the rank type for updating leader boards
        :type rank_type: str
        :param rank_increment: determines how much the rank count is incremented
        :type rank_increment: int
        :param min_increment: restrict scores to be above or equal to this minimum value
        :type min_increment: int
        :param max_increment: restrict scores to be below or equal to this maximum value
        :type max_increment: int
        :param validate: determines whether the customId on analytics are used to validate a user's achievement progress.
        :type validate: bool
        :param active: achievement is active or inactive
        :type active: bool
        :param trigger_definition: if provided will define what triggers to run after a tier is completed
        :type trigger_definition: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_achievement_serialize(
            version=version,
            app_key=app_key,
            title=title,
            device_id=device_id,
            account_id=account_id,
            analytics_tag=analytics_tag,
            description=description,
            rank_type=rank_type,
            rank_increment=rank_increment,
            min_increment=min_increment,
            max_increment=max_increment,
            validate=validate,
            active=active,
            trigger_definition=trigger_definition,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_achievement_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key the achievement is for")],
        title: Annotated[StrictStr, Field(description="the title of the achievement (255 character limit)")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        analytics_tag: Annotated[Optional[StrictStr], Field(description="the analytics tag that will trigger when a user's achievement count gets updated")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="the rank type for updating leader boards")] = None,
        rank_increment: Annotated[Optional[StrictInt], Field(description="determines how much the rank count is incremented")] = None,
        min_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be above or equal to this minimum value")] = None,
        max_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be below or equal to this maximum value")] = None,
        validate: Annotated[Optional[StrictBool], Field(description="determines whether the customId on analytics are used to validate a user's achievement progress.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="achievement is active or inactive")] = None,
        trigger_definition: Annotated[Optional[StrictStr], Field(description="if provided will define what triggers to run after a tier is completed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Achievement

        Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param app_key: the application key the achievement is for (required)
        :type app_key: str
        :param title: the title of the achievement (255 character limit) (required)
        :type title: str
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param analytics_tag: the analytics tag that will trigger when a user's achievement count gets updated
        :type analytics_tag: str
        :param description: the description of the achievement
        :type description: str
        :param rank_type: the rank type for updating leader boards
        :type rank_type: str
        :param rank_increment: determines how much the rank count is incremented
        :type rank_increment: int
        :param min_increment: restrict scores to be above or equal to this minimum value
        :type min_increment: int
        :param max_increment: restrict scores to be below or equal to this maximum value
        :type max_increment: int
        :param validate: determines whether the customId on analytics are used to validate a user's achievement progress.
        :type validate: bool
        :param active: achievement is active or inactive
        :type active: bool
        :param trigger_definition: if provided will define what triggers to run after a tier is completed
        :type trigger_definition: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_achievement_serialize(
            version=version,
            app_key=app_key,
            title=title,
            device_id=device_id,
            account_id=account_id,
            analytics_tag=analytics_tag,
            description=description,
            rank_type=rank_type,
            rank_increment=rank_increment,
            min_increment=min_increment,
            max_increment=max_increment,
            validate=validate,
            active=active,
            trigger_definition=trigger_definition,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_achievement_serialize(
        self,
        version,
        app_key,
        title,
        device_id,
        account_id,
        analytics_tag,
        description,
        rank_type,
        rank_increment,
        min_increment,
        max_increment,
        validate,
        active,
        trigger_definition,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if analytics_tag is not None:
            
            _query_params.append(('analyticsTag', analytics_tag))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if rank_increment is not None:
            
            _query_params.append(('rankIncrement', rank_increment))
            
        if min_increment is not None:
            
            _query_params.append(('minIncrement', min_increment))
            
        if max_increment is not None:
            
            _query_params.append(('maxIncrement', max_increment))
            
        if validate is not None:
            
            _query_params.append(('validate', validate))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if trigger_definition is not None:
            
            _query_params.append(('triggerDefinition', trigger_definition))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def create_achievement_tier(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="the achievement id for adding a new tier")],
        score_all_instances: Annotated[StrictBool, Field(description="score all instances")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        icon: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="achievement tier icon image file")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="the icon assetId, if icon is provided, icon will overrule")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement tier")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement tier")] = None,
        goal_count: Annotated[Optional[StrictInt], Field(description="the count requirement for completing the achievement tier")] = None,
        mission_id: Annotated[Optional[StrictInt], Field(description="The ID of the mission to associate with the achievement")] = None,
        game_id: Annotated[Optional[StrictInt], Field(description="The ID of the game to associate with the achievement")] = None,
        pack_id: Annotated[Optional[StrictInt], Field(description="The ID of the pack to associate with the achievement")] = None,
        game_level_id: Annotated[Optional[StrictInt], Field(description="The ID of the game level to associate with the achievement")] = None,
        game_object_id: Annotated[Optional[StrictInt], Field(description="The ID of the game object to associate with the achievement")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementTierResponse:
        """Create Achievement Tier

        Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_id: the achievement id for adding a new tier (required)
        :type achievement_id: int
        :param score_all_instances: score all instances (required)
        :type score_all_instances: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param icon: achievement tier icon image file
        :type icon: bytearray
        :param icon_asset_id: the icon assetId, if icon is provided, icon will overrule
        :type icon_asset_id: int
        :param title: the title of the achievement tier
        :type title: str
        :param description: the description of the achievement tier
        :type description: str
        :param goal_count: the count requirement for completing the achievement tier
        :type goal_count: int
        :param mission_id: The ID of the mission to associate with the achievement
        :type mission_id: int
        :param game_id: The ID of the game to associate with the achievement
        :type game_id: int
        :param pack_id: The ID of the pack to associate with the achievement
        :type pack_id: int
        :param game_level_id: The ID of the game level to associate with the achievement
        :type game_level_id: int
        :param game_object_id: The ID of the game object to associate with the achievement
        :type game_object_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_achievement_tier_serialize(
            version=version,
            achievement_id=achievement_id,
            score_all_instances=score_all_instances,
            device_id=device_id,
            account_id=account_id,
            icon=icon,
            icon_asset_id=icon_asset_id,
            title=title,
            description=description,
            goal_count=goal_count,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            game_object_id=game_object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_achievement_tier_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="the achievement id for adding a new tier")],
        score_all_instances: Annotated[StrictBool, Field(description="score all instances")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        icon: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="achievement tier icon image file")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="the icon assetId, if icon is provided, icon will overrule")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement tier")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement tier")] = None,
        goal_count: Annotated[Optional[StrictInt], Field(description="the count requirement for completing the achievement tier")] = None,
        mission_id: Annotated[Optional[StrictInt], Field(description="The ID of the mission to associate with the achievement")] = None,
        game_id: Annotated[Optional[StrictInt], Field(description="The ID of the game to associate with the achievement")] = None,
        pack_id: Annotated[Optional[StrictInt], Field(description="The ID of the pack to associate with the achievement")] = None,
        game_level_id: Annotated[Optional[StrictInt], Field(description="The ID of the game level to associate with the achievement")] = None,
        game_object_id: Annotated[Optional[StrictInt], Field(description="The ID of the game object to associate with the achievement")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementTierResponse]:
        """Create Achievement Tier

        Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_id: the achievement id for adding a new tier (required)
        :type achievement_id: int
        :param score_all_instances: score all instances (required)
        :type score_all_instances: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param icon: achievement tier icon image file
        :type icon: bytearray
        :param icon_asset_id: the icon assetId, if icon is provided, icon will overrule
        :type icon_asset_id: int
        :param title: the title of the achievement tier
        :type title: str
        :param description: the description of the achievement tier
        :type description: str
        :param goal_count: the count requirement for completing the achievement tier
        :type goal_count: int
        :param mission_id: The ID of the mission to associate with the achievement
        :type mission_id: int
        :param game_id: The ID of the game to associate with the achievement
        :type game_id: int
        :param pack_id: The ID of the pack to associate with the achievement
        :type pack_id: int
        :param game_level_id: The ID of the game level to associate with the achievement
        :type game_level_id: int
        :param game_object_id: The ID of the game object to associate with the achievement
        :type game_object_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_achievement_tier_serialize(
            version=version,
            achievement_id=achievement_id,
            score_all_instances=score_all_instances,
            device_id=device_id,
            account_id=account_id,
            icon=icon,
            icon_asset_id=icon_asset_id,
            title=title,
            description=description,
            goal_count=goal_count,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            game_object_id=game_object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_achievement_tier_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="the achievement id for adding a new tier")],
        score_all_instances: Annotated[StrictBool, Field(description="score all instances")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        icon: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="achievement tier icon image file")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="the icon assetId, if icon is provided, icon will overrule")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement tier")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement tier")] = None,
        goal_count: Annotated[Optional[StrictInt], Field(description="the count requirement for completing the achievement tier")] = None,
        mission_id: Annotated[Optional[StrictInt], Field(description="The ID of the mission to associate with the achievement")] = None,
        game_id: Annotated[Optional[StrictInt], Field(description="The ID of the game to associate with the achievement")] = None,
        pack_id: Annotated[Optional[StrictInt], Field(description="The ID of the pack to associate with the achievement")] = None,
        game_level_id: Annotated[Optional[StrictInt], Field(description="The ID of the game level to associate with the achievement")] = None,
        game_object_id: Annotated[Optional[StrictInt], Field(description="The ID of the game object to associate with the achievement")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Achievement Tier

        Create a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_id: the achievement id for adding a new tier (required)
        :type achievement_id: int
        :param score_all_instances: score all instances (required)
        :type score_all_instances: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param icon: achievement tier icon image file
        :type icon: bytearray
        :param icon_asset_id: the icon assetId, if icon is provided, icon will overrule
        :type icon_asset_id: int
        :param title: the title of the achievement tier
        :type title: str
        :param description: the description of the achievement tier
        :type description: str
        :param goal_count: the count requirement for completing the achievement tier
        :type goal_count: int
        :param mission_id: The ID of the mission to associate with the achievement
        :type mission_id: int
        :param game_id: The ID of the game to associate with the achievement
        :type game_id: int
        :param pack_id: The ID of the pack to associate with the achievement
        :type pack_id: int
        :param game_level_id: The ID of the game level to associate with the achievement
        :type game_level_id: int
        :param game_object_id: The ID of the game object to associate with the achievement
        :type game_object_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_achievement_tier_serialize(
            version=version,
            achievement_id=achievement_id,
            score_all_instances=score_all_instances,
            device_id=device_id,
            account_id=account_id,
            icon=icon,
            icon_asset_id=icon_asset_id,
            title=title,
            description=description,
            goal_count=goal_count,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            game_object_id=game_object_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_achievement_tier_serialize(
        self,
        version,
        achievement_id,
        score_all_instances,
        device_id,
        account_id,
        icon,
        icon_asset_id,
        title,
        description,
        goal_count,
        mission_id,
        game_id,
        pack_id,
        game_level_id,
        game_object_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_id is not None:
            
            _query_params.append(('achievementId', achievement_id))
            
        if icon is not None:
            
            _query_params.append(('icon', icon))
            
        if icon_asset_id is not None:
            
            _query_params.append(('iconAssetId', icon_asset_id))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if goal_count is not None:
            
            _query_params.append(('goalCount', goal_count))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if game_id is not None:
            
            _query_params.append(('gameId', game_id))
            
        if pack_id is not None:
            
            _query_params.append(('packId', pack_id))
            
        if game_level_id is not None:
            
            _query_params.append(('gameLevelId', game_level_id))
            
        if game_object_id is not None:
            
            _query_params.append(('gameObjectId', game_object_id))
            
        if score_all_instances is not None:
            
            _query_params.append(('scoreAllInstances', score_all_instances))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/tier/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_achievement(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="The ID of the achievement")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Achievement

        Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.

        :param version: (required)
        :type version: float
        :param achievement_id: The ID of the achievement (required)
        :type achievement_id: int
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_achievement_serialize(
            version=version,
            achievement_id=achievement_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_achievement_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="The ID of the achievement")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Achievement

        Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.

        :param version: (required)
        :type version: float
        :param achievement_id: The ID of the achievement (required)
        :type achievement_id: int
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_achievement_serialize(
            version=version,
            achievement_id=achievement_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_achievement_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="The ID of the achievement")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Achievement

        Deletes an achievement (for developer/retailer use). User must have permissions to the application the achievement was created for.

        :param version: (required)
        :type version: float
        :param achievement_id: The ID of the achievement (required)
        :type achievement_id: int
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_achievement_serialize(
            version=version,
            achievement_id=achievement_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_achievement_serialize(
        self,
        version,
        achievement_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_id is not None:
            
            _query_params.append(('achievementId', achievement_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_achievement_tier(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement id for deletion")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Achievement Tier

        Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.

        :param version: (required)
        :type version: float
        :param achievement_tier_id: the achievement id for deletion (required)
        :type achievement_tier_id: int
        :param account_id: the account id of the user (deviceId or accountId required).
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_achievement_tier_serialize(
            version=version,
            achievement_tier_id=achievement_tier_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_achievement_tier_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement id for deletion")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Achievement Tier

        Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.

        :param version: (required)
        :type version: float
        :param achievement_tier_id: the achievement id for deletion (required)
        :type achievement_tier_id: int
        :param account_id: the account id of the user (deviceId or accountId required).
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_achievement_tier_serialize(
            version=version,
            achievement_tier_id=achievement_tier_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_achievement_tier_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement id for deletion")],
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required).")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Achievement Tier

        Deletes an achievement tier (for developer/retailer use). User must have permissions to the application the achievement was created for.

        :param version: (required)
        :type version: float
        :param achievement_tier_id: the achievement id for deletion (required)
        :type achievement_tier_id: int
        :param account_id: the account id of the user (deviceId or accountId required).
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_achievement_tier_serialize(
            version=version,
            achievement_tier_id=achievement_tier_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_achievement_tier_serialize(
        self,
        version,
        achievement_tier_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_tier_id is not None:
            
            _query_params.append(('achievementTierId', achievement_tier_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/tier/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_achievement(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="The ID of the achievement")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="achievementType")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementTierResponse:
        """Get Achievement

        Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_id: The ID of the achievement (required)
        :type achievement_id: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param achievement_type: achievementType
        :type achievement_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_achievement_serialize(
            version=version,
            achievement_id=achievement_id,
            device_id=device_id,
            account_id=account_id,
            achievement_type=achievement_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_achievement_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="The ID of the achievement")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="achievementType")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementTierResponse]:
        """Get Achievement

        Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_id: The ID of the achievement (required)
        :type achievement_id: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param achievement_type: achievementType
        :type achievement_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_achievement_serialize(
            version=version,
            achievement_id=achievement_id,
            device_id=device_id,
            account_id=account_id,
            achievement_type=achievement_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_achievement_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_id: Annotated[StrictInt, Field(description="The ID of the achievement")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="achievementType")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Achievement

        Get an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_id: The ID of the achievement (required)
        :type achievement_id: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param achievement_type: achievementType
        :type achievement_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_achievement_serialize(
            version=version,
            achievement_id=achievement_id,
            device_id=device_id,
            account_id=account_id,
            achievement_type=achievement_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_achievement_serialize(
        self,
        version,
        achievement_id,
        device_id,
        account_id,
        achievement_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_id is not None:
            
            _query_params.append(('achievementId', achievement_id))
            
        if achievement_type is not None:
            
            _query_params.append(('achievementType', achievement_type))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/achievement/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_achievement_tier(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user (deviceId or accountId required)")],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement tier id that is being retrieved")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementTierResponse:
        """Gets an achievement tier

        Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (deviceId or accountId required) (required)
        :type account_id: int
        :param achievement_tier_id: the achievement tier id that is being retrieved (required)
        :type achievement_tier_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_achievement_tier_serialize(
            version=version,
            account_id=account_id,
            achievement_tier_id=achievement_tier_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_achievement_tier_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user (deviceId or accountId required)")],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement tier id that is being retrieved")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementTierResponse]:
        """Gets an achievement tier

        Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (deviceId or accountId required) (required)
        :type account_id: int
        :param achievement_tier_id: the achievement tier id that is being retrieved (required)
        :type achievement_tier_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_achievement_tier_serialize(
            version=version,
            account_id=account_id,
            achievement_tier_id=achievement_tier_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_achievement_tier_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user (deviceId or accountId required)")],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement tier id that is being retrieved")],
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Gets an achievement tier

        Gets an achievement tier (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (deviceId or accountId required) (required)
        :type account_id: int
        :param achievement_tier_id: the achievement tier id that is being retrieved (required)
        :type achievement_tier_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_achievement_tier_serialize(
            version=version,
            account_id=account_id,
            achievement_tier_id=achievement_tier_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_achievement_tier_serialize(
        self,
        version,
        account_id,
        achievement_tier_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_tier_id is not None:
            
            _query_params.append(('achievementTierId', achievement_tier_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/tier/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_user_achievements(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[StrictBool, Field(description="determines whether to return null fields in the response")],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        include_undiscovered: Annotated[StrictBool, Field(description="determines whether to return achievements that the user has not discovered yet")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_account_email: Annotated[Optional[StrictStr], Field(description="the email of the account to view achievements")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the id of the account to view achievements")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by achievement rankType")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by achievement type")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AchievementProgressResponse]:
        """Get Achievement Progress

        Gets a list of user achievements.

        :param version: (required)
        :type version: float
        :param return_nulls: determines whether to return null fields in the response (required)
        :type return_nulls: bool
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param include_undiscovered: determines whether to return achievements that the user has not discovered yet (required)
        :type include_undiscovered: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_email: the email of the account to view achievements
        :type connection_account_email: str
        :param connection_account_id: the id of the account to view achievements
        :type connection_account_id: int
        :param rank_type: filter results by achievement rankType
        :type rank_type: str
        :param achievement_type: filter results by achievement type
        :type achievement_type: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_achievements_serialize(
            version=version,
            return_nulls=return_nulls,
            app_key=app_key,
            include_undiscovered=include_undiscovered,
            device_id=device_id,
            account_id=account_id,
            connection_account_email=connection_account_email,
            connection_account_id=connection_account_id,
            rank_type=rank_type,
            achievement_type=achievement_type,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementProgressResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_user_achievements_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[StrictBool, Field(description="determines whether to return null fields in the response")],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        include_undiscovered: Annotated[StrictBool, Field(description="determines whether to return achievements that the user has not discovered yet")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_account_email: Annotated[Optional[StrictStr], Field(description="the email of the account to view achievements")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the id of the account to view achievements")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by achievement rankType")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by achievement type")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AchievementProgressResponse]]:
        """Get Achievement Progress

        Gets a list of user achievements.

        :param version: (required)
        :type version: float
        :param return_nulls: determines whether to return null fields in the response (required)
        :type return_nulls: bool
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param include_undiscovered: determines whether to return achievements that the user has not discovered yet (required)
        :type include_undiscovered: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_email: the email of the account to view achievements
        :type connection_account_email: str
        :param connection_account_id: the id of the account to view achievements
        :type connection_account_id: int
        :param rank_type: filter results by achievement rankType
        :type rank_type: str
        :param achievement_type: filter results by achievement type
        :type achievement_type: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_achievements_serialize(
            version=version,
            return_nulls=return_nulls,
            app_key=app_key,
            include_undiscovered=include_undiscovered,
            device_id=device_id,
            account_id=account_id,
            connection_account_email=connection_account_email,
            connection_account_id=connection_account_id,
            rank_type=rank_type,
            achievement_type=achievement_type,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementProgressResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_user_achievements_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        return_nulls: Annotated[StrictBool, Field(description="determines whether to return null fields in the response")],
        app_key: Annotated[StrictStr, Field(description="the application key for filtering results by application")],
        include_undiscovered: Annotated[StrictBool, Field(description="determines whether to return achievements that the user has not discovered yet")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        connection_account_email: Annotated[Optional[StrictStr], Field(description="the email of the account to view achievements")] = None,
        connection_account_id: Annotated[Optional[StrictInt], Field(description="the id of the account to view achievements")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by achievement rankType")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by achievement type")] = None,
        latitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current latitude of the user")] = None,
        longitude: Annotated[Optional[Union[StrictFloat, StrictInt]], Field(description="the current longitude of the user")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Achievement Progress

        Gets a list of user achievements.

        :param version: (required)
        :type version: float
        :param return_nulls: determines whether to return null fields in the response (required)
        :type return_nulls: bool
        :param app_key: the application key for filtering results by application (required)
        :type app_key: str
        :param include_undiscovered: determines whether to return achievements that the user has not discovered yet (required)
        :type include_undiscovered: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param connection_account_email: the email of the account to view achievements
        :type connection_account_email: str
        :param connection_account_id: the id of the account to view achievements
        :type connection_account_id: int
        :param rank_type: filter results by achievement rankType
        :type rank_type: str
        :param achievement_type: filter results by achievement type
        :type achievement_type: str
        :param latitude: the current latitude of the user
        :type latitude: float
        :param longitude: the current longitude of the user
        :type longitude: float
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_user_achievements_serialize(
            version=version,
            return_nulls=return_nulls,
            app_key=app_key,
            include_undiscovered=include_undiscovered,
            device_id=device_id,
            account_id=account_id,
            connection_account_email=connection_account_email,
            connection_account_id=connection_account_id,
            rank_type=rank_type,
            achievement_type=achievement_type,
            latitude=latitude,
            longitude=longitude,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementProgressResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_user_achievements_serialize(
        self,
        version,
        return_nulls,
        app_key,
        include_undiscovered,
        device_id,
        account_id,
        connection_account_email,
        connection_account_id,
        rank_type,
        achievement_type,
        latitude,
        longitude,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if return_nulls is not None:
            
            _query_params.append(('returnNulls', return_nulls))
            
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if connection_account_email is not None:
            
            _query_params.append(('connectionAccountEmail', connection_account_email))
            
        if connection_account_id is not None:
            
            _query_params.append(('connectionAccountId', connection_account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if achievement_type is not None:
            
            _query_params.append(('achievementType', achievement_type))
            
        if include_undiscovered is not None:
            
            _query_params.append(('includeUndiscovered', include_undiscovered))
            
        if latitude is not None:
            
            _query_params.append(('latitude', latitude))
            
        if longitude is not None:
            
            _query_params.append(('longitude', longitude))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/achievement/progress/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_achievement_tags(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[Optional[StrictStr], Field(description="filter results by application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """List Achievement Tags

        List achievement tags by application

        :param version: (required)
        :type version: float
        :param app_key: filter results by application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_achievement_tags_serialize(
            version=version,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_achievement_tags_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[Optional[StrictStr], Field(description="filter results by application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """List Achievement Tags

        List achievement tags by application

        :param version: (required)
        :type version: float
        :param app_key: filter results by application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_achievement_tags_serialize(
            version=version,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_achievement_tags_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[Optional[StrictStr], Field(description="filter results by application key")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Achievement Tags

        List achievement tags by application

        :param version: (required)
        :type version: float
        :param app_key: filter results by application key
        :type app_key: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_achievement_tags_serialize(
            version=version,
            app_key=app_key,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_achievement_tags_serialize(
        self,
        version,
        app_key,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/achievement/tag/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def list_achievements(
        self,
        version: Union[StrictFloat, StrictInt],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AchievementApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (has a hard limit of 1000)")],
        active_only: Annotated[StrictBool, Field(description="Filter results to only return active achievements")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by the achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are exact case sensitive matches)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AchievementShortResponse]:
        """List Achievements

        List achievements by billable.

        :param version: (required)
        :type version: float
        :param sort_field: the field to sort by. See AchievementApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000) (required)
        :type limit: int
        :param active_only: Filter results to only return active achievements (required)
        :type active_only: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: the application key
        :type app_key: str
        :param keyword: the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        :type keyword: str
        :param achievement_type: filter results by the achievementType (these are exact case sensitive matches)
        :type achievement_type: str
        :param rank_type: filter results by the rankType (these are exact case sensitive matches)
        :type rank_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_achievements_serialize(
            version=version,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def list_achievements_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AchievementApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (has a hard limit of 1000)")],
        active_only: Annotated[StrictBool, Field(description="Filter results to only return active achievements")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by the achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are exact case sensitive matches)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AchievementShortResponse]]:
        """List Achievements

        List achievements by billable.

        :param version: (required)
        :type version: float
        :param sort_field: the field to sort by. See AchievementApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000) (required)
        :type limit: int
        :param active_only: Filter results to only return active achievements (required)
        :type active_only: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: the application key
        :type app_key: str
        :param keyword: the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        :type keyword: str
        :param achievement_type: filter results by the achievementType (these are exact case sensitive matches)
        :type achievement_type: str
        :param rank_type: filter results by the rankType (these are exact case sensitive matches)
        :type rank_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_achievements_serialize(
            version=version,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def list_achievements_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AchievementApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (has a hard limit of 1000)")],
        active_only: Annotated[StrictBool, Field(description="Filter results to only return active achievements")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        app_key: Annotated[Optional[StrictStr], Field(description="the application key")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by the achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are exact case sensitive matches)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """List Achievements

        List achievements by billable.

        :param version: (required)
        :type version: float
        :param sort_field: the field to sort by. See AchievementApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000) (required)
        :type limit: int
        :param active_only: Filter results to only return active achievements (required)
        :type active_only: bool
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param app_key: the application key
        :type app_key: str
        :param keyword: the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        :type keyword: str
        :param achievement_type: filter results by the achievementType (these are exact case sensitive matches)
        :type achievement_type: str
        :param rank_type: filter results by the rankType (these are exact case sensitive matches)
        :type rank_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._list_achievements_serialize(
            version=version,
            sort_field=sort_field,
            descending=descending,
            start=start,
            limit=limit,
            active_only=active_only,
            device_id=device_id,
            account_id=account_id,
            app_key=app_key,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _list_achievements_serialize(
        self,
        version,
        sort_field,
        descending,
        start,
        limit,
        active_only,
        device_id,
        account_id,
        app_key,
        keyword,
        achievement_type,
        rank_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if achievement_type is not None:
            
            _query_params.append(('achievementType', achievement_type))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/achievement/list',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_achievements(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AchievementApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        include_tiers: Annotated[StrictBool, Field(description="return tiers, only applicable for version >3.18")],
        include_inactive_tiers: Annotated[StrictBool, Field(description="return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (has a hard limit of 1000)")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by the achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are exact case sensitive matches)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[AchievementShortResponse]:
        """Search Achievements

        Searches achievements by application for consumers.

        :param version: (required)
        :type version: float
        :param app_key: the application key (required)
        :type app_key: str
        :param sort_field: the field to sort by. See AchievementApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param include_tiers: return tiers, only applicable for version >3.18 (required)
        :type include_tiers: bool
        :param include_inactive_tiers: return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18 (required)
        :type include_inactive_tiers: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000) (required)
        :type limit: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        :type keyword: str
        :param achievement_type: filter results by the achievementType (these are exact case sensitive matches)
        :type achievement_type: str
        :param rank_type: filter results by the rankType (these are exact case sensitive matches)
        :type rank_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_achievements_serialize(
            version=version,
            app_key=app_key,
            sort_field=sort_field,
            descending=descending,
            include_tiers=include_tiers,
            include_inactive_tiers=include_inactive_tiers,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_achievements_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AchievementApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        include_tiers: Annotated[StrictBool, Field(description="return tiers, only applicable for version >3.18")],
        include_inactive_tiers: Annotated[StrictBool, Field(description="return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (has a hard limit of 1000)")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by the achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are exact case sensitive matches)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[AchievementShortResponse]]:
        """Search Achievements

        Searches achievements by application for consumers.

        :param version: (required)
        :type version: float
        :param app_key: the application key (required)
        :type app_key: str
        :param sort_field: the field to sort by. See AchievementApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param include_tiers: return tiers, only applicable for version >3.18 (required)
        :type include_tiers: bool
        :param include_inactive_tiers: return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18 (required)
        :type include_inactive_tiers: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000) (required)
        :type limit: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        :type keyword: str
        :param achievement_type: filter results by the achievementType (these are exact case sensitive matches)
        :type achievement_type: str
        :param rank_type: filter results by the rankType (these are exact case sensitive matches)
        :type rank_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_achievements_serialize(
            version=version,
            app_key=app_key,
            sort_field=sort_field,
            descending=descending,
            include_tiers=include_tiers,
            include_inactive_tiers=include_inactive_tiers,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_achievements_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        app_key: Annotated[StrictStr, Field(description="the application key")],
        sort_field: Annotated[StrictStr, Field(description="the field to sort by. See AchievementApiMap")],
        descending: Annotated[StrictBool, Field(description="determines whether the sorted list is in descending or ascending order")],
        include_tiers: Annotated[StrictBool, Field(description="return tiers, only applicable for version >3.18")],
        include_inactive_tiers: Annotated[StrictBool, Field(description="return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18")],
        start: Annotated[StrictInt, Field(description="the start index for pagination")],
        limit: Annotated[StrictInt, Field(description="the limit for pagination (has a hard limit of 1000)")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)")] = None,
        achievement_type: Annotated[Optional[StrictStr], Field(description="filter results by the achievementType (these are exact case sensitive matches)")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="filter results by the rankType (these are exact case sensitive matches)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Achievements

        Searches achievements by application for consumers.

        :param version: (required)
        :type version: float
        :param app_key: the application key (required)
        :type app_key: str
        :param sort_field: the field to sort by. See AchievementApiMap (required)
        :type sort_field: str
        :param descending: determines whether the sorted list is in descending or ascending order (required)
        :type descending: bool
        :param include_tiers: return tiers, only applicable for version >3.18 (required)
        :type include_tiers: bool
        :param include_inactive_tiers: return inactive tiers, only applicable when includeTiers is true, only applicable for version >3.18 (required)
        :type include_inactive_tiers: bool
        :param start: the start index for pagination (required)
        :type start: int
        :param limit: the limit for pagination (has a hard limit of 1000) (required)
        :type limit: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param keyword: the keyword used to filter results with (this returns results that have the keyword in the title or description of the achievement)
        :type keyword: str
        :param achievement_type: filter results by the achievementType (these are exact case sensitive matches)
        :type achievement_type: str
        :param rank_type: filter results by the rankType (these are exact case sensitive matches)
        :type rank_type: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_achievements_serialize(
            version=version,
            app_key=app_key,
            sort_field=sort_field,
            descending=descending,
            include_tiers=include_tiers,
            include_inactive_tiers=include_inactive_tiers,
            start=start,
            limit=limit,
            device_id=device_id,
            account_id=account_id,
            keyword=keyword,
            achievement_type=achievement_type,
            rank_type=rank_type,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[AchievementShortResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_achievements_serialize(
        self,
        version,
        app_key,
        sort_field,
        descending,
        include_tiers,
        include_inactive_tiers,
        start,
        limit,
        device_id,
        account_id,
        keyword,
        achievement_type,
        rank_type,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if achievement_type is not None:
            
            _query_params.append(('achievementType', achievement_type))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if include_tiers is not None:
            
            _query_params.append(('includeTiers', include_tiers))
            
        if include_inactive_tiers is not None:
            
            _query_params.append(('includeInactiveTiers', include_inactive_tiers))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/{version}/achievement/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_achievement(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        achievement_id: Annotated[Optional[StrictInt], Field(description="the achievement ID for updating an existing achievement")] = None,
        analytics_tag: Annotated[Optional[StrictStr], Field(description="the analytics tag that will trigger when a user's achievement count gets updated")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement (255 character limit)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="the rank type for updating leader boards")] = None,
        rank_increment: Annotated[Optional[StrictInt], Field(description="determines how much the rank count is incremented")] = None,
        min_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be above or equal to this minimum value")] = None,
        null_min_increment: Annotated[Optional[StrictBool], Field(description="enable to ignore usage of minIncrement")] = None,
        max_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be below or equal to this maximum value")] = None,
        null_max_increment: Annotated[Optional[StrictBool], Field(description="enable to ignore usage of maxIncrement")] = None,
        validate: Annotated[Optional[StrictBool], Field(description="determines whether the customId on analytics are used to validate a user's achievement progress.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="if it's active or inactive")] = None,
        trigger_definition: Annotated[Optional[StrictStr], Field(description="if provided will define what triggers to run after a tier is completed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementResponse:
        """Update Achievement

        Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param achievement_id: the achievement ID for updating an existing achievement
        :type achievement_id: int
        :param analytics_tag: the analytics tag that will trigger when a user's achievement count gets updated
        :type analytics_tag: str
        :param title: the title of the achievement (255 character limit)
        :type title: str
        :param description: the description of the achievement
        :type description: str
        :param rank_type: the rank type for updating leader boards
        :type rank_type: str
        :param rank_increment: determines how much the rank count is incremented
        :type rank_increment: int
        :param min_increment: restrict scores to be above or equal to this minimum value
        :type min_increment: int
        :param null_min_increment: enable to ignore usage of minIncrement
        :type null_min_increment: bool
        :param max_increment: restrict scores to be below or equal to this maximum value
        :type max_increment: int
        :param null_max_increment: enable to ignore usage of maxIncrement
        :type null_max_increment: bool
        :param validate: determines whether the customId on analytics are used to validate a user's achievement progress.
        :type validate: bool
        :param active: if it's active or inactive
        :type active: bool
        :param trigger_definition: if provided will define what triggers to run after a tier is completed
        :type trigger_definition: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_achievement_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            achievement_id=achievement_id,
            analytics_tag=analytics_tag,
            title=title,
            description=description,
            rank_type=rank_type,
            rank_increment=rank_increment,
            min_increment=min_increment,
            null_min_increment=null_min_increment,
            max_increment=max_increment,
            null_max_increment=null_max_increment,
            validate=validate,
            active=active,
            trigger_definition=trigger_definition,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_achievement_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        achievement_id: Annotated[Optional[StrictInt], Field(description="the achievement ID for updating an existing achievement")] = None,
        analytics_tag: Annotated[Optional[StrictStr], Field(description="the analytics tag that will trigger when a user's achievement count gets updated")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement (255 character limit)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="the rank type for updating leader boards")] = None,
        rank_increment: Annotated[Optional[StrictInt], Field(description="determines how much the rank count is incremented")] = None,
        min_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be above or equal to this minimum value")] = None,
        null_min_increment: Annotated[Optional[StrictBool], Field(description="enable to ignore usage of minIncrement")] = None,
        max_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be below or equal to this maximum value")] = None,
        null_max_increment: Annotated[Optional[StrictBool], Field(description="enable to ignore usage of maxIncrement")] = None,
        validate: Annotated[Optional[StrictBool], Field(description="determines whether the customId on analytics are used to validate a user's achievement progress.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="if it's active or inactive")] = None,
        trigger_definition: Annotated[Optional[StrictStr], Field(description="if provided will define what triggers to run after a tier is completed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementResponse]:
        """Update Achievement

        Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param achievement_id: the achievement ID for updating an existing achievement
        :type achievement_id: int
        :param analytics_tag: the analytics tag that will trigger when a user's achievement count gets updated
        :type analytics_tag: str
        :param title: the title of the achievement (255 character limit)
        :type title: str
        :param description: the description of the achievement
        :type description: str
        :param rank_type: the rank type for updating leader boards
        :type rank_type: str
        :param rank_increment: determines how much the rank count is incremented
        :type rank_increment: int
        :param min_increment: restrict scores to be above or equal to this minimum value
        :type min_increment: int
        :param null_min_increment: enable to ignore usage of minIncrement
        :type null_min_increment: bool
        :param max_increment: restrict scores to be below or equal to this maximum value
        :type max_increment: int
        :param null_max_increment: enable to ignore usage of maxIncrement
        :type null_max_increment: bool
        :param validate: determines whether the customId on analytics are used to validate a user's achievement progress.
        :type validate: bool
        :param active: if it's active or inactive
        :type active: bool
        :param trigger_definition: if provided will define what triggers to run after a tier is completed
        :type trigger_definition: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_achievement_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            achievement_id=achievement_id,
            analytics_tag=analytics_tag,
            title=title,
            description=description,
            rank_type=rank_type,
            rank_increment=rank_increment,
            min_increment=min_increment,
            null_min_increment=null_min_increment,
            max_increment=max_increment,
            null_max_increment=null_max_increment,
            validate=validate,
            active=active,
            trigger_definition=trigger_definition,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_achievement_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        achievement_id: Annotated[Optional[StrictInt], Field(description="the achievement ID for updating an existing achievement")] = None,
        analytics_tag: Annotated[Optional[StrictStr], Field(description="the analytics tag that will trigger when a user's achievement count gets updated")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement (255 character limit)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement")] = None,
        rank_type: Annotated[Optional[StrictStr], Field(description="the rank type for updating leader boards")] = None,
        rank_increment: Annotated[Optional[StrictInt], Field(description="determines how much the rank count is incremented")] = None,
        min_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be above or equal to this minimum value")] = None,
        null_min_increment: Annotated[Optional[StrictBool], Field(description="enable to ignore usage of minIncrement")] = None,
        max_increment: Annotated[Optional[StrictInt], Field(description="restrict scores to be below or equal to this maximum value")] = None,
        null_max_increment: Annotated[Optional[StrictBool], Field(description="enable to ignore usage of maxIncrement")] = None,
        validate: Annotated[Optional[StrictBool], Field(description="determines whether the customId on analytics are used to validate a user's achievement progress.")] = None,
        active: Annotated[Optional[StrictBool], Field(description="if it's active or inactive")] = None,
        trigger_definition: Annotated[Optional[StrictStr], Field(description="if provided will define what triggers to run after a tier is completed")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Achievement

        Updates an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param achievement_id: the achievement ID for updating an existing achievement
        :type achievement_id: int
        :param analytics_tag: the analytics tag that will trigger when a user's achievement count gets updated
        :type analytics_tag: str
        :param title: the title of the achievement (255 character limit)
        :type title: str
        :param description: the description of the achievement
        :type description: str
        :param rank_type: the rank type for updating leader boards
        :type rank_type: str
        :param rank_increment: determines how much the rank count is incremented
        :type rank_increment: int
        :param min_increment: restrict scores to be above or equal to this minimum value
        :type min_increment: int
        :param null_min_increment: enable to ignore usage of minIncrement
        :type null_min_increment: bool
        :param max_increment: restrict scores to be below or equal to this maximum value
        :type max_increment: int
        :param null_max_increment: enable to ignore usage of maxIncrement
        :type null_max_increment: bool
        :param validate: determines whether the customId on analytics are used to validate a user's achievement progress.
        :type validate: bool
        :param active: if it's active or inactive
        :type active: bool
        :param trigger_definition: if provided will define what triggers to run after a tier is completed
        :type trigger_definition: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_achievement_serialize(
            version=version,
            device_id=device_id,
            account_id=account_id,
            achievement_id=achievement_id,
            analytics_tag=analytics_tag,
            title=title,
            description=description,
            rank_type=rank_type,
            rank_increment=rank_increment,
            min_increment=min_increment,
            null_min_increment=null_min_increment,
            max_increment=max_increment,
            null_max_increment=null_max_increment,
            validate=validate,
            active=active,
            trigger_definition=trigger_definition,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_achievement_serialize(
        self,
        version,
        device_id,
        account_id,
        achievement_id,
        analytics_tag,
        title,
        description,
        rank_type,
        rank_increment,
        min_increment,
        null_min_increment,
        max_increment,
        null_max_increment,
        validate,
        active,
        trigger_definition,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_id is not None:
            
            _query_params.append(('achievementId', achievement_id))
            
        if analytics_tag is not None:
            
            _query_params.append(('analyticsTag', analytics_tag))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if rank_type is not None:
            
            _query_params.append(('rankType', rank_type))
            
        if rank_increment is not None:
            
            _query_params.append(('rankIncrement', rank_increment))
            
        if min_increment is not None:
            
            _query_params.append(('minIncrement', min_increment))
            
        if null_min_increment is not None:
            
            _query_params.append(('nullMinIncrement', null_min_increment))
            
        if max_increment is not None:
            
            _query_params.append(('maxIncrement', max_increment))
            
        if null_max_increment is not None:
            
            _query_params.append(('nullMaxIncrement', null_max_increment))
            
        if validate is not None:
            
            _query_params.append(('validate', validate))
            
        if active is not None:
            
            _query_params.append(('active', active))
            
        if trigger_definition is not None:
            
            _query_params.append(('triggerDefinition', trigger_definition))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_achievement_tier(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement tier id for updating")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        icon: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="achievement tier icon image file")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="the icon assetId, if icon is provided, icon will overrule")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement tier")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement tier")] = None,
        goal_count: Annotated[Optional[StrictInt], Field(description="the count requirement for completing the achievement tier")] = None,
        mission_id: Annotated[Optional[StrictInt], Field(description="The ID of the mission to associate with the achievement")] = None,
        game_id: Annotated[Optional[StrictInt], Field(description="The ID of the game to associate with the achievement")] = None,
        pack_id: Annotated[Optional[StrictInt], Field(description="The ID of the pack to associate with the achievement")] = None,
        game_level_id: Annotated[Optional[StrictInt], Field(description="The ID of the game level to associate with the achievement")] = None,
        game_object_id: Annotated[Optional[StrictInt], Field(description="The ID of the game object to associate with the achievement")] = None,
        score_all_instances: Annotated[Optional[StrictBool], Field(description="score all instances")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> AchievementTierResponse:
        """Update Achievement Tier

        Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_tier_id: the achievement tier id for updating (required)
        :type achievement_tier_id: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param icon: achievement tier icon image file
        :type icon: bytearray
        :param icon_asset_id: the icon assetId, if icon is provided, icon will overrule
        :type icon_asset_id: int
        :param title: the title of the achievement tier
        :type title: str
        :param description: the description of the achievement tier
        :type description: str
        :param goal_count: the count requirement for completing the achievement tier
        :type goal_count: int
        :param mission_id: The ID of the mission to associate with the achievement
        :type mission_id: int
        :param game_id: The ID of the game to associate with the achievement
        :type game_id: int
        :param pack_id: The ID of the pack to associate with the achievement
        :type pack_id: int
        :param game_level_id: The ID of the game level to associate with the achievement
        :type game_level_id: int
        :param game_object_id: The ID of the game object to associate with the achievement
        :type game_object_id: int
        :param score_all_instances: score all instances
        :type score_all_instances: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_achievement_tier_serialize(
            version=version,
            achievement_tier_id=achievement_tier_id,
            device_id=device_id,
            account_id=account_id,
            icon=icon,
            icon_asset_id=icon_asset_id,
            title=title,
            description=description,
            goal_count=goal_count,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            game_object_id=game_object_id,
            score_all_instances=score_all_instances,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_achievement_tier_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement tier id for updating")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        icon: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="achievement tier icon image file")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="the icon assetId, if icon is provided, icon will overrule")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement tier")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement tier")] = None,
        goal_count: Annotated[Optional[StrictInt], Field(description="the count requirement for completing the achievement tier")] = None,
        mission_id: Annotated[Optional[StrictInt], Field(description="The ID of the mission to associate with the achievement")] = None,
        game_id: Annotated[Optional[StrictInt], Field(description="The ID of the game to associate with the achievement")] = None,
        pack_id: Annotated[Optional[StrictInt], Field(description="The ID of the pack to associate with the achievement")] = None,
        game_level_id: Annotated[Optional[StrictInt], Field(description="The ID of the game level to associate with the achievement")] = None,
        game_object_id: Annotated[Optional[StrictInt], Field(description="The ID of the game object to associate with the achievement")] = None,
        score_all_instances: Annotated[Optional[StrictBool], Field(description="score all instances")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[AchievementTierResponse]:
        """Update Achievement Tier

        Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_tier_id: the achievement tier id for updating (required)
        :type achievement_tier_id: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param icon: achievement tier icon image file
        :type icon: bytearray
        :param icon_asset_id: the icon assetId, if icon is provided, icon will overrule
        :type icon_asset_id: int
        :param title: the title of the achievement tier
        :type title: str
        :param description: the description of the achievement tier
        :type description: str
        :param goal_count: the count requirement for completing the achievement tier
        :type goal_count: int
        :param mission_id: The ID of the mission to associate with the achievement
        :type mission_id: int
        :param game_id: The ID of the game to associate with the achievement
        :type game_id: int
        :param pack_id: The ID of the pack to associate with the achievement
        :type pack_id: int
        :param game_level_id: The ID of the game level to associate with the achievement
        :type game_level_id: int
        :param game_object_id: The ID of the game object to associate with the achievement
        :type game_object_id: int
        :param score_all_instances: score all instances
        :type score_all_instances: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_achievement_tier_serialize(
            version=version,
            achievement_tier_id=achievement_tier_id,
            device_id=device_id,
            account_id=account_id,
            icon=icon,
            icon_asset_id=icon_asset_id,
            title=title,
            description=description,
            goal_count=goal_count,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            game_object_id=game_object_id,
            score_all_instances=score_all_instances,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_achievement_tier_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        achievement_tier_id: Annotated[StrictInt, Field(description="the achievement tier id for updating")],
        device_id: Annotated[Optional[StrictStr], Field(description="a unique id given by the device (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="the account id of the user (deviceId or accountId required)")] = None,
        icon: Annotated[Optional[Union[StrictBytes, StrictStr, Tuple[StrictStr, StrictBytes]]], Field(description="achievement tier icon image file")] = None,
        icon_asset_id: Annotated[Optional[StrictInt], Field(description="the icon assetId, if icon is provided, icon will overrule")] = None,
        title: Annotated[Optional[StrictStr], Field(description="the title of the achievement tier")] = None,
        description: Annotated[Optional[StrictStr], Field(description="the description of the achievement tier")] = None,
        goal_count: Annotated[Optional[StrictInt], Field(description="the count requirement for completing the achievement tier")] = None,
        mission_id: Annotated[Optional[StrictInt], Field(description="The ID of the mission to associate with the achievement")] = None,
        game_id: Annotated[Optional[StrictInt], Field(description="The ID of the game to associate with the achievement")] = None,
        pack_id: Annotated[Optional[StrictInt], Field(description="The ID of the pack to associate with the achievement")] = None,
        game_level_id: Annotated[Optional[StrictInt], Field(description="The ID of the game level to associate with the achievement")] = None,
        game_object_id: Annotated[Optional[StrictInt], Field(description="The ID of the game object to associate with the achievement")] = None,
        score_all_instances: Annotated[Optional[StrictBool], Field(description="score all instances")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Achievement Tier

        Updates a tier of an achievement (for developer/retailer use). User must have permissions to the application the achievement is created for.

        :param version: (required)
        :type version: float
        :param achievement_tier_id: the achievement tier id for updating (required)
        :type achievement_tier_id: int
        :param device_id: a unique id given by the device (deviceId or accountId required)
        :type device_id: str
        :param account_id: the account id of the user (deviceId or accountId required)
        :type account_id: int
        :param icon: achievement tier icon image file
        :type icon: bytearray
        :param icon_asset_id: the icon assetId, if icon is provided, icon will overrule
        :type icon_asset_id: int
        :param title: the title of the achievement tier
        :type title: str
        :param description: the description of the achievement tier
        :type description: str
        :param goal_count: the count requirement for completing the achievement tier
        :type goal_count: int
        :param mission_id: The ID of the mission to associate with the achievement
        :type mission_id: int
        :param game_id: The ID of the game to associate with the achievement
        :type game_id: int
        :param pack_id: The ID of the pack to associate with the achievement
        :type pack_id: int
        :param game_level_id: The ID of the game level to associate with the achievement
        :type game_level_id: int
        :param game_object_id: The ID of the game object to associate with the achievement
        :type game_object_id: int
        :param score_all_instances: score all instances
        :type score_all_instances: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_achievement_tier_serialize(
            version=version,
            achievement_tier_id=achievement_tier_id,
            device_id=device_id,
            account_id=account_id,
            icon=icon,
            icon_asset_id=icon_asset_id,
            title=title,
            description=description,
            goal_count=goal_count,
            mission_id=mission_id,
            game_id=game_id,
            pack_id=pack_id,
            game_level_id=game_level_id,
            game_object_id=game_object_id,
            score_all_instances=score_all_instances,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "AchievementTierResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_achievement_tier_serialize(
        self,
        version,
        achievement_tier_id,
        device_id,
        account_id,
        icon,
        icon_asset_id,
        title,
        description,
        goal_count,
        mission_id,
        game_id,
        pack_id,
        game_level_id,
        game_object_id,
        score_all_instances,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_tier_id is not None:
            
            _query_params.append(('achievementTierId', achievement_tier_id))
            
        if icon is not None:
            
            _query_params.append(('icon', icon))
            
        if icon_asset_id is not None:
            
            _query_params.append(('iconAssetId', icon_asset_id))
            
        if title is not None:
            
            _query_params.append(('title', title))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if goal_count is not None:
            
            _query_params.append(('goalCount', goal_count))
            
        if mission_id is not None:
            
            _query_params.append(('missionId', mission_id))
            
        if game_id is not None:
            
            _query_params.append(('gameId', game_id))
            
        if pack_id is not None:
            
            _query_params.append(('packId', pack_id))
            
        if game_level_id is not None:
            
            _query_params.append(('gameLevelId', game_level_id))
            
        if game_object_id is not None:
            
            _query_params.append(('gameObjectId', game_object_id))
            
        if score_all_instances is not None:
            
            _query_params.append(('scoreAllInstances', score_all_instances))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/tier/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_user_achievement(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        achievement_id: Annotated[Optional[StrictInt], Field(description="the achievement id (achievementId or tag required)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="the analytic tag to identify an achievement (achievementId or tag required)")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="a custom identifier used for validation")] = None,
        increment: Annotated[Optional[StrictInt], Field(description="the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="a custom start date that the client can set (not yet used in server logic)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="a custom end date that the client can set (not yet used in server logic)")] = None,
        return_progress: Annotated[Optional[StrictBool], Field(description="determines whether to return the achievement progress response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Update Achievement Progress

        Update user achievement progress.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param achievement_id: the achievement id (achievementId or tag required)
        :type achievement_id: int
        :param tag: the analytic tag to identify an achievement (achievementId or tag required)
        :type tag: str
        :param custom_id: a custom identifier used for validation
        :type custom_id: int
        :param increment: the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
        :type increment: int
        :param start_date: a custom start date that the client can set (not yet used in server logic)
        :type start_date: int
        :param end_date: a custom end date that the client can set (not yet used in server logic)
        :type end_date: int
        :param return_progress: determines whether to return the achievement progress response
        :type return_progress: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_achievement_serialize(
            version=version,
            account_id=account_id,
            achievement_id=achievement_id,
            tag=tag,
            custom_id=custom_id,
            increment=increment,
            start_date=start_date,
            end_date=end_date,
            return_progress=return_progress,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_user_achievement_with_http_info(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        achievement_id: Annotated[Optional[StrictInt], Field(description="the achievement id (achievementId or tag required)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="the analytic tag to identify an achievement (achievementId or tag required)")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="a custom identifier used for validation")] = None,
        increment: Annotated[Optional[StrictInt], Field(description="the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="a custom start date that the client can set (not yet used in server logic)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="a custom end date that the client can set (not yet used in server logic)")] = None,
        return_progress: Annotated[Optional[StrictBool], Field(description="determines whether to return the achievement progress response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Update Achievement Progress

        Update user achievement progress.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param achievement_id: the achievement id (achievementId or tag required)
        :type achievement_id: int
        :param tag: the analytic tag to identify an achievement (achievementId or tag required)
        :type tag: str
        :param custom_id: a custom identifier used for validation
        :type custom_id: int
        :param increment: the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
        :type increment: int
        :param start_date: a custom start date that the client can set (not yet used in server logic)
        :type start_date: int
        :param end_date: a custom end date that the client can set (not yet used in server logic)
        :type end_date: int
        :param return_progress: determines whether to return the achievement progress response
        :type return_progress: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_achievement_serialize(
            version=version,
            account_id=account_id,
            achievement_id=achievement_id,
            tag=tag,
            custom_id=custom_id,
            increment=increment,
            start_date=start_date,
            end_date=end_date,
            return_progress=return_progress,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_user_achievement_without_preload_content(
        self,
        version: Union[StrictFloat, StrictInt],
        account_id: Annotated[StrictInt, Field(description="the account id of the user")],
        achievement_id: Annotated[Optional[StrictInt], Field(description="the achievement id (achievementId or tag required)")] = None,
        tag: Annotated[Optional[StrictStr], Field(description="the analytic tag to identify an achievement (achievementId or tag required)")] = None,
        custom_id: Annotated[Optional[StrictInt], Field(description="a custom identifier used for validation")] = None,
        increment: Annotated[Optional[StrictInt], Field(description="the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)")] = None,
        start_date: Annotated[Optional[StrictInt], Field(description="a custom start date that the client can set (not yet used in server logic)")] = None,
        end_date: Annotated[Optional[StrictInt], Field(description="a custom end date that the client can set (not yet used in server logic)")] = None,
        return_progress: Annotated[Optional[StrictBool], Field(description="determines whether to return the achievement progress response")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Achievement Progress

        Update user achievement progress.

        :param version: (required)
        :type version: float
        :param account_id: the account id of the user (required)
        :type account_id: int
        :param achievement_id: the achievement id (achievementId or tag required)
        :type achievement_id: int
        :param tag: the analytic tag to identify an achievement (achievementId or tag required)
        :type tag: str
        :param custom_id: a custom identifier used for validation
        :type custom_id: int
        :param increment: the amount to increment an achievement progress by (if no increment is sent in, the server defaults to using the achievement's rankIncrement value)
        :type increment: int
        :param start_date: a custom start date that the client can set (not yet used in server logic)
        :type start_date: int
        :param end_date: a custom end date that the client can set (not yet used in server logic)
        :type end_date: int
        :param return_progress: determines whether to return the achievement progress response
        :type return_progress: bool
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_user_achievement_serialize(
            version=version,
            account_id=account_id,
            achievement_id=achievement_id,
            tag=tag,
            custom_id=custom_id,
            increment=increment,
            start_date=start_date,
            end_date=end_date,
            return_progress=return_progress,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_user_achievement_serialize(
        self,
        version,
        account_id,
        achievement_id,
        tag,
        custom_id,
        increment,
        start_date,
        end_date,
        return_progress,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if version is not None:
            _path_params['version'] = version
        # process the query parameters
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if achievement_id is not None:
            
            _query_params.append(('achievementId', achievement_id))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if custom_id is not None:
            
            _query_params.append(('customId', custom_id))
            
        if increment is not None:
            
            _query_params.append(('increment', increment))
            
        if start_date is not None:
            
            _query_params.append(('startDate', start_date))
            
        if end_date is not None:
            
            _query_params.append(('endDate', end_date))
            
        if return_progress is not None:
            
            _query_params.append(('returnProgress', return_progress))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/api/{version}/achievement/progress/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


