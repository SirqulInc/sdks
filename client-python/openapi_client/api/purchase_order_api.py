# coding: utf-8

"""
    Sirqul IoT Platform

    Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>

    The version of the OpenAPI document: 3.16
    Contact: info@sirqul.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import List, Optional
from typing_extensions import Annotated
from openapi_client.models.order_response import OrderResponse
from openapi_client.models.sirqul_response import SirqulResponse

from openapi_client.api_client import ApiClient, RequestSerialized
from openapi_client.api_response import ApiResponse
from openapi_client.rest import RESTResponseType


class PurchaseOrderApi:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def create_order(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        remote_ref_type: Annotated[Optional[StrictStr], Field(description="Remote Reference type")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The Promo Code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderResponse:
        """Create Order

        Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ```  (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_order_id: Store identifier from external system
        :type external_order_id: str
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param remote_ref_type: Remote Reference type
        :type remote_ref_type: str
        :param external_date: External Date
        :type external_date: int
        :param promo_code: The Promo Code
        :type promo_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_serialize(
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_order_id=external_order_id,
            external_payment_id=external_payment_id,
            remote_ref_type=remote_ref_type,
            external_date=external_date,
            promo_code=promo_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def create_order_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        remote_ref_type: Annotated[Optional[StrictStr], Field(description="Remote Reference type")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The Promo Code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderResponse]:
        """Create Order

        Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ```  (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_order_id: Store identifier from external system
        :type external_order_id: str
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param remote_ref_type: Remote Reference type
        :type remote_ref_type: str
        :param external_date: External Date
        :type external_date: int
        :param promo_code: The Promo Code
        :type promo_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_serialize(
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_order_id=external_order_id,
            external_payment_id=external_payment_id,
            remote_ref_type=remote_ref_type,
            external_date=external_date,
            promo_code=promo_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def create_order_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        remote_ref_type: Annotated[Optional[StrictStr], Field(description="Remote Reference type")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The Promo Code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Create Order

        Creates a new purchase with some number of items associated with it. The purchase is added to the order that was created

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ```  (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_order_id: Store identifier from external system
        :type external_order_id: str
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param remote_ref_type: Remote Reference type
        :type remote_ref_type: str
        :param external_date: External Date
        :type external_date: int
        :param promo_code: The Promo Code
        :type promo_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._create_order_serialize(
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_order_id=external_order_id,
            external_payment_id=external_payment_id,
            remote_ref_type=remote_ref_type,
            external_date=external_date,
            promo_code=promo_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _create_order_serialize(
        self,
        app_key,
        cart,
        device_id,
        account_id,
        description,
        currency_type,
        payment_method_id,
        external_order_id,
        external_payment_id,
        remote_ref_type,
        external_date,
        promo_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if currency_type is not None:
            
            _query_params.append(('currencyType', currency_type))
            
        if cart is not None:
            
            _query_params.append(('cart', cart))
            
        if payment_method_id is not None:
            
            _query_params.append(('paymentMethodId', payment_method_id))
            
        if external_order_id is not None:
            
            _query_params.append(('externalOrderId', external_order_id))
            
        if external_payment_id is not None:
            
            _query_params.append(('externalPaymentId', external_payment_id))
            
        if remote_ref_type is not None:
            
            _query_params.append(('remoteRefType', remote_ref_type))
            
        if external_date is not None:
            
            _query_params.append(('externalDate', external_date))
            
        if promo_code is not None:
            
            _query_params.append(('promoCode', promo_code))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/order/create',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def delete_order(
        self,
        order_id: Annotated[StrictInt, Field(description="Order Id")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> SirqulResponse:
        """Delete Order

        Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

        :param order_id: Order Id (required)
        :type order_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_serialize(
            order_id=order_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def delete_order_with_http_info(
        self,
        order_id: Annotated[StrictInt, Field(description="Order Id")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[SirqulResponse]:
        """Delete Order

        Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

        :param order_id: Order Id (required)
        :type order_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_serialize(
            order_id=order_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def delete_order_without_preload_content(
        self,
        order_id: Annotated[StrictInt, Field(description="Order Id")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Delete Order

        Removes the transaction from the wallet by setting the deleted date to the current date/time.  Requires a valid account and transactionId.

        :param order_id: Order Id (required)
        :type order_id: int
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._delete_order_serialize(
            order_id=order_id,
            device_id=device_id,
            account_id=account_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "SirqulResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _delete_order_serialize(
        self,
        order_id,
        device_id,
        account_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/order/delete',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_order(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="The order id to get details of, either orderId or externalOrderId must be provided")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="The external order id to get details of, either orderId or externalOrderId must be provided")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderResponse:
        """Get Order

        Get an order record

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param order_id: The order id to get details of, either orderId or externalOrderId must be provided
        :type order_id: int
        :param external_order_id: The external order id to get details of, either orderId or externalOrderId must be provided
        :type external_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_serialize(
            device_id=device_id,
            account_id=account_id,
            order_id=order_id,
            external_order_id=external_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_order_with_http_info(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="The order id to get details of, either orderId or externalOrderId must be provided")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="The external order id to get details of, either orderId or externalOrderId must be provided")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderResponse]:
        """Get Order

        Get an order record

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param order_id: The order id to get details of, either orderId or externalOrderId must be provided
        :type order_id: int
        :param external_order_id: The external order id to get details of, either orderId or externalOrderId must be provided
        :type external_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_serialize(
            device_id=device_id,
            account_id=account_id,
            order_id=order_id,
            external_order_id=external_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_order_without_preload_content(
        self,
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        order_id: Annotated[Optional[StrictInt], Field(description="The order id to get details of, either orderId or externalOrderId must be provided")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="The external order id to get details of, either orderId or externalOrderId must be provided")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Order

        Get an order record

        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param order_id: The order id to get details of, either orderId or externalOrderId must be provided
        :type order_id: int
        :param external_order_id: The external order id to get details of, either orderId or externalOrderId must be provided
        :type external_order_id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_order_serialize(
            device_id=device_id,
            account_id=account_id,
            order_id=order_id,
            external_order_id=external_order_id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_order_serialize(
        self,
        device_id,
        account_id,
        order_id,
        external_order_id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if external_order_id is not None:
            
            _query_params.append(('externalOrderId', external_order_id))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/order/get',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def preview_order(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="A JSON list of items to purchase")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        remote_ref_type: Annotated[Optional[StrictStr], Field(description="Remote Reference type")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The Promo Code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderResponse:
        """Preview Order

        Previews a purchase to see the total cost before making it.

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: A JSON list of items to purchase (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` 
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_order_id: Store identifier from external system
        :type external_order_id: str
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param remote_ref_type: Remote Reference type
        :type remote_ref_type: str
        :param external_date: External Date
        :type external_date: int
        :param promo_code: The Promo Code
        :type promo_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_order_serialize(
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_order_id=external_order_id,
            external_payment_id=external_payment_id,
            remote_ref_type=remote_ref_type,
            external_date=external_date,
            promo_code=promo_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def preview_order_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="A JSON list of items to purchase")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        remote_ref_type: Annotated[Optional[StrictStr], Field(description="Remote Reference type")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The Promo Code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderResponse]:
        """Preview Order

        Previews a purchase to see the total cost before making it.

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: A JSON list of items to purchase (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` 
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_order_id: Store identifier from external system
        :type external_order_id: str
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param remote_ref_type: Remote Reference type
        :type remote_ref_type: str
        :param external_date: External Date
        :type external_date: int
        :param promo_code: The Promo Code
        :type promo_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_order_serialize(
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_order_id=external_order_id,
            external_payment_id=external_payment_id,
            remote_ref_type=remote_ref_type,
            external_date=external_date,
            promo_code=promo_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def preview_order_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="A JSON list of items to purchase")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_order_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        remote_ref_type: Annotated[Optional[StrictStr], Field(description="Remote Reference type")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        promo_code: Annotated[Optional[StrictStr], Field(description="The Promo Code")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Preview Order

        Previews a purchase to see the total cost before making it.

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: A JSON list of items to purchase (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer. ```json {   \"VOID\": \"used for when there is no payment involved (ie. for updating the status of a purchase order)\",   \"CASH\": \"use card on file\",   \"POINTS\": \"use account balance\",   \"TICKETS\": \"use tickets\",   \"REFUND\": \"not allowed for a create, requires a paymentTransactionId\",   \"CREDIT\": \"add to the account balance\",   \"RELOAD\": \"charge a credit card then add to the account balance\" } ``` 
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_order_id: Store identifier from external system
        :type external_order_id: str
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param remote_ref_type: Remote Reference type
        :type remote_ref_type: str
        :param external_date: External Date
        :type external_date: int
        :param promo_code: The Promo Code
        :type promo_code: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._preview_order_serialize(
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_order_id=external_order_id,
            external_payment_id=external_payment_id,
            remote_ref_type=remote_ref_type,
            external_date=external_date,
            promo_code=promo_code,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _preview_order_serialize(
        self,
        app_key,
        cart,
        device_id,
        account_id,
        description,
        currency_type,
        payment_method_id,
        external_order_id,
        external_payment_id,
        remote_ref_type,
        external_date,
        promo_code,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if currency_type is not None:
            
            _query_params.append(('currencyType', currency_type))
            
        if cart is not None:
            
            _query_params.append(('cart', cart))
            
        if payment_method_id is not None:
            
            _query_params.append(('paymentMethodId', payment_method_id))
            
        if external_order_id is not None:
            
            _query_params.append(('externalOrderId', external_order_id))
            
        if external_payment_id is not None:
            
            _query_params.append(('externalPaymentId', external_payment_id))
            
        if remote_ref_type is not None:
            
            _query_params.append(('remoteRefType', remote_ref_type))
            
        if external_date is not None:
            
            _query_params.append(('externalDate', external_date))
            
        if promo_code is not None:
            
            _query_params.append(('promoCode', promo_code))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/order/preview',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def search_orders(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return the resulting list in descending or ascending order")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Only return active orders")] = None,
        ignore_customer_filter: Annotated[Optional[StrictBool], Field(description="Determines whether to ignore the customer filter (requires an Admin/Exec account)")] = None,
        order_item_types: Annotated[Optional[StrictStr], Field(description="Filter results by orderItemTypes")] = None,
        order_item_ids: Annotated[Optional[StrictStr], Field(description="Filter results by orderItemIds")] = None,
        order_custom_types: Annotated[Optional[StrictStr], Field(description="Filter results by orderCustomTypes")] = None,
        order_custom_ids: Annotated[Optional[StrictStr], Field(description="Filter results by orderCustomIds")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what to sort the results by")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Filter results by offer type")] = None,
        special_offer_types: Annotated[Optional[StrictStr], Field(description="Filter results by special offer type")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Filter results by category Ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Filter results by filter Ids")] = None,
        offer_audience_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer audience Ids")] = None,
        transaction_audience_ids: Annotated[Optional[StrictStr], Field(description="Filter results by transaction audience Ids")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer Ids")] = None,
        offer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer location Ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Filter results by retailer Ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results by retailer location Ids")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        redeemable_start_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        redeemable_end_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> List[OrderResponse]:
        """Search Orders

        Search on active orders by customer

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param descending: Determines whether to return the resulting list in descending or ascending order
        :type descending: bool
        :param active_only: Only return active orders
        :type active_only: bool
        :param ignore_customer_filter: Determines whether to ignore the customer filter (requires an Admin/Exec account)
        :type ignore_customer_filter: bool
        :param order_item_types: Filter results by orderItemTypes
        :type order_item_types: str
        :param order_item_ids: Filter results by orderItemIds
        :type order_item_ids: str
        :param order_custom_types: Filter results by orderCustomTypes
        :type order_custom_types: str
        :param order_custom_ids: Filter results by orderCustomIds
        :type order_custom_ids: str
        :param sort_field: Determines what to sort the results by
        :type sort_field: str
        :param offer_types: Filter results by offer type
        :type offer_types: str
        :param special_offer_types: Filter results by special offer type
        :type special_offer_types: str
        :param category_ids: Filter results by category Ids
        :type category_ids: str
        :param filter_ids: Filter results by filter Ids
        :type filter_ids: str
        :param offer_audience_ids: Filter results by offer audience Ids
        :type offer_audience_ids: str
        :param transaction_audience_ids: Filter results by transaction audience Ids
        :type transaction_audience_ids: str
        :param offer_ids: Filter results by offer Ids
        :type offer_ids: str
        :param offer_location_ids: Filter results by offer location Ids
        :type offer_location_ids: str
        :param retailer_ids: Filter results by retailer Ids
        :type retailer_ids: str
        :param retailer_location_ids: Filter results by retailer location Ids
        :type retailer_location_ids: str
        :param statuses: Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
        :type statuses: str
        :param keyword: The keyword to search for
        :type keyword: str
        :param redeemable_start_date: Filter results by the offer redeemable date
        :type redeemable_start_date: int
        :param redeemable_end_date: Filter results by the offer redeemable date
        :type redeemable_end_date: int
        :param started_since: Filter results by the offer start date
        :type started_since: int
        :param started_before: Filter results by the offer start date
        :type started_before: int
        :param ended_since: Filter results by the offer end date
        :type ended_since: int
        :param ended_before: Filter results by the offer end date
        :type ended_before: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_orders_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            start=start,
            limit=limit,
            descending=descending,
            active_only=active_only,
            ignore_customer_filter=ignore_customer_filter,
            order_item_types=order_item_types,
            order_item_ids=order_item_ids,
            order_custom_types=order_custom_types,
            order_custom_ids=order_custom_ids,
            sort_field=sort_field,
            offer_types=offer_types,
            special_offer_types=special_offer_types,
            category_ids=category_ids,
            filter_ids=filter_ids,
            offer_audience_ids=offer_audience_ids,
            transaction_audience_ids=transaction_audience_ids,
            offer_ids=offer_ids,
            offer_location_ids=offer_location_ids,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            statuses=statuses,
            keyword=keyword,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def search_orders_with_http_info(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return the resulting list in descending or ascending order")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Only return active orders")] = None,
        ignore_customer_filter: Annotated[Optional[StrictBool], Field(description="Determines whether to ignore the customer filter (requires an Admin/Exec account)")] = None,
        order_item_types: Annotated[Optional[StrictStr], Field(description="Filter results by orderItemTypes")] = None,
        order_item_ids: Annotated[Optional[StrictStr], Field(description="Filter results by orderItemIds")] = None,
        order_custom_types: Annotated[Optional[StrictStr], Field(description="Filter results by orderCustomTypes")] = None,
        order_custom_ids: Annotated[Optional[StrictStr], Field(description="Filter results by orderCustomIds")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what to sort the results by")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Filter results by offer type")] = None,
        special_offer_types: Annotated[Optional[StrictStr], Field(description="Filter results by special offer type")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Filter results by category Ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Filter results by filter Ids")] = None,
        offer_audience_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer audience Ids")] = None,
        transaction_audience_ids: Annotated[Optional[StrictStr], Field(description="Filter results by transaction audience Ids")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer Ids")] = None,
        offer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer location Ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Filter results by retailer Ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results by retailer location Ids")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        redeemable_start_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        redeemable_end_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[List[OrderResponse]]:
        """Search Orders

        Search on active orders by customer

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param descending: Determines whether to return the resulting list in descending or ascending order
        :type descending: bool
        :param active_only: Only return active orders
        :type active_only: bool
        :param ignore_customer_filter: Determines whether to ignore the customer filter (requires an Admin/Exec account)
        :type ignore_customer_filter: bool
        :param order_item_types: Filter results by orderItemTypes
        :type order_item_types: str
        :param order_item_ids: Filter results by orderItemIds
        :type order_item_ids: str
        :param order_custom_types: Filter results by orderCustomTypes
        :type order_custom_types: str
        :param order_custom_ids: Filter results by orderCustomIds
        :type order_custom_ids: str
        :param sort_field: Determines what to sort the results by
        :type sort_field: str
        :param offer_types: Filter results by offer type
        :type offer_types: str
        :param special_offer_types: Filter results by special offer type
        :type special_offer_types: str
        :param category_ids: Filter results by category Ids
        :type category_ids: str
        :param filter_ids: Filter results by filter Ids
        :type filter_ids: str
        :param offer_audience_ids: Filter results by offer audience Ids
        :type offer_audience_ids: str
        :param transaction_audience_ids: Filter results by transaction audience Ids
        :type transaction_audience_ids: str
        :param offer_ids: Filter results by offer Ids
        :type offer_ids: str
        :param offer_location_ids: Filter results by offer location Ids
        :type offer_location_ids: str
        :param retailer_ids: Filter results by retailer Ids
        :type retailer_ids: str
        :param retailer_location_ids: Filter results by retailer location Ids
        :type retailer_location_ids: str
        :param statuses: Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
        :type statuses: str
        :param keyword: The keyword to search for
        :type keyword: str
        :param redeemable_start_date: Filter results by the offer redeemable date
        :type redeemable_start_date: int
        :param redeemable_end_date: Filter results by the offer redeemable date
        :type redeemable_end_date: int
        :param started_since: Filter results by the offer start date
        :type started_since: int
        :param started_before: Filter results by the offer start date
        :type started_before: int
        :param ended_since: Filter results by the offer end date
        :type ended_since: int
        :param ended_before: Filter results by the offer end date
        :type ended_before: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_orders_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            start=start,
            limit=limit,
            descending=descending,
            active_only=active_only,
            ignore_customer_filter=ignore_customer_filter,
            order_item_types=order_item_types,
            order_item_ids=order_item_ids,
            order_custom_types=order_custom_types,
            order_custom_ids=order_custom_ids,
            sort_field=sort_field,
            offer_types=offer_types,
            special_offer_types=special_offer_types,
            category_ids=category_ids,
            filter_ids=filter_ids,
            offer_audience_ids=offer_audience_ids,
            transaction_audience_ids=transaction_audience_ids,
            offer_ids=offer_ids,
            offer_location_ids=offer_location_ids,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            statuses=statuses,
            keyword=keyword,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def search_orders_without_preload_content(
        self,
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        start: Annotated[Optional[StrictInt], Field(description="The start index for pagination")] = None,
        limit: Annotated[Optional[StrictInt], Field(description="The limit for pagination")] = None,
        descending: Annotated[Optional[StrictBool], Field(description="Determines whether to return the resulting list in descending or ascending order")] = None,
        active_only: Annotated[Optional[StrictBool], Field(description="Only return active orders")] = None,
        ignore_customer_filter: Annotated[Optional[StrictBool], Field(description="Determines whether to ignore the customer filter (requires an Admin/Exec account)")] = None,
        order_item_types: Annotated[Optional[StrictStr], Field(description="Filter results by orderItemTypes")] = None,
        order_item_ids: Annotated[Optional[StrictStr], Field(description="Filter results by orderItemIds")] = None,
        order_custom_types: Annotated[Optional[StrictStr], Field(description="Filter results by orderCustomTypes")] = None,
        order_custom_ids: Annotated[Optional[StrictStr], Field(description="Filter results by orderCustomIds")] = None,
        sort_field: Annotated[Optional[StrictStr], Field(description="Determines what to sort the results by")] = None,
        offer_types: Annotated[Optional[StrictStr], Field(description="Filter results by offer type")] = None,
        special_offer_types: Annotated[Optional[StrictStr], Field(description="Filter results by special offer type")] = None,
        category_ids: Annotated[Optional[StrictStr], Field(description="Filter results by category Ids")] = None,
        filter_ids: Annotated[Optional[StrictStr], Field(description="Filter results by filter Ids")] = None,
        offer_audience_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer audience Ids")] = None,
        transaction_audience_ids: Annotated[Optional[StrictStr], Field(description="Filter results by transaction audience Ids")] = None,
        offer_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer Ids")] = None,
        offer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results by offer location Ids")] = None,
        retailer_ids: Annotated[Optional[StrictStr], Field(description="Filter results by retailer Ids")] = None,
        retailer_location_ids: Annotated[Optional[StrictStr], Field(description="Filter results by retailer location Ids")] = None,
        statuses: Annotated[Optional[StrictStr], Field(description="Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)")] = None,
        keyword: Annotated[Optional[StrictStr], Field(description="The keyword to search for")] = None,
        redeemable_start_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        redeemable_end_date: Annotated[Optional[StrictInt], Field(description="Filter results by the offer redeemable date")] = None,
        started_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        started_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer start date")] = None,
        ended_since: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        ended_before: Annotated[Optional[StrictInt], Field(description="Filter results by the offer end date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Search Orders

        Search on active orders by customer

        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param start: The start index for pagination
        :type start: int
        :param limit: The limit for pagination
        :type limit: int
        :param descending: Determines whether to return the resulting list in descending or ascending order
        :type descending: bool
        :param active_only: Only return active orders
        :type active_only: bool
        :param ignore_customer_filter: Determines whether to ignore the customer filter (requires an Admin/Exec account)
        :type ignore_customer_filter: bool
        :param order_item_types: Filter results by orderItemTypes
        :type order_item_types: str
        :param order_item_ids: Filter results by orderItemIds
        :type order_item_ids: str
        :param order_custom_types: Filter results by orderCustomTypes
        :type order_custom_types: str
        :param order_custom_ids: Filter results by orderCustomIds
        :type order_custom_ids: str
        :param sort_field: Determines what to sort the results by
        :type sort_field: str
        :param offer_types: Filter results by offer type
        :type offer_types: str
        :param special_offer_types: Filter results by special offer type
        :type special_offer_types: str
        :param category_ids: Filter results by category Ids
        :type category_ids: str
        :param filter_ids: Filter results by filter Ids
        :type filter_ids: str
        :param offer_audience_ids: Filter results by offer audience Ids
        :type offer_audience_ids: str
        :param transaction_audience_ids: Filter results by transaction audience Ids
        :type transaction_audience_ids: str
        :param offer_ids: Filter results by offer Ids
        :type offer_ids: str
        :param offer_location_ids: Filter results by offer location Ids
        :type offer_location_ids: str
        :param retailer_ids: Filter results by retailer Ids
        :type retailer_ids: str
        :param retailer_location_ids: Filter results by retailer location Ids
        :type retailer_location_ids: str
        :param statuses: Filter results by offer transaction status (0: non-redeemable, 1: redeemable, 2: redeemed, 3: user deleted, 4: unclaimed/rewarded, 5: membership active, 6: membership cancelled)
        :type statuses: str
        :param keyword: The keyword to search for
        :type keyword: str
        :param redeemable_start_date: Filter results by the offer redeemable date
        :type redeemable_start_date: int
        :param redeemable_end_date: Filter results by the offer redeemable date
        :type redeemable_end_date: int
        :param started_since: Filter results by the offer start date
        :type started_since: int
        :param started_before: Filter results by the offer start date
        :type started_before: int
        :param ended_since: Filter results by the offer end date
        :type ended_since: int
        :param ended_before: Filter results by the offer end date
        :type ended_before: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._search_orders_serialize(
            app_key=app_key,
            device_id=device_id,
            account_id=account_id,
            start=start,
            limit=limit,
            descending=descending,
            active_only=active_only,
            ignore_customer_filter=ignore_customer_filter,
            order_item_types=order_item_types,
            order_item_ids=order_item_ids,
            order_custom_types=order_custom_types,
            order_custom_ids=order_custom_ids,
            sort_field=sort_field,
            offer_types=offer_types,
            special_offer_types=special_offer_types,
            category_ids=category_ids,
            filter_ids=filter_ids,
            offer_audience_ids=offer_audience_ids,
            transaction_audience_ids=transaction_audience_ids,
            offer_ids=offer_ids,
            offer_location_ids=offer_location_ids,
            retailer_ids=retailer_ids,
            retailer_location_ids=retailer_location_ids,
            statuses=statuses,
            keyword=keyword,
            redeemable_start_date=redeemable_start_date,
            redeemable_end_date=redeemable_end_date,
            started_since=started_since,
            started_before=started_before,
            ended_since=ended_since,
            ended_before=ended_before,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "List[OrderResponse]",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _search_orders_serialize(
        self,
        app_key,
        device_id,
        account_id,
        start,
        limit,
        descending,
        active_only,
        ignore_customer_filter,
        order_item_types,
        order_item_ids,
        order_custom_types,
        order_custom_ids,
        sort_field,
        offer_types,
        special_offer_types,
        category_ids,
        filter_ids,
        offer_audience_ids,
        transaction_audience_ids,
        offer_ids,
        offer_location_ids,
        retailer_ids,
        retailer_location_ids,
        statuses,
        keyword,
        redeemable_start_date,
        redeemable_end_date,
        started_since,
        started_before,
        ended_since,
        ended_before,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if start is not None:
            
            _query_params.append(('start', start))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        if descending is not None:
            
            _query_params.append(('descending', descending))
            
        if active_only is not None:
            
            _query_params.append(('activeOnly', active_only))
            
        if ignore_customer_filter is not None:
            
            _query_params.append(('ignoreCustomerFilter', ignore_customer_filter))
            
        if order_item_types is not None:
            
            _query_params.append(('orderItemTypes', order_item_types))
            
        if order_item_ids is not None:
            
            _query_params.append(('orderItemIds', order_item_ids))
            
        if order_custom_types is not None:
            
            _query_params.append(('orderCustomTypes', order_custom_types))
            
        if order_custom_ids is not None:
            
            _query_params.append(('orderCustomIds', order_custom_ids))
            
        if sort_field is not None:
            
            _query_params.append(('sortField', sort_field))
            
        if offer_types is not None:
            
            _query_params.append(('offerTypes', offer_types))
            
        if special_offer_types is not None:
            
            _query_params.append(('specialOfferTypes', special_offer_types))
            
        if category_ids is not None:
            
            _query_params.append(('categoryIds', category_ids))
            
        if filter_ids is not None:
            
            _query_params.append(('filterIds', filter_ids))
            
        if offer_audience_ids is not None:
            
            _query_params.append(('offerAudienceIds', offer_audience_ids))
            
        if transaction_audience_ids is not None:
            
            _query_params.append(('transactionAudienceIds', transaction_audience_ids))
            
        if offer_ids is not None:
            
            _query_params.append(('offerIds', offer_ids))
            
        if offer_location_ids is not None:
            
            _query_params.append(('offerLocationIds', offer_location_ids))
            
        if retailer_ids is not None:
            
            _query_params.append(('retailerIds', retailer_ids))
            
        if retailer_location_ids is not None:
            
            _query_params.append(('retailerLocationIds', retailer_location_ids))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        if keyword is not None:
            
            _query_params.append(('keyword', keyword))
            
        if redeemable_start_date is not None:
            
            _query_params.append(('redeemableStartDate', redeemable_start_date))
            
        if redeemable_end_date is not None:
            
            _query_params.append(('redeemableEndDate', redeemable_end_date))
            
        if started_since is not None:
            
            _query_params.append(('startedSince', started_since))
            
        if started_before is not None:
            
            _query_params.append(('startedBefore', started_before))
            
        if ended_since is not None:
            
            _query_params.append(('endedSince', ended_since))
            
        if ended_before is not None:
            
            _query_params.append(('endedBefore', ended_before))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/order/search',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def update_order(
        self,
        order_id: Annotated[StrictInt, Field(description="The order to add the purchase to, leave null for new order.")],
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        payment_transaction_id: Annotated[Optional[StrictInt], Field(description="The payment transaction to apply the refund to")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> OrderResponse:
        """Update Order

        Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.

        :param order_id: The order to add the purchase to, leave null for new order. (required)
        :type order_id: int
        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ```  (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param payment_transaction_id: The payment transaction to apply the refund to
        :type payment_transaction_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param external_date: External Date
        :type external_date: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_order_serialize(
            order_id=order_id,
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            payment_transaction_id=payment_transaction_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_payment_id=external_payment_id,
            external_date=external_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def update_order_with_http_info(
        self,
        order_id: Annotated[StrictInt, Field(description="The order to add the purchase to, leave null for new order.")],
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        payment_transaction_id: Annotated[Optional[StrictInt], Field(description="The payment transaction to apply the refund to")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[OrderResponse]:
        """Update Order

        Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.

        :param order_id: The order to add the purchase to, leave null for new order. (required)
        :type order_id: int
        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ```  (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param payment_transaction_id: The payment transaction to apply the refund to
        :type payment_transaction_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param external_date: External Date
        :type external_date: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_order_serialize(
            order_id=order_id,
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            payment_transaction_id=payment_transaction_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_payment_id=external_payment_id,
            external_date=external_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def update_order_without_preload_content(
        self,
        order_id: Annotated[StrictInt, Field(description="The order to add the purchase to, leave null for new order.")],
        app_key: Annotated[StrictStr, Field(description="The application requesting the purchase")],
        cart: Annotated[StrictStr, Field(description="```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ``` ")],
        device_id: Annotated[Optional[StrictStr], Field(description="The device id (deviceId or accountId required)")] = None,
        account_id: Annotated[Optional[StrictInt], Field(description="The account id of the user (deviceId or accountId required)")] = None,
        payment_transaction_id: Annotated[Optional[StrictInt], Field(description="The payment transaction to apply the refund to")] = None,
        description: Annotated[Optional[StrictStr], Field(description="A description of the purchase")] = None,
        currency_type: Annotated[Optional[StrictStr], Field(description="Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  ")] = None,
        payment_method_id: Annotated[Optional[StrictInt], Field(description="Use a specific payment method (CASH), if not provided use default")] = None,
        external_payment_id: Annotated[Optional[StrictStr], Field(description="Store identifier from external system")] = None,
        external_date: Annotated[Optional[StrictInt], Field(description="External Date")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Update Order

        Updates new purchase with some number of items associated with it. The orderId provided is used to retrieve the record and the payment is added to it.

        :param order_id: The order to add the purchase to, leave null for new order. (required)
        :type order_id: int
        :param app_key: The application requesting the purchase (required)
        :type app_key: str
        :param cart: ```json [   { \"orderItemType\": \"OFFER\", \"orderItemId\": 234, \"orderCustomType\": \"OfferLocation\", \"orderCustomId\": 123, \"retailerLocationId\": 1234, \"quantity\": 2 },   { \"orderItemType\": \"OFFER\", \"orderItemId\": 235, \"quantity\": 2 },   { \"orderItemType\": \"CUSTOM\", \"amount\": 10.50, \"orderCustomType\": \"ServiceFee\" },   { \"orderItemType\": \"CUSTOM\", \"amount\": 25.10, \"quantity\": 2, \"orderCustomType\": \"Hat\", \"orderCustomId\": 123 } ] ```  (required)
        :type cart: str
        :param device_id: The device id (deviceId or accountId required)
        :type device_id: str
        :param account_id: The account id of the user (deviceId or accountId required)
        :type account_id: int
        :param payment_transaction_id: The payment transaction to apply the refund to
        :type payment_transaction_id: int
        :param description: A description of the purchase
        :type description: str
        :param currency_type: Determines the method of purchasing offer.  * VOID: used for when there is no payment involved (ie. for updating the status of a purchase order)  * CASH: use card on file  * POINTS: use account balance  * TICKETS: use tickets  * REFUND: not allowed for a create, requires a paymentTransactionId.  * CREDIT: add to the account balance  * RELOAD: charge a credit card then add to the account balance  
        :type currency_type: str
        :param payment_method_id: Use a specific payment method (CASH), if not provided use default
        :type payment_method_id: int
        :param external_payment_id: Store identifier from external system
        :type external_payment_id: str
        :param external_date: External Date
        :type external_date: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._update_order_serialize(
            order_id=order_id,
            app_key=app_key,
            cart=cart,
            device_id=device_id,
            account_id=account_id,
            payment_transaction_id=payment_transaction_id,
            description=description,
            currency_type=currency_type,
            payment_method_id=payment_method_id,
            external_payment_id=external_payment_id,
            external_date=external_date,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "OrderResponse",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _update_order_serialize(
        self,
        order_id,
        app_key,
        cart,
        device_id,
        account_id,
        payment_transaction_id,
        description,
        currency_type,
        payment_method_id,
        external_payment_id,
        external_date,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if device_id is not None:
            
            _query_params.append(('deviceId', device_id))
            
        if account_id is not None:
            
            _query_params.append(('accountId', account_id))
            
        if order_id is not None:
            
            _query_params.append(('orderId', order_id))
            
        if payment_transaction_id is not None:
            
            _query_params.append(('paymentTransactionId', payment_transaction_id))
            
        if app_key is not None:
            
            _query_params.append(('appKey', app_key))
            
        if description is not None:
            
            _query_params.append(('description', description))
            
        if currency_type is not None:
            
            _query_params.append(('currencyType', currency_type))
            
        if cart is not None:
            
            _query_params.append(('cart', cart))
            
        if payment_method_id is not None:
            
            _query_params.append(('paymentMethodId', payment_method_id))
            
        if external_payment_id is not None:
            
            _query_params.append(('externalPaymentId', external_payment_id))
            
        if external_date is not None:
            
            _query_params.append(('externalDate', external_date))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    '*/*'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
        ]

        return self.api_client.param_serialize(
            method='POST',
            resource_path='/order/update',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


