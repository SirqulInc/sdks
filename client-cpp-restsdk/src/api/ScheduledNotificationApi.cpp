/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.20.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "CppRestOpenAPIClient/api/ScheduledNotificationApi.h"
#include "CppRestOpenAPIClient/IHttpBody.h"
#include "CppRestOpenAPIClient/JsonBody.h"
#include "CppRestOpenAPIClient/MultipartFormData.h"

#include <boost/algorithm/string/replace.hpp>

#include <unordered_set>

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

ScheduledNotificationApi::ScheduledNotificationApi( std::shared_ptr<const ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

ScheduledNotificationApi::~ScheduledNotificationApi()
{
}

pplx::task<std::shared_ptr<ScheduledNotificationFullResponse>> ScheduledNotificationApi::createScheduledNotification(double version, int64_t accountId, utility::string_t name, utility::string_t type, utility::string_t message, boost::optional<int64_t> contentId, boost::optional<utility::string_t> contentName, boost::optional<utility::string_t> contentType, boost::optional<int64_t> parentId, boost::optional<utility::string_t> parentType, boost::optional<utility::string_t> appKey, boost::optional<utility::string_t> groupingId, boost::optional<utility::string_t> connectionGroupIds, boost::optional<utility::string_t> connectionAccountIds, boost::optional<int64_t> audienceId, boost::optional<utility::string_t> audienceIds, boost::optional<utility::string_t> albumIds, boost::optional<int64_t> reportId, boost::optional<utility::string_t> reportParams, boost::optional<utility::string_t> endpointURL, boost::optional<utility::string_t> payload, boost::optional<int64_t> scheduledDate, boost::optional<int64_t> startDate, boost::optional<int64_t> endDate, boost::optional<utility::string_t> cronExpression, boost::optional<utility::string_t> cronType, boost::optional<utility::string_t> metaData, boost::optional<utility::string_t> conditionalInput, boost::optional<utility::string_t> templateType, boost::optional<utility::string_t> visibility, boost::optional<bool> active, boost::optional<bool> sendNow, boost::optional<utility::string_t> eventType, boost::optional<utility::string_t> deepLinkURI, boost::optional<bool> sendToAll) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/{version}/notification/schedule/create");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(version)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("*/*") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ScheduledNotificationApi->createScheduledNotification does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("accountId")] = ApiClient::parameterToString(accountId);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("name")] = ApiClient::parameterToString(name);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("type")] = ApiClient::parameterToString(type);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("message")] = ApiClient::parameterToString(message);
    }
    if (contentId)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentId")] = ApiClient::parameterToString(*contentId);
    }
    if (contentName)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentName")] = ApiClient::parameterToString(*contentName);
    }
    if (contentType)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentType")] = ApiClient::parameterToString(*contentType);
    }
    if (parentId)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentId")] = ApiClient::parameterToString(*parentId);
    }
    if (parentType)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentType")] = ApiClient::parameterToString(*parentType);
    }
    if (appKey)
    {
        localVarQueryParams[utility::conversions::to_string_t("appKey")] = ApiClient::parameterToString(*appKey);
    }
    if (groupingId)
    {
        localVarQueryParams[utility::conversions::to_string_t("groupingId")] = ApiClient::parameterToString(*groupingId);
    }
    if (connectionGroupIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("connectionGroupIds")] = ApiClient::parameterToString(*connectionGroupIds);
    }
    if (connectionAccountIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("connectionAccountIds")] = ApiClient::parameterToString(*connectionAccountIds);
    }
    if (audienceId)
    {
        localVarQueryParams[utility::conversions::to_string_t("audienceId")] = ApiClient::parameterToString(*audienceId);
    }
    if (audienceIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("audienceIds")] = ApiClient::parameterToString(*audienceIds);
    }
    if (albumIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("albumIds")] = ApiClient::parameterToString(*albumIds);
    }
    if (reportId)
    {
        localVarQueryParams[utility::conversions::to_string_t("reportId")] = ApiClient::parameterToString(*reportId);
    }
    if (reportParams)
    {
        localVarQueryParams[utility::conversions::to_string_t("reportParams")] = ApiClient::parameterToString(*reportParams);
    }
    if (endpointURL)
    {
        localVarQueryParams[utility::conversions::to_string_t("endpointURL")] = ApiClient::parameterToString(*endpointURL);
    }
    if (payload)
    {
        localVarQueryParams[utility::conversions::to_string_t("payload")] = ApiClient::parameterToString(*payload);
    }
    if (scheduledDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("scheduledDate")] = ApiClient::parameterToString(*scheduledDate);
    }
    if (startDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("startDate")] = ApiClient::parameterToString(*startDate);
    }
    if (endDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("endDate")] = ApiClient::parameterToString(*endDate);
    }
    if (cronExpression)
    {
        localVarQueryParams[utility::conversions::to_string_t("cronExpression")] = ApiClient::parameterToString(*cronExpression);
    }
    if (cronType)
    {
        localVarQueryParams[utility::conversions::to_string_t("cronType")] = ApiClient::parameterToString(*cronType);
    }
    if (metaData)
    {
        localVarQueryParams[utility::conversions::to_string_t("metaData")] = ApiClient::parameterToString(*metaData);
    }
    if (conditionalInput)
    {
        localVarQueryParams[utility::conversions::to_string_t("conditionalInput")] = ApiClient::parameterToString(*conditionalInput);
    }
    if (templateType)
    {
        localVarQueryParams[utility::conversions::to_string_t("templateType")] = ApiClient::parameterToString(*templateType);
    }
    if (visibility)
    {
        localVarQueryParams[utility::conversions::to_string_t("visibility")] = ApiClient::parameterToString(*visibility);
    }
    if (active)
    {
        localVarQueryParams[utility::conversions::to_string_t("active")] = ApiClient::parameterToString(*active);
    }
    if (sendNow)
    {
        localVarQueryParams[utility::conversions::to_string_t("sendNow")] = ApiClient::parameterToString(*sendNow);
    }
    if (eventType)
    {
        localVarQueryParams[utility::conversions::to_string_t("eventType")] = ApiClient::parameterToString(*eventType);
    }
    if (deepLinkURI)
    {
        localVarQueryParams[utility::conversions::to_string_t("deepLinkURI")] = ApiClient::parameterToString(*deepLinkURI);
    }
    if (sendToAll)
    {
        localVarQueryParams[utility::conversions::to_string_t("sendToAll")] = ApiClient::parameterToString(*sendToAll);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ScheduledNotificationApi->createScheduledNotification does not consume any supported media type"));
    }


    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling createScheduledNotification: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling createScheduledNotification: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<ScheduledNotificationFullResponse> localVarResult(new ScheduledNotificationFullResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling createScheduledNotification: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<ScheduledNotificationFullResponse>> ScheduledNotificationApi::deleteScheduledNotification(double version, int64_t accountId, int64_t scheduledNotificationId, boost::optional<bool> deleteByGroupingId) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/{version}/notification/schedule/delete");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(version)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("*/*") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ScheduledNotificationApi->deleteScheduledNotification does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("accountId")] = ApiClient::parameterToString(accountId);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("scheduledNotificationId")] = ApiClient::parameterToString(scheduledNotificationId);
    }
    if (deleteByGroupingId)
    {
        localVarQueryParams[utility::conversions::to_string_t("deleteByGroupingId")] = ApiClient::parameterToString(*deleteByGroupingId);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ScheduledNotificationApi->deleteScheduledNotification does not consume any supported media type"));
    }


    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling deleteScheduledNotification: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling deleteScheduledNotification: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<ScheduledNotificationFullResponse> localVarResult(new ScheduledNotificationFullResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling deleteScheduledNotification: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<ScheduledNotificationFullResponse>> ScheduledNotificationApi::getScheduledNotification(double version, int64_t accountId, int64_t scheduledNotificationId) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/{version}/notification/schedule/get");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(version)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("*/*") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ScheduledNotificationApi->getScheduledNotification does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("accountId")] = ApiClient::parameterToString(accountId);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("scheduledNotificationId")] = ApiClient::parameterToString(scheduledNotificationId);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ScheduledNotificationApi->getScheduledNotification does not consume any supported media type"));
    }


    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling getScheduledNotification: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getScheduledNotification: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<ScheduledNotificationFullResponse> localVarResult(new ScheduledNotificationFullResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getScheduledNotification: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<SirqulResponse>> ScheduledNotificationApi::scheduleNotificationListings(double version, int64_t accountId, utility::string_t appKey, utility::string_t reportName, utility::string_t message, int32_t offset, int64_t recipientReportId, boost::optional<utility::string_t> reportParams, boost::optional<utility::string_t> type) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/{version}/notification/schedule/generate");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(version)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("*/*") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ScheduledNotificationApi->scheduleNotificationListings does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("accountId")] = ApiClient::parameterToString(accountId);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("appKey")] = ApiClient::parameterToString(appKey);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("reportName")] = ApiClient::parameterToString(reportName);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("message")] = ApiClient::parameterToString(message);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("offset")] = ApiClient::parameterToString(offset);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("recipientReportId")] = ApiClient::parameterToString(recipientReportId);
    }
    if (reportParams)
    {
        localVarQueryParams[utility::conversions::to_string_t("reportParams")] = ApiClient::parameterToString(*reportParams);
    }
    if (type)
    {
        localVarQueryParams[utility::conversions::to_string_t("type")] = ApiClient::parameterToString(*type);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ScheduledNotificationApi->scheduleNotificationListings does not consume any supported media type"));
    }


    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling scheduleNotificationListings: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling scheduleNotificationListings: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<SirqulResponse> localVarResult(new SirqulResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling scheduleNotificationListings: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<ScheduledNotificationFullResponse>> ScheduledNotificationApi::searchScheduledNotifications(double version, int64_t accountId, boost::optional<utility::string_t> groupingId, boost::optional<int64_t> audienceId, boost::optional<utility::string_t> filter, boost::optional<utility::string_t> types, boost::optional<utility::string_t> contentIds, boost::optional<utility::string_t> contentTypes, boost::optional<utility::string_t> parentIds, boost::optional<utility::string_t> parentTypes, boost::optional<utility::string_t> statuses, boost::optional<utility::string_t> templateTypes, boost::optional<utility::string_t> appKey, boost::optional<utility::string_t> keyword, boost::optional<utility::string_t> sortField, boost::optional<bool> descending, boost::optional<int32_t> start, boost::optional<int32_t> limit, boost::optional<bool> activeOnly, boost::optional<bool> groupByGroupingId, boost::optional<bool> returnAudienceAccountCount) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/{version}/notification/schedule/search");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(version)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("*/*") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ScheduledNotificationApi->searchScheduledNotifications does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("accountId")] = ApiClient::parameterToString(accountId);
    }
    if (groupingId)
    {
        localVarQueryParams[utility::conversions::to_string_t("groupingId")] = ApiClient::parameterToString(*groupingId);
    }
    if (audienceId)
    {
        localVarQueryParams[utility::conversions::to_string_t("audienceId")] = ApiClient::parameterToString(*audienceId);
    }
    if (filter)
    {
        localVarQueryParams[utility::conversions::to_string_t("filter")] = ApiClient::parameterToString(*filter);
    }
    if (types)
    {
        localVarQueryParams[utility::conversions::to_string_t("types")] = ApiClient::parameterToString(*types);
    }
    if (contentIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentIds")] = ApiClient::parameterToString(*contentIds);
    }
    if (contentTypes)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentTypes")] = ApiClient::parameterToString(*contentTypes);
    }
    if (parentIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentIds")] = ApiClient::parameterToString(*parentIds);
    }
    if (parentTypes)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentTypes")] = ApiClient::parameterToString(*parentTypes);
    }
    if (statuses)
    {
        localVarQueryParams[utility::conversions::to_string_t("statuses")] = ApiClient::parameterToString(*statuses);
    }
    if (templateTypes)
    {
        localVarQueryParams[utility::conversions::to_string_t("templateTypes")] = ApiClient::parameterToString(*templateTypes);
    }
    if (appKey)
    {
        localVarQueryParams[utility::conversions::to_string_t("appKey")] = ApiClient::parameterToString(*appKey);
    }
    if (keyword)
    {
        localVarQueryParams[utility::conversions::to_string_t("keyword")] = ApiClient::parameterToString(*keyword);
    }
    if (sortField)
    {
        localVarQueryParams[utility::conversions::to_string_t("sortField")] = ApiClient::parameterToString(*sortField);
    }
    if (descending)
    {
        localVarQueryParams[utility::conversions::to_string_t("descending")] = ApiClient::parameterToString(*descending);
    }
    if (start)
    {
        localVarQueryParams[utility::conversions::to_string_t("start")] = ApiClient::parameterToString(*start);
    }
    if (limit)
    {
        localVarQueryParams[utility::conversions::to_string_t("limit")] = ApiClient::parameterToString(*limit);
    }
    if (activeOnly)
    {
        localVarQueryParams[utility::conversions::to_string_t("activeOnly")] = ApiClient::parameterToString(*activeOnly);
    }
    if (groupByGroupingId)
    {
        localVarQueryParams[utility::conversions::to_string_t("groupByGroupingId")] = ApiClient::parameterToString(*groupByGroupingId);
    }
    if (returnAudienceAccountCount)
    {
        localVarQueryParams[utility::conversions::to_string_t("returnAudienceAccountCount")] = ApiClient::parameterToString(*returnAudienceAccountCount);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ScheduledNotificationApi->searchScheduledNotifications does not consume any supported media type"));
    }


    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling searchScheduledNotifications: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling searchScheduledNotifications: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<ScheduledNotificationFullResponse> localVarResult(new ScheduledNotificationFullResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling searchScheduledNotifications: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<ScheduledNotificationFullResponse>> ScheduledNotificationApi::updateScheduledNotification(double version, int64_t scheduledNotificationId, int64_t accountId, boost::optional<utility::string_t> name, boost::optional<utility::string_t> type, boost::optional<utility::string_t> message, boost::optional<utility::string_t> payload, boost::optional<int64_t> contentId, boost::optional<utility::string_t> contentName, boost::optional<utility::string_t> contentType, boost::optional<int64_t> parentId, boost::optional<utility::string_t> parentType, boost::optional<utility::string_t> appKey, boost::optional<utility::string_t> groupingId, boost::optional<utility::string_t> connectionGroupIds, boost::optional<utility::string_t> connectionAccountIds, boost::optional<int64_t> audienceId, boost::optional<utility::string_t> audienceIds, boost::optional<utility::string_t> albumIds, boost::optional<int64_t> reportId, boost::optional<utility::string_t> reportParams, boost::optional<utility::string_t> endpointURL, boost::optional<int64_t> scheduledDate, boost::optional<int64_t> startDate, boost::optional<int64_t> endDate, boost::optional<utility::string_t> cronExpression, boost::optional<utility::string_t> cronType, boost::optional<utility::string_t> metaData, boost::optional<utility::string_t> conditionalInput, boost::optional<utility::string_t> templateType, boost::optional<utility::string_t> visibility, boost::optional<bool> active, boost::optional<utility::string_t> errorMessage, boost::optional<utility::string_t> status, boost::optional<bool> updateByGroupingId, boost::optional<bool> sendNow, boost::optional<utility::string_t> eventType, boost::optional<utility::string_t> deepLinkURI, boost::optional<bool> sendToAll) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/api/{version}/notification/schedule/update");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("version") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(version)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("*/*") );

    utility::string_t localVarResponseHttpContentType;

    // use JSON if possible
    if ( localVarResponseHttpContentTypes.size() == 0 )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // JSON
    else if ( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarResponseHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarResponseHttpContentTypes.end() )
    {
        localVarResponseHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else
    {
        throw ApiException(400, utility::conversions::to_string_t("ScheduledNotificationApi->updateScheduledNotification does not produce any supported media type"));
    }

    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("scheduledNotificationId")] = ApiClient::parameterToString(scheduledNotificationId);
    }
    {
        localVarQueryParams[utility::conversions::to_string_t("accountId")] = ApiClient::parameterToString(accountId);
    }
    if (name)
    {
        localVarQueryParams[utility::conversions::to_string_t("name")] = ApiClient::parameterToString(*name);
    }
    if (type)
    {
        localVarQueryParams[utility::conversions::to_string_t("type")] = ApiClient::parameterToString(*type);
    }
    if (message)
    {
        localVarQueryParams[utility::conversions::to_string_t("message")] = ApiClient::parameterToString(*message);
    }
    if (payload)
    {
        localVarQueryParams[utility::conversions::to_string_t("payload")] = ApiClient::parameterToString(*payload);
    }
    if (contentId)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentId")] = ApiClient::parameterToString(*contentId);
    }
    if (contentName)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentName")] = ApiClient::parameterToString(*contentName);
    }
    if (contentType)
    {
        localVarQueryParams[utility::conversions::to_string_t("contentType")] = ApiClient::parameterToString(*contentType);
    }
    if (parentId)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentId")] = ApiClient::parameterToString(*parentId);
    }
    if (parentType)
    {
        localVarQueryParams[utility::conversions::to_string_t("parentType")] = ApiClient::parameterToString(*parentType);
    }
    if (appKey)
    {
        localVarQueryParams[utility::conversions::to_string_t("appKey")] = ApiClient::parameterToString(*appKey);
    }
    if (groupingId)
    {
        localVarQueryParams[utility::conversions::to_string_t("groupingId")] = ApiClient::parameterToString(*groupingId);
    }
    if (connectionGroupIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("connectionGroupIds")] = ApiClient::parameterToString(*connectionGroupIds);
    }
    if (connectionAccountIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("connectionAccountIds")] = ApiClient::parameterToString(*connectionAccountIds);
    }
    if (audienceId)
    {
        localVarQueryParams[utility::conversions::to_string_t("audienceId")] = ApiClient::parameterToString(*audienceId);
    }
    if (audienceIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("audienceIds")] = ApiClient::parameterToString(*audienceIds);
    }
    if (albumIds)
    {
        localVarQueryParams[utility::conversions::to_string_t("albumIds")] = ApiClient::parameterToString(*albumIds);
    }
    if (reportId)
    {
        localVarQueryParams[utility::conversions::to_string_t("reportId")] = ApiClient::parameterToString(*reportId);
    }
    if (reportParams)
    {
        localVarQueryParams[utility::conversions::to_string_t("reportParams")] = ApiClient::parameterToString(*reportParams);
    }
    if (endpointURL)
    {
        localVarQueryParams[utility::conversions::to_string_t("endpointURL")] = ApiClient::parameterToString(*endpointURL);
    }
    if (scheduledDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("scheduledDate")] = ApiClient::parameterToString(*scheduledDate);
    }
    if (startDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("startDate")] = ApiClient::parameterToString(*startDate);
    }
    if (endDate)
    {
        localVarQueryParams[utility::conversions::to_string_t("endDate")] = ApiClient::parameterToString(*endDate);
    }
    if (cronExpression)
    {
        localVarQueryParams[utility::conversions::to_string_t("cronExpression")] = ApiClient::parameterToString(*cronExpression);
    }
    if (cronType)
    {
        localVarQueryParams[utility::conversions::to_string_t("cronType")] = ApiClient::parameterToString(*cronType);
    }
    if (metaData)
    {
        localVarQueryParams[utility::conversions::to_string_t("metaData")] = ApiClient::parameterToString(*metaData);
    }
    if (conditionalInput)
    {
        localVarQueryParams[utility::conversions::to_string_t("conditionalInput")] = ApiClient::parameterToString(*conditionalInput);
    }
    if (templateType)
    {
        localVarQueryParams[utility::conversions::to_string_t("templateType")] = ApiClient::parameterToString(*templateType);
    }
    if (visibility)
    {
        localVarQueryParams[utility::conversions::to_string_t("visibility")] = ApiClient::parameterToString(*visibility);
    }
    if (active)
    {
        localVarQueryParams[utility::conversions::to_string_t("active")] = ApiClient::parameterToString(*active);
    }
    if (errorMessage)
    {
        localVarQueryParams[utility::conversions::to_string_t("errorMessage")] = ApiClient::parameterToString(*errorMessage);
    }
    if (status)
    {
        localVarQueryParams[utility::conversions::to_string_t("status")] = ApiClient::parameterToString(*status);
    }
    if (updateByGroupingId)
    {
        localVarQueryParams[utility::conversions::to_string_t("updateByGroupingId")] = ApiClient::parameterToString(*updateByGroupingId);
    }
    if (sendNow)
    {
        localVarQueryParams[utility::conversions::to_string_t("sendNow")] = ApiClient::parameterToString(*sendNow);
    }
    if (eventType)
    {
        localVarQueryParams[utility::conversions::to_string_t("eventType")] = ApiClient::parameterToString(*eventType);
    }
    if (deepLinkURI)
    {
        localVarQueryParams[utility::conversions::to_string_t("deepLinkURI")] = ApiClient::parameterToString(*deepLinkURI);
    }
    if (sendToAll)
    {
        localVarQueryParams[utility::conversions::to_string_t("sendToAll")] = ApiClient::parameterToString(*sendToAll);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    utility::string_t localVarRequestHttpContentType;

    // use JSON if possible
    if ( localVarConsumeHttpContentTypes.size() == 0 || localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/json")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/json");
    }
    // multipart formdata
    else if( localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != localVarConsumeHttpContentTypes.end() )
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("multipart/form-data");
    }
    else if (localVarConsumeHttpContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != localVarConsumeHttpContentTypes.end())
    {
        localVarRequestHttpContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
    }
    else
    {
        throw ApiException(415, utility::conversions::to_string_t("ScheduledNotificationApi->updateScheduledNotification does not consume any supported media type"));
    }


    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=, this](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling updateScheduledNotification: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling updateScheduledNotification: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string();
    })
    .then([=, this](utility::string_t localVarResponse)
    {
        std::shared_ptr<ScheduledNotificationFullResponse> localVarResult(new ScheduledNotificationFullResponse());

        if(localVarResponseHttpContentType == utility::conversions::to_string_t("application/json"))
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(localVarResponseHttpContentType == utility::conversions::to_string_t("multipart/form-data"))
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling updateScheduledNotification: unsupported response type"));
        }

        return localVarResult;
    });
}

}
}
}
}

