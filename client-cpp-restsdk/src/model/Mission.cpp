/**
 * Sirqul IoT Platform
 * Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
 *
 * The version of the OpenAPI document: 3.16
 * Contact: info@sirqul.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.20.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/Mission.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

Mission::Mission()
{
    m_Id = 0L;
    m_IdIsSet = false;
    m_Active = false;
    m_ActiveIsSet = false;
    m_Valid = false;
    m_ValidIsSet = false;
    m_OwnerIsSet = false;
    m_MissionTypeIsSet = false;
    m_Title = utility::conversions::to_string_t("");
    m_TitleIsSet = false;
    m_Description = utility::conversions::to_string_t("");
    m_DescriptionIsSet = false;
    m_CostToPlay = 0;
    m_CostToPlayIsSet = false;
    m_CostToPlayType = utility::conversions::to_string_t("");
    m_CostToPlayTypeIsSet = false;
    m_GamesIsSet = false;
    m_AudiencesIsSet = false;
    m_StartDate = utility::datetime();
    m_StartDateIsSet = false;
    m_EndDate = utility::datetime();
    m_EndDateIsSet = false;
    m_SequenceTypeIsSet = false;
    m_AuthorOverride = utility::conversions::to_string_t("");
    m_AuthorOverrideIsSet = false;
    m_IconIsSet = false;
    m_ImageIsSet = false;
    m_OffersIsSet = false;
    m_VisibilityIsSet = false;
    m_TaskIsSet = false;
    m_Points = 0L;
    m_PointsIsSet = false;
    m_TicketType = utility::conversions::to_string_t("");
    m_TicketTypeIsSet = false;
    m_TicketCount = 0L;
    m_TicketCountIsSet = false;
    m_AllocateTickets = false;
    m_AllocateTicketsIsSet = false;
    m_BillableEntityIsSet = false;
    m_Balance = 0.0;
    m_BalanceIsSet = false;
    m_StartingLimit = 0;
    m_StartingLimitIsSet = false;
    m_AvailableLimit = 0;
    m_AvailableLimitIsSet = false;
    m_InviteCount = 0;
    m_InviteCountIsSet = false;
    m_AcceptedCount = 0;
    m_AcceptedCountIsSet = false;
    m_InviteStatusIsSet = false;
    m_ChildCount = 0L;
    m_ChildCountIsSet = false;
    m_SecondsBetweenLevels = 0;
    m_SecondsBetweenLevelsIsSet = false;
    m_SecondsBetweenPacks = 0;
    m_SecondsBetweenPacksIsSet = false;
    m_MaximumLevelLength = 0;
    m_MaximumLevelLengthIsSet = false;
    m_EnableBuyBack = false;
    m_EnableBuyBackIsSet = false;
    m_ActivePackIsSet = false;
    m_MinimumToPlay = 0;
    m_MinimumToPlayIsSet = false;
    m_FixedReward = false;
    m_FixedRewardIsSet = false;
    m_Refunded = false;
    m_RefundedIsSet = false;
    m_NotificationsCreated = false;
    m_NotificationsCreatedIsSet = false;
    m_Rewarded = false;
    m_RewardedIsSet = false;
    m_ExternalId = 0L;
    m_ExternalIdIsSet = false;
    m_AdvancedReporting = false;
    m_AdvancedReportingIsSet = false;
    m_SplitRewardIsSet = false;
    m_JoinCode = utility::conversions::to_string_t("");
    m_JoinCodeIsSet = false;
    m_FirstPackIsSet = false;
    m_AllGameLevelsIsSet = false;
    m_AllPacksIsSet = false;
}

Mission::~Mission()
{
}

void Mission::validate()
{
    // TODO: implement validation
}

web::json::value Mission::toJson() const
{
    web::json::value val = web::json::value::object();
    if(m_IdIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_ActiveIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("active"))] = ModelBase::toJson(m_Active);
    }
    if(m_ValidIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("valid"))] = ModelBase::toJson(m_Valid);
    }
    if(m_OwnerIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("owner"))] = ModelBase::toJson(m_Owner);
    }
    if(m_MissionTypeIsSet)
    {
        
        utility::string_t refVal = fromMissionTypeEnum(m_MissionType);
        val[utility::conversions::to_string_t(_XPLATSTR("missionType"))] = ModelBase::toJson(refVal);
        
    }
    if(m_TitleIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("title"))] = ModelBase::toJson(m_Title);
    }
    if(m_DescriptionIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("description"))] = ModelBase::toJson(m_Description);
    }
    if(m_CostToPlayIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("costToPlay"))] = ModelBase::toJson(m_CostToPlay);
    }
    if(m_CostToPlayTypeIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("costToPlayType"))] = ModelBase::toJson(m_CostToPlayType);
    }
    if(m_GamesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("games"))] = ModelBase::toJson(m_Games);
    }
    if(m_AudiencesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("audiences"))] = ModelBase::toJson(m_Audiences);
    }
    if(m_StartDateIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("startDate"))] = ModelBase::toJson(m_StartDate);
    }
    if(m_EndDateIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("endDate"))] = ModelBase::toJson(m_EndDate);
    }
    if(m_SequenceTypeIsSet)
    {
        
        utility::string_t refVal = fromSequenceTypeEnum(m_SequenceType);
        val[utility::conversions::to_string_t(_XPLATSTR("sequenceType"))] = ModelBase::toJson(refVal);
        
    }
    if(m_AuthorOverrideIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("authorOverride"))] = ModelBase::toJson(m_AuthorOverride);
    }
    if(m_IconIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("icon"))] = ModelBase::toJson(m_Icon);
    }
    if(m_ImageIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("image"))] = ModelBase::toJson(m_Image);
    }
    if(m_OffersIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("offers"))] = ModelBase::toJson(m_Offers);
    }
    if(m_VisibilityIsSet)
    {
        
        utility::string_t refVal = fromVisibilityEnum(m_Visibility);
        val[utility::conversions::to_string_t(_XPLATSTR("visibility"))] = ModelBase::toJson(refVal);
        
    }
    if(m_TaskIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("task"))] = ModelBase::toJson(m_Task);
    }
    if(m_PointsIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("points"))] = ModelBase::toJson(m_Points);
    }
    if(m_TicketTypeIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("ticketType"))] = ModelBase::toJson(m_TicketType);
    }
    if(m_TicketCountIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("ticketCount"))] = ModelBase::toJson(m_TicketCount);
    }
    if(m_AllocateTicketsIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("allocateTickets"))] = ModelBase::toJson(m_AllocateTickets);
    }
    if(m_BillableEntityIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("billableEntity"))] = ModelBase::toJson(m_BillableEntity);
    }
    if(m_BalanceIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("balance"))] = ModelBase::toJson(m_Balance);
    }
    if(m_StartingLimitIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("startingLimit"))] = ModelBase::toJson(m_StartingLimit);
    }
    if(m_AvailableLimitIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("availableLimit"))] = ModelBase::toJson(m_AvailableLimit);
    }
    if(m_InviteCountIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("inviteCount"))] = ModelBase::toJson(m_InviteCount);
    }
    if(m_AcceptedCountIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("acceptedCount"))] = ModelBase::toJson(m_AcceptedCount);
    }
    if(m_InviteStatusIsSet)
    {
        
        utility::string_t refVal = fromInviteStatusEnum(m_InviteStatus);
        val[utility::conversions::to_string_t(_XPLATSTR("inviteStatus"))] = ModelBase::toJson(refVal);
        
    }
    if(m_ChildCountIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("childCount"))] = ModelBase::toJson(m_ChildCount);
    }
    if(m_SecondsBetweenLevelsIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("secondsBetweenLevels"))] = ModelBase::toJson(m_SecondsBetweenLevels);
    }
    if(m_SecondsBetweenPacksIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("secondsBetweenPacks"))] = ModelBase::toJson(m_SecondsBetweenPacks);
    }
    if(m_MaximumLevelLengthIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("maximumLevelLength"))] = ModelBase::toJson(m_MaximumLevelLength);
    }
    if(m_EnableBuyBackIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("enableBuyBack"))] = ModelBase::toJson(m_EnableBuyBack);
    }
    if(m_ActivePackIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("activePack"))] = ModelBase::toJson(m_ActivePack);
    }
    if(m_MinimumToPlayIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("minimumToPlay"))] = ModelBase::toJson(m_MinimumToPlay);
    }
    if(m_FixedRewardIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("fixedReward"))] = ModelBase::toJson(m_FixedReward);
    }
    if(m_RefundedIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("refunded"))] = ModelBase::toJson(m_Refunded);
    }
    if(m_NotificationsCreatedIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("notificationsCreated"))] = ModelBase::toJson(m_NotificationsCreated);
    }
    if(m_RewardedIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("rewarded"))] = ModelBase::toJson(m_Rewarded);
    }
    if(m_ExternalIdIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("externalId"))] = ModelBase::toJson(m_ExternalId);
    }
    if(m_AdvancedReportingIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("advancedReporting"))] = ModelBase::toJson(m_AdvancedReporting);
    }
    if(m_SplitRewardIsSet)
    {
        
        utility::string_t refVal = fromSplitRewardEnum(m_SplitReward);
        val[utility::conversions::to_string_t(_XPLATSTR("splitReward"))] = ModelBase::toJson(refVal);
        
    }
    if(m_JoinCodeIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("joinCode"))] = ModelBase::toJson(m_JoinCode);
    }
    if(m_FirstPackIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("firstPack"))] = ModelBase::toJson(m_FirstPack);
    }
    if(m_AllGameLevelsIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("allGameLevels"))] = ModelBase::toJson(m_AllGameLevels);
    }
    if(m_AllPacksIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("allPacks"))] = ModelBase::toJson(m_AllPacks);
    }

    return val;
}

bool Mission::fromJson(const web::json::value& val)
{
    bool ok = true;
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("id")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("active"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("active")));
        if(!fieldValue.is_null())
        {
            bool refVal_setActive;
            ok &= ModelBase::fromJson(fieldValue, refVal_setActive);
            setActive(refVal_setActive);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("valid"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("valid")));
        if(!fieldValue.is_null())
        {
            bool refVal_setValid;
            ok &= ModelBase::fromJson(fieldValue, refVal_setValid);
            setValid(refVal_setValid);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("owner"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("owner")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Account> refVal_setOwner;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOwner);
            setOwner(refVal_setOwner);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("missionType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("missionType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setMissionType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMissionType);
            
            setMissionType(toMissionTypeEnum(refVal_setMissionType));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("title"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("title")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setTitle;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTitle);
            setTitle(refVal_setTitle);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("description"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("description")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setDescription;
            ok &= ModelBase::fromJson(fieldValue, refVal_setDescription);
            setDescription(refVal_setDescription);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("costToPlay"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("costToPlay")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setCostToPlay;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCostToPlay);
            setCostToPlay(refVal_setCostToPlay);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("costToPlayType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("costToPlayType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setCostToPlayType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCostToPlayType);
            setCostToPlayType(refVal_setCostToPlayType);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("games"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("games")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<Game>> refVal_setGames;
            ok &= ModelBase::fromJson(fieldValue, refVal_setGames);
            setGames(refVal_setGames);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("audiences"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("audiences")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<Audience>> refVal_setAudiences;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAudiences);
            setAudiences(refVal_setAudiences);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("startDate"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("startDate")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setStartDate;
            ok &= ModelBase::fromJson(fieldValue, refVal_setStartDate);
            setStartDate(refVal_setStartDate);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("endDate"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("endDate")));
        if(!fieldValue.is_null())
        {
            utility::datetime refVal_setEndDate;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEndDate);
            setEndDate(refVal_setEndDate);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("sequenceType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("sequenceType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSequenceType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSequenceType);
            
            setSequenceType(toSequenceTypeEnum(refVal_setSequenceType));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("authorOverride"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("authorOverride")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setAuthorOverride;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAuthorOverride);
            setAuthorOverride(refVal_setAuthorOverride);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("icon"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("icon")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Asset> refVal_setIcon;
            ok &= ModelBase::fromJson(fieldValue, refVal_setIcon);
            setIcon(refVal_setIcon);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("image"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("image")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Asset> refVal_setImage;
            ok &= ModelBase::fromJson(fieldValue, refVal_setImage);
            setImage(refVal_setImage);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("offers"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("offers")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<Offer>> refVal_setOffers;
            ok &= ModelBase::fromJson(fieldValue, refVal_setOffers);
            setOffers(refVal_setOffers);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("visibility"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("visibility")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setVisibility;
            ok &= ModelBase::fromJson(fieldValue, refVal_setVisibility);
            
            setVisibility(toVisibilityEnum(refVal_setVisibility));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("task"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("task")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<MissionTask> refVal_setTask;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTask);
            setTask(refVal_setTask);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("points"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("points")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setPoints;
            ok &= ModelBase::fromJson(fieldValue, refVal_setPoints);
            setPoints(refVal_setPoints);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("ticketType"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("ticketType")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setTicketType;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTicketType);
            setTicketType(refVal_setTicketType);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("ticketCount"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("ticketCount")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setTicketCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_setTicketCount);
            setTicketCount(refVal_setTicketCount);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("allocateTickets"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("allocateTickets")));
        if(!fieldValue.is_null())
        {
            bool refVal_setAllocateTickets;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllocateTickets);
            setAllocateTickets(refVal_setAllocateTickets);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("billableEntity"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("billableEntity")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<BillableEntity> refVal_setBillableEntity;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBillableEntity);
            setBillableEntity(refVal_setBillableEntity);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("balance"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("balance")));
        if(!fieldValue.is_null())
        {
            double refVal_setBalance;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBalance);
            setBalance(refVal_setBalance);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("startingLimit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("startingLimit")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setStartingLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setStartingLimit);
            setStartingLimit(refVal_setStartingLimit);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("availableLimit"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("availableLimit")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setAvailableLimit;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAvailableLimit);
            setAvailableLimit(refVal_setAvailableLimit);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("inviteCount"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("inviteCount")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setInviteCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInviteCount);
            setInviteCount(refVal_setInviteCount);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("acceptedCount"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("acceptedCount")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setAcceptedCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAcceptedCount);
            setAcceptedCount(refVal_setAcceptedCount);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("inviteStatus"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("inviteStatus")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setInviteStatus;
            ok &= ModelBase::fromJson(fieldValue, refVal_setInviteStatus);
            
            setInviteStatus(toInviteStatusEnum(refVal_setInviteStatus));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("childCount"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("childCount")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setChildCount;
            ok &= ModelBase::fromJson(fieldValue, refVal_setChildCount);
            setChildCount(refVal_setChildCount);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenLevels"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenLevels")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setSecondsBetweenLevels;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSecondsBetweenLevels);
            setSecondsBetweenLevels(refVal_setSecondsBetweenLevels);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenPacks"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenPacks")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setSecondsBetweenPacks;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSecondsBetweenPacks);
            setSecondsBetweenPacks(refVal_setSecondsBetweenPacks);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("maximumLevelLength"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("maximumLevelLength")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMaximumLevelLength;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMaximumLevelLength);
            setMaximumLevelLength(refVal_setMaximumLevelLength);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("enableBuyBack"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("enableBuyBack")));
        if(!fieldValue.is_null())
        {
            bool refVal_setEnableBuyBack;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEnableBuyBack);
            setEnableBuyBack(refVal_setEnableBuyBack);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("activePack"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("activePack")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Pack> refVal_setActivePack;
            ok &= ModelBase::fromJson(fieldValue, refVal_setActivePack);
            setActivePack(refVal_setActivePack);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("minimumToPlay"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("minimumToPlay")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setMinimumToPlay;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMinimumToPlay);
            setMinimumToPlay(refVal_setMinimumToPlay);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("fixedReward"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("fixedReward")));
        if(!fieldValue.is_null())
        {
            bool refVal_setFixedReward;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFixedReward);
            setFixedReward(refVal_setFixedReward);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("refunded"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("refunded")));
        if(!fieldValue.is_null())
        {
            bool refVal_setRefunded;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRefunded);
            setRefunded(refVal_setRefunded);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("notificationsCreated"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("notificationsCreated")));
        if(!fieldValue.is_null())
        {
            bool refVal_setNotificationsCreated;
            ok &= ModelBase::fromJson(fieldValue, refVal_setNotificationsCreated);
            setNotificationsCreated(refVal_setNotificationsCreated);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("rewarded"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("rewarded")));
        if(!fieldValue.is_null())
        {
            bool refVal_setRewarded;
            ok &= ModelBase::fromJson(fieldValue, refVal_setRewarded);
            setRewarded(refVal_setRewarded);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("externalId"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("externalId")));
        if(!fieldValue.is_null())
        {
            int64_t refVal_setExternalId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setExternalId);
            setExternalId(refVal_setExternalId);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("advancedReporting"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("advancedReporting")));
        if(!fieldValue.is_null())
        {
            bool refVal_setAdvancedReporting;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAdvancedReporting);
            setAdvancedReporting(refVal_setAdvancedReporting);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("splitReward"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("splitReward")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setSplitReward;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSplitReward);
            
            setSplitReward(toSplitRewardEnum(refVal_setSplitReward));
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("joinCode"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("joinCode")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setJoinCode;
            ok &= ModelBase::fromJson(fieldValue, refVal_setJoinCode);
            setJoinCode(refVal_setJoinCode);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("firstPack"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("firstPack")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<Pack> refVal_setFirstPack;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFirstPack);
            setFirstPack(refVal_setFirstPack);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("allGameLevels"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("allGameLevels")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<GameLevel>> refVal_setAllGameLevels;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllGameLevels);
            setAllGameLevels(refVal_setAllGameLevels);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("allPacks"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("allPacks")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<Pack>> refVal_setAllPacks;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAllPacks);
            setAllPacks(refVal_setAllPacks);
            
        }
    }
    return ok;
}

void Mission::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("id")), m_Id));
    }
    if(m_ActiveIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("active")), m_Active));
    }
    if(m_ValidIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("valid")), m_Valid));
    }
    if(m_OwnerIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("owner")), m_Owner));
    }
    if(m_MissionTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("missionType")), fromMissionTypeEnum(m_MissionType)));
    }
    if(m_TitleIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("title")), m_Title));
    }
    if(m_DescriptionIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("description")), m_Description));
    }
    if(m_CostToPlayIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("costToPlay")), m_CostToPlay));
    }
    if(m_CostToPlayTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("costToPlayType")), m_CostToPlayType));
    }
    if(m_GamesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("games")), m_Games));
    }
    if(m_AudiencesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("audiences")), m_Audiences));
    }
    if(m_StartDateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("startDate")), m_StartDate));
    }
    if(m_EndDateIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("endDate")), m_EndDate));
    }
    if(m_SequenceTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("sequenceType")), fromSequenceTypeEnum(m_SequenceType)));
    }
    if(m_AuthorOverrideIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("authorOverride")), m_AuthorOverride));
    }
    if(m_IconIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("icon")), m_Icon));
    }
    if(m_ImageIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("image")), m_Image));
    }
    if(m_OffersIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("offers")), m_Offers));
    }
    if(m_VisibilityIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("visibility")), fromVisibilityEnum(m_Visibility)));
    }
    if(m_TaskIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("task")), m_Task));
    }
    if(m_PointsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("points")), m_Points));
    }
    if(m_TicketTypeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("ticketType")), m_TicketType));
    }
    if(m_TicketCountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("ticketCount")), m_TicketCount));
    }
    if(m_AllocateTicketsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("allocateTickets")), m_AllocateTickets));
    }
    if(m_BillableEntityIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("billableEntity")), m_BillableEntity));
    }
    if(m_BalanceIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("balance")), m_Balance));
    }
    if(m_StartingLimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("startingLimit")), m_StartingLimit));
    }
    if(m_AvailableLimitIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("availableLimit")), m_AvailableLimit));
    }
    if(m_InviteCountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("inviteCount")), m_InviteCount));
    }
    if(m_AcceptedCountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("acceptedCount")), m_AcceptedCount));
    }
    if(m_InviteStatusIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("inviteStatus")), fromInviteStatusEnum(m_InviteStatus)));
    }
    if(m_ChildCountIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("childCount")), m_ChildCount));
    }
    if(m_SecondsBetweenLevelsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("secondsBetweenLevels")), m_SecondsBetweenLevels));
    }
    if(m_SecondsBetweenPacksIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("secondsBetweenPacks")), m_SecondsBetweenPacks));
    }
    if(m_MaximumLevelLengthIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("maximumLevelLength")), m_MaximumLevelLength));
    }
    if(m_EnableBuyBackIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("enableBuyBack")), m_EnableBuyBack));
    }
    if(m_ActivePackIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("activePack")), m_ActivePack));
    }
    if(m_MinimumToPlayIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("minimumToPlay")), m_MinimumToPlay));
    }
    if(m_FixedRewardIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("fixedReward")), m_FixedReward));
    }
    if(m_RefundedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("refunded")), m_Refunded));
    }
    if(m_NotificationsCreatedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("notificationsCreated")), m_NotificationsCreated));
    }
    if(m_RewardedIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("rewarded")), m_Rewarded));
    }
    if(m_ExternalIdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("externalId")), m_ExternalId));
    }
    if(m_AdvancedReportingIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("advancedReporting")), m_AdvancedReporting));
    }
    if(m_SplitRewardIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("splitReward")), fromSplitRewardEnum(m_SplitReward)));
    }
    if(m_JoinCodeIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("joinCode")), m_JoinCode));
    }
    if(m_FirstPackIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("firstPack")), m_FirstPack));
    }
    if(m_AllGameLevelsIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("allGameLevels")), m_AllGameLevels));
    }
    if(m_AllPacksIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("allPacks")), m_AllPacks));
    }
}

bool Mission::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("id"))))
    {
        int64_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("active"))))
    {
        bool refVal_setActive;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("active"))), refVal_setActive );
        setActive(refVal_setActive);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("valid"))))
    {
        bool refVal_setValid;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("valid"))), refVal_setValid );
        setValid(refVal_setValid);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("owner"))))
    {
        std::shared_ptr<Account> refVal_setOwner;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("owner"))), refVal_setOwner );
        setOwner(refVal_setOwner);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("missionType"))))
    {
        utility::string_t refVal_setMissionType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("missionType"))), refVal_setMissionType );
        setMissionType(toMissionTypeEnum(refVal_setMissionType));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("title"))))
    {
        utility::string_t refVal_setTitle;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("title"))), refVal_setTitle );
        setTitle(refVal_setTitle);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("description"))))
    {
        utility::string_t refVal_setDescription;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("description"))), refVal_setDescription );
        setDescription(refVal_setDescription);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("costToPlay"))))
    {
        int32_t refVal_setCostToPlay;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("costToPlay"))), refVal_setCostToPlay );
        setCostToPlay(refVal_setCostToPlay);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("costToPlayType"))))
    {
        utility::string_t refVal_setCostToPlayType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("costToPlayType"))), refVal_setCostToPlayType );
        setCostToPlayType(refVal_setCostToPlayType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("games"))))
    {
        std::vector<std::shared_ptr<Game>> refVal_setGames;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("games"))), refVal_setGames );
        setGames(refVal_setGames);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("audiences"))))
    {
        std::vector<std::shared_ptr<Audience>> refVal_setAudiences;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("audiences"))), refVal_setAudiences );
        setAudiences(refVal_setAudiences);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("startDate"))))
    {
        utility::datetime refVal_setStartDate;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("startDate"))), refVal_setStartDate );
        setStartDate(refVal_setStartDate);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("endDate"))))
    {
        utility::datetime refVal_setEndDate;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("endDate"))), refVal_setEndDate );
        setEndDate(refVal_setEndDate);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("sequenceType"))))
    {
        utility::string_t refVal_setSequenceType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("sequenceType"))), refVal_setSequenceType );
        setSequenceType(toSequenceTypeEnum(refVal_setSequenceType));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("authorOverride"))))
    {
        utility::string_t refVal_setAuthorOverride;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("authorOverride"))), refVal_setAuthorOverride );
        setAuthorOverride(refVal_setAuthorOverride);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("icon"))))
    {
        std::shared_ptr<Asset> refVal_setIcon;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("icon"))), refVal_setIcon );
        setIcon(refVal_setIcon);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("image"))))
    {
        std::shared_ptr<Asset> refVal_setImage;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("image"))), refVal_setImage );
        setImage(refVal_setImage);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("offers"))))
    {
        std::vector<std::shared_ptr<Offer>> refVal_setOffers;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("offers"))), refVal_setOffers );
        setOffers(refVal_setOffers);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("visibility"))))
    {
        utility::string_t refVal_setVisibility;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("visibility"))), refVal_setVisibility );
        setVisibility(toVisibilityEnum(refVal_setVisibility));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("task"))))
    {
        std::shared_ptr<MissionTask> refVal_setTask;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("task"))), refVal_setTask );
        setTask(refVal_setTask);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("points"))))
    {
        int64_t refVal_setPoints;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("points"))), refVal_setPoints );
        setPoints(refVal_setPoints);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("ticketType"))))
    {
        utility::string_t refVal_setTicketType;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("ticketType"))), refVal_setTicketType );
        setTicketType(refVal_setTicketType);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("ticketCount"))))
    {
        int64_t refVal_setTicketCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("ticketCount"))), refVal_setTicketCount );
        setTicketCount(refVal_setTicketCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("allocateTickets"))))
    {
        bool refVal_setAllocateTickets;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("allocateTickets"))), refVal_setAllocateTickets );
        setAllocateTickets(refVal_setAllocateTickets);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("billableEntity"))))
    {
        std::shared_ptr<BillableEntity> refVal_setBillableEntity;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("billableEntity"))), refVal_setBillableEntity );
        setBillableEntity(refVal_setBillableEntity);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("balance"))))
    {
        double refVal_setBalance;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("balance"))), refVal_setBalance );
        setBalance(refVal_setBalance);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("startingLimit"))))
    {
        int32_t refVal_setStartingLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("startingLimit"))), refVal_setStartingLimit );
        setStartingLimit(refVal_setStartingLimit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("availableLimit"))))
    {
        int32_t refVal_setAvailableLimit;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("availableLimit"))), refVal_setAvailableLimit );
        setAvailableLimit(refVal_setAvailableLimit);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("inviteCount"))))
    {
        int32_t refVal_setInviteCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("inviteCount"))), refVal_setInviteCount );
        setInviteCount(refVal_setInviteCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("acceptedCount"))))
    {
        int32_t refVal_setAcceptedCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("acceptedCount"))), refVal_setAcceptedCount );
        setAcceptedCount(refVal_setAcceptedCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("inviteStatus"))))
    {
        utility::string_t refVal_setInviteStatus;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("inviteStatus"))), refVal_setInviteStatus );
        setInviteStatus(toInviteStatusEnum(refVal_setInviteStatus));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("childCount"))))
    {
        int64_t refVal_setChildCount;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("childCount"))), refVal_setChildCount );
        setChildCount(refVal_setChildCount);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenLevels"))))
    {
        int32_t refVal_setSecondsBetweenLevels;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenLevels"))), refVal_setSecondsBetweenLevels );
        setSecondsBetweenLevels(refVal_setSecondsBetweenLevels);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenPacks"))))
    {
        int32_t refVal_setSecondsBetweenPacks;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("secondsBetweenPacks"))), refVal_setSecondsBetweenPacks );
        setSecondsBetweenPacks(refVal_setSecondsBetweenPacks);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("maximumLevelLength"))))
    {
        int32_t refVal_setMaximumLevelLength;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("maximumLevelLength"))), refVal_setMaximumLevelLength );
        setMaximumLevelLength(refVal_setMaximumLevelLength);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("enableBuyBack"))))
    {
        bool refVal_setEnableBuyBack;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("enableBuyBack"))), refVal_setEnableBuyBack );
        setEnableBuyBack(refVal_setEnableBuyBack);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("activePack"))))
    {
        std::shared_ptr<Pack> refVal_setActivePack;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("activePack"))), refVal_setActivePack );
        setActivePack(refVal_setActivePack);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("minimumToPlay"))))
    {
        int32_t refVal_setMinimumToPlay;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("minimumToPlay"))), refVal_setMinimumToPlay );
        setMinimumToPlay(refVal_setMinimumToPlay);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("fixedReward"))))
    {
        bool refVal_setFixedReward;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("fixedReward"))), refVal_setFixedReward );
        setFixedReward(refVal_setFixedReward);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("refunded"))))
    {
        bool refVal_setRefunded;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("refunded"))), refVal_setRefunded );
        setRefunded(refVal_setRefunded);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("notificationsCreated"))))
    {
        bool refVal_setNotificationsCreated;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("notificationsCreated"))), refVal_setNotificationsCreated );
        setNotificationsCreated(refVal_setNotificationsCreated);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("rewarded"))))
    {
        bool refVal_setRewarded;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("rewarded"))), refVal_setRewarded );
        setRewarded(refVal_setRewarded);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("externalId"))))
    {
        int64_t refVal_setExternalId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("externalId"))), refVal_setExternalId );
        setExternalId(refVal_setExternalId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("advancedReporting"))))
    {
        bool refVal_setAdvancedReporting;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("advancedReporting"))), refVal_setAdvancedReporting );
        setAdvancedReporting(refVal_setAdvancedReporting);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("splitReward"))))
    {
        utility::string_t refVal_setSplitReward;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("splitReward"))), refVal_setSplitReward );
        setSplitReward(toSplitRewardEnum(refVal_setSplitReward));
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("joinCode"))))
    {
        utility::string_t refVal_setJoinCode;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("joinCode"))), refVal_setJoinCode );
        setJoinCode(refVal_setJoinCode);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("firstPack"))))
    {
        std::shared_ptr<Pack> refVal_setFirstPack;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("firstPack"))), refVal_setFirstPack );
        setFirstPack(refVal_setFirstPack);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("allGameLevels"))))
    {
        std::vector<std::shared_ptr<GameLevel>> refVal_setAllGameLevels;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("allGameLevels"))), refVal_setAllGameLevels );
        setAllGameLevels(refVal_setAllGameLevels);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("allPacks"))))
    {
        std::vector<std::shared_ptr<Pack>> refVal_setAllPacks;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("allPacks"))), refVal_setAllPacks );
        setAllPacks(refVal_setAllPacks);
    }
    return ok;
}

Mission::MissionTypeEnum Mission::toMissionTypeEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("PUBLIC")) {
        return MissionTypeEnum::PUBLIC;
    }
    
    if (value == utility::conversions::to_string_t("SHARED")) {
        return MissionTypeEnum::SHARED;
    }
    
    if (value == utility::conversions::to_string_t("TOURNAMENT")) {
        return MissionTypeEnum::TOURNAMENT;
    }
    
    if (value == utility::conversions::to_string_t("POOLPLAY")) {
        return MissionTypeEnum::POOLPLAY;
    }
    
    throw std::invalid_argument("Invalid value for conversion to MissionTypeEnum");
}


const utility::string_t Mission::fromMissionTypeEnum(const MissionTypeEnum value) const
{
    switch(value)
    {
        
        case MissionTypeEnum::PUBLIC: return utility::conversions::to_string_t("PUBLIC");
        
        case MissionTypeEnum::SHARED: return utility::conversions::to_string_t("SHARED");
        
        case MissionTypeEnum::TOURNAMENT: return utility::conversions::to_string_t("TOURNAMENT");
        
        case MissionTypeEnum::POOLPLAY: return utility::conversions::to_string_t("POOLPLAY");
        
    }
}

Mission::SequenceTypeEnum Mission::toSequenceTypeEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("FIRST_AVAILABLE")) {
        return SequenceTypeEnum::FIRST_AVAILABLE;
    }
    
    if (value == utility::conversions::to_string_t("ALL_AVAILABLE")) {
        return SequenceTypeEnum::ALL_AVAILABLE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to SequenceTypeEnum");
}


const utility::string_t Mission::fromSequenceTypeEnum(const SequenceTypeEnum value) const
{
    switch(value)
    {
        
        case SequenceTypeEnum::FIRST_AVAILABLE: return utility::conversions::to_string_t("FIRST_AVAILABLE");
        
        case SequenceTypeEnum::ALL_AVAILABLE: return utility::conversions::to_string_t("ALL_AVAILABLE");
        
    }
}

Mission::VisibilityEnum Mission::toVisibilityEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("PUBLIC")) {
        return VisibilityEnum::PUBLIC;
    }
    
    if (value == utility::conversions::to_string_t("LISTABLE")) {
        return VisibilityEnum::LISTABLE;
    }
    
    if (value == utility::conversions::to_string_t("REWARDABLE")) {
        return VisibilityEnum::REWARDABLE;
    }
    
    if (value == utility::conversions::to_string_t("TRIGGERABLE")) {
        return VisibilityEnum::TRIGGERABLE;
    }
    
    if (value == utility::conversions::to_string_t("PRIVATE")) {
        return VisibilityEnum::PRIVATE;
    }
    
    throw std::invalid_argument("Invalid value for conversion to VisibilityEnum");
}


const utility::string_t Mission::fromVisibilityEnum(const VisibilityEnum value) const
{
    switch(value)
    {
        
        case VisibilityEnum::PUBLIC: return utility::conversions::to_string_t("PUBLIC");
        
        case VisibilityEnum::LISTABLE: return utility::conversions::to_string_t("LISTABLE");
        
        case VisibilityEnum::REWARDABLE: return utility::conversions::to_string_t("REWARDABLE");
        
        case VisibilityEnum::TRIGGERABLE: return utility::conversions::to_string_t("TRIGGERABLE");
        
        case VisibilityEnum::PRIVATE: return utility::conversions::to_string_t("PRIVATE");
        
    }
}

Mission::InviteStatusEnum Mission::toInviteStatusEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("AVAILABLE")) {
        return InviteStatusEnum::AVAILABLE;
    }
    
    if (value == utility::conversions::to_string_t("PENDING")) {
        return InviteStatusEnum::PENDING;
    }
    
    if (value == utility::conversions::to_string_t("UPDATED")) {
        return InviteStatusEnum::UPDATED;
    }
    
    if (value == utility::conversions::to_string_t("ACCEPTED")) {
        return InviteStatusEnum::ACCEPTED;
    }
    
    if (value == utility::conversions::to_string_t("ACTIVE")) {
        return InviteStatusEnum::ACTIVE;
    }
    
    if (value == utility::conversions::to_string_t("BUY_BACK")) {
        return InviteStatusEnum::BUY_BACK;
    }
    
    if (value == utility::conversions::to_string_t("FAILED")) {
        return InviteStatusEnum::FAILED;
    }
    
    if (value == utility::conversions::to_string_t("QUIT")) {
        return InviteStatusEnum::QUIT;
    }
    
    if (value == utility::conversions::to_string_t("COMPLETED")) {
        return InviteStatusEnum::COMPLETED;
    }
    
    if (value == utility::conversions::to_string_t("PENDING_REVIEW")) {
        return InviteStatusEnum::PENDING_REVIEW;
    }
    
    if (value == utility::conversions::to_string_t("REJECTED")) {
        return InviteStatusEnum::REJECTED;
    }
    
    throw std::invalid_argument("Invalid value for conversion to InviteStatusEnum");
}


const utility::string_t Mission::fromInviteStatusEnum(const InviteStatusEnum value) const
{
    switch(value)
    {
        
        case InviteStatusEnum::AVAILABLE: return utility::conversions::to_string_t("AVAILABLE");
        
        case InviteStatusEnum::PENDING: return utility::conversions::to_string_t("PENDING");
        
        case InviteStatusEnum::UPDATED: return utility::conversions::to_string_t("UPDATED");
        
        case InviteStatusEnum::ACCEPTED: return utility::conversions::to_string_t("ACCEPTED");
        
        case InviteStatusEnum::ACTIVE: return utility::conversions::to_string_t("ACTIVE");
        
        case InviteStatusEnum::BUY_BACK: return utility::conversions::to_string_t("BUY_BACK");
        
        case InviteStatusEnum::FAILED: return utility::conversions::to_string_t("FAILED");
        
        case InviteStatusEnum::QUIT: return utility::conversions::to_string_t("QUIT");
        
        case InviteStatusEnum::COMPLETED: return utility::conversions::to_string_t("COMPLETED");
        
        case InviteStatusEnum::PENDING_REVIEW: return utility::conversions::to_string_t("PENDING_REVIEW");
        
        case InviteStatusEnum::REJECTED: return utility::conversions::to_string_t("REJECTED");
        
    }
}

Mission::SplitRewardEnum Mission::toSplitRewardEnum(const utility::string_t& value) const
{
    
    if (value == utility::conversions::to_string_t("EVEN")) {
        return SplitRewardEnum::EVEN;
    }
    
    if (value == utility::conversions::to_string_t("ALL")) {
        return SplitRewardEnum::ALL;
    }
    
    if (value == utility::conversions::to_string_t("FIRST")) {
        return SplitRewardEnum::FIRST;
    }
    
    if (value == utility::conversions::to_string_t("RANDOM")) {
        return SplitRewardEnum::RANDOM;
    }
    
    throw std::invalid_argument("Invalid value for conversion to SplitRewardEnum");
}


const utility::string_t Mission::fromSplitRewardEnum(const SplitRewardEnum value) const
{
    switch(value)
    {
        
        case SplitRewardEnum::EVEN: return utility::conversions::to_string_t("EVEN");
        
        case SplitRewardEnum::ALL: return utility::conversions::to_string_t("ALL");
        
        case SplitRewardEnum::FIRST: return utility::conversions::to_string_t("FIRST");
        
        case SplitRewardEnum::RANDOM: return utility::conversions::to_string_t("RANDOM");
        
    }
}


int64_t Mission::getId() const
{
    return m_Id;
}

void Mission::setId(int64_t value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool Mission::idIsSet() const
{
    return m_IdIsSet;
}

void Mission::unsetId()
{
    m_IdIsSet = false;
}
bool Mission::isActive() const
{
    return m_Active;
}

void Mission::setActive(bool value)
{
    m_Active = value;
    m_ActiveIsSet = true;
}

bool Mission::activeIsSet() const
{
    return m_ActiveIsSet;
}

void Mission::unsetActive()
{
    m_ActiveIsSet = false;
}
bool Mission::isValid() const
{
    return m_Valid;
}

void Mission::setValid(bool value)
{
    m_Valid = value;
    m_ValidIsSet = true;
}

bool Mission::validIsSet() const
{
    return m_ValidIsSet;
}

void Mission::unsetValid()
{
    m_ValidIsSet = false;
}
std::shared_ptr<Account> Mission::getOwner() const
{
    return m_Owner;
}


void Mission::setOwner(const std::shared_ptr<Account>& value)
{
    m_Owner = value;
    m_OwnerIsSet = true;
}

bool Mission::ownerIsSet() const
{
    return m_OwnerIsSet;
}

void Mission::unsetOwner()
{
    m_OwnerIsSet = false;
}
Mission::MissionTypeEnum Mission::getMissionType() const
{
    return m_MissionType;
}


void Mission::setMissionType(const MissionTypeEnum value)
{
    m_MissionType = value;
    m_MissionTypeIsSet = true;
}

bool Mission::missionTypeIsSet() const
{
    return m_MissionTypeIsSet;
}

void Mission::unsetMissionType()
{
    m_MissionTypeIsSet = false;
}
utility::string_t Mission::getTitle() const
{
    return m_Title;
}


void Mission::setTitle(const utility::string_t& value)
{
    m_Title = value;
    m_TitleIsSet = true;
}

bool Mission::titleIsSet() const
{
    return m_TitleIsSet;
}

void Mission::unsetTitle()
{
    m_TitleIsSet = false;
}
utility::string_t Mission::getDescription() const
{
    return m_Description;
}


void Mission::setDescription(const utility::string_t& value)
{
    m_Description = value;
    m_DescriptionIsSet = true;
}

bool Mission::descriptionIsSet() const
{
    return m_DescriptionIsSet;
}

void Mission::unsetDescription()
{
    m_DescriptionIsSet = false;
}
int32_t Mission::getCostToPlay() const
{
    return m_CostToPlay;
}

void Mission::setCostToPlay(int32_t value)
{
    m_CostToPlay = value;
    m_CostToPlayIsSet = true;
}

bool Mission::costToPlayIsSet() const
{
    return m_CostToPlayIsSet;
}

void Mission::unsetCostToPlay()
{
    m_CostToPlayIsSet = false;
}
utility::string_t Mission::getCostToPlayType() const
{
    return m_CostToPlayType;
}


void Mission::setCostToPlayType(const utility::string_t& value)
{
    m_CostToPlayType = value;
    m_CostToPlayTypeIsSet = true;
}

bool Mission::costToPlayTypeIsSet() const
{
    return m_CostToPlayTypeIsSet;
}

void Mission::unsetCostToPlayType()
{
    m_CostToPlayTypeIsSet = false;
}
std::vector<std::shared_ptr<Game>> Mission::getGames() const
{
    return m_Games;
}


void Mission::setGames(const std::vector<std::shared_ptr<Game>>& value)
{
    m_Games = value;
    m_GamesIsSet = true;
}

bool Mission::gamesIsSet() const
{
    return m_GamesIsSet;
}

void Mission::unsetGames()
{
    m_GamesIsSet = false;
}
std::vector<std::shared_ptr<Audience>> Mission::getAudiences() const
{
    return m_Audiences;
}


void Mission::setAudiences(const std::vector<std::shared_ptr<Audience>>& value)
{
    m_Audiences = value;
    m_AudiencesIsSet = true;
}

bool Mission::audiencesIsSet() const
{
    return m_AudiencesIsSet;
}

void Mission::unsetAudiences()
{
    m_AudiencesIsSet = false;
}
utility::datetime Mission::getStartDate() const
{
    return m_StartDate;
}


void Mission::setStartDate(const utility::datetime& value)
{
    m_StartDate = value;
    m_StartDateIsSet = true;
}

bool Mission::startDateIsSet() const
{
    return m_StartDateIsSet;
}

void Mission::unsetStartDate()
{
    m_StartDateIsSet = false;
}
utility::datetime Mission::getEndDate() const
{
    return m_EndDate;
}


void Mission::setEndDate(const utility::datetime& value)
{
    m_EndDate = value;
    m_EndDateIsSet = true;
}

bool Mission::endDateIsSet() const
{
    return m_EndDateIsSet;
}

void Mission::unsetEndDate()
{
    m_EndDateIsSet = false;
}
Mission::SequenceTypeEnum Mission::getSequenceType() const
{
    return m_SequenceType;
}


void Mission::setSequenceType(const SequenceTypeEnum value)
{
    m_SequenceType = value;
    m_SequenceTypeIsSet = true;
}

bool Mission::sequenceTypeIsSet() const
{
    return m_SequenceTypeIsSet;
}

void Mission::unsetSequenceType()
{
    m_SequenceTypeIsSet = false;
}
utility::string_t Mission::getAuthorOverride() const
{
    return m_AuthorOverride;
}


void Mission::setAuthorOverride(const utility::string_t& value)
{
    m_AuthorOverride = value;
    m_AuthorOverrideIsSet = true;
}

bool Mission::authorOverrideIsSet() const
{
    return m_AuthorOverrideIsSet;
}

void Mission::unsetAuthorOverride()
{
    m_AuthorOverrideIsSet = false;
}
std::shared_ptr<Asset> Mission::getIcon() const
{
    return m_Icon;
}


void Mission::setIcon(const std::shared_ptr<Asset>& value)
{
    m_Icon = value;
    m_IconIsSet = true;
}

bool Mission::iconIsSet() const
{
    return m_IconIsSet;
}

void Mission::unsetIcon()
{
    m_IconIsSet = false;
}
std::shared_ptr<Asset> Mission::getImage() const
{
    return m_Image;
}


void Mission::setImage(const std::shared_ptr<Asset>& value)
{
    m_Image = value;
    m_ImageIsSet = true;
}

bool Mission::imageIsSet() const
{
    return m_ImageIsSet;
}

void Mission::unsetImage()
{
    m_ImageIsSet = false;
}
std::vector<std::shared_ptr<Offer>> Mission::getOffers() const
{
    return m_Offers;
}


void Mission::setOffers(const std::vector<std::shared_ptr<Offer>>& value)
{
    m_Offers = value;
    m_OffersIsSet = true;
}

bool Mission::offersIsSet() const
{
    return m_OffersIsSet;
}

void Mission::unsetOffers()
{
    m_OffersIsSet = false;
}
Mission::VisibilityEnum Mission::getVisibility() const
{
    return m_Visibility;
}


void Mission::setVisibility(const VisibilityEnum value)
{
    m_Visibility = value;
    m_VisibilityIsSet = true;
}

bool Mission::visibilityIsSet() const
{
    return m_VisibilityIsSet;
}

void Mission::unsetVisibility()
{
    m_VisibilityIsSet = false;
}
std::shared_ptr<MissionTask> Mission::getTask() const
{
    return m_Task;
}


void Mission::setTask(const std::shared_ptr<MissionTask>& value)
{
    m_Task = value;
    m_TaskIsSet = true;
}

bool Mission::taskIsSet() const
{
    return m_TaskIsSet;
}

void Mission::unsetTask()
{
    m_TaskIsSet = false;
}
int64_t Mission::getPoints() const
{
    return m_Points;
}

void Mission::setPoints(int64_t value)
{
    m_Points = value;
    m_PointsIsSet = true;
}

bool Mission::pointsIsSet() const
{
    return m_PointsIsSet;
}

void Mission::unsetPoints()
{
    m_PointsIsSet = false;
}
utility::string_t Mission::getTicketType() const
{
    return m_TicketType;
}


void Mission::setTicketType(const utility::string_t& value)
{
    m_TicketType = value;
    m_TicketTypeIsSet = true;
}

bool Mission::ticketTypeIsSet() const
{
    return m_TicketTypeIsSet;
}

void Mission::unsetTicketType()
{
    m_TicketTypeIsSet = false;
}
int64_t Mission::getTicketCount() const
{
    return m_TicketCount;
}

void Mission::setTicketCount(int64_t value)
{
    m_TicketCount = value;
    m_TicketCountIsSet = true;
}

bool Mission::ticketCountIsSet() const
{
    return m_TicketCountIsSet;
}

void Mission::unsetTicketCount()
{
    m_TicketCountIsSet = false;
}
bool Mission::isAllocateTickets() const
{
    return m_AllocateTickets;
}

void Mission::setAllocateTickets(bool value)
{
    m_AllocateTickets = value;
    m_AllocateTicketsIsSet = true;
}

bool Mission::allocateTicketsIsSet() const
{
    return m_AllocateTicketsIsSet;
}

void Mission::unsetAllocateTickets()
{
    m_AllocateTicketsIsSet = false;
}
std::shared_ptr<BillableEntity> Mission::getBillableEntity() const
{
    return m_BillableEntity;
}


void Mission::setBillableEntity(const std::shared_ptr<BillableEntity>& value)
{
    m_BillableEntity = value;
    m_BillableEntityIsSet = true;
}

bool Mission::billableEntityIsSet() const
{
    return m_BillableEntityIsSet;
}

void Mission::unsetBillableEntity()
{
    m_BillableEntityIsSet = false;
}
double Mission::getBalance() const
{
    return m_Balance;
}

void Mission::setBalance(double value)
{
    m_Balance = value;
    m_BalanceIsSet = true;
}

bool Mission::balanceIsSet() const
{
    return m_BalanceIsSet;
}

void Mission::unsetBalance()
{
    m_BalanceIsSet = false;
}
int32_t Mission::getStartingLimit() const
{
    return m_StartingLimit;
}

void Mission::setStartingLimit(int32_t value)
{
    m_StartingLimit = value;
    m_StartingLimitIsSet = true;
}

bool Mission::startingLimitIsSet() const
{
    return m_StartingLimitIsSet;
}

void Mission::unsetStartingLimit()
{
    m_StartingLimitIsSet = false;
}
int32_t Mission::getAvailableLimit() const
{
    return m_AvailableLimit;
}

void Mission::setAvailableLimit(int32_t value)
{
    m_AvailableLimit = value;
    m_AvailableLimitIsSet = true;
}

bool Mission::availableLimitIsSet() const
{
    return m_AvailableLimitIsSet;
}

void Mission::unsetAvailableLimit()
{
    m_AvailableLimitIsSet = false;
}
int32_t Mission::getInviteCount() const
{
    return m_InviteCount;
}

void Mission::setInviteCount(int32_t value)
{
    m_InviteCount = value;
    m_InviteCountIsSet = true;
}

bool Mission::inviteCountIsSet() const
{
    return m_InviteCountIsSet;
}

void Mission::unsetInviteCount()
{
    m_InviteCountIsSet = false;
}
int32_t Mission::getAcceptedCount() const
{
    return m_AcceptedCount;
}

void Mission::setAcceptedCount(int32_t value)
{
    m_AcceptedCount = value;
    m_AcceptedCountIsSet = true;
}

bool Mission::acceptedCountIsSet() const
{
    return m_AcceptedCountIsSet;
}

void Mission::unsetAcceptedCount()
{
    m_AcceptedCountIsSet = false;
}
Mission::InviteStatusEnum Mission::getInviteStatus() const
{
    return m_InviteStatus;
}


void Mission::setInviteStatus(const InviteStatusEnum value)
{
    m_InviteStatus = value;
    m_InviteStatusIsSet = true;
}

bool Mission::inviteStatusIsSet() const
{
    return m_InviteStatusIsSet;
}

void Mission::unsetInviteStatus()
{
    m_InviteStatusIsSet = false;
}
int64_t Mission::getChildCount() const
{
    return m_ChildCount;
}

void Mission::setChildCount(int64_t value)
{
    m_ChildCount = value;
    m_ChildCountIsSet = true;
}

bool Mission::childCountIsSet() const
{
    return m_ChildCountIsSet;
}

void Mission::unsetChildCount()
{
    m_ChildCountIsSet = false;
}
int32_t Mission::getSecondsBetweenLevels() const
{
    return m_SecondsBetweenLevels;
}

void Mission::setSecondsBetweenLevels(int32_t value)
{
    m_SecondsBetweenLevels = value;
    m_SecondsBetweenLevelsIsSet = true;
}

bool Mission::secondsBetweenLevelsIsSet() const
{
    return m_SecondsBetweenLevelsIsSet;
}

void Mission::unsetSecondsBetweenLevels()
{
    m_SecondsBetweenLevelsIsSet = false;
}
int32_t Mission::getSecondsBetweenPacks() const
{
    return m_SecondsBetweenPacks;
}

void Mission::setSecondsBetweenPacks(int32_t value)
{
    m_SecondsBetweenPacks = value;
    m_SecondsBetweenPacksIsSet = true;
}

bool Mission::secondsBetweenPacksIsSet() const
{
    return m_SecondsBetweenPacksIsSet;
}

void Mission::unsetSecondsBetweenPacks()
{
    m_SecondsBetweenPacksIsSet = false;
}
int32_t Mission::getMaximumLevelLength() const
{
    return m_MaximumLevelLength;
}

void Mission::setMaximumLevelLength(int32_t value)
{
    m_MaximumLevelLength = value;
    m_MaximumLevelLengthIsSet = true;
}

bool Mission::maximumLevelLengthIsSet() const
{
    return m_MaximumLevelLengthIsSet;
}

void Mission::unsetMaximumLevelLength()
{
    m_MaximumLevelLengthIsSet = false;
}
bool Mission::isEnableBuyBack() const
{
    return m_EnableBuyBack;
}

void Mission::setEnableBuyBack(bool value)
{
    m_EnableBuyBack = value;
    m_EnableBuyBackIsSet = true;
}

bool Mission::enableBuyBackIsSet() const
{
    return m_EnableBuyBackIsSet;
}

void Mission::unsetEnableBuyBack()
{
    m_EnableBuyBackIsSet = false;
}
std::shared_ptr<Pack> Mission::getActivePack() const
{
    return m_ActivePack;
}


void Mission::setActivePack(const std::shared_ptr<Pack>& value)
{
    m_ActivePack = value;
    m_ActivePackIsSet = true;
}

bool Mission::activePackIsSet() const
{
    return m_ActivePackIsSet;
}

void Mission::unsetActivePack()
{
    m_ActivePackIsSet = false;
}
int32_t Mission::getMinimumToPlay() const
{
    return m_MinimumToPlay;
}

void Mission::setMinimumToPlay(int32_t value)
{
    m_MinimumToPlay = value;
    m_MinimumToPlayIsSet = true;
}

bool Mission::minimumToPlayIsSet() const
{
    return m_MinimumToPlayIsSet;
}

void Mission::unsetMinimumToPlay()
{
    m_MinimumToPlayIsSet = false;
}
bool Mission::isFixedReward() const
{
    return m_FixedReward;
}

void Mission::setFixedReward(bool value)
{
    m_FixedReward = value;
    m_FixedRewardIsSet = true;
}

bool Mission::fixedRewardIsSet() const
{
    return m_FixedRewardIsSet;
}

void Mission::unsetFixedReward()
{
    m_FixedRewardIsSet = false;
}
bool Mission::isRefunded() const
{
    return m_Refunded;
}

void Mission::setRefunded(bool value)
{
    m_Refunded = value;
    m_RefundedIsSet = true;
}

bool Mission::refundedIsSet() const
{
    return m_RefundedIsSet;
}

void Mission::unsetRefunded()
{
    m_RefundedIsSet = false;
}
bool Mission::isNotificationsCreated() const
{
    return m_NotificationsCreated;
}

void Mission::setNotificationsCreated(bool value)
{
    m_NotificationsCreated = value;
    m_NotificationsCreatedIsSet = true;
}

bool Mission::notificationsCreatedIsSet() const
{
    return m_NotificationsCreatedIsSet;
}

void Mission::unsetNotificationsCreated()
{
    m_NotificationsCreatedIsSet = false;
}
bool Mission::isRewarded() const
{
    return m_Rewarded;
}

void Mission::setRewarded(bool value)
{
    m_Rewarded = value;
    m_RewardedIsSet = true;
}

bool Mission::rewardedIsSet() const
{
    return m_RewardedIsSet;
}

void Mission::unsetRewarded()
{
    m_RewardedIsSet = false;
}
int64_t Mission::getExternalId() const
{
    return m_ExternalId;
}

void Mission::setExternalId(int64_t value)
{
    m_ExternalId = value;
    m_ExternalIdIsSet = true;
}

bool Mission::externalIdIsSet() const
{
    return m_ExternalIdIsSet;
}

void Mission::unsetExternalId()
{
    m_ExternalIdIsSet = false;
}
bool Mission::isAdvancedReporting() const
{
    return m_AdvancedReporting;
}

void Mission::setAdvancedReporting(bool value)
{
    m_AdvancedReporting = value;
    m_AdvancedReportingIsSet = true;
}

bool Mission::advancedReportingIsSet() const
{
    return m_AdvancedReportingIsSet;
}

void Mission::unsetAdvancedReporting()
{
    m_AdvancedReportingIsSet = false;
}
Mission::SplitRewardEnum Mission::getSplitReward() const
{
    return m_SplitReward;
}


void Mission::setSplitReward(const SplitRewardEnum value)
{
    m_SplitReward = value;
    m_SplitRewardIsSet = true;
}

bool Mission::splitRewardIsSet() const
{
    return m_SplitRewardIsSet;
}

void Mission::unsetSplitReward()
{
    m_SplitRewardIsSet = false;
}
utility::string_t Mission::getJoinCode() const
{
    return m_JoinCode;
}


void Mission::setJoinCode(const utility::string_t& value)
{
    m_JoinCode = value;
    m_JoinCodeIsSet = true;
}

bool Mission::joinCodeIsSet() const
{
    return m_JoinCodeIsSet;
}

void Mission::unsetJoinCode()
{
    m_JoinCodeIsSet = false;
}
std::shared_ptr<Pack> Mission::getFirstPack() const
{
    return m_FirstPack;
}


void Mission::setFirstPack(const std::shared_ptr<Pack>& value)
{
    m_FirstPack = value;
    m_FirstPackIsSet = true;
}

bool Mission::firstPackIsSet() const
{
    return m_FirstPackIsSet;
}

void Mission::unsetFirstPack()
{
    m_FirstPackIsSet = false;
}
std::vector<std::shared_ptr<GameLevel>> Mission::getAllGameLevels() const
{
    return m_AllGameLevels;
}


void Mission::setAllGameLevels(const std::vector<std::shared_ptr<GameLevel>>& value)
{
    m_AllGameLevels = value;
    m_AllGameLevelsIsSet = true;
}

bool Mission::allGameLevelsIsSet() const
{
    return m_AllGameLevelsIsSet;
}

void Mission::unsetAllGameLevels()
{
    m_AllGameLevelsIsSet = false;
}
std::vector<std::shared_ptr<Pack>> Mission::getAllPacks() const
{
    return m_AllPacks;
}


void Mission::setAllPacks(const std::vector<std::shared_ptr<Pack>>& value)
{
    m_AllPacks = value;
    m_AllPacksIsSet = true;
}

bool Mission::allPacksIsSet() const
{
    return m_AllPacksIsSet;
}

void Mission::unsetAllPacks()
{
    m_AllPacksIsSet = false;
}

}
}
}
}


