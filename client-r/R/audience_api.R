#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Audience operations
#' @description AudienceApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateAudience  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_name <- "name_example" # character | The name of the audience
#' var_description <- "description_example" # character | The description of the audience (Optional)
#' var_search_tags <- "search_tags_example" # character | The search tags (Optional)
#' var_gender <- "gender_example" # character | The gender; possible values are: MALE, FEMALE, ANY (Optional)
#' var_age_groups <- "age_groups_example" # character | The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (Optional)
#' var_category_ids <- "category_ids_example" # character | The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (Optional)
#' var_application_ids <- "application_ids_example" # character | The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (Optional)
#' var_game_experience_level <- "game_experience_level_example" # character | The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (Optional)
#' var_devices <- "devices_example" # character | (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (Optional)
#' var_device_ids <- "device_ids_example" # character | The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (Optional)
#' var_device_versions <- "device_versions_example" # character | The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (Optional)
#' var_locations <- "locations_example" # character | The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (Optional)
#' var_radius <- "radius_example" # character | The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (Optional)
#' var_start_time_offset <- 56 # integer | Seconds from the start time of an event (Optional)
#' var_end_time_offset <- 56 # integer | Seconds from the end time of an event (Optional)
#' var_send_suggestion <- TRUE # character | If true, then notify matching users when they are inside the radius (Optional)
#' var_associate_description <- "associate_description_example" # character | The description of the associated object (Optional)
#' var_associate_type <- "associate_type_example" # character | The type of the object to center the audience geofence (Optional)
#' var_associate_id <- 56 # integer | The ID of the object to center the audience geofence (Optional)
#' var_grouping_id <- "grouping_id_example" # character | Optional grouping id for the audience (Optional)
#' var_meta_data <- "meta_data_example" # character | External custom client defined data (Optional)
#' var_visibility <- "visibility_example" # character | Visibility of the audience (Optional)
#' var_audience_type <- "audience_type_example" # character | Type of audience (Optional)
#' var_use_order <- "use_order_example" # character | Use order for cohort (Optional)
#' var_cohort_regions_data <- "cohort_regions_data_example" # character | Cohort data for \"cohort\" audience type (Optional)
#' var_app_key <- "app_key_example" # character | Filter results by application key (Optional)
#' var_trilateration_types <- "trilateration_types_example" # character | Trilateration types (Optional)
#' var_unique_name <- "unique_name_example" # character | If true, makes sure the audience name is unique (Optional)
#'
#' #Create Audience
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateAudience(var_account_id, var_name, description = var_description, search_tags = var_search_tags, gender = var_gender, age_groups = var_age_groups, category_ids = var_category_ids, application_ids = var_application_ids, game_experience_level = var_game_experience_level, devices = var_devices, device_ids = var_device_ids, device_versions = var_device_versions, locations = var_locations, radius = var_radius, start_time_offset = var_start_time_offset, end_time_offset = var_end_time_offset, send_suggestion = var_send_suggestion, associate_description = var_associate_description, associate_type = var_associate_type, associate_id = var_associate_id, grouping_id = var_grouping_id, meta_data = var_meta_data, visibility = var_visibility, audience_type = var_audience_type, use_order = var_use_order, cohort_regions_data = var_cohort_regions_data, app_key = var_app_key, trilateration_types = var_trilateration_types, unique_name = var_unique_namedata_file = "result.txt")
#' result <- api_instance$CreateAudience(var_account_id, var_name, description = var_description, search_tags = var_search_tags, gender = var_gender, age_groups = var_age_groups, category_ids = var_category_ids, application_ids = var_application_ids, game_experience_level = var_game_experience_level, devices = var_devices, device_ids = var_device_ids, device_versions = var_device_versions, locations = var_locations, radius = var_radius, start_time_offset = var_start_time_offset, end_time_offset = var_end_time_offset, send_suggestion = var_send_suggestion, associate_description = var_associate_description, associate_type = var_associate_type, associate_id = var_associate_id, grouping_id = var_grouping_id, meta_data = var_meta_data, visibility = var_visibility, audience_type = var_audience_type, use_order = var_use_order, cohort_regions_data = var_cohort_regions_data, app_key = var_app_key, trilateration_types = var_trilateration_types, unique_name = var_unique_name)
#' dput(result)
#'
#'
#' ####################  DeleteAudience  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_audience_id <- 56 # integer | The id of the audience to delete.
#'
#' #Delete Audience
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteAudience(var_account_id, var_audience_iddata_file = "result.txt")
#' result <- api_instance$DeleteAudience(var_account_id, var_audience_id)
#' dput(result)
#'
#'
#' ####################  GetAgeGroups  ####################
#'
#' library(openapi)
#'
#' #Get Age Groups
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetAgeGroups(data_file = "result.txt")
#' result <- api_instance$GetAgeGroups()
#' dput(result)
#'
#'
#' ####################  GetAudience  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_audience_id <- 56 # integer | The id of the audience to return.
#' var_app_key <- "app_key_example" # character | The application key (optional). If provided, results may be scoped to this application. (Optional)
#' var_return_account_count <- FALSE # character | (boolean) set to true to include the accountCount associated with current audience of the current app (Optional)
#' var_return_album_count <- FALSE # character | (boolean) set to true to include the albumCount associated with current audience of the current app (Optional)
#' var_album_types_for_count <- "album_types_for_count_example" # character | (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned. (Optional)
#'
#' #Get Audience
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetAudience(var_account_id, var_audience_id, app_key = var_app_key, return_account_count = var_return_account_count, return_album_count = var_return_album_count, album_types_for_count = var_album_types_for_countdata_file = "result.txt")
#' result <- api_instance$GetAudience(var_account_id, var_audience_id, app_key = var_app_key, return_account_count = var_return_account_count, return_album_count = var_return_album_count, album_types_for_count = var_album_types_for_count)
#' dput(result)
#'
#'
#' ####################  GetAudienceList  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user. (Optional)
#' var_album_ids <- "album_ids_example" # character | Comma separated list of album IDs to filter results with (Optional)
#' var_keyword <- "keyword_example" # character | The keyword used to search (Optional)
#' var_keyword_fields <- "SEARCH_TAGS,NAME,DESCRIPTION" # character | Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (Optional)
#' var_sort_field <- "NAME" # character | The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (Optional)
#' var_descending <- FALSE # character | The order to return the results. Default is false, which will return the results in ascending order. (Optional)
#' var_start <- 0 # integer | The index into the record set to start with. (Optional)
#' var_limit <- 20 # integer | The total number of record to return (there is a hard limit of 100). (Optional)
#' var_send_suggestion <- "send_suggestion_example" # character | Filter results based on whether or not the audience is set to send suggestions (Optional)
#' var_active_only <- "active_only_example" # character | Determines whether to return only active results. Default is false. (Optional)
#' var_group_by_grouping_id <- "group_by_grouping_id_example" # character | Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal) (Optional)
#' var_app_key <- "app_key_example" # character | Filter results by application key (Optional)
#' var_return_global <- "return_global_example" # character | If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well (Optional)
#' var_exact_keyword <- "exact_keyword_example" # character | If true, match keyword exactly (Optional)
#' var_audience_type <- "audience_type_example" # character | (Deprecated) Filter results by audience type (Optional)
#' var_audience_types <- "audience_types_example" # character | comma separated string with the different audience types you want to filter for (Optional)
#' var_return_account_count <- FALSE # character | (boolean) set to true to include the accountCount associated with current audience of the current app (Optional)
#' var_return_album_count <- FALSE # character | (boolean) set to true to include the albumCount associated with current audience of the current app (Optional)
#' var_album_types_for_count <- "album_types_for_count_example" # character | (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned. (Optional)
#'
#' #Search Audiences
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetAudienceList(account_id = var_account_id, album_ids = var_album_ids, keyword = var_keyword, keyword_fields = var_keyword_fields, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, send_suggestion = var_send_suggestion, active_only = var_active_only, group_by_grouping_id = var_group_by_grouping_id, app_key = var_app_key, return_global = var_return_global, exact_keyword = var_exact_keyword, audience_type = var_audience_type, audience_types = var_audience_types, return_account_count = var_return_account_count, return_album_count = var_return_album_count, album_types_for_count = var_album_types_for_countdata_file = "result.txt")
#' result <- api_instance$GetAudienceList(account_id = var_account_id, album_ids = var_album_ids, keyword = var_keyword, keyword_fields = var_keyword_fields, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, send_suggestion = var_send_suggestion, active_only = var_active_only, group_by_grouping_id = var_group_by_grouping_id, app_key = var_app_key, return_global = var_return_global, exact_keyword = var_exact_keyword, audience_type = var_audience_type, audience_types = var_audience_types, return_account_count = var_return_account_count, return_album_count = var_return_album_count, album_types_for_count = var_album_types_for_count)
#' dput(result)
#'
#'
#' ####################  GetDevices  ####################
#'
#' library(openapi)
#' var_include_inactive <- "include_inactive_example" # character | If true return inactive record as well. default is false.
#'
#' #Get Devices
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetDevices(var_include_inactivedata_file = "result.txt")
#' result <- api_instance$GetDevices(var_include_inactive)
#' dput(result)
#'
#'
#' ####################  GetExperiences  ####################
#'
#' library(openapi)
#'
#' #Get Experiences
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetExperiences(data_file = "result.txt")
#' result <- api_instance$GetExperiences()
#' dput(result)
#'
#'
#' ####################  GetGroupedAudiences  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_audience_grouping_id <- "audience_grouping_id_example" # character | The audience grouping id to return.
#'
#' #Get GroupedAudiences
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetGroupedAudiences(var_account_id, var_audience_grouping_iddata_file = "result.txt")
#' result <- api_instance$GetGroupedAudiences(var_account_id, var_audience_grouping_id)
#' dput(result)
#'
#'
#' ####################  ListByAccount  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account to match offers for.
#' var_limit <- 56 # integer | the limit of the index
#' var_suggestion_type <- "suggestion_type_example" # character | the type of suggestion
#'
#' #List Suggestions by Audience
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ListByAccount(var_account_id, var_limit, var_suggestion_typedata_file = "result.txt")
#' result <- api_instance$ListByAccount(var_account_id, var_limit, var_suggestion_type)
#' dput(result)
#'
#'
#' ####################  ListByAudience  ####################
#'
#' library(openapi)
#' var_limit <- 56 # integer | this is the limit of the index
#' var_gender <- "gender_example" # character | this is the gender to list offers by (Optional)
#' var_age <- 56 # integer | this is the age to list offers by (Optional)
#' var_category_ids <- "category_ids_example" # character | this is the category IDs to list offers by (Optional)
#' var_latitude <- 3.4 # numeric | this is the latitude to list offers by (Optional)
#' var_longitude <- 3.4 # numeric | this is the longitude to list offers by (Optional)
#'
#' #List Offers by Audience
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ListByAudience(var_limit, gender = var_gender, age = var_age, category_ids = var_category_ids, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$ListByAudience(var_limit, gender = var_gender, age = var_age, category_ids = var_category_ids, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  ListLastestByAccount  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account to match offers for.
#' var_timeframe <- 56 # integer | The timeframe in seconds of the latest suggestions
#' var_suggestion_type <- "suggestion_type_example" # character | The type of trigger suggestions to return
#'
#' #List Sent Suggestions 
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ListLastestByAccount(var_account_id, var_timeframe, var_suggestion_typedata_file = "result.txt")
#' result <- api_instance$ListLastestByAccount(var_account_id, var_timeframe, var_suggestion_type)
#' dput(result)
#'
#'
#' ####################  SendByAccount  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account to match offers for.
#' var_latitude <- 3.4 # numeric | the latitude
#' var_longitude <- 3.4 # numeric | the longitude
#'
#' #Send Suggestions
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SendByAccount(var_account_id, var_latitude, var_longitudedata_file = "result.txt")
#' result <- api_instance$SendByAccount(var_account_id, var_latitude, var_longitude)
#' dput(result)
#'
#'
#' ####################  UpdateAudience  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_audience_id <- 56 # integer | The id of the audience to update.
#' var_name <- "name_example" # character | The name of the audience (Optional)
#' var_description <- "description_example" # character | The description of the audience (Optional)
#' var_search_tags <- "search_tags_example" # character | The search tags (Optional)
#' var_gender <- "gender_example" # character | The gender; possible values are: MALE, FEMALE, ANY (Optional)
#' var_age_groups <- "age_groups_example" # character | The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none) (Optional)
#' var_category_ids <- "category_ids_example" # character | The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values) (Optional)
#' var_application_ids <- "application_ids_example" # character | The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values) (Optional)
#' var_game_experience_level <- "game_experience_level_example" # character | The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT (Optional)
#' var_devices <- "devices_example" # character | (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values) (Optional)
#' var_device_ids <- "device_ids_example" # character | The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values) (Optional)
#' var_device_versions <- "device_versions_example" # character | The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4) (Optional)
#' var_locations <- "locations_example" # character | The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2) (Optional)
#' var_radius <- "radius_example" # character | The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair. (Optional)
#' var_active <- "active_example" # character | if audience is active (Optional)
#' var_send_suggestion <- "send_suggestion_example" # character | If true, then notify matching users when they are inside the radius (Optional)
#' var_start_time_offset <- 56 # integer | Seconds from the start time of an event (Optional)
#' var_end_time_offset <- 56 # integer | Seconds from the end time of an event (Optional)
#' var_associate_description <- "associate_description_example" # character | the associate description (Optional)
#' var_associate_type <- "associate_type_example" # character | The type of the object to center the audience geofence (Optional)
#' var_associate_id <- 56 # integer | The ID of the object to center the audience geofence (Optional)
#' var_grouping_id <- "grouping_id_example" # character | Optional grouping id for the audience (Optional)
#' var_meta_data <- "meta_data_example" # character | External custom client defined data (Optional)
#' var_visibility <- "visibility_example" # character | Visibility of the audience (Optional)
#' var_audience_type <- "audience_type_example" # character | Type of audience (Optional)
#' var_use_order <- "use_order_example" # character | Use order for cohort (Optional)
#' var_cohort_regions_data <- "cohort_regions_data_example" # character | Cohort data for \"cohort\" audience type (Optional)
#' var_app_key <- "app_key_example" # character | Filter results by application key (Optional)
#' var_trilateration_types <- "trilateration_types_example" # character | Trilateration types (Optional)
#' var_unique_name <- "unique_name_example" # character | If true, makes sure the audience name is unique (Optional)
#'
#' #Update Audience
#' api_instance <- AudienceApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateAudience(var_account_id, var_audience_id, name = var_name, description = var_description, search_tags = var_search_tags, gender = var_gender, age_groups = var_age_groups, category_ids = var_category_ids, application_ids = var_application_ids, game_experience_level = var_game_experience_level, devices = var_devices, device_ids = var_device_ids, device_versions = var_device_versions, locations = var_locations, radius = var_radius, active = var_active, send_suggestion = var_send_suggestion, start_time_offset = var_start_time_offset, end_time_offset = var_end_time_offset, associate_description = var_associate_description, associate_type = var_associate_type, associate_id = var_associate_id, grouping_id = var_grouping_id, meta_data = var_meta_data, visibility = var_visibility, audience_type = var_audience_type, use_order = var_use_order, cohort_regions_data = var_cohort_regions_data, app_key = var_app_key, trilateration_types = var_trilateration_types, unique_name = var_unique_namedata_file = "result.txt")
#' result <- api_instance$UpdateAudience(var_account_id, var_audience_id, name = var_name, description = var_description, search_tags = var_search_tags, gender = var_gender, age_groups = var_age_groups, category_ids = var_category_ids, application_ids = var_application_ids, game_experience_level = var_game_experience_level, devices = var_devices, device_ids = var_device_ids, device_versions = var_device_versions, locations = var_locations, radius = var_radius, active = var_active, send_suggestion = var_send_suggestion, start_time_offset = var_start_time_offset, end_time_offset = var_end_time_offset, associate_description = var_associate_description, associate_type = var_associate_type, associate_id = var_associate_id, grouping_id = var_grouping_id, meta_data = var_meta_data, visibility = var_visibility, audience_type = var_audience_type, use_order = var_use_order, cohort_regions_data = var_cohort_regions_data, app_key = var_app_key, trilateration_types = var_trilateration_types, unique_name = var_unique_name)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
AudienceApi <- R6::R6Class(
  "AudienceApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new AudienceApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Audience
    #'
    #' @param account_id The logged in user.
    #' @param name The name of the audience
    #' @param description (optional) The description of the audience
    #' @param search_tags (optional) The search tags
    #' @param gender (optional) The gender; possible values are: MALE, FEMALE, ANY
    #' @param age_groups (optional) The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    #' @param category_ids (optional) The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    #' @param application_ids (optional) The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    #' @param game_experience_level (optional) The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    #' @param devices (optional) (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    #' @param device_ids (optional) The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    #' @param device_versions (optional) The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    #' @param locations (optional) The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    #' @param radius (optional) The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    #' @param start_time_offset (optional) Seconds from the start time of an event
    #' @param end_time_offset (optional) Seconds from the end time of an event
    #' @param send_suggestion (optional) If true, then notify matching users when they are inside the radius (default value: TRUE)
    #' @param associate_description (optional) The description of the associated object
    #' @param associate_type (optional) The type of the object to center the audience geofence
    #' @param associate_id (optional) The ID of the object to center the audience geofence
    #' @param grouping_id (optional) Optional grouping id for the audience
    #' @param meta_data (optional) External custom client defined data
    #' @param visibility (optional) Visibility of the audience
    #' @param audience_type (optional) Type of audience
    #' @param use_order (optional) Use order for cohort
    #' @param cohort_regions_data (optional) Cohort data for \"cohort\" audience type
    #' @param app_key (optional) Filter results by application key
    #' @param trilateration_types (optional) Trilateration types
    #' @param unique_name (optional) If true, makes sure the audience name is unique
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AudienceResponse
    CreateAudience = function(account_id, name, description = NULL, search_tags = NULL, gender = NULL, age_groups = NULL, category_ids = NULL, application_ids = NULL, game_experience_level = NULL, devices = NULL, device_ids = NULL, device_versions = NULL, locations = NULL, radius = NULL, start_time_offset = NULL, end_time_offset = NULL, send_suggestion = TRUE, associate_description = NULL, associate_type = NULL, associate_id = NULL, grouping_id = NULL, meta_data = NULL, visibility = NULL, audience_type = NULL, use_order = NULL, cohort_regions_data = NULL, app_key = NULL, trilateration_types = NULL, unique_name = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateAudienceWithHttpInfo(account_id, name, description, search_tags, gender, age_groups, category_ids, application_ids, game_experience_level, devices, device_ids, device_versions, locations, radius, start_time_offset, end_time_offset, send_suggestion, associate_description, associate_type, associate_id, grouping_id, meta_data, visibility, audience_type, use_order, cohort_regions_data, app_key, trilateration_types, unique_name, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Audience
    #'
    #' @param account_id The logged in user.
    #' @param name The name of the audience
    #' @param description (optional) The description of the audience
    #' @param search_tags (optional) The search tags
    #' @param gender (optional) The gender; possible values are: MALE, FEMALE, ANY
    #' @param age_groups (optional) The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    #' @param category_ids (optional) The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    #' @param application_ids (optional) The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    #' @param game_experience_level (optional) The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    #' @param devices (optional) (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    #' @param device_ids (optional) The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    #' @param device_versions (optional) The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    #' @param locations (optional) The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    #' @param radius (optional) The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    #' @param start_time_offset (optional) Seconds from the start time of an event
    #' @param end_time_offset (optional) Seconds from the end time of an event
    #' @param send_suggestion (optional) If true, then notify matching users when they are inside the radius (default value: TRUE)
    #' @param associate_description (optional) The description of the associated object
    #' @param associate_type (optional) The type of the object to center the audience geofence
    #' @param associate_id (optional) The ID of the object to center the audience geofence
    #' @param grouping_id (optional) Optional grouping id for the audience
    #' @param meta_data (optional) External custom client defined data
    #' @param visibility (optional) Visibility of the audience
    #' @param audience_type (optional) Type of audience
    #' @param use_order (optional) Use order for cohort
    #' @param cohort_regions_data (optional) Cohort data for \"cohort\" audience type
    #' @param app_key (optional) Filter results by application key
    #' @param trilateration_types (optional) Trilateration types
    #' @param unique_name (optional) If true, makes sure the audience name is unique
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AudienceResponse) with additional information such as HTTP status code, headers
    CreateAudienceWithHttpInfo = function(account_id, name, description = NULL, search_tags = NULL, gender = NULL, age_groups = NULL, category_ids = NULL, application_ids = NULL, game_experience_level = NULL, devices = NULL, device_ids = NULL, device_versions = NULL, locations = NULL, radius = NULL, start_time_offset = NULL, end_time_offset = NULL, send_suggestion = TRUE, associate_description = NULL, associate_type = NULL, associate_id = NULL, grouping_id = NULL, meta_data = NULL, visibility = NULL, audience_type = NULL, use_order = NULL, cohort_regions_data = NULL, app_key = NULL, trilateration_types = NULL, unique_name = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$CreateAudience, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling AudienceApi$CreateAudience, `name` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling AudienceApi$CreateAudience, `description` is not nullable")
      }

      if (!missing(`search_tags`) && is.null(`search_tags`)) {
        stop("Invalid value for `search_tags` when calling AudienceApi$CreateAudience, `search_tags` is not nullable")
      }

      if (!missing(`gender`) && is.null(`gender`)) {
        stop("Invalid value for `gender` when calling AudienceApi$CreateAudience, `gender` is not nullable")
      }

      if (!missing(`age_groups`) && is.null(`age_groups`)) {
        stop("Invalid value for `age_groups` when calling AudienceApi$CreateAudience, `age_groups` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling AudienceApi$CreateAudience, `category_ids` is not nullable")
      }

      if (!missing(`application_ids`) && is.null(`application_ids`)) {
        stop("Invalid value for `application_ids` when calling AudienceApi$CreateAudience, `application_ids` is not nullable")
      }

      if (!missing(`game_experience_level`) && is.null(`game_experience_level`)) {
        stop("Invalid value for `game_experience_level` when calling AudienceApi$CreateAudience, `game_experience_level` is not nullable")
      }

      if (!missing(`devices`) && is.null(`devices`)) {
        stop("Invalid value for `devices` when calling AudienceApi$CreateAudience, `devices` is not nullable")
      }

      if (!missing(`device_ids`) && is.null(`device_ids`)) {
        stop("Invalid value for `device_ids` when calling AudienceApi$CreateAudience, `device_ids` is not nullable")
      }

      if (!missing(`device_versions`) && is.null(`device_versions`)) {
        stop("Invalid value for `device_versions` when calling AudienceApi$CreateAudience, `device_versions` is not nullable")
      }

      if (!missing(`locations`) && is.null(`locations`)) {
        stop("Invalid value for `locations` when calling AudienceApi$CreateAudience, `locations` is not nullable")
      }

      if (!missing(`radius`) && is.null(`radius`)) {
        stop("Invalid value for `radius` when calling AudienceApi$CreateAudience, `radius` is not nullable")
      }

      if (!missing(`start_time_offset`) && is.null(`start_time_offset`)) {
        stop("Invalid value for `start_time_offset` when calling AudienceApi$CreateAudience, `start_time_offset` is not nullable")
      }

      if (!missing(`end_time_offset`) && is.null(`end_time_offset`)) {
        stop("Invalid value for `end_time_offset` when calling AudienceApi$CreateAudience, `end_time_offset` is not nullable")
      }

      if (!missing(`send_suggestion`) && is.null(`send_suggestion`)) {
        stop("Invalid value for `send_suggestion` when calling AudienceApi$CreateAudience, `send_suggestion` is not nullable")
      }

      if (!missing(`associate_description`) && is.null(`associate_description`)) {
        stop("Invalid value for `associate_description` when calling AudienceApi$CreateAudience, `associate_description` is not nullable")
      }

      if (!missing(`associate_type`) && is.null(`associate_type`)) {
        stop("Invalid value for `associate_type` when calling AudienceApi$CreateAudience, `associate_type` is not nullable")
      }

      if (!missing(`associate_id`) && is.null(`associate_id`)) {
        stop("Invalid value for `associate_id` when calling AudienceApi$CreateAudience, `associate_id` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling AudienceApi$CreateAudience, `grouping_id` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling AudienceApi$CreateAudience, `meta_data` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling AudienceApi$CreateAudience, `visibility` is not nullable")
      }

      if (!missing(`audience_type`) && is.null(`audience_type`)) {
        stop("Invalid value for `audience_type` when calling AudienceApi$CreateAudience, `audience_type` is not nullable")
      }

      if (!missing(`use_order`) && is.null(`use_order`)) {
        stop("Invalid value for `use_order` when calling AudienceApi$CreateAudience, `use_order` is not nullable")
      }

      if (!missing(`cohort_regions_data`) && is.null(`cohort_regions_data`)) {
        stop("Invalid value for `cohort_regions_data` when calling AudienceApi$CreateAudience, `cohort_regions_data` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling AudienceApi$CreateAudience, `app_key` is not nullable")
      }

      if (!missing(`trilateration_types`) && is.null(`trilateration_types`)) {
        stop("Invalid value for `trilateration_types` when calling AudienceApi$CreateAudience, `trilateration_types` is not nullable")
      }

      if (!missing(`unique_name`) && is.null(`unique_name`)) {
        stop("Invalid value for `unique_name` when calling AudienceApi$CreateAudience, `unique_name` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["searchTags"]] <- `search_tags`

      query_params[["gender"]] <- `gender`

      query_params[["ageGroups"]] <- `age_groups`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["applicationIds"]] <- `application_ids`

      query_params[["gameExperienceLevel"]] <- `game_experience_level`

      query_params[["devices"]] <- `devices`

      query_params[["deviceIds"]] <- `device_ids`

      query_params[["deviceVersions"]] <- `device_versions`

      query_params[["locations"]] <- `locations`

      query_params[["radius"]] <- `radius`

      query_params[["startTimeOffset"]] <- `start_time_offset`

      query_params[["endTimeOffset"]] <- `end_time_offset`

      query_params[["sendSuggestion"]] <- `send_suggestion`

      query_params[["associateDescription"]] <- `associate_description`

      query_params[["associateType"]] <- `associate_type`

      query_params[["associateId"]] <- `associate_id`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["metaData"]] <- `meta_data`

      query_params[["visibility"]] <- `visibility`

      query_params[["audienceType"]] <- `audience_type`

      query_params[["useOrder"]] <- `use_order`

      query_params[["cohortRegionsData"]] <- `cohort_regions_data`

      query_params[["appKey"]] <- `app_key`

      query_params[["trilaterationTypes"]] <- `trilateration_types`

      query_params[["uniqueName"]] <- `unique_name`

      local_var_url_path <- "/audience/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AudienceResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Audience
    #'
    #' @param account_id The logged in user.
    #' @param audience_id The id of the audience to delete.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteAudience = function(account_id, audience_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteAudienceWithHttpInfo(account_id, audience_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Audience
    #'
    #' @param account_id The logged in user.
    #' @param audience_id The id of the audience to delete.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteAudienceWithHttpInfo = function(account_id, audience_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`audience_id`)) {
        stop("Missing required parameter `audience_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$DeleteAudience, `account_id` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling AudienceApi$DeleteAudience, `audience_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["audienceId"]] <- `audience_id`

      local_var_url_path <- "/audience/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Age Groups
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AgeGroupResponse]
    GetAgeGroups = function(data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetAgeGroupsWithHttpInfo(data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Age Groups
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AgeGroupResponse]) with additional information such as HTTP status code, headers
    GetAgeGroupsWithHttpInfo = function(data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      local_var_url_path <- "/audience/ageGroups"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AgeGroupResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Audience
    #'
    #' @param account_id The logged in user.
    #' @param audience_id The id of the audience to return.
    #' @param app_key (optional) The application key (optional). If provided, results may be scoped to this application.
    #' @param return_account_count (optional) (boolean) set to true to include the accountCount associated with current audience of the current app (default value: FALSE)
    #' @param return_album_count (optional) (boolean) set to true to include the albumCount associated with current audience of the current app (default value: FALSE)
    #' @param album_types_for_count (optional) (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AudienceResponse
    GetAudience = function(account_id, audience_id, app_key = NULL, return_account_count = FALSE, return_album_count = FALSE, album_types_for_count = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetAudienceWithHttpInfo(account_id, audience_id, app_key, return_account_count, return_album_count, album_types_for_count, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Audience
    #'
    #' @param account_id The logged in user.
    #' @param audience_id The id of the audience to return.
    #' @param app_key (optional) The application key (optional). If provided, results may be scoped to this application.
    #' @param return_account_count (optional) (boolean) set to true to include the accountCount associated with current audience of the current app (default value: FALSE)
    #' @param return_album_count (optional) (boolean) set to true to include the albumCount associated with current audience of the current app (default value: FALSE)
    #' @param album_types_for_count (optional) (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AudienceResponse) with additional information such as HTTP status code, headers
    GetAudienceWithHttpInfo = function(account_id, audience_id, app_key = NULL, return_account_count = FALSE, return_album_count = FALSE, album_types_for_count = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`audience_id`)) {
        stop("Missing required parameter `audience_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$GetAudience, `account_id` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling AudienceApi$GetAudience, `audience_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling AudienceApi$GetAudience, `app_key` is not nullable")
      }

      if (!missing(`return_account_count`) && is.null(`return_account_count`)) {
        stop("Invalid value for `return_account_count` when calling AudienceApi$GetAudience, `return_account_count` is not nullable")
      }

      if (!missing(`return_album_count`) && is.null(`return_album_count`)) {
        stop("Invalid value for `return_album_count` when calling AudienceApi$GetAudience, `return_album_count` is not nullable")
      }

      if (!missing(`album_types_for_count`) && is.null(`album_types_for_count`)) {
        stop("Invalid value for `album_types_for_count` when calling AudienceApi$GetAudience, `album_types_for_count` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["audienceId"]] <- `audience_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["returnAccountCount"]] <- `return_account_count`

      query_params[["returnAlbumCount"]] <- `return_album_count`

      query_params[["albumTypesForCount"]] <- `album_types_for_count`

      local_var_url_path <- "/audience/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AudienceResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Audiences
    #'
    #' @param account_id (optional) The logged in user.
    #' @param album_ids (optional) Comma separated list of album IDs to filter results with
    #' @param keyword (optional) The keyword used to search
    #' @param keyword_fields (optional) Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (default value: "SEARCH_TAGS,NAME,DESCRIPTION")
    #' @param sort_field (optional) The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (default value: "NAME")
    #' @param descending (optional) The order to return the results. Default is false, which will return the results in ascending order. (default value: FALSE)
    #' @param start (optional) The index into the record set to start with. (default value: 0)
    #' @param limit (optional) The total number of record to return (there is a hard limit of 100). (default value: 20)
    #' @param send_suggestion (optional) Filter results based on whether or not the audience is set to send suggestions
    #' @param active_only (optional) Determines whether to return only active results. Default is false.
    #' @param group_by_grouping_id (optional) Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
    #' @param app_key (optional) Filter results by application key
    #' @param return_global (optional) If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
    #' @param exact_keyword (optional) If true, match keyword exactly
    #' @param audience_type (optional) (Deprecated) Filter results by audience type
    #' @param audience_types (optional) comma separated string with the different audience types you want to filter for
    #' @param return_account_count (optional) (boolean) set to true to include the accountCount associated with current audience of the current app (default value: FALSE)
    #' @param return_album_count (optional) (boolean) set to true to include the albumCount associated with current audience of the current app (default value: FALSE)
    #' @param album_types_for_count (optional) (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[SearchResponse]
    GetAudienceList = function(account_id = NULL, album_ids = NULL, keyword = NULL, keyword_fields = "SEARCH_TAGS,NAME,DESCRIPTION", sort_field = "NAME", descending = FALSE, start = 0, limit = 20, send_suggestion = NULL, active_only = NULL, group_by_grouping_id = NULL, app_key = NULL, return_global = NULL, exact_keyword = NULL, audience_type = NULL, audience_types = NULL, return_account_count = FALSE, return_album_count = FALSE, album_types_for_count = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetAudienceListWithHttpInfo(account_id, album_ids, keyword, keyword_fields, sort_field, descending, start, limit, send_suggestion, active_only, group_by_grouping_id, app_key, return_global, exact_keyword, audience_type, audience_types, return_account_count, return_album_count, album_types_for_count, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Audiences
    #'
    #' @param account_id (optional) The logged in user.
    #' @param album_ids (optional) Comma separated list of album IDs to filter results with
    #' @param keyword (optional) The keyword used to search
    #' @param keyword_fields (optional) Comma separated list of fields that the keywords will match against. Possible values include: SEARCH_TAGS, NAME, DESCRIPTION, OWNER_DISPLAY (default value: "SEARCH_TAGS,NAME,DESCRIPTION")
    #' @param sort_field (optional) The field to sort by, possible values include: {ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, OWNER_ID, OWNER_DISPLAY, GENDER} (default value: "NAME")
    #' @param descending (optional) The order to return the results. Default is false, which will return the results in ascending order. (default value: FALSE)
    #' @param start (optional) The index into the record set to start with. (default value: 0)
    #' @param limit (optional) The total number of record to return (there is a hard limit of 100). (default value: 20)
    #' @param send_suggestion (optional) Filter results based on whether or not the audience is set to send suggestions
    #' @param active_only (optional) Determines whether to return only active results. Default is false.
    #' @param group_by_grouping_id (optional) Groups results by the audience groupingId (this does not work in conjunction with the following parameters: albumIds, audienceType, appKey, returnGlobal)
    #' @param app_key (optional) Filter results by application key
    #' @param return_global (optional) If filtering by appKey, determines whether or not audiences that do not have an application set will also be returned as well
    #' @param exact_keyword (optional) If true, match keyword exactly
    #' @param audience_type (optional) (Deprecated) Filter results by audience type
    #' @param audience_types (optional) comma separated string with the different audience types you want to filter for
    #' @param return_account_count (optional) (boolean) set to true to include the accountCount associated with current audience of the current app (default value: FALSE)
    #' @param return_album_count (optional) (boolean) set to true to include the albumCount associated with current audience of the current app (default value: FALSE)
    #' @param album_types_for_count (optional) (String) comma separated list, return an array with each item is the count of each album type. If not provided, \"all_types\" count is returned.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[SearchResponse]) with additional information such as HTTP status code, headers
    GetAudienceListWithHttpInfo = function(account_id = NULL, album_ids = NULL, keyword = NULL, keyword_fields = "SEARCH_TAGS,NAME,DESCRIPTION", sort_field = "NAME", descending = FALSE, start = 0, limit = 20, send_suggestion = NULL, active_only = NULL, group_by_grouping_id = NULL, app_key = NULL, return_global = NULL, exact_keyword = NULL, audience_type = NULL, audience_types = NULL, return_account_count = FALSE, return_album_count = FALSE, album_types_for_count = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$GetAudienceList, `account_id` is not nullable")
      }

      if (!missing(`album_ids`) && is.null(`album_ids`)) {
        stop("Invalid value for `album_ids` when calling AudienceApi$GetAudienceList, `album_ids` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling AudienceApi$GetAudienceList, `keyword` is not nullable")
      }

      if (!missing(`keyword_fields`) && is.null(`keyword_fields`)) {
        stop("Invalid value for `keyword_fields` when calling AudienceApi$GetAudienceList, `keyword_fields` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling AudienceApi$GetAudienceList, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling AudienceApi$GetAudienceList, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling AudienceApi$GetAudienceList, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling AudienceApi$GetAudienceList, `limit` is not nullable")
      }

      if (!missing(`send_suggestion`) && is.null(`send_suggestion`)) {
        stop("Invalid value for `send_suggestion` when calling AudienceApi$GetAudienceList, `send_suggestion` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling AudienceApi$GetAudienceList, `active_only` is not nullable")
      }

      if (!missing(`group_by_grouping_id`) && is.null(`group_by_grouping_id`)) {
        stop("Invalid value for `group_by_grouping_id` when calling AudienceApi$GetAudienceList, `group_by_grouping_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling AudienceApi$GetAudienceList, `app_key` is not nullable")
      }

      if (!missing(`return_global`) && is.null(`return_global`)) {
        stop("Invalid value for `return_global` when calling AudienceApi$GetAudienceList, `return_global` is not nullable")
      }

      if (!missing(`exact_keyword`) && is.null(`exact_keyword`)) {
        stop("Invalid value for `exact_keyword` when calling AudienceApi$GetAudienceList, `exact_keyword` is not nullable")
      }

      if (!missing(`audience_type`) && is.null(`audience_type`)) {
        stop("Invalid value for `audience_type` when calling AudienceApi$GetAudienceList, `audience_type` is not nullable")
      }

      if (!missing(`audience_types`) && is.null(`audience_types`)) {
        stop("Invalid value for `audience_types` when calling AudienceApi$GetAudienceList, `audience_types` is not nullable")
      }

      if (!missing(`return_account_count`) && is.null(`return_account_count`)) {
        stop("Invalid value for `return_account_count` when calling AudienceApi$GetAudienceList, `return_account_count` is not nullable")
      }

      if (!missing(`return_album_count`) && is.null(`return_album_count`)) {
        stop("Invalid value for `return_album_count` when calling AudienceApi$GetAudienceList, `return_album_count` is not nullable")
      }

      if (!missing(`album_types_for_count`) && is.null(`album_types_for_count`)) {
        stop("Invalid value for `album_types_for_count` when calling AudienceApi$GetAudienceList, `album_types_for_count` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["albumIds"]] <- `album_ids`

      query_params[["keyword"]] <- `keyword`

      query_params[["keywordFields"]] <- `keyword_fields`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DESCRIPTION", "SEND_SUGGESTION", "OWNER_ID", "OWNER_DISPLAY", "GENDER"))) {
        stop("Invalid value for sort_field when calling AudienceApi$GetAudienceList. Must be [ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DESCRIPTION, SEND_SUGGESTION, OWNER_ID, OWNER_DISPLAY, GENDER].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["sendSuggestion"]] <- `send_suggestion`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["groupByGroupingId"]] <- `group_by_grouping_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["returnGlobal"]] <- `return_global`

      query_params[["exactKeyword"]] <- `exact_keyword`

      query_params[["audienceType"]] <- `audience_type`

      query_params[["audienceTypes"]] <- `audience_types`

      query_params[["returnAccountCount"]] <- `return_account_count`

      query_params[["returnAlbumCount"]] <- `return_album_count`

      query_params[["albumTypesForCount"]] <- `album_types_for_count`

      local_var_url_path <- "/audience/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[SearchResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Devices
    #'
    #' @param include_inactive If true return inactive record as well. default is false.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AudienceDeviceResponse]
    GetDevices = function(include_inactive, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetDevicesWithHttpInfo(include_inactive, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Devices
    #'
    #' @param include_inactive If true return inactive record as well. default is false.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AudienceDeviceResponse]) with additional information such as HTTP status code, headers
    GetDevicesWithHttpInfo = function(include_inactive, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`include_inactive`)) {
        stop("Missing required parameter `include_inactive`.")
      }

      if (!missing(`include_inactive`) && is.null(`include_inactive`)) {
        stop("Invalid value for `include_inactive` when calling AudienceApi$GetDevices, `include_inactive` is not nullable")
      }

      query_params[["includeInactive"]] <- `include_inactive`

      local_var_url_path <- "/audience/devices"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AudienceDeviceResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Experiences
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    GetExperiences = function(data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetExperiencesWithHttpInfo(data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Experiences
    #'
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    GetExperiencesWithHttpInfo = function(data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      local_var_url_path <- "/audience/experiences"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get GroupedAudiences
    #'
    #' @param account_id The logged in user.
    #' @param audience_grouping_id The audience grouping id to return.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AudienceResponse
    GetGroupedAudiences = function(account_id, audience_grouping_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetGroupedAudiencesWithHttpInfo(account_id, audience_grouping_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get GroupedAudiences
    #'
    #' @param account_id The logged in user.
    #' @param audience_grouping_id The audience grouping id to return.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AudienceResponse) with additional information such as HTTP status code, headers
    GetGroupedAudiencesWithHttpInfo = function(account_id, audience_grouping_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`audience_grouping_id`)) {
        stop("Missing required parameter `audience_grouping_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$GetGroupedAudiences, `account_id` is not nullable")
      }

      if (!missing(`audience_grouping_id`) && is.null(`audience_grouping_id`)) {
        stop("Invalid value for `audience_grouping_id` when calling AudienceApi$GetGroupedAudiences, `audience_grouping_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["audienceGroupingId"]] <- `audience_grouping_id`

      local_var_url_path <- "/audience/grouped/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AudienceResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' List Suggestions by Audience
    #'
    #' @param account_id The account to match offers for.
    #' @param limit the limit of the index
    #' @param suggestion_type the type of suggestion
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OfferListResponse
    ListByAccount = function(account_id, limit, suggestion_type, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$ListByAccountWithHttpInfo(account_id, limit, suggestion_type, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' List Suggestions by Audience
    #'
    #' @param account_id The account to match offers for.
    #' @param limit the limit of the index
    #' @param suggestion_type the type of suggestion
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OfferListResponse) with additional information such as HTTP status code, headers
    ListByAccountWithHttpInfo = function(account_id, limit, suggestion_type, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`suggestion_type`)) {
        stop("Missing required parameter `suggestion_type`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$ListByAccount, `account_id` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling AudienceApi$ListByAccount, `limit` is not nullable")
      }

      if (!missing(`suggestion_type`) && is.null(`suggestion_type`)) {
        stop("Invalid value for `suggestion_type` when calling AudienceApi$ListByAccount, `suggestion_type` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["limit"]] <- `limit`

      query_params[["suggestionType"]] <- `suggestion_type`

      local_var_url_path <- "/audience/suggestion/list"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OfferListResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' List Offers by Audience
    #'
    #' @param limit this is the limit of the index
    #' @param gender (optional) this is the gender to list offers by
    #' @param age (optional) this is the age to list offers by
    #' @param category_ids (optional) this is the category IDs to list offers by
    #' @param latitude (optional) this is the latitude to list offers by
    #' @param longitude (optional) this is the longitude to list offers by
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OfferListResponse
    ListByAudience = function(limit, gender = NULL, age = NULL, category_ids = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$ListByAudienceWithHttpInfo(limit, gender, age, category_ids, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' List Offers by Audience
    #'
    #' @param limit this is the limit of the index
    #' @param gender (optional) this is the gender to list offers by
    #' @param age (optional) this is the age to list offers by
    #' @param category_ids (optional) this is the category IDs to list offers by
    #' @param latitude (optional) this is the latitude to list offers by
    #' @param longitude (optional) this is the longitude to list offers by
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OfferListResponse) with additional information such as HTTP status code, headers
    ListByAudienceWithHttpInfo = function(limit, gender = NULL, age = NULL, category_ids = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling AudienceApi$ListByAudience, `limit` is not nullable")
      }

      if (!missing(`gender`) && is.null(`gender`)) {
        stop("Invalid value for `gender` when calling AudienceApi$ListByAudience, `gender` is not nullable")
      }

      if (!missing(`age`) && is.null(`age`)) {
        stop("Invalid value for `age` when calling AudienceApi$ListByAudience, `age` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling AudienceApi$ListByAudience, `category_ids` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling AudienceApi$ListByAudience, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling AudienceApi$ListByAudience, `longitude` is not nullable")
      }

      query_params[["gender"]] <- `gender`

      query_params[["age"]] <- `age`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/audience/suggestion/offersByAudience"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OfferListResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' List Sent Suggestions 
    #'
    #' @param account_id The account to match offers for.
    #' @param timeframe The timeframe in seconds of the latest suggestions
    #' @param suggestion_type The type of trigger suggestions to return
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return OfferListResponse
    ListLastestByAccount = function(account_id, timeframe, suggestion_type, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$ListLastestByAccountWithHttpInfo(account_id, timeframe, suggestion_type, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' List Sent Suggestions 
    #'
    #' @param account_id The account to match offers for.
    #' @param timeframe The timeframe in seconds of the latest suggestions
    #' @param suggestion_type The type of trigger suggestions to return
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (OfferListResponse) with additional information such as HTTP status code, headers
    ListLastestByAccountWithHttpInfo = function(account_id, timeframe, suggestion_type, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`timeframe`)) {
        stop("Missing required parameter `timeframe`.")
      }

      if (missing(`suggestion_type`)) {
        stop("Missing required parameter `suggestion_type`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$ListLastestByAccount, `account_id` is not nullable")
      }

      if (!missing(`timeframe`) && is.null(`timeframe`)) {
        stop("Invalid value for `timeframe` when calling AudienceApi$ListLastestByAccount, `timeframe` is not nullable")
      }

      if (!missing(`suggestion_type`) && is.null(`suggestion_type`)) {
        stop("Invalid value for `suggestion_type` when calling AudienceApi$ListLastestByAccount, `suggestion_type` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["timeframe"]] <- `timeframe`

      query_params[["suggestionType"]] <- `suggestion_type`

      local_var_url_path <- "/audience/suggestion/latest"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "OfferListResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Send Suggestions
    #'
    #' @param account_id The account to match offers for.
    #' @param latitude the latitude
    #' @param longitude the longitude
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    SendByAccount = function(account_id, latitude, longitude, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SendByAccountWithHttpInfo(account_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Send Suggestions
    #'
    #' @param account_id The account to match offers for.
    #' @param latitude the latitude
    #' @param longitude the longitude
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    SendByAccountWithHttpInfo = function(account_id, latitude, longitude, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`latitude`)) {
        stop("Missing required parameter `latitude`.")
      }

      if (missing(`longitude`)) {
        stop("Missing required parameter `longitude`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$SendByAccount, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling AudienceApi$SendByAccount, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling AudienceApi$SendByAccount, `longitude` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/audience/suggestion/send"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Audience
    #'
    #' @param account_id The logged in user.
    #' @param audience_id The id of the audience to update.
    #' @param name (optional) The name of the audience
    #' @param description (optional) The description of the audience
    #' @param search_tags (optional) The search tags
    #' @param gender (optional) The gender; possible values are: MALE, FEMALE, ANY
    #' @param age_groups (optional) The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    #' @param category_ids (optional) The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    #' @param application_ids (optional) The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    #' @param game_experience_level (optional) The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    #' @param devices (optional) (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    #' @param device_ids (optional) The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    #' @param device_versions (optional) The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    #' @param locations (optional) The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    #' @param radius (optional) The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    #' @param active (optional) if audience is active
    #' @param send_suggestion (optional) If true, then notify matching users when they are inside the radius
    #' @param start_time_offset (optional) Seconds from the start time of an event
    #' @param end_time_offset (optional) Seconds from the end time of an event
    #' @param associate_description (optional) the associate description
    #' @param associate_type (optional) The type of the object to center the audience geofence
    #' @param associate_id (optional) The ID of the object to center the audience geofence
    #' @param grouping_id (optional) Optional grouping id for the audience
    #' @param meta_data (optional) External custom client defined data
    #' @param visibility (optional) Visibility of the audience
    #' @param audience_type (optional) Type of audience
    #' @param use_order (optional) Use order for cohort
    #' @param cohort_regions_data (optional) Cohort data for \"cohort\" audience type
    #' @param app_key (optional) Filter results by application key
    #' @param trilateration_types (optional) Trilateration types
    #' @param unique_name (optional) If true, makes sure the audience name is unique
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AudienceResponse
    UpdateAudience = function(account_id, audience_id, name = NULL, description = NULL, search_tags = NULL, gender = NULL, age_groups = NULL, category_ids = NULL, application_ids = NULL, game_experience_level = NULL, devices = NULL, device_ids = NULL, device_versions = NULL, locations = NULL, radius = NULL, active = NULL, send_suggestion = NULL, start_time_offset = NULL, end_time_offset = NULL, associate_description = NULL, associate_type = NULL, associate_id = NULL, grouping_id = NULL, meta_data = NULL, visibility = NULL, audience_type = NULL, use_order = NULL, cohort_regions_data = NULL, app_key = NULL, trilateration_types = NULL, unique_name = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateAudienceWithHttpInfo(account_id, audience_id, name, description, search_tags, gender, age_groups, category_ids, application_ids, game_experience_level, devices, device_ids, device_versions, locations, radius, active, send_suggestion, start_time_offset, end_time_offset, associate_description, associate_type, associate_id, grouping_id, meta_data, visibility, audience_type, use_order, cohort_regions_data, app_key, trilateration_types, unique_name, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Audience
    #'
    #' @param account_id The logged in user.
    #' @param audience_id The id of the audience to update.
    #' @param name (optional) The name of the audience
    #' @param description (optional) The description of the audience
    #' @param search_tags (optional) The search tags
    #' @param gender (optional) The gender; possible values are: MALE, FEMALE, ANY
    #' @param age_groups (optional) The list of age groups, comma separated; possible values are AGE_0_13, AGE_14_17, AGE_18_22, AGE_23_30, AGE_31_54, AGE_55_PLUS, AGE_ANY (to reset to none)
    #' @param category_ids (optional) The list of category ids, comma separated; possible values are retrieved via /api/{version}/category/search (pass in id values)
    #' @param application_ids (optional) The list of application ids, comma separated; possible values are retrieved via /api/{version}/application/list (pass in id values)
    #' @param game_experience_level (optional) The experience level of the player; possible values are: ANY, NEW, BEGINNER, INTERMEDIATE, EXPERT
    #' @param devices (optional) (Deprecated) Use deviceIds. The list of targeted device names, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in name values)
    #' @param device_ids (optional) The list of targeted device ids, comma separated; possible values are retrieved via /api/{version}/audience/devices (pass in id values)
    #' @param device_versions (optional) The list of targeted device version ranges that are aligned with the provided devices list, comma separated (examples: 2.3-X, 0-5.1.4, 4.3.1-6.1.4)
    #' @param locations (optional) The list of locations to build the center around; comma separated list of latitude/longitude pairs (example: lat1,long1,lat2,long2)
    #' @param radius (optional) The list of radius of influence for the audience, in miles; comma separated list. Either provide 1 to be applied to all location pairs or a matching list to each lat/long pair.
    #' @param active (optional) if audience is active
    #' @param send_suggestion (optional) If true, then notify matching users when they are inside the radius
    #' @param start_time_offset (optional) Seconds from the start time of an event
    #' @param end_time_offset (optional) Seconds from the end time of an event
    #' @param associate_description (optional) the associate description
    #' @param associate_type (optional) The type of the object to center the audience geofence
    #' @param associate_id (optional) The ID of the object to center the audience geofence
    #' @param grouping_id (optional) Optional grouping id for the audience
    #' @param meta_data (optional) External custom client defined data
    #' @param visibility (optional) Visibility of the audience
    #' @param audience_type (optional) Type of audience
    #' @param use_order (optional) Use order for cohort
    #' @param cohort_regions_data (optional) Cohort data for \"cohort\" audience type
    #' @param app_key (optional) Filter results by application key
    #' @param trilateration_types (optional) Trilateration types
    #' @param unique_name (optional) If true, makes sure the audience name is unique
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AudienceResponse) with additional information such as HTTP status code, headers
    UpdateAudienceWithHttpInfo = function(account_id, audience_id, name = NULL, description = NULL, search_tags = NULL, gender = NULL, age_groups = NULL, category_ids = NULL, application_ids = NULL, game_experience_level = NULL, devices = NULL, device_ids = NULL, device_versions = NULL, locations = NULL, radius = NULL, active = NULL, send_suggestion = NULL, start_time_offset = NULL, end_time_offset = NULL, associate_description = NULL, associate_type = NULL, associate_id = NULL, grouping_id = NULL, meta_data = NULL, visibility = NULL, audience_type = NULL, use_order = NULL, cohort_regions_data = NULL, app_key = NULL, trilateration_types = NULL, unique_name = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`audience_id`)) {
        stop("Missing required parameter `audience_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AudienceApi$UpdateAudience, `account_id` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling AudienceApi$UpdateAudience, `audience_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling AudienceApi$UpdateAudience, `name` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling AudienceApi$UpdateAudience, `description` is not nullable")
      }

      if (!missing(`search_tags`) && is.null(`search_tags`)) {
        stop("Invalid value for `search_tags` when calling AudienceApi$UpdateAudience, `search_tags` is not nullable")
      }

      if (!missing(`gender`) && is.null(`gender`)) {
        stop("Invalid value for `gender` when calling AudienceApi$UpdateAudience, `gender` is not nullable")
      }

      if (!missing(`age_groups`) && is.null(`age_groups`)) {
        stop("Invalid value for `age_groups` when calling AudienceApi$UpdateAudience, `age_groups` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling AudienceApi$UpdateAudience, `category_ids` is not nullable")
      }

      if (!missing(`application_ids`) && is.null(`application_ids`)) {
        stop("Invalid value for `application_ids` when calling AudienceApi$UpdateAudience, `application_ids` is not nullable")
      }

      if (!missing(`game_experience_level`) && is.null(`game_experience_level`)) {
        stop("Invalid value for `game_experience_level` when calling AudienceApi$UpdateAudience, `game_experience_level` is not nullable")
      }

      if (!missing(`devices`) && is.null(`devices`)) {
        stop("Invalid value for `devices` when calling AudienceApi$UpdateAudience, `devices` is not nullable")
      }

      if (!missing(`device_ids`) && is.null(`device_ids`)) {
        stop("Invalid value for `device_ids` when calling AudienceApi$UpdateAudience, `device_ids` is not nullable")
      }

      if (!missing(`device_versions`) && is.null(`device_versions`)) {
        stop("Invalid value for `device_versions` when calling AudienceApi$UpdateAudience, `device_versions` is not nullable")
      }

      if (!missing(`locations`) && is.null(`locations`)) {
        stop("Invalid value for `locations` when calling AudienceApi$UpdateAudience, `locations` is not nullable")
      }

      if (!missing(`radius`) && is.null(`radius`)) {
        stop("Invalid value for `radius` when calling AudienceApi$UpdateAudience, `radius` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling AudienceApi$UpdateAudience, `active` is not nullable")
      }

      if (!missing(`send_suggestion`) && is.null(`send_suggestion`)) {
        stop("Invalid value for `send_suggestion` when calling AudienceApi$UpdateAudience, `send_suggestion` is not nullable")
      }

      if (!missing(`start_time_offset`) && is.null(`start_time_offset`)) {
        stop("Invalid value for `start_time_offset` when calling AudienceApi$UpdateAudience, `start_time_offset` is not nullable")
      }

      if (!missing(`end_time_offset`) && is.null(`end_time_offset`)) {
        stop("Invalid value for `end_time_offset` when calling AudienceApi$UpdateAudience, `end_time_offset` is not nullable")
      }

      if (!missing(`associate_description`) && is.null(`associate_description`)) {
        stop("Invalid value for `associate_description` when calling AudienceApi$UpdateAudience, `associate_description` is not nullable")
      }

      if (!missing(`associate_type`) && is.null(`associate_type`)) {
        stop("Invalid value for `associate_type` when calling AudienceApi$UpdateAudience, `associate_type` is not nullable")
      }

      if (!missing(`associate_id`) && is.null(`associate_id`)) {
        stop("Invalid value for `associate_id` when calling AudienceApi$UpdateAudience, `associate_id` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling AudienceApi$UpdateAudience, `grouping_id` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling AudienceApi$UpdateAudience, `meta_data` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling AudienceApi$UpdateAudience, `visibility` is not nullable")
      }

      if (!missing(`audience_type`) && is.null(`audience_type`)) {
        stop("Invalid value for `audience_type` when calling AudienceApi$UpdateAudience, `audience_type` is not nullable")
      }

      if (!missing(`use_order`) && is.null(`use_order`)) {
        stop("Invalid value for `use_order` when calling AudienceApi$UpdateAudience, `use_order` is not nullable")
      }

      if (!missing(`cohort_regions_data`) && is.null(`cohort_regions_data`)) {
        stop("Invalid value for `cohort_regions_data` when calling AudienceApi$UpdateAudience, `cohort_regions_data` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling AudienceApi$UpdateAudience, `app_key` is not nullable")
      }

      if (!missing(`trilateration_types`) && is.null(`trilateration_types`)) {
        stop("Invalid value for `trilateration_types` when calling AudienceApi$UpdateAudience, `trilateration_types` is not nullable")
      }

      if (!missing(`unique_name`) && is.null(`unique_name`)) {
        stop("Invalid value for `unique_name` when calling AudienceApi$UpdateAudience, `unique_name` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["audienceId"]] <- `audience_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["searchTags"]] <- `search_tags`

      query_params[["gender"]] <- `gender`

      query_params[["ageGroups"]] <- `age_groups`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["applicationIds"]] <- `application_ids`

      query_params[["gameExperienceLevel"]] <- `game_experience_level`

      query_params[["devices"]] <- `devices`

      query_params[["deviceIds"]] <- `device_ids`

      query_params[["deviceVersions"]] <- `device_versions`

      query_params[["locations"]] <- `locations`

      query_params[["radius"]] <- `radius`

      query_params[["active"]] <- `active`

      query_params[["sendSuggestion"]] <- `send_suggestion`

      query_params[["startTimeOffset"]] <- `start_time_offset`

      query_params[["endTimeOffset"]] <- `end_time_offset`

      query_params[["associateDescription"]] <- `associate_description`

      query_params[["associateType"]] <- `associate_type`

      query_params[["associateId"]] <- `associate_id`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["metaData"]] <- `meta_data`

      query_params[["visibility"]] <- `visibility`

      query_params[["audienceType"]] <- `audience_type`

      query_params[["useOrder"]] <- `use_order`

      query_params[["cohortRegionsData"]] <- `cohort_regions_data`

      query_params[["appKey"]] <- `app_key`

      query_params[["trilaterationTypes"]] <- `trilateration_types`

      query_params[["uniqueName"]] <- `unique_name`

      local_var_url_path <- "/audience/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AudienceResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
