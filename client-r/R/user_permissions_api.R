#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title UserPermissions operations
#' @description UserPermissionsApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  AddUsersToPermissionable  ####################
#'
#' library(openapi)
#' var_permissionable_type <- "permissionable_type_example" # character | the permissionable type of the object
#' var_permissionable_id <- 56 # integer | the id of the permissionable object
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_read <- TRUE # character | the read permission of the users/groups (Optional)
#' var_write <- FALSE # character | the write permission of the users/groups (Optional)
#' var_delete <- FALSE # character | the delete permission of the users/groups (Optional)
#' var_add <- FALSE # character | the add permission of the users/groups (Optional)
#' var_connection_ids <- "connection_ids_example" # character | a comma separated list of connection ids (NOT the account ids) (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | a comma separated list of account ids (Optional)
#' var_connection_group_ids <- "connection_group_ids_example" # character | a comma separated list of connection group ids (these are groups made by the user) (Optional)
#' var_pending <- FALSE # character | sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (Optional)
#' var_admin <- "admin_example" # character | sets whether the added users will become admins or not (Optional)
#' var_include_friend_group <- FALSE # character | flag to determine whether to include the built-in \"friends\" group (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#' var_audience_ids <- "audience_ids_example" # character | comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used. (Optional)
#'
#' #Add User
#' api_instance <- UserPermissionsApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddUsersToPermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, read = var_read, write = var_write, delete = var_delete, add = var_add, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, connection_group_ids = var_connection_group_ids, pending = var_pending, admin = var_admin, include_friend_group = var_include_friend_group, latitude = var_latitude, longitude = var_longitude, audience_ids = var_audience_idsdata_file = "result.txt")
#' result <- api_instance$AddUsersToPermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, read = var_read, write = var_write, delete = var_delete, add = var_add, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, connection_group_ids = var_connection_group_ids, pending = var_pending, admin = var_admin, include_friend_group = var_include_friend_group, latitude = var_latitude, longitude = var_longitude, audience_ids = var_audience_ids)
#' dput(result)
#'
#'
#' ####################  ApprovePermissionable  ####################
#'
#' library(openapi)
#' var_permissionable_type <- "permissionable_type_example" # character | The permissionable type of the object
#' var_permissionable_id <- 56 # integer | The id of the permissionable object
#' var_device_id <- "device_id_example" # character | A unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account ID of the user (deviceId or accountId required) (Optional)
#' var_approval_status <- "APPROVED" # character | The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (Optional)
#'
#' #Approve Permissionable
#' api_instance <- UserPermissionsApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ApprovePermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, approval_status = var_approval_statusdata_file = "result.txt")
#' result <- api_instance$ApprovePermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, approval_status = var_approval_status)
#' dput(result)
#'
#'
#' ####################  LeaveFromPermissionable  ####################
#'
#' library(openapi)
#' var_permissionable_type <- "permissionable_type_example" # character | the permissionable type PermissionableType
#' var_permissionable_id <- 56 # integer | the id of the permissionable object
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#'
#' #Leave
#' api_instance <- UserPermissionsApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$LeaveFromPermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitudedata_file = "result.txt")
#' result <- api_instance$LeaveFromPermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, latitude = var_latitude, longitude = var_longitude)
#' dput(result)
#'
#'
#' ####################  RemoveUsersFromPermissionable  ####################
#'
#' library(openapi)
#' var_permissionable_type <- "permissionable_type_example" # character | the permissionable type of the object
#' var_permissionable_id <- 56 # integer | the id of the permissionable object
#' var_device_id <- "device_id_example" # character | the device id (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_connection_ids <- "connection_ids_example" # character | a comma separated list of connection ids (NOT the account ids) (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | a comma separated list of account ids (Optional)
#' var_connection_group_ids <- "connection_group_ids_example" # character | a comma separated list of connection group ids (these are groups made by the user) (Optional)
#' var_remove_friend_group <- FALSE # character | flag to determine whether to remove the built-in \"friends\" group (Optional)
#' var_latitude <- 3.4 # numeric | the current latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the current longitude of the user (Optional)
#' var_audience_ids <- "audience_ids_example" # character | comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used. (Optional)
#'
#' #Remove User
#' api_instance <- UserPermissionsApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveUsersFromPermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, connection_group_ids = var_connection_group_ids, remove_friend_group = var_remove_friend_group, latitude = var_latitude, longitude = var_longitude, audience_ids = var_audience_idsdata_file = "result.txt")
#' result <- api_instance$RemoveUsersFromPermissionable(var_permissionable_type, var_permissionable_id, device_id = var_device_id, account_id = var_account_id, connection_ids = var_connection_ids, connection_account_ids = var_connection_account_ids, connection_group_ids = var_connection_group_ids, remove_friend_group = var_remove_friend_group, latitude = var_latitude, longitude = var_longitude, audience_ids = var_audience_ids)
#' dput(result)
#'
#'
#' ####################  SearchPermissionables  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | A unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account ID of the user (deviceId or accountId required) (Optional)
#' var_connection_account_id <- 56 # integer | Filter results for a specific user account (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | Comma separated list of account IDs to filter results with (Optional)
#' var_permissionable_type <- "permissionable_type_example" # character | Filter user permissions by the permissionable object type (Optional)
#' var_permissionable_id <- 56 # integer | The id of the permissionable object to filter by (Optional)
#' var_keyword <- "keyword_example" # character | Keyword to search within permissionable records (Optional)
#' var_sort_field <- "sort_field_example" # character | Field to sort results on (Optional)
#' var_descending <- "descending_example" # character | Sort descending when true (Optional)
#' var_pending <- "pending_example" # character | Return user permissions that are pending (Optional)
#' var_admin <- "admin_example" # character | Return user permissions that are admins (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var_limit <- 20 # integer | the limit for pagination (Optional)
#'
#' #Search Permissionables
#' api_instance <- UserPermissionsApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchPermissionables(device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, connection_account_ids = var_connection_account_ids, permissionable_type = var_permissionable_type, permissionable_id = var_permissionable_id, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, pending = var_pending, admin = var_admin, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchPermissionables(device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, connection_account_ids = var_connection_account_ids, permissionable_type = var_permissionable_type, permissionable_id = var_permissionable_id, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, pending = var_pending, admin = var_admin, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  SearchPermissionablesFollowingDistance  ####################
#'
#' library(openapi)
#' var_latitude <- 3.4 # numeric | The latitude of the current account
#' var_longitude <- 3.4 # numeric | The longitude of the current account
#' var_device_id <- "device_id_example" # character | A unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account ID of the user (deviceId or accountId required) (Optional)
#' var_connection_account_id <- 56 # integer | Filter results for a specific user account (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | Comma separated list of account IDs to filter results with (Optional)
#' var_permissionable_type <- "permissionable_type_example" # character | Filter user permissions by the permissionable object type (Optional)
#' var_permissionable_id <- 56 # integer | The id of the permissionable object to filter by (Optional)
#' var_search_range <- 5 # numeric | The search range in miles (Optional)
#' var_keyword <- "keyword_example" # character | Keyword to search within permissionable records (Optional)
#' var_pending <- "pending_example" # character | Return user permissions that are pending (Optional)
#' var_admin <- "admin_example" # character | Return user permissions that are admins (Optional)
#' var_start <- 0 # integer | The start index for pagination (Optional)
#' var_limit <- 20 # integer | The limit for pagination (Optional)
#'
#' #Search Permissionables by Distnace
#' api_instance <- UserPermissionsApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchPermissionablesFollowingDistance(var_latitude, var_longitude, device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, connection_account_ids = var_connection_account_ids, permissionable_type = var_permissionable_type, permissionable_id = var_permissionable_id, search_range = var_search_range, keyword = var_keyword, pending = var_pending, admin = var_admin, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchPermissionablesFollowingDistance(var_latitude, var_longitude, device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, connection_account_ids = var_connection_account_ids, permissionable_type = var_permissionable_type, permissionable_id = var_permissionable_id, search_range = var_search_range, keyword = var_keyword, pending = var_pending, admin = var_admin, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
UserPermissionsApi <- R6::R6Class(
  "UserPermissionsApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new UserPermissionsApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Add User
    #'
    #' @param permissionable_type the permissionable type of the object
    #' @param permissionable_id the id of the permissionable object
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param read (optional) the read permission of the users/groups (default value: TRUE)
    #' @param write (optional) the write permission of the users/groups (default value: FALSE)
    #' @param delete (optional) the delete permission of the users/groups (default value: FALSE)
    #' @param add (optional) the add permission of the users/groups (default value: FALSE)
    #' @param connection_ids (optional) a comma separated list of connection ids (NOT the account ids)
    #' @param connection_account_ids (optional) a comma separated list of account ids
    #' @param connection_group_ids (optional) a comma separated list of connection group ids (these are groups made by the user)
    #' @param pending (optional) sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (default value: FALSE)
    #' @param admin (optional) sets whether the added users will become admins or not
    #' @param include_friend_group (optional) flag to determine whether to include the built-in \"friends\" group (default value: FALSE)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param audience_ids (optional) comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    AddUsersToPermissionable = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, read = TRUE, write = FALSE, delete = FALSE, add = FALSE, connection_ids = NULL, connection_account_ids = NULL, connection_group_ids = NULL, pending = FALSE, admin = NULL, include_friend_group = FALSE, latitude = NULL, longitude = NULL, audience_ids = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddUsersToPermissionableWithHttpInfo(permissionable_type, permissionable_id, device_id, account_id, read, write, delete, add, connection_ids, connection_account_ids, connection_group_ids, pending, admin, include_friend_group, latitude, longitude, audience_ids, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Add User
    #'
    #' @param permissionable_type the permissionable type of the object
    #' @param permissionable_id the id of the permissionable object
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param read (optional) the read permission of the users/groups (default value: TRUE)
    #' @param write (optional) the write permission of the users/groups (default value: FALSE)
    #' @param delete (optional) the delete permission of the users/groups (default value: FALSE)
    #' @param add (optional) the add permission of the users/groups (default value: FALSE)
    #' @param connection_ids (optional) a comma separated list of connection ids (NOT the account ids)
    #' @param connection_account_ids (optional) a comma separated list of account ids
    #' @param connection_group_ids (optional) a comma separated list of connection group ids (these are groups made by the user)
    #' @param pending (optional) sets whether the added users are marked as pending (and will require the album admins to accept) - admins can set this to false (to accept) (default value: FALSE)
    #' @param admin (optional) sets whether the added users will become admins or not
    #' @param include_friend_group (optional) flag to determine whether to include the built-in \"friends\" group (default value: FALSE)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param audience_ids (optional) comma separated list of audience ids. This is a feature only available to the permissionable's application owner (and its employees). This will add all users from these audiences to the permissionable object. Notifications will not be sent to users if this feature is used.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    AddUsersToPermissionableWithHttpInfo = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, read = TRUE, write = FALSE, delete = FALSE, add = FALSE, connection_ids = NULL, connection_account_ids = NULL, connection_group_ids = NULL, pending = FALSE, admin = NULL, include_friend_group = FALSE, latitude = NULL, longitude = NULL, audience_ids = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`permissionable_type`)) {
        stop("Missing required parameter `permissionable_type`.")
      }

      if (missing(`permissionable_id`)) {
        stop("Missing required parameter `permissionable_id`.")
      }

      if (!missing(`permissionable_type`) && is.null(`permissionable_type`)) {
        stop("Invalid value for `permissionable_type` when calling UserPermissionsApi$AddUsersToPermissionable, `permissionable_type` is not nullable")
      }

      if (!missing(`permissionable_id`) && is.null(`permissionable_id`)) {
        stop("Invalid value for `permissionable_id` when calling UserPermissionsApi$AddUsersToPermissionable, `permissionable_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling UserPermissionsApi$AddUsersToPermissionable, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling UserPermissionsApi$AddUsersToPermissionable, `account_id` is not nullable")
      }

      if (!missing(`read`) && is.null(`read`)) {
        stop("Invalid value for `read` when calling UserPermissionsApi$AddUsersToPermissionable, `read` is not nullable")
      }

      if (!missing(`write`) && is.null(`write`)) {
        stop("Invalid value for `write` when calling UserPermissionsApi$AddUsersToPermissionable, `write` is not nullable")
      }

      if (!missing(`delete`) && is.null(`delete`)) {
        stop("Invalid value for `delete` when calling UserPermissionsApi$AddUsersToPermissionable, `delete` is not nullable")
      }

      if (!missing(`add`) && is.null(`add`)) {
        stop("Invalid value for `add` when calling UserPermissionsApi$AddUsersToPermissionable, `add` is not nullable")
      }

      if (!missing(`connection_ids`) && is.null(`connection_ids`)) {
        stop("Invalid value for `connection_ids` when calling UserPermissionsApi$AddUsersToPermissionable, `connection_ids` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling UserPermissionsApi$AddUsersToPermissionable, `connection_account_ids` is not nullable")
      }

      if (!missing(`connection_group_ids`) && is.null(`connection_group_ids`)) {
        stop("Invalid value for `connection_group_ids` when calling UserPermissionsApi$AddUsersToPermissionable, `connection_group_ids` is not nullable")
      }

      if (!missing(`pending`) && is.null(`pending`)) {
        stop("Invalid value for `pending` when calling UserPermissionsApi$AddUsersToPermissionable, `pending` is not nullable")
      }

      if (!missing(`admin`) && is.null(`admin`)) {
        stop("Invalid value for `admin` when calling UserPermissionsApi$AddUsersToPermissionable, `admin` is not nullable")
      }

      if (!missing(`include_friend_group`) && is.null(`include_friend_group`)) {
        stop("Invalid value for `include_friend_group` when calling UserPermissionsApi$AddUsersToPermissionable, `include_friend_group` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling UserPermissionsApi$AddUsersToPermissionable, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling UserPermissionsApi$AddUsersToPermissionable, `longitude` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling UserPermissionsApi$AddUsersToPermissionable, `audience_ids` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      if (!is.null(`permissionable_type`) && !(`permissionable_type` %in% c("ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"))) {
        stop("Invalid value for permissionable_type when calling UserPermissionsApi$AddUsersToPermissionable. Must be [ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER].")
      }
      query_params[["permissionableType"]] <- `permissionable_type`

      query_params[["permissionableId"]] <- `permissionable_id`

      query_params[["read"]] <- `read`

      query_params[["write"]] <- `write`

      query_params[["delete"]] <- `delete`

      query_params[["add"]] <- `add`

      query_params[["connectionIds"]] <- `connection_ids`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      query_params[["connectionGroupIds"]] <- `connection_group_ids`

      query_params[["pending"]] <- `pending`

      query_params[["admin"]] <- `admin`

      query_params[["includeFriendGroup"]] <- `include_friend_group`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["audienceIds"]] <- `audience_ids`

      local_var_url_path <- "/consumer/permissions/add"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Approve Permissionable
    #'
    #' @param permissionable_type The permissionable type of the object
    #' @param permissionable_id The id of the permissionable object
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param approval_status (optional) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (default value: "APPROVED")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    ApprovePermissionable = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, approval_status = "APPROVED", data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$ApprovePermissionableWithHttpInfo(permissionable_type, permissionable_id, device_id, account_id, approval_status, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Approve Permissionable
    #'
    #' @param permissionable_type The permissionable type of the object
    #' @param permissionable_id The id of the permissionable object
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param approval_status (optional) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (default value: "APPROVED")
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    ApprovePermissionableWithHttpInfo = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, approval_status = "APPROVED", data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`permissionable_type`)) {
        stop("Missing required parameter `permissionable_type`.")
      }

      if (missing(`permissionable_id`)) {
        stop("Missing required parameter `permissionable_id`.")
      }

      if (!missing(`permissionable_type`) && is.null(`permissionable_type`)) {
        stop("Invalid value for `permissionable_type` when calling UserPermissionsApi$ApprovePermissionable, `permissionable_type` is not nullable")
      }

      if (!missing(`permissionable_id`) && is.null(`permissionable_id`)) {
        stop("Invalid value for `permissionable_id` when calling UserPermissionsApi$ApprovePermissionable, `permissionable_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling UserPermissionsApi$ApprovePermissionable, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling UserPermissionsApi$ApprovePermissionable, `account_id` is not nullable")
      }

      if (!missing(`approval_status`) && is.null(`approval_status`)) {
        stop("Invalid value for `approval_status` when calling UserPermissionsApi$ApprovePermissionable, `approval_status` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      if (!is.null(`permissionable_type`) && !(`permissionable_type` %in% c("ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"))) {
        stop("Invalid value for permissionable_type when calling UserPermissionsApi$ApprovePermissionable. Must be [ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER].")
      }
      query_params[["permissionableType"]] <- `permissionable_type`

      query_params[["permissionableId"]] <- `permissionable_id`

      if (!is.null(`approval_status`) && !(`approval_status` %in% c("PENDING", "REJECTED", "APPROVED", "FEATURED"))) {
        stop("Invalid value for approval_status when calling UserPermissionsApi$ApprovePermissionable. Must be [PENDING, REJECTED, APPROVED, FEATURED].")
      }
      query_params[["approvalStatus"]] <- `approval_status`

      local_var_url_path <- "/permissionable/approve"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Leave
    #'
    #' @param permissionable_type the permissionable type PermissionableType
    #' @param permissionable_id the id of the permissionable object
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    LeaveFromPermissionable = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$LeaveFromPermissionableWithHttpInfo(permissionable_type, permissionable_id, device_id, account_id, latitude, longitude, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Leave
    #'
    #' @param permissionable_type the permissionable type PermissionableType
    #' @param permissionable_id the id of the permissionable object
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    LeaveFromPermissionableWithHttpInfo = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, latitude = NULL, longitude = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`permissionable_type`)) {
        stop("Missing required parameter `permissionable_type`.")
      }

      if (missing(`permissionable_id`)) {
        stop("Missing required parameter `permissionable_id`.")
      }

      if (!missing(`permissionable_type`) && is.null(`permissionable_type`)) {
        stop("Invalid value for `permissionable_type` when calling UserPermissionsApi$LeaveFromPermissionable, `permissionable_type` is not nullable")
      }

      if (!missing(`permissionable_id`) && is.null(`permissionable_id`)) {
        stop("Invalid value for `permissionable_id` when calling UserPermissionsApi$LeaveFromPermissionable, `permissionable_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling UserPermissionsApi$LeaveFromPermissionable, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling UserPermissionsApi$LeaveFromPermissionable, `account_id` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling UserPermissionsApi$LeaveFromPermissionable, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling UserPermissionsApi$LeaveFromPermissionable, `longitude` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["permissionableType"]] <- `permissionable_type`

      query_params[["permissionableId"]] <- `permissionable_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      local_var_url_path <- "/consumer/permissions/leave"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Remove User
    #'
    #' @param permissionable_type the permissionable type of the object
    #' @param permissionable_id the id of the permissionable object
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_ids (optional) a comma separated list of connection ids (NOT the account ids)
    #' @param connection_account_ids (optional) a comma separated list of account ids
    #' @param connection_group_ids (optional) a comma separated list of connection group ids (these are groups made by the user)
    #' @param remove_friend_group (optional) flag to determine whether to remove the built-in \"friends\" group (default value: FALSE)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param audience_ids (optional) comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveUsersFromPermissionable = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, connection_ids = NULL, connection_account_ids = NULL, connection_group_ids = NULL, remove_friend_group = FALSE, latitude = NULL, longitude = NULL, audience_ids = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveUsersFromPermissionableWithHttpInfo(permissionable_type, permissionable_id, device_id, account_id, connection_ids, connection_account_ids, connection_group_ids, remove_friend_group, latitude, longitude, audience_ids, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Remove User
    #'
    #' @param permissionable_type the permissionable type of the object
    #' @param permissionable_id the id of the permissionable object
    #' @param device_id (optional) the device id (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param connection_ids (optional) a comma separated list of connection ids (NOT the account ids)
    #' @param connection_account_ids (optional) a comma separated list of account ids
    #' @param connection_group_ids (optional) a comma separated list of connection group ids (these are groups made by the user)
    #' @param remove_friend_group (optional) flag to determine whether to remove the built-in \"friends\" group (default value: FALSE)
    #' @param latitude (optional) the current latitude of the user
    #' @param longitude (optional) the current longitude of the user
    #' @param audience_ids (optional) comma separated list of audience ids. This will remove all users from these audiences from the permissionable object. Notifications will not be sent to users if this feature is used.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveUsersFromPermissionableWithHttpInfo = function(permissionable_type, permissionable_id, device_id = NULL, account_id = NULL, connection_ids = NULL, connection_account_ids = NULL, connection_group_ids = NULL, remove_friend_group = FALSE, latitude = NULL, longitude = NULL, audience_ids = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`permissionable_type`)) {
        stop("Missing required parameter `permissionable_type`.")
      }

      if (missing(`permissionable_id`)) {
        stop("Missing required parameter `permissionable_id`.")
      }

      if (!missing(`permissionable_type`) && is.null(`permissionable_type`)) {
        stop("Invalid value for `permissionable_type` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `permissionable_type` is not nullable")
      }

      if (!missing(`permissionable_id`) && is.null(`permissionable_id`)) {
        stop("Invalid value for `permissionable_id` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `permissionable_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `account_id` is not nullable")
      }

      if (!missing(`connection_ids`) && is.null(`connection_ids`)) {
        stop("Invalid value for `connection_ids` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `connection_ids` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `connection_account_ids` is not nullable")
      }

      if (!missing(`connection_group_ids`) && is.null(`connection_group_ids`)) {
        stop("Invalid value for `connection_group_ids` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `connection_group_ids` is not nullable")
      }

      if (!missing(`remove_friend_group`) && is.null(`remove_friend_group`)) {
        stop("Invalid value for `remove_friend_group` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `remove_friend_group` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `longitude` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling UserPermissionsApi$RemoveUsersFromPermissionable, `audience_ids` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      if (!is.null(`permissionable_type`) && !(`permissionable_type` %in% c("ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"))) {
        stop("Invalid value for permissionable_type when calling UserPermissionsApi$RemoveUsersFromPermissionable. Must be [ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER].")
      }
      query_params[["permissionableType"]] <- `permissionable_type`

      query_params[["permissionableId"]] <- `permissionable_id`

      query_params[["connectionIds"]] <- `connection_ids`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      query_params[["connectionGroupIds"]] <- `connection_group_ids`

      query_params[["removeFriendGroup"]] <- `remove_friend_group`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["audienceIds"]] <- `audience_ids`

      local_var_url_path <- "/consumer/permissions/remove"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Permissionables
    #'
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param connection_account_id (optional) Filter results for a specific user account
    #' @param connection_account_ids (optional) Comma separated list of account IDs to filter results with
    #' @param permissionable_type (optional) Filter user permissions by the permissionable object type
    #' @param permissionable_id (optional) The id of the permissionable object to filter by
    #' @param keyword (optional) Keyword to search within permissionable records
    #' @param sort_field (optional) Field to sort results on
    #' @param descending (optional) Sort descending when true
    #' @param pending (optional) Return user permissions that are pending
    #' @param admin (optional) Return user permissions that are admins
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[UserPermissionsResponse]
    SearchPermissionables = function(device_id = NULL, account_id = NULL, connection_account_id = NULL, connection_account_ids = NULL, permissionable_type = NULL, permissionable_id = NULL, keyword = NULL, sort_field = NULL, descending = NULL, pending = NULL, admin = NULL, start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchPermissionablesWithHttpInfo(device_id, account_id, connection_account_id, connection_account_ids, permissionable_type, permissionable_id, keyword, sort_field, descending, pending, admin, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Permissionables
    #'
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param connection_account_id (optional) Filter results for a specific user account
    #' @param connection_account_ids (optional) Comma separated list of account IDs to filter results with
    #' @param permissionable_type (optional) Filter user permissions by the permissionable object type
    #' @param permissionable_id (optional) The id of the permissionable object to filter by
    #' @param keyword (optional) Keyword to search within permissionable records
    #' @param sort_field (optional) Field to sort results on
    #' @param descending (optional) Sort descending when true
    #' @param pending (optional) Return user permissions that are pending
    #' @param admin (optional) Return user permissions that are admins
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[UserPermissionsResponse]) with additional information such as HTTP status code, headers
    SearchPermissionablesWithHttpInfo = function(device_id = NULL, account_id = NULL, connection_account_id = NULL, connection_account_ids = NULL, permissionable_type = NULL, permissionable_id = NULL, keyword = NULL, sort_field = NULL, descending = NULL, pending = NULL, admin = NULL, start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling UserPermissionsApi$SearchPermissionables, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling UserPermissionsApi$SearchPermissionables, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling UserPermissionsApi$SearchPermissionables, `connection_account_id` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling UserPermissionsApi$SearchPermissionables, `connection_account_ids` is not nullable")
      }

      if (!missing(`permissionable_type`) && is.null(`permissionable_type`)) {
        stop("Invalid value for `permissionable_type` when calling UserPermissionsApi$SearchPermissionables, `permissionable_type` is not nullable")
      }

      if (!missing(`permissionable_id`) && is.null(`permissionable_id`)) {
        stop("Invalid value for `permissionable_id` when calling UserPermissionsApi$SearchPermissionables, `permissionable_id` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling UserPermissionsApi$SearchPermissionables, `keyword` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling UserPermissionsApi$SearchPermissionables, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling UserPermissionsApi$SearchPermissionables, `descending` is not nullable")
      }

      if (!missing(`pending`) && is.null(`pending`)) {
        stop("Invalid value for `pending` when calling UserPermissionsApi$SearchPermissionables, `pending` is not nullable")
      }

      if (!missing(`admin`) && is.null(`admin`)) {
        stop("Invalid value for `admin` when calling UserPermissionsApi$SearchPermissionables, `admin` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling UserPermissionsApi$SearchPermissionables, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UserPermissionsApi$SearchPermissionables, `limit` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      if (!is.null(`permissionable_type`) && !(`permissionable_type` %in% c("ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"))) {
        stop("Invalid value for permissionable_type when calling UserPermissionsApi$SearchPermissionables. Must be [ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER].")
      }
      query_params[["permissionableType"]] <- `permissionable_type`

      query_params[["permissionableId"]] <- `permissionable_id`

      query_params[["keyword"]] <- `keyword`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["pending"]] <- `pending`

      query_params[["admin"]] <- `admin`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/permissions/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[UserPermissionsResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Permissionables by Distnace
    #'
    #' @param latitude The latitude of the current account
    #' @param longitude The longitude of the current account
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param connection_account_id (optional) Filter results for a specific user account
    #' @param connection_account_ids (optional) Comma separated list of account IDs to filter results with
    #' @param permissionable_type (optional) Filter user permissions by the permissionable object type
    #' @param permissionable_id (optional) The id of the permissionable object to filter by
    #' @param search_range (optional) The search range in miles (default value: 5)
    #' @param keyword (optional) Keyword to search within permissionable records
    #' @param pending (optional) Return user permissions that are pending
    #' @param admin (optional) Return user permissions that are admins
    #' @param start (optional) The start index for pagination (default value: 0)
    #' @param limit (optional) The limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[UserPermissionsResponse]
    SearchPermissionablesFollowingDistance = function(latitude, longitude, device_id = NULL, account_id = NULL, connection_account_id = NULL, connection_account_ids = NULL, permissionable_type = NULL, permissionable_id = NULL, search_range = 5, keyword = NULL, pending = NULL, admin = NULL, start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchPermissionablesFollowingDistanceWithHttpInfo(latitude, longitude, device_id, account_id, connection_account_id, connection_account_ids, permissionable_type, permissionable_id, search_range, keyword, pending, admin, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Permissionables by Distnace
    #'
    #' @param latitude The latitude of the current account
    #' @param longitude The longitude of the current account
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param connection_account_id (optional) Filter results for a specific user account
    #' @param connection_account_ids (optional) Comma separated list of account IDs to filter results with
    #' @param permissionable_type (optional) Filter user permissions by the permissionable object type
    #' @param permissionable_id (optional) The id of the permissionable object to filter by
    #' @param search_range (optional) The search range in miles (default value: 5)
    #' @param keyword (optional) Keyword to search within permissionable records
    #' @param pending (optional) Return user permissions that are pending
    #' @param admin (optional) Return user permissions that are admins
    #' @param start (optional) The start index for pagination (default value: 0)
    #' @param limit (optional) The limit for pagination (default value: 20)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[UserPermissionsResponse]) with additional information such as HTTP status code, headers
    SearchPermissionablesFollowingDistanceWithHttpInfo = function(latitude, longitude, device_id = NULL, account_id = NULL, connection_account_id = NULL, connection_account_ids = NULL, permissionable_type = NULL, permissionable_id = NULL, search_range = 5, keyword = NULL, pending = NULL, admin = NULL, start = 0, limit = 20, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`latitude`)) {
        stop("Missing required parameter `latitude`.")
      }

      if (missing(`longitude`)) {
        stop("Missing required parameter `longitude`.")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `longitude` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `connection_account_id` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `connection_account_ids` is not nullable")
      }

      if (!missing(`permissionable_type`) && is.null(`permissionable_type`)) {
        stop("Invalid value for `permissionable_type` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `permissionable_type` is not nullable")
      }

      if (!missing(`permissionable_id`) && is.null(`permissionable_id`)) {
        stop("Invalid value for `permissionable_id` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `permissionable_id` is not nullable")
      }

      if (!missing(`search_range`) && is.null(`search_range`)) {
        stop("Invalid value for `search_range` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `search_range` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `keyword` is not nullable")
      }

      if (!missing(`pending`) && is.null(`pending`)) {
        stop("Invalid value for `pending` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `pending` is not nullable")
      }

      if (!missing(`admin`) && is.null(`admin`)) {
        stop("Invalid value for `admin` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `admin` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling UserPermissionsApi$SearchPermissionablesFollowingDistance, `limit` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      if (!is.null(`permissionable_type`) && !(`permissionable_type` %in% c("ACCOUNT", "GAMELEVEL", "ALBUM_CONTEST", "THEME_DESCRIPTOR", "SCHEDULED_NOTIFICATION", "TASK", "TRIGGER"))) {
        stop("Invalid value for permissionable_type when calling UserPermissionsApi$SearchPermissionablesFollowingDistance. Must be [ACCOUNT, GAMELEVEL, ALBUM_CONTEST, THEME_DESCRIPTOR, SCHEDULED_NOTIFICATION, TASK, TRIGGER].")
      }
      query_params[["permissionableType"]] <- `permissionable_type`

      query_params[["permissionableId"]] <- `permissionable_id`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["searchRange"]] <- `search_range`

      query_params[["keyword"]] <- `keyword`

      query_params[["pending"]] <- `pending`

      query_params[["admin"]] <- `admin`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/permissions/distancesearch"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[UserPermissionsResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
