#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Trigger operations
#' @description TriggerApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateTrigger  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user
#' var_name <- "name_example" # character | The name of the trigger
#' var_app_key <- "app_key_example" # character | The application to target (Optional)
#' var_grouping_id <- "grouping_id_example" # character | Client defined identifier for grouping triggers (Optional)
#' var_endpoint_url <- "endpoint_url_example" # character | The URL for making an HTTP call (Optional)
#' var_payload <- "payload_example" # character | The parameters for making an HTTP call (Optional)
#' var_scheduled_date <- 56 # integer | The date and time of the next trigger (Optional)
#' var_start_date <- 56 # integer | The starting date of the trigger (Optional)
#' var_end_date <- 56 # integer | The ending date of the trigger (Optional)
#' var_cron_expression <- "cron_expression_example" # character | The cron expression that represents the trigger's schedule (Optional)
#' var_conditional_input <- "conditional_input_example" # character | Json input representing conditional logic that has to be met before running the trigger (Optional)
#' var_visibility <- "visibility_example" # character | The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (Optional)
#' var_active <- TRUE # character | Sets whether the Trigger is active or not (inactive Triggers are not processed) (Optional)
#'
#' #Create Trigger
#' api_instance <- TriggerApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateTrigger(var_account_id, var_name, app_key = var_app_key, grouping_id = var_grouping_id, endpoint_url = var_endpoint_url, payload = var_payload, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, conditional_input = var_conditional_input, visibility = var_visibility, active = var_activedata_file = "result.txt")
#' result <- api_instance$CreateTrigger(var_account_id, var_name, app_key = var_app_key, grouping_id = var_grouping_id, endpoint_url = var_endpoint_url, payload = var_payload, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, conditional_input = var_conditional_input, visibility = var_visibility, active = var_active)
#' dput(result)
#'
#'
#' ####################  DeleteTrigger  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_trigger_id <- 56 # integer | The id of the trigger to delete.
#'
#' #Delete Trigger
#' api_instance <- TriggerApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteTrigger(var_account_id, var_trigger_iddata_file = "result.txt")
#' result <- api_instance$DeleteTrigger(var_account_id, var_trigger_id)
#' dput(result)
#'
#'
#' ####################  GetTrigger  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_trigger_id <- 56 # integer | The id of the Trigger to return.
#'
#' #Get Trigger
#' api_instance <- TriggerApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetTrigger(var_account_id, var_trigger_iddata_file = "result.txt")
#' result <- api_instance$GetTrigger(var_account_id, var_trigger_id)
#' dput(result)
#'
#'
#' ####################  SearchTriggers  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_grouping_id <- "grouping_id_example" # character | Filter results by a grouping identifier defined by the client (Optional)
#' var_filter <- "MINE" # character | A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (Optional)
#' var_statuses <- "NEW,ERROR,COMPLETE,PROCESSING" # character | Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (Optional)
#' var_template_types <- "template_types_example" # character | Template Types (Optional)
#' var_app_key <- "app_key_example" # character | Filter the list by a specific application (Optional)
#' var_keyword <- "keyword_example" # character | Keyword search on the trigger names. (Optional)
#' var_sort_field <- "CREATED" # character | The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (Optional)
#' var_descending <- TRUE # character | Determines whether the sorted list is in descending or ascending order (Optional)
#' var_start <- 0 # integer | Start the result set at some index. (Optional)
#' var_limit <- 20 # integer | Limit the result to some number. (Optional)
#' var_active_only <- TRUE # character | Determines whether to return only active results (Optional)
#'
#' #Search Triggers
#' api_instance <- TriggerApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchTriggers(var_account_id, grouping_id = var_grouping_id, filter = var_filter, statuses = var_statuses, template_types = var_template_types, app_key = var_app_key, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_onlydata_file = "result.txt")
#' result <- api_instance$SearchTriggers(var_account_id, grouping_id = var_grouping_id, filter = var_filter, statuses = var_statuses, template_types = var_template_types, app_key = var_app_key, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_only)
#' dput(result)
#'
#'
#' ####################  UpdateTrigger  ####################
#'
#' library(openapi)
#' var_trigger_id <- 56 # integer | The trigger to update
#' var_account_id <- 56 # integer | The logged in user
#' var_name <- "name_example" # character | The name of the trigger (Optional)
#' var_app_key <- "app_key_example" # character | The application to target (Optional)
#' var_grouping_id <- "grouping_id_example" # character | Client defined identifier for grouping triggers (Optional)
#' var_endpoint_url <- "endpoint_url_example" # character | The URL for making an HTTP call (Optional)
#' var_payload <- "payload_example" # character | The parameters for making an HTTP call (Optional)
#' var_scheduled_date <- 56 # integer | The date and time of the next trigger (Optional)
#' var_start_date <- 56 # integer | The starting date of the trigger (Optional)
#' var_end_date <- 56 # integer | The ending date of the trigger (Optional)
#' var_cron_expression <- "cron_expression_example" # character | The cron expression that represents the trigger's schedule (Optional)
#' var_conditional_input <- "conditional_input_example" # character | Json input representing conditional logic that has to be met before running the trigger (Optional)
#' var_visibility <- "visibility_example" # character | The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (Optional)
#' var_active <- "active_example" # character | Sets whether the Trigger is active or not (inactive Triggers are not processed) (Optional)
#'
#' #Update Trigger
#' api_instance <- TriggerApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateTrigger(var_trigger_id, var_account_id, name = var_name, app_key = var_app_key, grouping_id = var_grouping_id, endpoint_url = var_endpoint_url, payload = var_payload, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, conditional_input = var_conditional_input, visibility = var_visibility, active = var_activedata_file = "result.txt")
#' result <- api_instance$UpdateTrigger(var_trigger_id, var_account_id, name = var_name, app_key = var_app_key, grouping_id = var_grouping_id, endpoint_url = var_endpoint_url, payload = var_payload, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, conditional_input = var_conditional_input, visibility = var_visibility, active = var_active)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
TriggerApi <- R6::R6Class(
  "TriggerApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new TriggerApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Trigger
    #'
    #' @param account_id The logged in user
    #' @param name The name of the trigger
    #' @param app_key (optional) The application to target
    #' @param grouping_id (optional) Client defined identifier for grouping triggers
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param scheduled_date (optional) The date and time of the next trigger
    #' @param start_date (optional) The starting date of the trigger
    #' @param end_date (optional) The ending date of the trigger
    #' @param cron_expression (optional) The cron expression that represents the trigger's schedule
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the trigger
    #' @param visibility (optional) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Trigger is active or not (inactive Triggers are not processed) (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return TriggerResponse
    CreateTrigger = function(account_id, name, app_key = NULL, grouping_id = NULL, endpoint_url = NULL, payload = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, conditional_input = NULL, visibility = NULL, active = TRUE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateTriggerWithHttpInfo(account_id, name, app_key, grouping_id, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, conditional_input, visibility, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Trigger
    #'
    #' @param account_id The logged in user
    #' @param name The name of the trigger
    #' @param app_key (optional) The application to target
    #' @param grouping_id (optional) Client defined identifier for grouping triggers
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param scheduled_date (optional) The date and time of the next trigger
    #' @param start_date (optional) The starting date of the trigger
    #' @param end_date (optional) The ending date of the trigger
    #' @param cron_expression (optional) The cron expression that represents the trigger's schedule
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the trigger
    #' @param visibility (optional) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Trigger is active or not (inactive Triggers are not processed) (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (TriggerResponse) with additional information such as HTTP status code, headers
    CreateTriggerWithHttpInfo = function(account_id, name, app_key = NULL, grouping_id = NULL, endpoint_url = NULL, payload = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, conditional_input = NULL, visibility = NULL, active = TRUE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TriggerApi$CreateTrigger, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling TriggerApi$CreateTrigger, `name` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TriggerApi$CreateTrigger, `app_key` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling TriggerApi$CreateTrigger, `grouping_id` is not nullable")
      }

      if (!missing(`endpoint_url`) && is.null(`endpoint_url`)) {
        stop("Invalid value for `endpoint_url` when calling TriggerApi$CreateTrigger, `endpoint_url` is not nullable")
      }

      if (!missing(`payload`) && is.null(`payload`)) {
        stop("Invalid value for `payload` when calling TriggerApi$CreateTrigger, `payload` is not nullable")
      }

      if (!missing(`scheduled_date`) && is.null(`scheduled_date`)) {
        stop("Invalid value for `scheduled_date` when calling TriggerApi$CreateTrigger, `scheduled_date` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TriggerApi$CreateTrigger, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TriggerApi$CreateTrigger, `end_date` is not nullable")
      }

      if (!missing(`cron_expression`) && is.null(`cron_expression`)) {
        stop("Invalid value for `cron_expression` when calling TriggerApi$CreateTrigger, `cron_expression` is not nullable")
      }

      if (!missing(`conditional_input`) && is.null(`conditional_input`)) {
        stop("Invalid value for `conditional_input` when calling TriggerApi$CreateTrigger, `conditional_input` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling TriggerApi$CreateTrigger, `visibility` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling TriggerApi$CreateTrigger, `active` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["appKey"]] <- `app_key`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["endpointURL"]] <- `endpoint_url`

      query_params[["payload"]] <- `payload`

      query_params[["scheduledDate"]] <- `scheduled_date`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["cronExpression"]] <- `cron_expression`

      query_params[["conditionalInput"]] <- `conditional_input`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling TriggerApi$CreateTrigger. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/trigger/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "TriggerResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Trigger
    #'
    #' @param account_id The logged in user.
    #' @param trigger_id The id of the trigger to delete.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteTrigger = function(account_id, trigger_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteTriggerWithHttpInfo(account_id, trigger_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Trigger
    #'
    #' @param account_id The logged in user.
    #' @param trigger_id The id of the trigger to delete.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteTriggerWithHttpInfo = function(account_id, trigger_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`trigger_id`)) {
        stop("Missing required parameter `trigger_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TriggerApi$DeleteTrigger, `account_id` is not nullable")
      }

      if (!missing(`trigger_id`) && is.null(`trigger_id`)) {
        stop("Invalid value for `trigger_id` when calling TriggerApi$DeleteTrigger, `trigger_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["triggerId"]] <- `trigger_id`

      local_var_url_path <- "/trigger/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Trigger
    #'
    #' @param account_id The logged in user.
    #' @param trigger_id The id of the Trigger to return.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return TriggerResponse
    GetTrigger = function(account_id, trigger_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetTriggerWithHttpInfo(account_id, trigger_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Trigger
    #'
    #' @param account_id The logged in user.
    #' @param trigger_id The id of the Trigger to return.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (TriggerResponse) with additional information such as HTTP status code, headers
    GetTriggerWithHttpInfo = function(account_id, trigger_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`trigger_id`)) {
        stop("Missing required parameter `trigger_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TriggerApi$GetTrigger, `account_id` is not nullable")
      }

      if (!missing(`trigger_id`) && is.null(`trigger_id`)) {
        stop("Invalid value for `trigger_id` when calling TriggerApi$GetTrigger, `trigger_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["triggerId"]] <- `trigger_id`

      local_var_url_path <- "/trigger/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "TriggerResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Triggers
    #'
    #' @param account_id The logged in user.
    #' @param grouping_id (optional) Filter results by a grouping identifier defined by the client
    #' @param filter (optional) A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (default value: "MINE")
    #' @param statuses (optional) Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (default value: "NEW,ERROR,COMPLETE,PROCESSING")
    #' @param template_types (optional) Template Types
    #' @param app_key (optional) Filter the list by a specific application
    #' @param keyword (optional) Keyword search on the trigger names.
    #' @param sort_field (optional) The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (default value: "CREATED")
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order (default value: TRUE)
    #' @param start (optional) Start the result set at some index. (default value: 0)
    #' @param limit (optional) Limit the result to some number. (default value: 20)
    #' @param active_only (optional) Determines whether to return only active results (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[TriggerResponse]
    SearchTriggers = function(account_id, grouping_id = NULL, filter = "MINE", statuses = "NEW,ERROR,COMPLETE,PROCESSING", template_types = NULL, app_key = NULL, keyword = NULL, sort_field = "CREATED", descending = TRUE, start = 0, limit = 20, active_only = TRUE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchTriggersWithHttpInfo(account_id, grouping_id, filter, statuses, template_types, app_key, keyword, sort_field, descending, start, limit, active_only, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Triggers
    #'
    #' @param account_id The logged in user.
    #' @param grouping_id (optional) Filter results by a grouping identifier defined by the client
    #' @param filter (optional) A comma separated list of filters. * MINE - Return triggers that the user has created * SHARED - Return triggers that have been shared to the user * FOLLOWER - Return triggers that have been created by the user''s followers (the content needs to have been APPROVED or FEATURED) * FOLLOWING - Return triggers that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED) * PUBLIC - Return all PUBLIC triggers that have been APPROVED or FEATURED * ALL_PUBLIC - Return all PUBLIC triggers regardless of whether they are approved or not (ignores the approval status) * LIKED - Return all triggers that the user has liked * FEATURED - Return all triggers that have been featured * PENDING - Return all pending triggers  (default value: "MINE")
    #' @param statuses (optional) Filter results by status (comma separated list). Values include: NEW, ERROR, COMPLETE, PROCESSING, TEMPLATE (default value: "NEW,ERROR,COMPLETE,PROCESSING")
    #' @param template_types (optional) Template Types
    #' @param app_key (optional) Filter the list by a specific application
    #' @param keyword (optional) Keyword search on the trigger names.
    #' @param sort_field (optional) The field to sort by. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, SCHEDULED_DATE, START_DATE, END_DATE (default value: "CREATED")
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order (default value: TRUE)
    #' @param start (optional) Start the result set at some index. (default value: 0)
    #' @param limit (optional) Limit the result to some number. (default value: 20)
    #' @param active_only (optional) Determines whether to return only active results (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[TriggerResponse]) with additional information such as HTTP status code, headers
    SearchTriggersWithHttpInfo = function(account_id, grouping_id = NULL, filter = "MINE", statuses = "NEW,ERROR,COMPLETE,PROCESSING", template_types = NULL, app_key = NULL, keyword = NULL, sort_field = "CREATED", descending = TRUE, start = 0, limit = 20, active_only = TRUE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TriggerApi$SearchTriggers, `account_id` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling TriggerApi$SearchTriggers, `grouping_id` is not nullable")
      }

      if (!missing(`filter`) && is.null(`filter`)) {
        stop("Invalid value for `filter` when calling TriggerApi$SearchTriggers, `filter` is not nullable")
      }

      if (!missing(`statuses`) && is.null(`statuses`)) {
        stop("Invalid value for `statuses` when calling TriggerApi$SearchTriggers, `statuses` is not nullable")
      }

      if (!missing(`template_types`) && is.null(`template_types`)) {
        stop("Invalid value for `template_types` when calling TriggerApi$SearchTriggers, `template_types` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TriggerApi$SearchTriggers, `app_key` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling TriggerApi$SearchTriggers, `keyword` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling TriggerApi$SearchTriggers, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling TriggerApi$SearchTriggers, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling TriggerApi$SearchTriggers, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling TriggerApi$SearchTriggers, `limit` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling TriggerApi$SearchTriggers, `active_only` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["filter"]] <- `filter`

      query_params[["statuses"]] <- `statuses`

      query_params[["templateTypes"]] <- `template_types`

      query_params[["appKey"]] <- `app_key`

      query_params[["keyword"]] <- `keyword`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["activeOnly"]] <- `active_only`

      local_var_url_path <- "/trigger/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[TriggerResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Trigger
    #'
    #' @param trigger_id The trigger to update
    #' @param account_id The logged in user
    #' @param name (optional) The name of the trigger
    #' @param app_key (optional) The application to target
    #' @param grouping_id (optional) Client defined identifier for grouping triggers
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param scheduled_date (optional) The date and time of the next trigger
    #' @param start_date (optional) The starting date of the trigger
    #' @param end_date (optional) The ending date of the trigger
    #' @param cron_expression (optional) The cron expression that represents the trigger's schedule
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the trigger
    #' @param visibility (optional) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Trigger is active or not (inactive Triggers are not processed)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return TriggerResponse
    UpdateTrigger = function(trigger_id, account_id, name = NULL, app_key = NULL, grouping_id = NULL, endpoint_url = NULL, payload = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, conditional_input = NULL, visibility = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateTriggerWithHttpInfo(trigger_id, account_id, name, app_key, grouping_id, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, conditional_input, visibility, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Trigger
    #'
    #' @param trigger_id The trigger to update
    #' @param account_id The logged in user
    #' @param name (optional) The name of the trigger
    #' @param app_key (optional) The application to target
    #' @param grouping_id (optional) Client defined identifier for grouping triggers
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param scheduled_date (optional) The date and time of the next trigger
    #' @param start_date (optional) The starting date of the trigger
    #' @param end_date (optional) The ending date of the trigger
    #' @param cron_expression (optional) The cron expression that represents the trigger's schedule
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the trigger
    #' @param visibility (optional) The determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Trigger is active or not (inactive Triggers are not processed)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (TriggerResponse) with additional information such as HTTP status code, headers
    UpdateTriggerWithHttpInfo = function(trigger_id, account_id, name = NULL, app_key = NULL, grouping_id = NULL, endpoint_url = NULL, payload = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, conditional_input = NULL, visibility = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`trigger_id`)) {
        stop("Missing required parameter `trigger_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`trigger_id`) && is.null(`trigger_id`)) {
        stop("Invalid value for `trigger_id` when calling TriggerApi$UpdateTrigger, `trigger_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling TriggerApi$UpdateTrigger, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling TriggerApi$UpdateTrigger, `name` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling TriggerApi$UpdateTrigger, `app_key` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling TriggerApi$UpdateTrigger, `grouping_id` is not nullable")
      }

      if (!missing(`endpoint_url`) && is.null(`endpoint_url`)) {
        stop("Invalid value for `endpoint_url` when calling TriggerApi$UpdateTrigger, `endpoint_url` is not nullable")
      }

      if (!missing(`payload`) && is.null(`payload`)) {
        stop("Invalid value for `payload` when calling TriggerApi$UpdateTrigger, `payload` is not nullable")
      }

      if (!missing(`scheduled_date`) && is.null(`scheduled_date`)) {
        stop("Invalid value for `scheduled_date` when calling TriggerApi$UpdateTrigger, `scheduled_date` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling TriggerApi$UpdateTrigger, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling TriggerApi$UpdateTrigger, `end_date` is not nullable")
      }

      if (!missing(`cron_expression`) && is.null(`cron_expression`)) {
        stop("Invalid value for `cron_expression` when calling TriggerApi$UpdateTrigger, `cron_expression` is not nullable")
      }

      if (!missing(`conditional_input`) && is.null(`conditional_input`)) {
        stop("Invalid value for `conditional_input` when calling TriggerApi$UpdateTrigger, `conditional_input` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling TriggerApi$UpdateTrigger, `visibility` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling TriggerApi$UpdateTrigger, `active` is not nullable")
      }

      query_params[["triggerId"]] <- `trigger_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["appKey"]] <- `app_key`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["endpointURL"]] <- `endpoint_url`

      query_params[["payload"]] <- `payload`

      query_params[["scheduledDate"]] <- `scheduled_date`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["cronExpression"]] <- `cron_expression`

      query_params[["conditionalInput"]] <- `conditional_input`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling TriggerApi$UpdateTrigger. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/trigger/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "TriggerResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
