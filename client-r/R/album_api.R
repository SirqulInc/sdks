#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Album operations
#' @description AlbumApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  AddAlbumCollection  ####################
#'
#' library(openapi)
#' var_title <- "title_example" # character | the title of the album
#' var_cover_asset_nullable <- "cover_asset_nullable_example" # character | determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image
#' var_include_cover_in_asset_list <- "include_cover_in_asset_list_example" # character | determines whether the cover image should be added to the album asset list
#' var_public_read <- "public_read_example" # character | determines whether the album's participants has read permissions
#' var_public_write <- "public_write_example" # character | determines whether the album's participants has write permissions
#' var_public_delete <- "public_delete_example" # character | determines whether the album's participants has delete permissions
#' var_public_add <- "public_add_example" # character | determines whether the album's participants has add permissions
#' var_anonymous <- "anonymous_example" # character | determines whether the album is posted anonymously
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#' var_assets_to_add <- "assets_to_add_example" # character | Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album) (Optional)
#' var_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty) (Optional)
#' var_media_url <- "media_url_example" # character | this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty) (Optional)
#' var_asset_id <- 56 # integer | The asset ID to set the album cover image (Optional)
#' var_attached_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video. (Optional)
#' var_attached_media_url <- "attached_media_url_example" # character | this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc) (Optional)
#' var_start_date <- 56 # integer | the start date (Optional)
#' var_end_date <- 56 # integer | the end date (Optional)
#' var_tags <- "tags_example" # character | the tags (Optional)
#' var_description <- "description_example" # character | the description of the album (Optional)
#' var_album_type <- "album_type_example" # character | a custom field used for aggregation and searching (Optional)
#' var_album_type_id <- 56 # integer | a custom indexed number used for aggregation and searching (Optional)
#' var_sub_type <- "sub_type_example" # character | a custom string field used for aggregation and searching (Optional)
#' var_latitude <- 3.4 # numeric | latitude used to update the album's location (Optional)
#' var_longitude <- 3.4 # numeric | longitude used to update the album's location (Optional)
#' var_location_description <- "location_description_example" # character | the location description (Optional)
#' var_visibility <- "visibility_example" # character | the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (Optional)
#' var_game_type <- "game_type_example" # character | @deprecated, use the appKey (Optional)
#' var_app_key <- "app_key_example" # character | the application key (Optional)
#' var_cell_phone <- "cell_phone_example" # character | the cell phone number (Optional)
#' var_street_address <- "street_address_example" # character | The street address of the location (Optional)
#' var_street_address2 <- "street_address2_example" # character | Additional address information (such as a suite number, floor number, building name, or PO Box) (Optional)
#' var_city <- "city_example" # character | The city of the location (Optional)
#' var_state <- "state_example" # character | The state of of the location (Optional)
#' var_postal_code <- "postal_code_example" # character | The postal code of the location (Optional)
#' var_full_address <- "full_address_example" # character | The full address of the location which should include the street address, city, state, and postal code (Optional)
#' var_meta_data <- "meta_data_example" # character | External custom client defined data (Optional)
#' var_category_ids <- "category_ids_example" # character | comma separated category ids string associated with the Album (Optional)
#' var_category_filter_ids <- "category_filter_ids_example" # character | comma separated filter ids string associated with the Album (Optional)
#' var_audience_ids <- "audience_ids_example" # character | comma separated audience ids string associated with the album (Optional)
#' var_include_all_app_users_as_members <- "include_all_app_users_as_members_example" # character | determines whether to include all app users as members (only admins of the app can do this) (Optional)
#' var_include_audiences_as_members <- "include_audiences_as_members_example" # character | determines whether to include all users of the audiences as members (only admins of the app can do this) (Optional)
#' var_audience_operator <- "audience_operator_example" # character | determines whether to use ands or ors when using the audience list to add users (Optional)
#' var_approval_status <- "approval_status_example" # character | The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (Optional)
#' var_linked_object_type <- "linked_object_type_example" # character | sets a linked object so that it can be returned as part of the album response (Optional)
#' var_linked_object_id <- 56 # integer | sets a linked object id so that it can be returned as part of the album response (Optional)
#'
#' #Create Album
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddAlbumCollection(var_title, var_cover_asset_nullable, var_include_cover_in_asset_list, var_public_read, var_public_write, var_public_delete, var_public_add, var_anonymous, device_id = var_device_id, account_id = var_account_id, assets_to_add = var_assets_to_add, media = var_media, media_url = var_media_url, asset_id = var_asset_id, attached_media = var_attached_media, attached_media_url = var_attached_media_url, start_date = var_start_date, end_date = var_end_date, tags = var_tags, description = var_description, album_type = var_album_type, album_type_id = var_album_type_id, sub_type = var_sub_type, latitude = var_latitude, longitude = var_longitude, location_description = var_location_description, visibility = var_visibility, game_type = var_game_type, app_key = var_app_key, cell_phone = var_cell_phone, street_address = var_street_address, street_address2 = var_street_address2, city = var_city, state = var_state, postal_code = var_postal_code, full_address = var_full_address, meta_data = var_meta_data, category_ids = var_category_ids, category_filter_ids = var_category_filter_ids, audience_ids = var_audience_ids, include_all_app_users_as_members = var_include_all_app_users_as_members, include_audiences_as_members = var_include_audiences_as_members, audience_operator = var_audience_operator, approval_status = var_approval_status, linked_object_type = var_linked_object_type, linked_object_id = var_linked_object_iddata_file = "result.txt")
#' result <- api_instance$AddAlbumCollection(var_title, var_cover_asset_nullable, var_include_cover_in_asset_list, var_public_read, var_public_write, var_public_delete, var_public_add, var_anonymous, device_id = var_device_id, account_id = var_account_id, assets_to_add = var_assets_to_add, media = var_media, media_url = var_media_url, asset_id = var_asset_id, attached_media = var_attached_media, attached_media_url = var_attached_media_url, start_date = var_start_date, end_date = var_end_date, tags = var_tags, description = var_description, album_type = var_album_type, album_type_id = var_album_type_id, sub_type = var_sub_type, latitude = var_latitude, longitude = var_longitude, location_description = var_location_description, visibility = var_visibility, game_type = var_game_type, app_key = var_app_key, cell_phone = var_cell_phone, street_address = var_street_address, street_address2 = var_street_address2, city = var_city, state = var_state, postal_code = var_postal_code, full_address = var_full_address, meta_data = var_meta_data, category_ids = var_category_ids, category_filter_ids = var_category_filter_ids, audience_ids = var_audience_ids, include_all_app_users_as_members = var_include_all_app_users_as_members, include_audiences_as_members = var_include_audiences_as_members, audience_operator = var_audience_operator, approval_status = var_approval_status, linked_object_type = var_linked_object_type, linked_object_id = var_linked_object_id)
#' dput(result)
#'
#'
#' ####################  AddAlbumUsers  ####################
#'
#' library(openapi)
#' var_album_id <- 56 # integer | the album ID
#' var_include_friend_group <- "include_friend_group_example" # character | determines whether to include all friends as participants
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#' var_read <- "read_example" # character | determines whether the users being added have read permissions (Optional)
#' var_write <- "write_example" # character | determines whether the users being added have write permissions (Optional)
#' var_delete <- "delete_example" # character | determines whether the users being added have delete permissions (Optional)
#' var_add <- "add_example" # character | determines whether the users being added have add permissions (Optional)
#' var_connections <- "connections_example" # character | comma separated list of connection IDs (Optional)
#' var_connection_groups <- "connection_groups_example" # character | comma separated list of connection group IDs (Optional)
#'
#' #Add Album Users
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$AddAlbumUsers(var_album_id, var_include_friend_group, device_id = var_device_id, account_id = var_account_id, read = var_read, write = var_write, delete = var_delete, add = var_add, connections = var_connections, connection_groups = var_connection_groupsdata_file = "result.txt")
#' result <- api_instance$AddAlbumUsers(var_album_id, var_include_friend_group, device_id = var_device_id, account_id = var_account_id, read = var_read, write = var_write, delete = var_delete, add = var_add, connections = var_connections, connection_groups = var_connection_groups)
#' dput(result)
#'
#'
#' ####################  ApproveAlbum  ####################
#'
#' library(openapi)
#' var_album_id <- 56 # integer | The ID of the album
#' var_device_id <- "device_id_example" # character | A unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | The account ID of the user (deviceId or accountId required) (Optional)
#' var_approval_status <- "approval_status_example" # character | The approval status to set {PENDING, REJECTED, APPROVED, FEATURED} (Optional)
#' var_verified <- "verified_example" # character | Sets whether the album should be marked as \"verified\" (Optional)
#'
#' #Approve Album
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ApproveAlbum(var_album_id, device_id = var_device_id, account_id = var_account_id, approval_status = var_approval_status, verified = var_verifieddata_file = "result.txt")
#' result <- api_instance$ApproveAlbum(var_album_id, device_id = var_device_id, account_id = var_account_id, approval_status = var_approval_status, verified = var_verified)
#' dput(result)
#'
#'
#' ####################  GetAlbumCollection  ####################
#'
#' library(openapi)
#' var_return_nulls <- "return_nulls_example" # character | This parameter is deprecated.
#' var_album_id <- 56 # integer | the album to look up
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#' var_like_preview_size <- 56 # integer | returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\"Â endpoint. (Optional)
#' var_asset_preview_size <- 56 # integer | returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\"Â endpoint. (Optional)
#' var_note_preview_size <- 56 # integer | returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint. (Optional)
#' var_connection_preview_size <- 56 # integer | returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint. (Optional)
#' var_audience_preview_size <- 56 # integer | returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint. (Optional)
#'
#' # Get Album
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetAlbumCollection(var_return_nulls, var_album_id, device_id = var_device_id, account_id = var_account_id, like_preview_size = var_like_preview_size, asset_preview_size = var_asset_preview_size, note_preview_size = var_note_preview_size, connection_preview_size = var_connection_preview_size, audience_preview_size = var_audience_preview_sizedata_file = "result.txt")
#' result <- api_instance$GetAlbumCollection(var_return_nulls, var_album_id, device_id = var_device_id, account_id = var_account_id, like_preview_size = var_like_preview_size, asset_preview_size = var_asset_preview_size, note_preview_size = var_note_preview_size, connection_preview_size = var_connection_preview_size, audience_preview_size = var_audience_preview_size)
#' dput(result)
#'
#'
#' ####################  LeaveAlbum  ####################
#'
#' library(openapi)
#' var_album_id <- 56 # integer | the album ID
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#'
#' #Leave Album
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$LeaveAlbum(var_album_id, device_id = var_device_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$LeaveAlbum(var_album_id, device_id = var_device_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  RemoveAlbum  ####################
#'
#' library(openapi)
#' var_album_id <- 56 # integer | the album ID to delete
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#'
#' #Delete Album
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveAlbum(var_album_id, device_id = var_device_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$RemoveAlbum(var_album_id, device_id = var_device_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  RemoveAlbumUsers  ####################
#'
#' library(openapi)
#' var_album_id <- 56 # integer | the album ID
#' var_remove_friend_group <- "remove_friend_group_example" # character | remove friend group
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#' var_connections <- "connections_example" # character | comma separated list of connection IDs (Optional)
#' var_connection_groups <- "connection_groups_example" # character | comma separated list of connection group IDs (Optional)
#'
#' #Remove Album Users
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$RemoveAlbumUsers(var_album_id, var_remove_friend_group, device_id = var_device_id, account_id = var_account_id, connections = var_connections, connection_groups = var_connection_groupsdata_file = "result.txt")
#' result <- api_instance$RemoveAlbumUsers(var_album_id, var_remove_friend_group, device_id = var_device_id, account_id = var_account_id, connections = var_connections, connection_groups = var_connection_groups)
#' dput(result)
#'
#'
#' ####################  SearchAlbums  ####################
#'
#' library(openapi)
#' var_filter <- "filter_example" # character | a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
#' var_album_type_id <- 56 # integer | id of custom albumType
#' var_sub_type <- "sub_type_example" # character | filter albums with this album sub type
#' var_include_inactive <- "include_inactive_example" # character | determines whether to return inactive albums
#' var_sort_field <- "sort_field_example" # character | the field to sort by. See AlbumApiMap
#' var_descending <- "descending_example" # character | determines whether the sorted list is in descending or ascending order
#' var_start <- 56 # integer | the start index for pagination
#' var_limit <- 56 # integer | the limit for pagination (There is a hard limit of 100)
#' var_range <- 3.4 # numeric | the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)
#' var_include_liked <- "include_liked_example" # character | returns whether or not the current logged in user has liked the album
#' var_include_favorited <- "include_favorited_example" # character | returns whether or not the current logged in user has favorited the album
#' var_include_permissions <- "include_permissions_example" # character | returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)
#' var_like_preview_size <- 56 # integer | returns the last X likes
#' var_asset_preview_size <- 56 # integer | returns the first X assets
#' var_note_preview_size <- 56 # integer | returns the last X notes
#' var_connection_preview_size <- 56 # integer | returns the first X users/connections
#' var_audience_preview_size <- 56 # integer | returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#' var_connection_account_id <- 56 # integer | the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited. (Optional)
#' var_owner_id <- 56 # integer | search on albums that have been created by this account (that the user has permissions to) (Optional)
#' var_album_ids <- "album_ids_example" # character | search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true) (Optional)
#' var_exclude_album_ids <- "exclude_album_ids_example" # character | Only for CLOUDINDEX mode, exclude albums with ids matching this list (Optional)
#' var_media_id <- 56 # integer | search on albums that are in a particular media offering (Optional)
#' var_keyword <- "keyword_example" # character | keyword search string (Optional)
#' var_album_type <- "album_type_example" # character | filter albums with this album type (Optional)
#' var_limit_per_album_type <- 56 # integer | When using multiple album types this sets a per-album-type limit (used with cloud index mode) (Optional)
#' var_date_created <- 56 # integer | return items that have been created before this date (time-stamp in milliseconds) (Optional)
#' var_updated_since <- 56 # integer | return items that have been updated since this date (time-stamp in milliseconds) (Optional)
#' var_updated_before <- 56 # integer | return items that have been updated before this date (time-stamp in milliseconds) (Optional)
#' var_created_since <- 56 # integer | return items that have been created since this date (time-stamp in milliseconds) (Optional)
#' var_created_before <- 56 # integer | return items that have been created before this date (time-stamp in milliseconds) (Optional)
#' var_started_since <- 56 # integer | return items that have been started since this date (time-stamp in milliseconds) (Optional)
#' var_started_before <- 56 # integer | return items that have been started before this date (time-stamp in milliseconds) (Optional)
#' var_ended_since <- 56 # integer | return items that have been ended since this date (time-stamp in milliseconds) (Optional)
#' var_ended_before <- 56 # integer | return items that have been ended before this date (time-stamp in milliseconds) (Optional)
#' var_latitude <- 3.4 # numeric | the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE) (Optional)
#' var_longitude <- 3.4 # numeric | the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE) (Optional)
#' var_app_key <- "app_key_example" # character | the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to. (Optional)
#' var_category_ids <- "category_ids_example" # character | return results with categories matching this list (Optional)
#' var_category_filter_ids <- "category_filter_ids_example" # character | return results with filters matching this list (Optional)
#' var_audience_ids <- "audience_ids_example" # character | return results with audiences matching this list (Optional)
#' var_exclude_audience_ids <- "exclude_audience_ids_example" # character | exclude audiences with ids matching this list (Optional)
#' var_include_completable <- "include_completable_example" # character | returns the user's completable object for the album if it exists (Optional)
#' var_include_rating <- "include_rating_example" # character | returns the user's rating for the album if it exists (Optional)
#' var_search_mode <- "search_mode_example" # character | The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default. (Optional)
#' var_stack_search <- "stack_search_example" # character | groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize (Optional)
#' var_stack_window_size <- 56 # integer | size of each window for each stack (Optional)
#' var_min_stack_per_page <- 56 # integer | The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results (Optional)
#' var_stack_pagination_identifier <- "stack_pagination_identifier_example" # character | this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch (Optional)
#' var_stack_details <- "stack_details_example" # character | set this to true when making the call to view the albums in the stack (Optional)
#' var_flag_count_minimum <- 56 # integer | Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold) (Optional)
#' var_remove_flagged_content <- TRUE # character | return items that have flagCount >= flagThreshold (controls removal of flagged content) (Optional)
#' var_verified_filter <- "verified_filter_example" # character | setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both) (Optional)
#' var_linked_object_type <- "linked_object_type_example" # character | filter results by the linkedObjectType (Optional)
#' var_linked_object_id <- 56 # integer | filter results by the linkedObjectId (Optional)
#' var_order_audience_id <- 56 # integer | determines whether to use the order assigned via the /album/order/* api (which is tied to an audience) (Optional)
#' var_ignore_default_app_filter <- "ignore_default_app_filter_example" # character | if true, ignore the application's default app filter when searching (Optional)
#' var_search_expression <- "search_expression_example" # character | Advanced search expression to be used by the server (Optional)
#' var_generate_albums <- "generate_albums_example" # character | If true and results are empty, attempt to generate albums via templates (Optional)
#'
#' #Search Albums
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchAlbums(var_filter, var_album_type_id, var_sub_type, var_include_inactive, var_sort_field, var_descending, var_start, var_limit, var_range, var_include_liked, var_include_favorited, var_include_permissions, var_like_preview_size, var_asset_preview_size, var_note_preview_size, var_connection_preview_size, var_audience_preview_size, device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, owner_id = var_owner_id, album_ids = var_album_ids, exclude_album_ids = var_exclude_album_ids, media_id = var_media_id, keyword = var_keyword, album_type = var_album_type, limit_per_album_type = var_limit_per_album_type, date_created = var_date_created, updated_since = var_updated_since, updated_before = var_updated_before, created_since = var_created_since, created_before = var_created_before, started_since = var_started_since, started_before = var_started_before, ended_since = var_ended_since, ended_before = var_ended_before, latitude = var_latitude, longitude = var_longitude, app_key = var_app_key, category_ids = var_category_ids, category_filter_ids = var_category_filter_ids, audience_ids = var_audience_ids, exclude_audience_ids = var_exclude_audience_ids, include_completable = var_include_completable, include_rating = var_include_rating, search_mode = var_search_mode, stack_search = var_stack_search, stack_window_size = var_stack_window_size, min_stack_per_page = var_min_stack_per_page, stack_pagination_identifier = var_stack_pagination_identifier, stack_details = var_stack_details, flag_count_minimum = var_flag_count_minimum, remove_flagged_content = var_remove_flagged_content, verified_filter = var_verified_filter, linked_object_type = var_linked_object_type, linked_object_id = var_linked_object_id, order_audience_id = var_order_audience_id, ignore_default_app_filter = var_ignore_default_app_filter, search_expression = var_search_expression, generate_albums = var_generate_albumsdata_file = "result.txt")
#' result <- api_instance$SearchAlbums(var_filter, var_album_type_id, var_sub_type, var_include_inactive, var_sort_field, var_descending, var_start, var_limit, var_range, var_include_liked, var_include_favorited, var_include_permissions, var_like_preview_size, var_asset_preview_size, var_note_preview_size, var_connection_preview_size, var_audience_preview_size, device_id = var_device_id, account_id = var_account_id, connection_account_id = var_connection_account_id, owner_id = var_owner_id, album_ids = var_album_ids, exclude_album_ids = var_exclude_album_ids, media_id = var_media_id, keyword = var_keyword, album_type = var_album_type, limit_per_album_type = var_limit_per_album_type, date_created = var_date_created, updated_since = var_updated_since, updated_before = var_updated_before, created_since = var_created_since, created_before = var_created_before, started_since = var_started_since, started_before = var_started_before, ended_since = var_ended_since, ended_before = var_ended_before, latitude = var_latitude, longitude = var_longitude, app_key = var_app_key, category_ids = var_category_ids, category_filter_ids = var_category_filter_ids, audience_ids = var_audience_ids, exclude_audience_ids = var_exclude_audience_ids, include_completable = var_include_completable, include_rating = var_include_rating, search_mode = var_search_mode, stack_search = var_stack_search, stack_window_size = var_stack_window_size, min_stack_per_page = var_min_stack_per_page, stack_pagination_identifier = var_stack_pagination_identifier, stack_details = var_stack_details, flag_count_minimum = var_flag_count_minimum, remove_flagged_content = var_remove_flagged_content, verified_filter = var_verified_filter, linked_object_type = var_linked_object_type, linked_object_id = var_linked_object_id, order_audience_id = var_order_audience_id, ignore_default_app_filter = var_ignore_default_app_filter, search_expression = var_search_expression, generate_albums = var_generate_albums)
#' dput(result)
#'
#'
#' ####################  UpdateAlbumCollection  ####################
#'
#' library(openapi)
#' var_album_id <- 56 # integer | the ID of the album to update
#' var_device_id <- "device_id_example" # character | a unique ID given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account ID of the user (deviceId or accountId required) (Optional)
#' var_assets_to_add <- "assets_to_add_example" # character | Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album) (Optional)
#' var_assets_to_remove <- "assets_to_remove_example" # character | Comma separated list of asset IDs to remove from the album's asset list (Optional)
#' var_asset_id <- 56 # integer | the cover asset ID (Optional)
#' var_media <- File.new('/path/to/file') # data.frame | a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty) (Optional)
#' var_media_url <- "media_url_example" # character | this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty) (Optional)
#' var_active <- "active_example" # character | determines whether the album is active or inactive (Optional)
#' var_title <- "title_example" # character | the title of the album (Optional)
#' var_start_date <- 56 # integer | the start date (Optional)
#' var_end_date <- 56 # integer | the end date (Optional)
#' var_tags <- "tags_example" # character | the tags (Optional)
#' var_description <- "description_example" # character | the description of the album (Optional)
#' var_album_type <- "album_type_example" # character | a custom field used for aggregation and searching (Optional)
#' var_album_type_id <- 56 # integer | a custom indexed number used for aggregation and searching (Optional)
#' var_sub_type <- "sub_type_example" # character | a custom string field used for aggregation and searching (Optional)
#' var_public_read <- "public_read_example" # character | determines whether the album's participants have read permissions (Optional)
#' var_public_write <- "public_write_example" # character | determines whether the album's participants have write permissions (Optional)
#' var_public_delete <- "public_delete_example" # character | determines whether the album's participants have delete permissions (Optional)
#' var_public_add <- "public_add_example" # character | determines whether the album's participants have add permissions (Optional)
#' var_latitude <- 3.4 # numeric | latitude used to update the album's location (Optional)
#' var_longitude <- 3.4 # numeric | longitude used to update the album's location (Optional)
#' var_location_description <- "location_description_example" # character | the location description (Optional)
#' var_visibility <- "visibility_example" # character | the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants) (Optional)
#' var_cell_phone <- "cell_phone_example" # character | the cell phone number (Optional)
#' var_street_address <- "street_address_example" # character | The street address of the location (Optional)
#' var_street_address2 <- "street_address2_example" # character | Additional address information (such as a suite number, floor number, building name, or PO Box) (Optional)
#' var_city <- "city_example" # character | The city of the location (Optional)
#' var_state <- "state_example" # character | The state of of the location (Optional)
#' var_postal_code <- "postal_code_example" # character | The postal code of the location (Optional)
#' var_full_address <- "full_address_example" # character | The full address of the location which should include the street address, city, state, and postal code (Optional)
#' var_anonymous <- "anonymous_example" # character | determines whether the album is posted anonymously (Optional)
#' var_meta_data <- "meta_data_example" # character | External custom client defined data (Optional)
#' var_category_ids <- "category_ids_example" # character | comma separated category ids string associated with the Album (Optional)
#' var_category_filter_ids <- "category_filter_ids_example" # character | comma separated filter ids string associated with the Album (Optional)
#' var_audience_ids <- "audience_ids_example" # character | comma separated audience ids string associated with the album (Optional)
#' var_audience_ids_to_add <- "audience_ids_to_add_example" # character | comma separated audience ids to add to the album (Optional)
#' var_audience_ids_to_remove <- "audience_ids_to_remove_example" # character | comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd) (Optional)
#' var_include_all_app_users_as_members <- "include_all_app_users_as_members_example" # character | determines whether to include all app users as members (only admins of the app can do this) (Optional)
#' var_include_audiences_as_members <- "include_audiences_as_members_example" # character | determines whether to include all users of the audiences as members (only admins of the app can do this) (Optional)
#' var_audience_operator <- "audience_operator_example" # character | determines whether to use ands or ors when using the audience list to add users (Optional)
#' var_linked_object_type <- "linked_object_type_example" # character | sets a linked object so that it can be returned as part of the album response (Optional)
#' var_linked_object_id <- 56 # integer | sets a linked object id so that it can be returned as part of the album response (Optional)
#' var_index_now <- "index_now_example" # character | determines whether the album should be indexed immediately (Optional)
#'
#' #Update Album
#' api_instance <- AlbumApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateAlbumCollection(var_album_id, device_id = var_device_id, account_id = var_account_id, assets_to_add = var_assets_to_add, assets_to_remove = var_assets_to_remove, asset_id = var_asset_id, media = var_media, media_url = var_media_url, active = var_active, title = var_title, start_date = var_start_date, end_date = var_end_date, tags = var_tags, description = var_description, album_type = var_album_type, album_type_id = var_album_type_id, sub_type = var_sub_type, public_read = var_public_read, public_write = var_public_write, public_delete = var_public_delete, public_add = var_public_add, latitude = var_latitude, longitude = var_longitude, location_description = var_location_description, visibility = var_visibility, cell_phone = var_cell_phone, street_address = var_street_address, street_address2 = var_street_address2, city = var_city, state = var_state, postal_code = var_postal_code, full_address = var_full_address, anonymous = var_anonymous, meta_data = var_meta_data, category_ids = var_category_ids, category_filter_ids = var_category_filter_ids, audience_ids = var_audience_ids, audience_ids_to_add = var_audience_ids_to_add, audience_ids_to_remove = var_audience_ids_to_remove, include_all_app_users_as_members = var_include_all_app_users_as_members, include_audiences_as_members = var_include_audiences_as_members, audience_operator = var_audience_operator, linked_object_type = var_linked_object_type, linked_object_id = var_linked_object_id, index_now = var_index_nowdata_file = "result.txt")
#' result <- api_instance$UpdateAlbumCollection(var_album_id, device_id = var_device_id, account_id = var_account_id, assets_to_add = var_assets_to_add, assets_to_remove = var_assets_to_remove, asset_id = var_asset_id, media = var_media, media_url = var_media_url, active = var_active, title = var_title, start_date = var_start_date, end_date = var_end_date, tags = var_tags, description = var_description, album_type = var_album_type, album_type_id = var_album_type_id, sub_type = var_sub_type, public_read = var_public_read, public_write = var_public_write, public_delete = var_public_delete, public_add = var_public_add, latitude = var_latitude, longitude = var_longitude, location_description = var_location_description, visibility = var_visibility, cell_phone = var_cell_phone, street_address = var_street_address, street_address2 = var_street_address2, city = var_city, state = var_state, postal_code = var_postal_code, full_address = var_full_address, anonymous = var_anonymous, meta_data = var_meta_data, category_ids = var_category_ids, category_filter_ids = var_category_filter_ids, audience_ids = var_audience_ids, audience_ids_to_add = var_audience_ids_to_add, audience_ids_to_remove = var_audience_ids_to_remove, include_all_app_users_as_members = var_include_all_app_users_as_members, include_audiences_as_members = var_include_audiences_as_members, audience_operator = var_audience_operator, linked_object_type = var_linked_object_type, linked_object_id = var_linked_object_id, index_now = var_index_now)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
AlbumApi <- R6::R6Class(
  "AlbumApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new AlbumApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Album
    #'
    #' @param title the title of the album
    #' @param cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image
    #' @param include_cover_in_asset_list determines whether the cover image should be added to the album asset list
    #' @param public_read determines whether the album's participants has read permissions
    #' @param public_write determines whether the album's participants has write permissions
    #' @param public_delete determines whether the album's participants has delete permissions
    #' @param public_add determines whether the album's participants has add permissions
    #' @param anonymous determines whether the album is posted anonymously
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param assets_to_add (optional) Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
    #' @param media (optional) a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
    #' @param media_url (optional) this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
    #' @param asset_id (optional) The asset ID to set the album cover image
    #' @param attached_media (optional) a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
    #' @param attached_media_url (optional) this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
    #' @param start_date (optional) the start date
    #' @param end_date (optional) the end date
    #' @param tags (optional) the tags
    #' @param description (optional) the description of the album
    #' @param album_type (optional) a custom field used for aggregation and searching
    #' @param album_type_id (optional) a custom indexed number used for aggregation and searching
    #' @param sub_type (optional) a custom string field used for aggregation and searching
    #' @param latitude (optional) latitude used to update the album's location
    #' @param longitude (optional) longitude used to update the album's location
    #' @param location_description (optional) the location description
    #' @param visibility (optional) the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
    #' @param game_type (optional) @deprecated, use the appKey
    #' @param app_key (optional) the application key
    #' @param cell_phone (optional) the cell phone number
    #' @param street_address (optional) The street address of the location
    #' @param street_address2 (optional) Additional address information (such as a suite number, floor number, building name, or PO Box)
    #' @param city (optional) The city of the location
    #' @param state (optional) The state of of the location
    #' @param postal_code (optional) The postal code of the location
    #' @param full_address (optional) The full address of the location which should include the street address, city, state, and postal code
    #' @param meta_data (optional) External custom client defined data
    #' @param category_ids (optional) comma separated category ids string associated with the Album
    #' @param category_filter_ids (optional) comma separated filter ids string associated with the Album
    #' @param audience_ids (optional) comma separated audience ids string associated with the album
    #' @param include_all_app_users_as_members (optional) determines whether to include all app users as members (only admins of the app can do this)
    #' @param include_audiences_as_members (optional) determines whether to include all users of the audiences as members (only admins of the app can do this)
    #' @param audience_operator (optional) determines whether to use ands or ors when using the audience list to add users
    #' @param approval_status (optional) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
    #' @param linked_object_type (optional) sets a linked object so that it can be returned as part of the album response
    #' @param linked_object_id (optional) sets a linked object id so that it can be returned as part of the album response
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SearchResponse
    AddAlbumCollection = function(title, cover_asset_nullable, include_cover_in_asset_list, public_read, public_write, public_delete, public_add, anonymous, device_id = NULL, account_id = NULL, assets_to_add = NULL, media = NULL, media_url = NULL, asset_id = NULL, attached_media = NULL, attached_media_url = NULL, start_date = NULL, end_date = NULL, tags = NULL, description = NULL, album_type = NULL, album_type_id = NULL, sub_type = NULL, latitude = NULL, longitude = NULL, location_description = NULL, visibility = NULL, game_type = NULL, app_key = NULL, cell_phone = NULL, street_address = NULL, street_address2 = NULL, city = NULL, state = NULL, postal_code = NULL, full_address = NULL, meta_data = NULL, category_ids = NULL, category_filter_ids = NULL, audience_ids = NULL, include_all_app_users_as_members = NULL, include_audiences_as_members = NULL, audience_operator = NULL, approval_status = NULL, linked_object_type = NULL, linked_object_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddAlbumCollectionWithHttpInfo(title, cover_asset_nullable, include_cover_in_asset_list, public_read, public_write, public_delete, public_add, anonymous, device_id, account_id, assets_to_add, media, media_url, asset_id, attached_media, attached_media_url, start_date, end_date, tags, description, album_type, album_type_id, sub_type, latitude, longitude, location_description, visibility, game_type, app_key, cell_phone, street_address, street_address2, city, state, postal_code, full_address, meta_data, category_ids, category_filter_ids, audience_ids, include_all_app_users_as_members, include_audiences_as_members, audience_operator, approval_status, linked_object_type, linked_object_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Album
    #'
    #' @param title the title of the album
    #' @param cover_asset_nullable determines whether the cover image of the album can be empty, else will use the user's profile picture as the cover image
    #' @param include_cover_in_asset_list determines whether the cover image should be added to the album asset list
    #' @param public_read determines whether the album's participants has read permissions
    #' @param public_write determines whether the album's participants has write permissions
    #' @param public_delete determines whether the album's participants has delete permissions
    #' @param public_add determines whether the album's participants has add permissions
    #' @param anonymous determines whether the album is posted anonymously
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param assets_to_add (optional) Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
    #' @param media (optional) a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
    #' @param media_url (optional) this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
    #' @param asset_id (optional) The asset ID to set the album cover image
    #' @param attached_media (optional) a MultipartFile containing an asset that the \"media\" file references. Example to upload a video: the \"media\" file should contain a screen capture of the video, and the \"attachedMedia\" should be the actual video.
    #' @param attached_media_url (optional) this can be used if the \"attachedMedia\" is a link (i.e. a Youtube video, etc)
    #' @param start_date (optional) the start date
    #' @param end_date (optional) the end date
    #' @param tags (optional) the tags
    #' @param description (optional) the description of the album
    #' @param album_type (optional) a custom field used for aggregation and searching
    #' @param album_type_id (optional) a custom indexed number used for aggregation and searching
    #' @param sub_type (optional) a custom string field used for aggregation and searching
    #' @param latitude (optional) latitude used to update the album's location
    #' @param longitude (optional) longitude used to update the album's location
    #' @param location_description (optional) the location description
    #' @param visibility (optional) the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
    #' @param game_type (optional) @deprecated, use the appKey
    #' @param app_key (optional) the application key
    #' @param cell_phone (optional) the cell phone number
    #' @param street_address (optional) The street address of the location
    #' @param street_address2 (optional) Additional address information (such as a suite number, floor number, building name, or PO Box)
    #' @param city (optional) The city of the location
    #' @param state (optional) The state of of the location
    #' @param postal_code (optional) The postal code of the location
    #' @param full_address (optional) The full address of the location which should include the street address, city, state, and postal code
    #' @param meta_data (optional) External custom client defined data
    #' @param category_ids (optional) comma separated category ids string associated with the Album
    #' @param category_filter_ids (optional) comma separated filter ids string associated with the Album
    #' @param audience_ids (optional) comma separated audience ids string associated with the album
    #' @param include_all_app_users_as_members (optional) determines whether to include all app users as members (only admins of the app can do this)
    #' @param include_audiences_as_members (optional) determines whether to include all users of the audiences as members (only admins of the app can do this)
    #' @param audience_operator (optional) determines whether to use ands or ors when using the audience list to add users
    #' @param approval_status (optional) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
    #' @param linked_object_type (optional) sets a linked object so that it can be returned as part of the album response
    #' @param linked_object_id (optional) sets a linked object id so that it can be returned as part of the album response
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SearchResponse) with additional information such as HTTP status code, headers
    AddAlbumCollectionWithHttpInfo = function(title, cover_asset_nullable, include_cover_in_asset_list, public_read, public_write, public_delete, public_add, anonymous, device_id = NULL, account_id = NULL, assets_to_add = NULL, media = NULL, media_url = NULL, asset_id = NULL, attached_media = NULL, attached_media_url = NULL, start_date = NULL, end_date = NULL, tags = NULL, description = NULL, album_type = NULL, album_type_id = NULL, sub_type = NULL, latitude = NULL, longitude = NULL, location_description = NULL, visibility = NULL, game_type = NULL, app_key = NULL, cell_phone = NULL, street_address = NULL, street_address2 = NULL, city = NULL, state = NULL, postal_code = NULL, full_address = NULL, meta_data = NULL, category_ids = NULL, category_filter_ids = NULL, audience_ids = NULL, include_all_app_users_as_members = NULL, include_audiences_as_members = NULL, audience_operator = NULL, approval_status = NULL, linked_object_type = NULL, linked_object_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`title`)) {
        stop("Missing required parameter `title`.")
      }

      if (missing(`cover_asset_nullable`)) {
        stop("Missing required parameter `cover_asset_nullable`.")
      }

      if (missing(`include_cover_in_asset_list`)) {
        stop("Missing required parameter `include_cover_in_asset_list`.")
      }

      if (missing(`public_read`)) {
        stop("Missing required parameter `public_read`.")
      }

      if (missing(`public_write`)) {
        stop("Missing required parameter `public_write`.")
      }

      if (missing(`public_delete`)) {
        stop("Missing required parameter `public_delete`.")
      }

      if (missing(`public_add`)) {
        stop("Missing required parameter `public_add`.")
      }

      if (missing(`anonymous`)) {
        stop("Missing required parameter `anonymous`.")
      }

      if (!missing(`title`) && is.null(`title`)) {
        stop("Invalid value for `title` when calling AlbumApi$AddAlbumCollection, `title` is not nullable")
      }

      if (!missing(`cover_asset_nullable`) && is.null(`cover_asset_nullable`)) {
        stop("Invalid value for `cover_asset_nullable` when calling AlbumApi$AddAlbumCollection, `cover_asset_nullable` is not nullable")
      }

      if (!missing(`include_cover_in_asset_list`) && is.null(`include_cover_in_asset_list`)) {
        stop("Invalid value for `include_cover_in_asset_list` when calling AlbumApi$AddAlbumCollection, `include_cover_in_asset_list` is not nullable")
      }

      if (!missing(`public_read`) && is.null(`public_read`)) {
        stop("Invalid value for `public_read` when calling AlbumApi$AddAlbumCollection, `public_read` is not nullable")
      }

      if (!missing(`public_write`) && is.null(`public_write`)) {
        stop("Invalid value for `public_write` when calling AlbumApi$AddAlbumCollection, `public_write` is not nullable")
      }

      if (!missing(`public_delete`) && is.null(`public_delete`)) {
        stop("Invalid value for `public_delete` when calling AlbumApi$AddAlbumCollection, `public_delete` is not nullable")
      }

      if (!missing(`public_add`) && is.null(`public_add`)) {
        stop("Invalid value for `public_add` when calling AlbumApi$AddAlbumCollection, `public_add` is not nullable")
      }

      if (!missing(`anonymous`) && is.null(`anonymous`)) {
        stop("Invalid value for `anonymous` when calling AlbumApi$AddAlbumCollection, `anonymous` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$AddAlbumCollection, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$AddAlbumCollection, `account_id` is not nullable")
      }

      if (!missing(`assets_to_add`) && is.null(`assets_to_add`)) {
        stop("Invalid value for `assets_to_add` when calling AlbumApi$AddAlbumCollection, `assets_to_add` is not nullable")
      }

      if (!missing(`media`) && is.null(`media`)) {
        stop("Invalid value for `media` when calling AlbumApi$AddAlbumCollection, `media` is not nullable")
      }

      if (!missing(`media_url`) && is.null(`media_url`)) {
        stop("Invalid value for `media_url` when calling AlbumApi$AddAlbumCollection, `media_url` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling AlbumApi$AddAlbumCollection, `asset_id` is not nullable")
      }

      if (!missing(`attached_media`) && is.null(`attached_media`)) {
        stop("Invalid value for `attached_media` when calling AlbumApi$AddAlbumCollection, `attached_media` is not nullable")
      }

      if (!missing(`attached_media_url`) && is.null(`attached_media_url`)) {
        stop("Invalid value for `attached_media_url` when calling AlbumApi$AddAlbumCollection, `attached_media_url` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling AlbumApi$AddAlbumCollection, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling AlbumApi$AddAlbumCollection, `end_date` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling AlbumApi$AddAlbumCollection, `tags` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling AlbumApi$AddAlbumCollection, `description` is not nullable")
      }

      if (!missing(`album_type`) && is.null(`album_type`)) {
        stop("Invalid value for `album_type` when calling AlbumApi$AddAlbumCollection, `album_type` is not nullable")
      }

      if (!missing(`album_type_id`) && is.null(`album_type_id`)) {
        stop("Invalid value for `album_type_id` when calling AlbumApi$AddAlbumCollection, `album_type_id` is not nullable")
      }

      if (!missing(`sub_type`) && is.null(`sub_type`)) {
        stop("Invalid value for `sub_type` when calling AlbumApi$AddAlbumCollection, `sub_type` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling AlbumApi$AddAlbumCollection, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling AlbumApi$AddAlbumCollection, `longitude` is not nullable")
      }

      if (!missing(`location_description`) && is.null(`location_description`)) {
        stop("Invalid value for `location_description` when calling AlbumApi$AddAlbumCollection, `location_description` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling AlbumApi$AddAlbumCollection, `visibility` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling AlbumApi$AddAlbumCollection, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling AlbumApi$AddAlbumCollection, `app_key` is not nullable")
      }

      if (!missing(`cell_phone`) && is.null(`cell_phone`)) {
        stop("Invalid value for `cell_phone` when calling AlbumApi$AddAlbumCollection, `cell_phone` is not nullable")
      }

      if (!missing(`street_address`) && is.null(`street_address`)) {
        stop("Invalid value for `street_address` when calling AlbumApi$AddAlbumCollection, `street_address` is not nullable")
      }

      if (!missing(`street_address2`) && is.null(`street_address2`)) {
        stop("Invalid value for `street_address2` when calling AlbumApi$AddAlbumCollection, `street_address2` is not nullable")
      }

      if (!missing(`city`) && is.null(`city`)) {
        stop("Invalid value for `city` when calling AlbumApi$AddAlbumCollection, `city` is not nullable")
      }

      if (!missing(`state`) && is.null(`state`)) {
        stop("Invalid value for `state` when calling AlbumApi$AddAlbumCollection, `state` is not nullable")
      }

      if (!missing(`postal_code`) && is.null(`postal_code`)) {
        stop("Invalid value for `postal_code` when calling AlbumApi$AddAlbumCollection, `postal_code` is not nullable")
      }

      if (!missing(`full_address`) && is.null(`full_address`)) {
        stop("Invalid value for `full_address` when calling AlbumApi$AddAlbumCollection, `full_address` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling AlbumApi$AddAlbumCollection, `meta_data` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling AlbumApi$AddAlbumCollection, `category_ids` is not nullable")
      }

      if (!missing(`category_filter_ids`) && is.null(`category_filter_ids`)) {
        stop("Invalid value for `category_filter_ids` when calling AlbumApi$AddAlbumCollection, `category_filter_ids` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling AlbumApi$AddAlbumCollection, `audience_ids` is not nullable")
      }

      if (!missing(`include_all_app_users_as_members`) && is.null(`include_all_app_users_as_members`)) {
        stop("Invalid value for `include_all_app_users_as_members` when calling AlbumApi$AddAlbumCollection, `include_all_app_users_as_members` is not nullable")
      }

      if (!missing(`include_audiences_as_members`) && is.null(`include_audiences_as_members`)) {
        stop("Invalid value for `include_audiences_as_members` when calling AlbumApi$AddAlbumCollection, `include_audiences_as_members` is not nullable")
      }

      if (!missing(`audience_operator`) && is.null(`audience_operator`)) {
        stop("Invalid value for `audience_operator` when calling AlbumApi$AddAlbumCollection, `audience_operator` is not nullable")
      }

      if (!missing(`approval_status`) && is.null(`approval_status`)) {
        stop("Invalid value for `approval_status` when calling AlbumApi$AddAlbumCollection, `approval_status` is not nullable")
      }

      if (!missing(`linked_object_type`) && is.null(`linked_object_type`)) {
        stop("Invalid value for `linked_object_type` when calling AlbumApi$AddAlbumCollection, `linked_object_type` is not nullable")
      }

      if (!missing(`linked_object_id`) && is.null(`linked_object_id`)) {
        stop("Invalid value for `linked_object_id` when calling AlbumApi$AddAlbumCollection, `linked_object_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["title"]] <- `title`

      query_params[["assetsToAdd"]] <- `assets_to_add`

      query_params[["media"]] <- `media`

      query_params[["mediaURL"]] <- `media_url`

      query_params[["assetId"]] <- `asset_id`

      query_params[["attachedMedia"]] <- `attached_media`

      query_params[["attachedMediaURL"]] <- `attached_media_url`

      query_params[["coverAssetNullable"]] <- `cover_asset_nullable`

      query_params[["includeCoverInAssetList"]] <- `include_cover_in_asset_list`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["tags"]] <- `tags`

      query_params[["description"]] <- `description`

      query_params[["albumType"]] <- `album_type`

      query_params[["albumTypeId"]] <- `album_type_id`

      query_params[["subType"]] <- `sub_type`

      query_params[["publicRead"]] <- `public_read`

      query_params[["publicWrite"]] <- `public_write`

      query_params[["publicDelete"]] <- `public_delete`

      query_params[["publicAdd"]] <- `public_add`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["locationDescription"]] <- `location_description`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling AlbumApi$AddAlbumCollection. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["cellPhone"]] <- `cell_phone`

      query_params[["streetAddress"]] <- `street_address`

      query_params[["streetAddress2"]] <- `street_address2`

      query_params[["city"]] <- `city`

      query_params[["state"]] <- `state`

      query_params[["postalCode"]] <- `postal_code`

      query_params[["fullAddress"]] <- `full_address`

      query_params[["anonymous"]] <- `anonymous`

      query_params[["metaData"]] <- `meta_data`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["categoryFilterIds"]] <- `category_filter_ids`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["includeAllAppUsersAsMembers"]] <- `include_all_app_users_as_members`

      query_params[["includeAudiencesAsMembers"]] <- `include_audiences_as_members`

      query_params[["audienceOperator"]] <- `audience_operator`

      if (!is.null(`approval_status`) && !(`approval_status` %in% c("PENDING", "REJECTED", "APPROVED", "FEATURED"))) {
        stop("Invalid value for approval_status when calling AlbumApi$AddAlbumCollection. Must be [PENDING, REJECTED, APPROVED, FEATURED].")
      }
      query_params[["approvalStatus"]] <- `approval_status`

      query_params[["linkedObjectType"]] <- `linked_object_type`

      query_params[["linkedObjectId"]] <- `linked_object_id`

      local_var_url_path <- "/album/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SearchResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Add Album Users
    #'
    #' @param album_id the album ID
    #' @param include_friend_group determines whether to include all friends as participants
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param read (optional) determines whether the users being added have read permissions
    #' @param write (optional) determines whether the users being added have write permissions
    #' @param delete (optional) determines whether the users being added have delete permissions
    #' @param add (optional) determines whether the users being added have add permissions
    #' @param connections (optional) comma separated list of connection IDs
    #' @param connection_groups (optional) comma separated list of connection group IDs
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    AddAlbumUsers = function(album_id, include_friend_group, device_id = NULL, account_id = NULL, read = NULL, write = NULL, delete = NULL, add = NULL, connections = NULL, connection_groups = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$AddAlbumUsersWithHttpInfo(album_id, include_friend_group, device_id, account_id, read, write, delete, add, connections, connection_groups, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Add Album Users
    #'
    #' @param album_id the album ID
    #' @param include_friend_group determines whether to include all friends as participants
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param read (optional) determines whether the users being added have read permissions
    #' @param write (optional) determines whether the users being added have write permissions
    #' @param delete (optional) determines whether the users being added have delete permissions
    #' @param add (optional) determines whether the users being added have add permissions
    #' @param connections (optional) comma separated list of connection IDs
    #' @param connection_groups (optional) comma separated list of connection group IDs
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    AddAlbumUsersWithHttpInfo = function(album_id, include_friend_group, device_id = NULL, account_id = NULL, read = NULL, write = NULL, delete = NULL, add = NULL, connections = NULL, connection_groups = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (missing(`include_friend_group`)) {
        stop("Missing required parameter `include_friend_group`.")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$AddAlbumUsers, `album_id` is not nullable")
      }

      if (!missing(`include_friend_group`) && is.null(`include_friend_group`)) {
        stop("Invalid value for `include_friend_group` when calling AlbumApi$AddAlbumUsers, `include_friend_group` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$AddAlbumUsers, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$AddAlbumUsers, `account_id` is not nullable")
      }

      if (!missing(`read`) && is.null(`read`)) {
        stop("Invalid value for `read` when calling AlbumApi$AddAlbumUsers, `read` is not nullable")
      }

      if (!missing(`write`) && is.null(`write`)) {
        stop("Invalid value for `write` when calling AlbumApi$AddAlbumUsers, `write` is not nullable")
      }

      if (!missing(`delete`) && is.null(`delete`)) {
        stop("Invalid value for `delete` when calling AlbumApi$AddAlbumUsers, `delete` is not nullable")
      }

      if (!missing(`add`) && is.null(`add`)) {
        stop("Invalid value for `add` when calling AlbumApi$AddAlbumUsers, `add` is not nullable")
      }

      if (!missing(`connections`) && is.null(`connections`)) {
        stop("Invalid value for `connections` when calling AlbumApi$AddAlbumUsers, `connections` is not nullable")
      }

      if (!missing(`connection_groups`) && is.null(`connection_groups`)) {
        stop("Invalid value for `connection_groups` when calling AlbumApi$AddAlbumUsers, `connection_groups` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      query_params[["read"]] <- `read`

      query_params[["write"]] <- `write`

      query_params[["delete"]] <- `delete`

      query_params[["add"]] <- `add`

      query_params[["connections"]] <- `connections`

      query_params[["connectionGroups"]] <- `connection_groups`

      query_params[["includeFriendGroup"]] <- `include_friend_group`

      local_var_url_path <- "/album/user/add"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Approve Album
    #'
    #' @param album_id The ID of the album
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param approval_status (optional) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
    #' @param verified (optional) Sets whether the album should be marked as \"verified\"
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    ApproveAlbum = function(album_id, device_id = NULL, account_id = NULL, approval_status = NULL, verified = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$ApproveAlbumWithHttpInfo(album_id, device_id, account_id, approval_status, verified, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Approve Album
    #'
    #' @param album_id The ID of the album
    #' @param device_id (optional) A unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) The account ID of the user (deviceId or accountId required)
    #' @param approval_status (optional) The approval status to set {PENDING, REJECTED, APPROVED, FEATURED}
    #' @param verified (optional) Sets whether the album should be marked as \"verified\"
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    ApproveAlbumWithHttpInfo = function(album_id, device_id = NULL, account_id = NULL, approval_status = NULL, verified = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$ApproveAlbum, `album_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$ApproveAlbum, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$ApproveAlbum, `account_id` is not nullable")
      }

      if (!missing(`approval_status`) && is.null(`approval_status`)) {
        stop("Invalid value for `approval_status` when calling AlbumApi$ApproveAlbum, `approval_status` is not nullable")
      }

      if (!missing(`verified`) && is.null(`verified`)) {
        stop("Invalid value for `verified` when calling AlbumApi$ApproveAlbum, `verified` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      if (!is.null(`approval_status`) && !(`approval_status` %in% c("PENDING", "REJECTED", "APPROVED", "FEATURED"))) {
        stop("Invalid value for approval_status when calling AlbumApi$ApproveAlbum. Must be [PENDING, REJECTED, APPROVED, FEATURED].")
      }
      query_params[["approvalStatus"]] <- `approval_status`

      query_params[["verified"]] <- `verified`

      local_var_url_path <- "/album/approve"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #'  Get Album
    #'
    #' @param return_nulls This parameter is deprecated.
    #' @param album_id the album to look up
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param like_preview_size (optional) returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\"Â endpoint.
    #' @param asset_preview_size (optional) returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\"Â endpoint.
    #' @param note_preview_size (optional) returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
    #' @param connection_preview_size (optional) returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
    #' @param audience_preview_size (optional) returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AlbumFullResponse
    GetAlbumCollection = function(return_nulls, album_id, device_id = NULL, account_id = NULL, like_preview_size = NULL, asset_preview_size = NULL, note_preview_size = NULL, connection_preview_size = NULL, audience_preview_size = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetAlbumCollectionWithHttpInfo(return_nulls, album_id, device_id, account_id, like_preview_size, asset_preview_size, note_preview_size, connection_preview_size, audience_preview_size, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #'  Get Album
    #'
    #' @param return_nulls This parameter is deprecated.
    #' @param album_id the album to look up
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param like_preview_size (optional) returns the last X likes. To search on and paginate the remaining likes - please use the \"/like/search\"Â endpoint.
    #' @param asset_preview_size (optional) returns the first X assets. To search on and paginate the remaining assets - please use the \"/assets/search\"Â endpoint.
    #' @param note_preview_size (optional) returns the last X notes. To search on and paginate the remaining notes - please use the \"/note/search\" endpoint.
    #' @param connection_preview_size (optional) returns the first X users/connections. To search on and paginate the remaining connections - please use the \"/permissions/search\" endpoint.
    #' @param audience_preview_size (optional) returns the first X audiences. To search on and paginate the remaining audiences - please use the \"/audience/search\" endpoint.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AlbumFullResponse) with additional information such as HTTP status code, headers
    GetAlbumCollectionWithHttpInfo = function(return_nulls, album_id, device_id = NULL, account_id = NULL, like_preview_size = NULL, asset_preview_size = NULL, note_preview_size = NULL, connection_preview_size = NULL, audience_preview_size = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`return_nulls`)) {
        stop("Missing required parameter `return_nulls`.")
      }

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (!missing(`return_nulls`) && is.null(`return_nulls`)) {
        stop("Invalid value for `return_nulls` when calling AlbumApi$GetAlbumCollection, `return_nulls` is not nullable")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$GetAlbumCollection, `album_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$GetAlbumCollection, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$GetAlbumCollection, `account_id` is not nullable")
      }

      if (!missing(`like_preview_size`) && is.null(`like_preview_size`)) {
        stop("Invalid value for `like_preview_size` when calling AlbumApi$GetAlbumCollection, `like_preview_size` is not nullable")
      }

      if (!missing(`asset_preview_size`) && is.null(`asset_preview_size`)) {
        stop("Invalid value for `asset_preview_size` when calling AlbumApi$GetAlbumCollection, `asset_preview_size` is not nullable")
      }

      if (!missing(`note_preview_size`) && is.null(`note_preview_size`)) {
        stop("Invalid value for `note_preview_size` when calling AlbumApi$GetAlbumCollection, `note_preview_size` is not nullable")
      }

      if (!missing(`connection_preview_size`) && is.null(`connection_preview_size`)) {
        stop("Invalid value for `connection_preview_size` when calling AlbumApi$GetAlbumCollection, `connection_preview_size` is not nullable")
      }

      if (!missing(`audience_preview_size`) && is.null(`audience_preview_size`)) {
        stop("Invalid value for `audience_preview_size` when calling AlbumApi$GetAlbumCollection, `audience_preview_size` is not nullable")
      }

      query_params[["returnNulls"]] <- `return_nulls`

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      query_params[["likePreviewSize"]] <- `like_preview_size`

      query_params[["assetPreviewSize"]] <- `asset_preview_size`

      query_params[["notePreviewSize"]] <- `note_preview_size`

      query_params[["connectionPreviewSize"]] <- `connection_preview_size`

      query_params[["audiencePreviewSize"]] <- `audience_preview_size`

      local_var_url_path <- "/album/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AlbumFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Leave Album
    #'
    #' @param album_id the album ID
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    LeaveAlbum = function(album_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$LeaveAlbumWithHttpInfo(album_id, device_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Leave Album
    #'
    #' @param album_id the album ID
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    LeaveAlbumWithHttpInfo = function(album_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$LeaveAlbum, `album_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$LeaveAlbum, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$LeaveAlbum, `account_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      local_var_url_path <- "/album/user/leave"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Album
    #'
    #' @param album_id the album ID to delete
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveAlbum = function(album_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveAlbumWithHttpInfo(album_id, device_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Album
    #'
    #' @param album_id the album ID to delete
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveAlbumWithHttpInfo = function(album_id, device_id = NULL, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$RemoveAlbum, `album_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$RemoveAlbum, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$RemoveAlbum, `account_id` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      local_var_url_path <- "/album/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Remove Album Users
    #'
    #' @param album_id the album ID
    #' @param remove_friend_group remove friend group
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param connections (optional) comma separated list of connection IDs
    #' @param connection_groups (optional) comma separated list of connection group IDs
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    RemoveAlbumUsers = function(album_id, remove_friend_group, device_id = NULL, account_id = NULL, connections = NULL, connection_groups = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$RemoveAlbumUsersWithHttpInfo(album_id, remove_friend_group, device_id, account_id, connections, connection_groups, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Remove Album Users
    #'
    #' @param album_id the album ID
    #' @param remove_friend_group remove friend group
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param connections (optional) comma separated list of connection IDs
    #' @param connection_groups (optional) comma separated list of connection group IDs
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    RemoveAlbumUsersWithHttpInfo = function(album_id, remove_friend_group, device_id = NULL, account_id = NULL, connections = NULL, connection_groups = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (missing(`remove_friend_group`)) {
        stop("Missing required parameter `remove_friend_group`.")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$RemoveAlbumUsers, `album_id` is not nullable")
      }

      if (!missing(`remove_friend_group`) && is.null(`remove_friend_group`)) {
        stop("Invalid value for `remove_friend_group` when calling AlbumApi$RemoveAlbumUsers, `remove_friend_group` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$RemoveAlbumUsers, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$RemoveAlbumUsers, `account_id` is not nullable")
      }

      if (!missing(`connections`) && is.null(`connections`)) {
        stop("Invalid value for `connections` when calling AlbumApi$RemoveAlbumUsers, `connections` is not nullable")
      }

      if (!missing(`connection_groups`) && is.null(`connection_groups`)) {
        stop("Invalid value for `connection_groups` when calling AlbumApi$RemoveAlbumUsers, `connection_groups` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      query_params[["connections"]] <- `connections`

      query_params[["connectionGroups"]] <- `connection_groups`

      query_params[["removeFriendGroup"]] <- `remove_friend_group`

      local_var_url_path <- "/album/user/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Albums
    #'
    #' @param filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
    #' @param album_type_id id of custom albumType
    #' @param sub_type filter albums with this album sub type
    #' @param include_inactive determines whether to return inactive albums
    #' @param sort_field the field to sort by. See AlbumApiMap
    #' @param descending determines whether the sorted list is in descending or ascending order
    #' @param start the start index for pagination
    #' @param limit the limit for pagination (There is a hard limit of 100)
    #' @param range the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)
    #' @param include_liked returns whether or not the current logged in user has liked the album
    #' @param include_favorited returns whether or not the current logged in user has favorited the album
    #' @param include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)
    #' @param like_preview_size returns the last X likes
    #' @param asset_preview_size returns the first X assets
    #' @param note_preview_size returns the last X notes
    #' @param connection_preview_size returns the first X users/connections
    #' @param audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param connection_account_id (optional) the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
    #' @param owner_id (optional) search on albums that have been created by this account (that the user has permissions to)
    #' @param album_ids (optional) search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
    #' @param exclude_album_ids (optional) Only for CLOUDINDEX mode, exclude albums with ids matching this list
    #' @param media_id (optional) search on albums that are in a particular media offering
    #' @param keyword (optional) keyword search string
    #' @param album_type (optional) filter albums with this album type
    #' @param limit_per_album_type (optional) When using multiple album types this sets a per-album-type limit (used with cloud index mode)
    #' @param date_created (optional) return items that have been created before this date (time-stamp in milliseconds)
    #' @param updated_since (optional) return items that have been updated since this date (time-stamp in milliseconds)
    #' @param updated_before (optional) return items that have been updated before this date (time-stamp in milliseconds)
    #' @param created_since (optional) return items that have been created since this date (time-stamp in milliseconds)
    #' @param created_before (optional) return items that have been created before this date (time-stamp in milliseconds)
    #' @param started_since (optional) return items that have been started since this date (time-stamp in milliseconds)
    #' @param started_before (optional) return items that have been started before this date (time-stamp in milliseconds)
    #' @param ended_since (optional) return items that have been ended since this date (time-stamp in milliseconds)
    #' @param ended_before (optional) return items that have been ended before this date (time-stamp in milliseconds)
    #' @param latitude (optional) the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
    #' @param longitude (optional) the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
    #' @param app_key (optional) the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
    #' @param category_ids (optional) return results with categories matching this list
    #' @param category_filter_ids (optional) return results with filters matching this list
    #' @param audience_ids (optional) return results with audiences matching this list
    #' @param exclude_audience_ids (optional) exclude audiences with ids matching this list
    #' @param include_completable (optional) returns the user's completable object for the album if it exists
    #' @param include_rating (optional) returns the user's rating for the album if it exists
    #' @param search_mode (optional) The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
    #' @param stack_search (optional) groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
    #' @param stack_window_size (optional) size of each window for each stack
    #' @param min_stack_per_page (optional) The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
    #' @param stack_pagination_identifier (optional) this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
    #' @param stack_details (optional) set this to true when making the call to view the albums in the stack
    #' @param flag_count_minimum (optional) Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
    #' @param remove_flagged_content (optional) return items that have flagCount >= flagThreshold (controls removal of flagged content) (default value: TRUE)
    #' @param verified_filter (optional) setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
    #' @param linked_object_type (optional) filter results by the linkedObjectType
    #' @param linked_object_id (optional) filter results by the linkedObjectId
    #' @param order_audience_id (optional) determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
    #' @param ignore_default_app_filter (optional) if true, ignore the application's default app filter when searching
    #' @param search_expression (optional) Advanced search expression to be used by the server
    #' @param generate_albums (optional) If true and results are empty, attempt to generate albums via templates
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[AlbumFullResponse]
    SearchAlbums = function(filter, album_type_id, sub_type, include_inactive, sort_field, descending, start, limit, range, include_liked, include_favorited, include_permissions, like_preview_size, asset_preview_size, note_preview_size, connection_preview_size, audience_preview_size, device_id = NULL, account_id = NULL, connection_account_id = NULL, owner_id = NULL, album_ids = NULL, exclude_album_ids = NULL, media_id = NULL, keyword = NULL, album_type = NULL, limit_per_album_type = NULL, date_created = NULL, updated_since = NULL, updated_before = NULL, created_since = NULL, created_before = NULL, started_since = NULL, started_before = NULL, ended_since = NULL, ended_before = NULL, latitude = NULL, longitude = NULL, app_key = NULL, category_ids = NULL, category_filter_ids = NULL, audience_ids = NULL, exclude_audience_ids = NULL, include_completable = NULL, include_rating = NULL, search_mode = NULL, stack_search = NULL, stack_window_size = NULL, min_stack_per_page = NULL, stack_pagination_identifier = NULL, stack_details = NULL, flag_count_minimum = NULL, remove_flagged_content = TRUE, verified_filter = NULL, linked_object_type = NULL, linked_object_id = NULL, order_audience_id = NULL, ignore_default_app_filter = NULL, search_expression = NULL, generate_albums = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchAlbumsWithHttpInfo(filter, album_type_id, sub_type, include_inactive, sort_field, descending, start, limit, range, include_liked, include_favorited, include_permissions, like_preview_size, asset_preview_size, note_preview_size, connection_preview_size, audience_preview_size, device_id, account_id, connection_account_id, owner_id, album_ids, exclude_album_ids, media_id, keyword, album_type, limit_per_album_type, date_created, updated_since, updated_before, created_since, created_before, started_since, started_before, ended_since, ended_before, latitude, longitude, app_key, category_ids, category_filter_ids, audience_ids, exclude_audience_ids, include_completable, include_rating, search_mode, stack_search, stack_window_size, min_stack_per_page, stack_pagination_identifier, stack_details, flag_count_minimum, remove_flagged_content, verified_filter, linked_object_type, linked_object_id, order_audience_id, ignore_default_app_filter, search_expression, generate_albums, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Albums
    #'
    #' @param filter a comma separated list of filters: * MINE - Return albums that the user has created. * SHARED - Return albums that have been shared to the user via addAlbumUsers, or addUsersToPermissionable . * FOLLOWER - Return albums that have been created by the user's followers (the content needs to have been APPROVED or FEATURED). * FOLLOWING - Return albums that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). * PUBLIC - Return all PUBLIC albums that have been APPROVED or FEATURED. * ALL_PUBLIC - Return all PUBLIC albums regardless of whether they are approved or not (ignores the approval status). * LIKED - Return all albums that the user has liked. * FEATURED - Return all albums that have been featured. * PENDING - Return all pending albums. 
    #' @param album_type_id id of custom albumType
    #' @param sub_type filter albums with this album sub type
    #' @param include_inactive determines whether to return inactive albums
    #' @param sort_field the field to sort by. See AlbumApiMap
    #' @param descending determines whether the sorted list is in descending or ascending order
    #' @param start the start index for pagination
    #' @param limit the limit for pagination (There is a hard limit of 100)
    #' @param range the maximum range the album can be from the center (used when sortField=ALBUM_DISTANCE)
    #' @param include_liked returns whether or not the current logged in user has liked the album
    #' @param include_favorited returns whether or not the current logged in user has favorited the album
    #' @param include_permissions returns permission details on whether they have read/write/delete permissions etc (client app probably doesn't need this)
    #' @param like_preview_size returns the last X likes
    #' @param asset_preview_size returns the first X assets
    #' @param note_preview_size returns the last X notes
    #' @param connection_preview_size returns the first X users/connections
    #' @param audience_preview_size returns the first X audiences. To search on and paginate the remaining audiences, please use the \"/audience/search\" endpoint.
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param connection_account_id (optional) the account ID of the user that the results will be based on. This is used to return albums that this account has liked/favorited.
    #' @param owner_id (optional) search on albums that have been created by this account (that the user has permissions to)
    #' @param album_ids (optional) search on album within a comma separated list of album IDs (this does not work with sortField=ALBUM_DISTANCE, or when stackSearch=true)
    #' @param exclude_album_ids (optional) Only for CLOUDINDEX mode, exclude albums with ids matching this list
    #' @param media_id (optional) search on albums that are in a particular media offering
    #' @param keyword (optional) keyword search string
    #' @param album_type (optional) filter albums with this album type
    #' @param limit_per_album_type (optional) When using multiple album types this sets a per-album-type limit (used with cloud index mode)
    #' @param date_created (optional) return items that have been created before this date (time-stamp in milliseconds)
    #' @param updated_since (optional) return items that have been updated since this date (time-stamp in milliseconds)
    #' @param updated_before (optional) return items that have been updated before this date (time-stamp in milliseconds)
    #' @param created_since (optional) return items that have been created since this date (time-stamp in milliseconds)
    #' @param created_before (optional) return items that have been created before this date (time-stamp in milliseconds)
    #' @param started_since (optional) return items that have been started since this date (time-stamp in milliseconds)
    #' @param started_before (optional) return items that have been started before this date (time-stamp in milliseconds)
    #' @param ended_since (optional) return items that have been ended since this date (time-stamp in milliseconds)
    #' @param ended_before (optional) return items that have been ended before this date (time-stamp in milliseconds)
    #' @param latitude (optional) the latitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
    #' @param longitude (optional) the longitude of where the search is centered on (used when sortField=ALBUM_DISTANCE)
    #' @param app_key (optional) the application key to filter results by application. This is required for consumer searches. Leaving this empty will return albums for the applications that the logged in user owns or has access to.
    #' @param category_ids (optional) return results with categories matching this list
    #' @param category_filter_ids (optional) return results with filters matching this list
    #' @param audience_ids (optional) return results with audiences matching this list
    #' @param exclude_audience_ids (optional) exclude audiences with ids matching this list
    #' @param include_completable (optional) returns the user's completable object for the album if it exists
    #' @param include_rating (optional) returns the user's rating for the album if it exists
    #' @param search_mode (optional) The search index mode to use (RDS, LUCENE, or CLOUDINDEX). If not provided will use server default.
    #' @param stack_search (optional) groups similar albums together that have the same albumTypeId, within a time window defined in stackWindowSize
    #' @param stack_window_size (optional) size of each window for each stack
    #' @param min_stack_per_page (optional) The minimum number of stacks returned in a response. For example,  first call, minStackPerPage = 20, the API will return at least 20 results
    #' @param stack_pagination_identifier (optional) this is used to tell the system where it left off on the previous previous page, since we can't use start/limit for stackSearch
    #' @param stack_details (optional) set this to true when making the call to view the albums in the stack
    #' @param flag_count_minimum (optional) Return any results that have a minimum of the specified flag count (even ones that have met the flag threshold)
    #' @param remove_flagged_content (optional) return items that have flagCount >= flagThreshold (controls removal of flagged content) (default value: TRUE)
    #' @param verified_filter (optional) setting to true will return only verified albums only, setting to false will return non-verified albums only (leave empty to return both)
    #' @param linked_object_type (optional) filter results by the linkedObjectType
    #' @param linked_object_id (optional) filter results by the linkedObjectId
    #' @param order_audience_id (optional) determines whether to use the order assigned via the /album/order/* api (which is tied to an audience)
    #' @param ignore_default_app_filter (optional) if true, ignore the application's default app filter when searching
    #' @param search_expression (optional) Advanced search expression to be used by the server
    #' @param generate_albums (optional) If true and results are empty, attempt to generate albums via templates
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[AlbumFullResponse]) with additional information such as HTTP status code, headers
    SearchAlbumsWithHttpInfo = function(filter, album_type_id, sub_type, include_inactive, sort_field, descending, start, limit, range, include_liked, include_favorited, include_permissions, like_preview_size, asset_preview_size, note_preview_size, connection_preview_size, audience_preview_size, device_id = NULL, account_id = NULL, connection_account_id = NULL, owner_id = NULL, album_ids = NULL, exclude_album_ids = NULL, media_id = NULL, keyword = NULL, album_type = NULL, limit_per_album_type = NULL, date_created = NULL, updated_since = NULL, updated_before = NULL, created_since = NULL, created_before = NULL, started_since = NULL, started_before = NULL, ended_since = NULL, ended_before = NULL, latitude = NULL, longitude = NULL, app_key = NULL, category_ids = NULL, category_filter_ids = NULL, audience_ids = NULL, exclude_audience_ids = NULL, include_completable = NULL, include_rating = NULL, search_mode = NULL, stack_search = NULL, stack_window_size = NULL, min_stack_per_page = NULL, stack_pagination_identifier = NULL, stack_details = NULL, flag_count_minimum = NULL, remove_flagged_content = TRUE, verified_filter = NULL, linked_object_type = NULL, linked_object_id = NULL, order_audience_id = NULL, ignore_default_app_filter = NULL, search_expression = NULL, generate_albums = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`filter`)) {
        stop("Missing required parameter `filter`.")
      }

      if (missing(`album_type_id`)) {
        stop("Missing required parameter `album_type_id`.")
      }

      if (missing(`sub_type`)) {
        stop("Missing required parameter `sub_type`.")
      }

      if (missing(`include_inactive`)) {
        stop("Missing required parameter `include_inactive`.")
      }

      if (missing(`sort_field`)) {
        stop("Missing required parameter `sort_field`.")
      }

      if (missing(`descending`)) {
        stop("Missing required parameter `descending`.")
      }

      if (missing(`start`)) {
        stop("Missing required parameter `start`.")
      }

      if (missing(`limit`)) {
        stop("Missing required parameter `limit`.")
      }

      if (missing(`range`)) {
        stop("Missing required parameter `range`.")
      }

      if (missing(`include_liked`)) {
        stop("Missing required parameter `include_liked`.")
      }

      if (missing(`include_favorited`)) {
        stop("Missing required parameter `include_favorited`.")
      }

      if (missing(`include_permissions`)) {
        stop("Missing required parameter `include_permissions`.")
      }

      if (missing(`like_preview_size`)) {
        stop("Missing required parameter `like_preview_size`.")
      }

      if (missing(`asset_preview_size`)) {
        stop("Missing required parameter `asset_preview_size`.")
      }

      if (missing(`note_preview_size`)) {
        stop("Missing required parameter `note_preview_size`.")
      }

      if (missing(`connection_preview_size`)) {
        stop("Missing required parameter `connection_preview_size`.")
      }

      if (missing(`audience_preview_size`)) {
        stop("Missing required parameter `audience_preview_size`.")
      }

      if (!missing(`filter`) && is.null(`filter`)) {
        stop("Invalid value for `filter` when calling AlbumApi$SearchAlbums, `filter` is not nullable")
      }

      if (!missing(`album_type_id`) && is.null(`album_type_id`)) {
        stop("Invalid value for `album_type_id` when calling AlbumApi$SearchAlbums, `album_type_id` is not nullable")
      }

      if (!missing(`sub_type`) && is.null(`sub_type`)) {
        stop("Invalid value for `sub_type` when calling AlbumApi$SearchAlbums, `sub_type` is not nullable")
      }

      if (!missing(`include_inactive`) && is.null(`include_inactive`)) {
        stop("Invalid value for `include_inactive` when calling AlbumApi$SearchAlbums, `include_inactive` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling AlbumApi$SearchAlbums, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling AlbumApi$SearchAlbums, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling AlbumApi$SearchAlbums, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling AlbumApi$SearchAlbums, `limit` is not nullable")
      }

      if (!missing(`range`) && is.null(`range`)) {
        stop("Invalid value for `range` when calling AlbumApi$SearchAlbums, `range` is not nullable")
      }

      if (!missing(`include_liked`) && is.null(`include_liked`)) {
        stop("Invalid value for `include_liked` when calling AlbumApi$SearchAlbums, `include_liked` is not nullable")
      }

      if (!missing(`include_favorited`) && is.null(`include_favorited`)) {
        stop("Invalid value for `include_favorited` when calling AlbumApi$SearchAlbums, `include_favorited` is not nullable")
      }

      if (!missing(`include_permissions`) && is.null(`include_permissions`)) {
        stop("Invalid value for `include_permissions` when calling AlbumApi$SearchAlbums, `include_permissions` is not nullable")
      }

      if (!missing(`like_preview_size`) && is.null(`like_preview_size`)) {
        stop("Invalid value for `like_preview_size` when calling AlbumApi$SearchAlbums, `like_preview_size` is not nullable")
      }

      if (!missing(`asset_preview_size`) && is.null(`asset_preview_size`)) {
        stop("Invalid value for `asset_preview_size` when calling AlbumApi$SearchAlbums, `asset_preview_size` is not nullable")
      }

      if (!missing(`note_preview_size`) && is.null(`note_preview_size`)) {
        stop("Invalid value for `note_preview_size` when calling AlbumApi$SearchAlbums, `note_preview_size` is not nullable")
      }

      if (!missing(`connection_preview_size`) && is.null(`connection_preview_size`)) {
        stop("Invalid value for `connection_preview_size` when calling AlbumApi$SearchAlbums, `connection_preview_size` is not nullable")
      }

      if (!missing(`audience_preview_size`) && is.null(`audience_preview_size`)) {
        stop("Invalid value for `audience_preview_size` when calling AlbumApi$SearchAlbums, `audience_preview_size` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$SearchAlbums, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$SearchAlbums, `account_id` is not nullable")
      }

      if (!missing(`connection_account_id`) && is.null(`connection_account_id`)) {
        stop("Invalid value for `connection_account_id` when calling AlbumApi$SearchAlbums, `connection_account_id` is not nullable")
      }

      if (!missing(`owner_id`) && is.null(`owner_id`)) {
        stop("Invalid value for `owner_id` when calling AlbumApi$SearchAlbums, `owner_id` is not nullable")
      }

      if (!missing(`album_ids`) && is.null(`album_ids`)) {
        stop("Invalid value for `album_ids` when calling AlbumApi$SearchAlbums, `album_ids` is not nullable")
      }

      if (!missing(`exclude_album_ids`) && is.null(`exclude_album_ids`)) {
        stop("Invalid value for `exclude_album_ids` when calling AlbumApi$SearchAlbums, `exclude_album_ids` is not nullable")
      }

      if (!missing(`media_id`) && is.null(`media_id`)) {
        stop("Invalid value for `media_id` when calling AlbumApi$SearchAlbums, `media_id` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling AlbumApi$SearchAlbums, `keyword` is not nullable")
      }

      if (!missing(`album_type`) && is.null(`album_type`)) {
        stop("Invalid value for `album_type` when calling AlbumApi$SearchAlbums, `album_type` is not nullable")
      }

      if (!missing(`limit_per_album_type`) && is.null(`limit_per_album_type`)) {
        stop("Invalid value for `limit_per_album_type` when calling AlbumApi$SearchAlbums, `limit_per_album_type` is not nullable")
      }

      if (!missing(`date_created`) && is.null(`date_created`)) {
        stop("Invalid value for `date_created` when calling AlbumApi$SearchAlbums, `date_created` is not nullable")
      }

      if (!missing(`updated_since`) && is.null(`updated_since`)) {
        stop("Invalid value for `updated_since` when calling AlbumApi$SearchAlbums, `updated_since` is not nullable")
      }

      if (!missing(`updated_before`) && is.null(`updated_before`)) {
        stop("Invalid value for `updated_before` when calling AlbumApi$SearchAlbums, `updated_before` is not nullable")
      }

      if (!missing(`created_since`) && is.null(`created_since`)) {
        stop("Invalid value for `created_since` when calling AlbumApi$SearchAlbums, `created_since` is not nullable")
      }

      if (!missing(`created_before`) && is.null(`created_before`)) {
        stop("Invalid value for `created_before` when calling AlbumApi$SearchAlbums, `created_before` is not nullable")
      }

      if (!missing(`started_since`) && is.null(`started_since`)) {
        stop("Invalid value for `started_since` when calling AlbumApi$SearchAlbums, `started_since` is not nullable")
      }

      if (!missing(`started_before`) && is.null(`started_before`)) {
        stop("Invalid value for `started_before` when calling AlbumApi$SearchAlbums, `started_before` is not nullable")
      }

      if (!missing(`ended_since`) && is.null(`ended_since`)) {
        stop("Invalid value for `ended_since` when calling AlbumApi$SearchAlbums, `ended_since` is not nullable")
      }

      if (!missing(`ended_before`) && is.null(`ended_before`)) {
        stop("Invalid value for `ended_before` when calling AlbumApi$SearchAlbums, `ended_before` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling AlbumApi$SearchAlbums, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling AlbumApi$SearchAlbums, `longitude` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling AlbumApi$SearchAlbums, `app_key` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling AlbumApi$SearchAlbums, `category_ids` is not nullable")
      }

      if (!missing(`category_filter_ids`) && is.null(`category_filter_ids`)) {
        stop("Invalid value for `category_filter_ids` when calling AlbumApi$SearchAlbums, `category_filter_ids` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling AlbumApi$SearchAlbums, `audience_ids` is not nullable")
      }

      if (!missing(`exclude_audience_ids`) && is.null(`exclude_audience_ids`)) {
        stop("Invalid value for `exclude_audience_ids` when calling AlbumApi$SearchAlbums, `exclude_audience_ids` is not nullable")
      }

      if (!missing(`include_completable`) && is.null(`include_completable`)) {
        stop("Invalid value for `include_completable` when calling AlbumApi$SearchAlbums, `include_completable` is not nullable")
      }

      if (!missing(`include_rating`) && is.null(`include_rating`)) {
        stop("Invalid value for `include_rating` when calling AlbumApi$SearchAlbums, `include_rating` is not nullable")
      }

      if (!missing(`search_mode`) && is.null(`search_mode`)) {
        stop("Invalid value for `search_mode` when calling AlbumApi$SearchAlbums, `search_mode` is not nullable")
      }

      if (!missing(`stack_search`) && is.null(`stack_search`)) {
        stop("Invalid value for `stack_search` when calling AlbumApi$SearchAlbums, `stack_search` is not nullable")
      }

      if (!missing(`stack_window_size`) && is.null(`stack_window_size`)) {
        stop("Invalid value for `stack_window_size` when calling AlbumApi$SearchAlbums, `stack_window_size` is not nullable")
      }

      if (!missing(`min_stack_per_page`) && is.null(`min_stack_per_page`)) {
        stop("Invalid value for `min_stack_per_page` when calling AlbumApi$SearchAlbums, `min_stack_per_page` is not nullable")
      }

      if (!missing(`stack_pagination_identifier`) && is.null(`stack_pagination_identifier`)) {
        stop("Invalid value for `stack_pagination_identifier` when calling AlbumApi$SearchAlbums, `stack_pagination_identifier` is not nullable")
      }

      if (!missing(`stack_details`) && is.null(`stack_details`)) {
        stop("Invalid value for `stack_details` when calling AlbumApi$SearchAlbums, `stack_details` is not nullable")
      }

      if (!missing(`flag_count_minimum`) && is.null(`flag_count_minimum`)) {
        stop("Invalid value for `flag_count_minimum` when calling AlbumApi$SearchAlbums, `flag_count_minimum` is not nullable")
      }

      if (!missing(`remove_flagged_content`) && is.null(`remove_flagged_content`)) {
        stop("Invalid value for `remove_flagged_content` when calling AlbumApi$SearchAlbums, `remove_flagged_content` is not nullable")
      }

      if (!missing(`verified_filter`) && is.null(`verified_filter`)) {
        stop("Invalid value for `verified_filter` when calling AlbumApi$SearchAlbums, `verified_filter` is not nullable")
      }

      if (!missing(`linked_object_type`) && is.null(`linked_object_type`)) {
        stop("Invalid value for `linked_object_type` when calling AlbumApi$SearchAlbums, `linked_object_type` is not nullable")
      }

      if (!missing(`linked_object_id`) && is.null(`linked_object_id`)) {
        stop("Invalid value for `linked_object_id` when calling AlbumApi$SearchAlbums, `linked_object_id` is not nullable")
      }

      if (!missing(`order_audience_id`) && is.null(`order_audience_id`)) {
        stop("Invalid value for `order_audience_id` when calling AlbumApi$SearchAlbums, `order_audience_id` is not nullable")
      }

      if (!missing(`ignore_default_app_filter`) && is.null(`ignore_default_app_filter`)) {
        stop("Invalid value for `ignore_default_app_filter` when calling AlbumApi$SearchAlbums, `ignore_default_app_filter` is not nullable")
      }

      if (!missing(`search_expression`) && is.null(`search_expression`)) {
        stop("Invalid value for `search_expression` when calling AlbumApi$SearchAlbums, `search_expression` is not nullable")
      }

      if (!missing(`generate_albums`) && is.null(`generate_albums`)) {
        stop("Invalid value for `generate_albums` when calling AlbumApi$SearchAlbums, `generate_albums` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["connectionAccountId"]] <- `connection_account_id`

      query_params[["ownerId"]] <- `owner_id`

      query_params[["albumIds"]] <- `album_ids`

      query_params[["excludeAlbumIds"]] <- `exclude_album_ids`

      query_params[["mediaId"]] <- `media_id`

      query_params[["keyword"]] <- `keyword`

      query_params[["filter"]] <- `filter`

      query_params[["albumType"]] <- `album_type`

      query_params[["albumTypeId"]] <- `album_type_id`

      query_params[["subType"]] <- `sub_type`

      query_params[["includeInactive"]] <- `include_inactive`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["limitPerAlbumType"]] <- `limit_per_album_type`

      query_params[["dateCreated"]] <- `date_created`

      query_params[["updatedSince"]] <- `updated_since`

      query_params[["updatedBefore"]] <- `updated_before`

      query_params[["createdSince"]] <- `created_since`

      query_params[["createdBefore"]] <- `created_before`

      query_params[["startedSince"]] <- `started_since`

      query_params[["startedBefore"]] <- `started_before`

      query_params[["endedSince"]] <- `ended_since`

      query_params[["endedBefore"]] <- `ended_before`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["range"]] <- `range`

      query_params[["appKey"]] <- `app_key`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["categoryFilterIds"]] <- `category_filter_ids`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["excludeAudienceIds"]] <- `exclude_audience_ids`

      query_params[["includeLiked"]] <- `include_liked`

      query_params[["includeFavorited"]] <- `include_favorited`

      query_params[["includePermissions"]] <- `include_permissions`

      query_params[["includeCompletable"]] <- `include_completable`

      query_params[["includeRating"]] <- `include_rating`

      query_params[["likePreviewSize"]] <- `like_preview_size`

      query_params[["assetPreviewSize"]] <- `asset_preview_size`

      query_params[["notePreviewSize"]] <- `note_preview_size`

      query_params[["connectionPreviewSize"]] <- `connection_preview_size`

      query_params[["audiencePreviewSize"]] <- `audience_preview_size`

      query_params[["searchMode"]] <- `search_mode`

      query_params[["stackSearch"]] <- `stack_search`

      query_params[["stackWindowSize"]] <- `stack_window_size`

      query_params[["minStackPerPage"]] <- `min_stack_per_page`

      query_params[["stackPaginationIdentifier"]] <- `stack_pagination_identifier`

      query_params[["stackDetails"]] <- `stack_details`

      query_params[["flagCountMinimum"]] <- `flag_count_minimum`

      query_params[["removeFlaggedContent"]] <- `remove_flagged_content`

      query_params[["verifiedFilter"]] <- `verified_filter`

      query_params[["linkedObjectType"]] <- `linked_object_type`

      query_params[["linkedObjectId"]] <- `linked_object_id`

      query_params[["orderAudienceId"]] <- `order_audience_id`

      query_params[["ignoreDefaultAppFilter"]] <- `ignore_default_app_filter`

      query_params[["searchExpression"]] <- `search_expression`

      query_params[["generateAlbums"]] <- `generate_albums`

      local_var_url_path <- "/album/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[AlbumFullResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Album
    #'
    #' @param album_id the ID of the album to update
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param assets_to_add (optional) Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
    #' @param assets_to_remove (optional) Comma separated list of asset IDs to remove from the album's asset list
    #' @param asset_id (optional) the cover asset ID
    #' @param media (optional) a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
    #' @param media_url (optional) this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
    #' @param active (optional) determines whether the album is active or inactive
    #' @param title (optional) the title of the album
    #' @param start_date (optional) the start date
    #' @param end_date (optional) the end date
    #' @param tags (optional) the tags
    #' @param description (optional) the description of the album
    #' @param album_type (optional) a custom field used for aggregation and searching
    #' @param album_type_id (optional) a custom indexed number used for aggregation and searching
    #' @param sub_type (optional) a custom string field used for aggregation and searching
    #' @param public_read (optional) determines whether the album's participants have read permissions
    #' @param public_write (optional) determines whether the album's participants have write permissions
    #' @param public_delete (optional) determines whether the album's participants have delete permissions
    #' @param public_add (optional) determines whether the album's participants have add permissions
    #' @param latitude (optional) latitude used to update the album's location
    #' @param longitude (optional) longitude used to update the album's location
    #' @param location_description (optional) the location description
    #' @param visibility (optional) the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
    #' @param cell_phone (optional) the cell phone number
    #' @param street_address (optional) The street address of the location
    #' @param street_address2 (optional) Additional address information (such as a suite number, floor number, building name, or PO Box)
    #' @param city (optional) The city of the location
    #' @param state (optional) The state of of the location
    #' @param postal_code (optional) The postal code of the location
    #' @param full_address (optional) The full address of the location which should include the street address, city, state, and postal code
    #' @param anonymous (optional) determines whether the album is posted anonymously
    #' @param meta_data (optional) External custom client defined data
    #' @param category_ids (optional) comma separated category ids string associated with the Album
    #' @param category_filter_ids (optional) comma separated filter ids string associated with the Album
    #' @param audience_ids (optional) comma separated audience ids string associated with the album
    #' @param audience_ids_to_add (optional) comma separated audience ids to add to the album
    #' @param audience_ids_to_remove (optional) comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
    #' @param include_all_app_users_as_members (optional) determines whether to include all app users as members (only admins of the app can do this)
    #' @param include_audiences_as_members (optional) determines whether to include all users of the audiences as members (only admins of the app can do this)
    #' @param audience_operator (optional) determines whether to use ands or ors when using the audience list to add users
    #' @param linked_object_type (optional) sets a linked object so that it can be returned as part of the album response
    #' @param linked_object_id (optional) sets a linked object id so that it can be returned as part of the album response
    #' @param index_now (optional) determines whether the album should be indexed immediately
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return AlbumResponse
    UpdateAlbumCollection = function(album_id, device_id = NULL, account_id = NULL, assets_to_add = NULL, assets_to_remove = NULL, asset_id = NULL, media = NULL, media_url = NULL, active = NULL, title = NULL, start_date = NULL, end_date = NULL, tags = NULL, description = NULL, album_type = NULL, album_type_id = NULL, sub_type = NULL, public_read = NULL, public_write = NULL, public_delete = NULL, public_add = NULL, latitude = NULL, longitude = NULL, location_description = NULL, visibility = NULL, cell_phone = NULL, street_address = NULL, street_address2 = NULL, city = NULL, state = NULL, postal_code = NULL, full_address = NULL, anonymous = NULL, meta_data = NULL, category_ids = NULL, category_filter_ids = NULL, audience_ids = NULL, audience_ids_to_add = NULL, audience_ids_to_remove = NULL, include_all_app_users_as_members = NULL, include_audiences_as_members = NULL, audience_operator = NULL, linked_object_type = NULL, linked_object_id = NULL, index_now = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateAlbumCollectionWithHttpInfo(album_id, device_id, account_id, assets_to_add, assets_to_remove, asset_id, media, media_url, active, title, start_date, end_date, tags, description, album_type, album_type_id, sub_type, public_read, public_write, public_delete, public_add, latitude, longitude, location_description, visibility, cell_phone, street_address, street_address2, city, state, postal_code, full_address, anonymous, meta_data, category_ids, category_filter_ids, audience_ids, audience_ids_to_add, audience_ids_to_remove, include_all_app_users_as_members, include_audiences_as_members, audience_operator, linked_object_type, linked_object_id, index_now, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Album
    #'
    #' @param album_id the ID of the album to update
    #' @param device_id (optional) a unique ID given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account ID of the user (deviceId or accountId required)
    #' @param assets_to_add (optional) Comma separated list of asset IDs to add to the album's asset list (use \"assetId\" for setting the cover of the album)
    #' @param assets_to_remove (optional) Comma separated list of asset IDs to remove from the album's asset list
    #' @param asset_id (optional) the cover asset ID
    #' @param media (optional) a MultipartFile containing the cover image of the album (this will only be used if \"assetId\" is empty)
    #' @param media_url (optional) this can be used if the \"media\" is a link (this will only be used if \"assetId\" and media are empty)
    #' @param active (optional) determines whether the album is active or inactive
    #' @param title (optional) the title of the album
    #' @param start_date (optional) the start date
    #' @param end_date (optional) the end date
    #' @param tags (optional) the tags
    #' @param description (optional) the description of the album
    #' @param album_type (optional) a custom field used for aggregation and searching
    #' @param album_type_id (optional) a custom indexed number used for aggregation and searching
    #' @param sub_type (optional) a custom string field used for aggregation and searching
    #' @param public_read (optional) determines whether the album's participants have read permissions
    #' @param public_write (optional) determines whether the album's participants have write permissions
    #' @param public_delete (optional) determines whether the album's participants have delete permissions
    #' @param public_add (optional) determines whether the album's participants have add permissions
    #' @param latitude (optional) latitude used to update the album's location
    #' @param longitude (optional) longitude used to update the album's location
    #' @param location_description (optional) the location description
    #' @param visibility (optional) the determines the album's participants (PUBLIC - includes everyone in the system as a potential participant, PRIVATE - only considers people who have been invited as participants)
    #' @param cell_phone (optional) the cell phone number
    #' @param street_address (optional) The street address of the location
    #' @param street_address2 (optional) Additional address information (such as a suite number, floor number, building name, or PO Box)
    #' @param city (optional) The city of the location
    #' @param state (optional) The state of of the location
    #' @param postal_code (optional) The postal code of the location
    #' @param full_address (optional) The full address of the location which should include the street address, city, state, and postal code
    #' @param anonymous (optional) determines whether the album is posted anonymously
    #' @param meta_data (optional) External custom client defined data
    #' @param category_ids (optional) comma separated category ids string associated with the Album
    #' @param category_filter_ids (optional) comma separated filter ids string associated with the Album
    #' @param audience_ids (optional) comma separated audience ids string associated with the album
    #' @param audience_ids_to_add (optional) comma separated audience ids to add to the album
    #' @param audience_ids_to_remove (optional) comma separated audience ids to remove from the album (overrides audienceIds and audienceIdsToAdd)
    #' @param include_all_app_users_as_members (optional) determines whether to include all app users as members (only admins of the app can do this)
    #' @param include_audiences_as_members (optional) determines whether to include all users of the audiences as members (only admins of the app can do this)
    #' @param audience_operator (optional) determines whether to use ands or ors when using the audience list to add users
    #' @param linked_object_type (optional) sets a linked object so that it can be returned as part of the album response
    #' @param linked_object_id (optional) sets a linked object id so that it can be returned as part of the album response
    #' @param index_now (optional) determines whether the album should be indexed immediately
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (AlbumResponse) with additional information such as HTTP status code, headers
    UpdateAlbumCollectionWithHttpInfo = function(album_id, device_id = NULL, account_id = NULL, assets_to_add = NULL, assets_to_remove = NULL, asset_id = NULL, media = NULL, media_url = NULL, active = NULL, title = NULL, start_date = NULL, end_date = NULL, tags = NULL, description = NULL, album_type = NULL, album_type_id = NULL, sub_type = NULL, public_read = NULL, public_write = NULL, public_delete = NULL, public_add = NULL, latitude = NULL, longitude = NULL, location_description = NULL, visibility = NULL, cell_phone = NULL, street_address = NULL, street_address2 = NULL, city = NULL, state = NULL, postal_code = NULL, full_address = NULL, anonymous = NULL, meta_data = NULL, category_ids = NULL, category_filter_ids = NULL, audience_ids = NULL, audience_ids_to_add = NULL, audience_ids_to_remove = NULL, include_all_app_users_as_members = NULL, include_audiences_as_members = NULL, audience_operator = NULL, linked_object_type = NULL, linked_object_id = NULL, index_now = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`album_id`)) {
        stop("Missing required parameter `album_id`.")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling AlbumApi$UpdateAlbumCollection, `album_id` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling AlbumApi$UpdateAlbumCollection, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling AlbumApi$UpdateAlbumCollection, `account_id` is not nullable")
      }

      if (!missing(`assets_to_add`) && is.null(`assets_to_add`)) {
        stop("Invalid value for `assets_to_add` when calling AlbumApi$UpdateAlbumCollection, `assets_to_add` is not nullable")
      }

      if (!missing(`assets_to_remove`) && is.null(`assets_to_remove`)) {
        stop("Invalid value for `assets_to_remove` when calling AlbumApi$UpdateAlbumCollection, `assets_to_remove` is not nullable")
      }

      if (!missing(`asset_id`) && is.null(`asset_id`)) {
        stop("Invalid value for `asset_id` when calling AlbumApi$UpdateAlbumCollection, `asset_id` is not nullable")
      }

      if (!missing(`media`) && is.null(`media`)) {
        stop("Invalid value for `media` when calling AlbumApi$UpdateAlbumCollection, `media` is not nullable")
      }

      if (!missing(`media_url`) && is.null(`media_url`)) {
        stop("Invalid value for `media_url` when calling AlbumApi$UpdateAlbumCollection, `media_url` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling AlbumApi$UpdateAlbumCollection, `active` is not nullable")
      }

      if (!missing(`title`) && is.null(`title`)) {
        stop("Invalid value for `title` when calling AlbumApi$UpdateAlbumCollection, `title` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling AlbumApi$UpdateAlbumCollection, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling AlbumApi$UpdateAlbumCollection, `end_date` is not nullable")
      }

      if (!missing(`tags`) && is.null(`tags`)) {
        stop("Invalid value for `tags` when calling AlbumApi$UpdateAlbumCollection, `tags` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling AlbumApi$UpdateAlbumCollection, `description` is not nullable")
      }

      if (!missing(`album_type`) && is.null(`album_type`)) {
        stop("Invalid value for `album_type` when calling AlbumApi$UpdateAlbumCollection, `album_type` is not nullable")
      }

      if (!missing(`album_type_id`) && is.null(`album_type_id`)) {
        stop("Invalid value for `album_type_id` when calling AlbumApi$UpdateAlbumCollection, `album_type_id` is not nullable")
      }

      if (!missing(`sub_type`) && is.null(`sub_type`)) {
        stop("Invalid value for `sub_type` when calling AlbumApi$UpdateAlbumCollection, `sub_type` is not nullable")
      }

      if (!missing(`public_read`) && is.null(`public_read`)) {
        stop("Invalid value for `public_read` when calling AlbumApi$UpdateAlbumCollection, `public_read` is not nullable")
      }

      if (!missing(`public_write`) && is.null(`public_write`)) {
        stop("Invalid value for `public_write` when calling AlbumApi$UpdateAlbumCollection, `public_write` is not nullable")
      }

      if (!missing(`public_delete`) && is.null(`public_delete`)) {
        stop("Invalid value for `public_delete` when calling AlbumApi$UpdateAlbumCollection, `public_delete` is not nullable")
      }

      if (!missing(`public_add`) && is.null(`public_add`)) {
        stop("Invalid value for `public_add` when calling AlbumApi$UpdateAlbumCollection, `public_add` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling AlbumApi$UpdateAlbumCollection, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling AlbumApi$UpdateAlbumCollection, `longitude` is not nullable")
      }

      if (!missing(`location_description`) && is.null(`location_description`)) {
        stop("Invalid value for `location_description` when calling AlbumApi$UpdateAlbumCollection, `location_description` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling AlbumApi$UpdateAlbumCollection, `visibility` is not nullable")
      }

      if (!missing(`cell_phone`) && is.null(`cell_phone`)) {
        stop("Invalid value for `cell_phone` when calling AlbumApi$UpdateAlbumCollection, `cell_phone` is not nullable")
      }

      if (!missing(`street_address`) && is.null(`street_address`)) {
        stop("Invalid value for `street_address` when calling AlbumApi$UpdateAlbumCollection, `street_address` is not nullable")
      }

      if (!missing(`street_address2`) && is.null(`street_address2`)) {
        stop("Invalid value for `street_address2` when calling AlbumApi$UpdateAlbumCollection, `street_address2` is not nullable")
      }

      if (!missing(`city`) && is.null(`city`)) {
        stop("Invalid value for `city` when calling AlbumApi$UpdateAlbumCollection, `city` is not nullable")
      }

      if (!missing(`state`) && is.null(`state`)) {
        stop("Invalid value for `state` when calling AlbumApi$UpdateAlbumCollection, `state` is not nullable")
      }

      if (!missing(`postal_code`) && is.null(`postal_code`)) {
        stop("Invalid value for `postal_code` when calling AlbumApi$UpdateAlbumCollection, `postal_code` is not nullable")
      }

      if (!missing(`full_address`) && is.null(`full_address`)) {
        stop("Invalid value for `full_address` when calling AlbumApi$UpdateAlbumCollection, `full_address` is not nullable")
      }

      if (!missing(`anonymous`) && is.null(`anonymous`)) {
        stop("Invalid value for `anonymous` when calling AlbumApi$UpdateAlbumCollection, `anonymous` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling AlbumApi$UpdateAlbumCollection, `meta_data` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling AlbumApi$UpdateAlbumCollection, `category_ids` is not nullable")
      }

      if (!missing(`category_filter_ids`) && is.null(`category_filter_ids`)) {
        stop("Invalid value for `category_filter_ids` when calling AlbumApi$UpdateAlbumCollection, `category_filter_ids` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling AlbumApi$UpdateAlbumCollection, `audience_ids` is not nullable")
      }

      if (!missing(`audience_ids_to_add`) && is.null(`audience_ids_to_add`)) {
        stop("Invalid value for `audience_ids_to_add` when calling AlbumApi$UpdateAlbumCollection, `audience_ids_to_add` is not nullable")
      }

      if (!missing(`audience_ids_to_remove`) && is.null(`audience_ids_to_remove`)) {
        stop("Invalid value for `audience_ids_to_remove` when calling AlbumApi$UpdateAlbumCollection, `audience_ids_to_remove` is not nullable")
      }

      if (!missing(`include_all_app_users_as_members`) && is.null(`include_all_app_users_as_members`)) {
        stop("Invalid value for `include_all_app_users_as_members` when calling AlbumApi$UpdateAlbumCollection, `include_all_app_users_as_members` is not nullable")
      }

      if (!missing(`include_audiences_as_members`) && is.null(`include_audiences_as_members`)) {
        stop("Invalid value for `include_audiences_as_members` when calling AlbumApi$UpdateAlbumCollection, `include_audiences_as_members` is not nullable")
      }

      if (!missing(`audience_operator`) && is.null(`audience_operator`)) {
        stop("Invalid value for `audience_operator` when calling AlbumApi$UpdateAlbumCollection, `audience_operator` is not nullable")
      }

      if (!missing(`linked_object_type`) && is.null(`linked_object_type`)) {
        stop("Invalid value for `linked_object_type` when calling AlbumApi$UpdateAlbumCollection, `linked_object_type` is not nullable")
      }

      if (!missing(`linked_object_id`) && is.null(`linked_object_id`)) {
        stop("Invalid value for `linked_object_id` when calling AlbumApi$UpdateAlbumCollection, `linked_object_id` is not nullable")
      }

      if (!missing(`index_now`) && is.null(`index_now`)) {
        stop("Invalid value for `index_now` when calling AlbumApi$UpdateAlbumCollection, `index_now` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["albumId"]] <- `album_id`

      query_params[["assetsToAdd"]] <- `assets_to_add`

      query_params[["assetsToRemove"]] <- `assets_to_remove`

      query_params[["assetId"]] <- `asset_id`

      query_params[["media"]] <- `media`

      query_params[["mediaURL"]] <- `media_url`

      query_params[["active"]] <- `active`

      query_params[["title"]] <- `title`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["tags"]] <- `tags`

      query_params[["description"]] <- `description`

      query_params[["albumType"]] <- `album_type`

      query_params[["albumTypeId"]] <- `album_type_id`

      query_params[["subType"]] <- `sub_type`

      query_params[["publicRead"]] <- `public_read`

      query_params[["publicWrite"]] <- `public_write`

      query_params[["publicDelete"]] <- `public_delete`

      query_params[["publicAdd"]] <- `public_add`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["locationDescription"]] <- `location_description`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling AlbumApi$UpdateAlbumCollection. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["cellPhone"]] <- `cell_phone`

      query_params[["streetAddress"]] <- `street_address`

      query_params[["streetAddress2"]] <- `street_address2`

      query_params[["city"]] <- `city`

      query_params[["state"]] <- `state`

      query_params[["postalCode"]] <- `postal_code`

      query_params[["fullAddress"]] <- `full_address`

      query_params[["anonymous"]] <- `anonymous`

      query_params[["metaData"]] <- `meta_data`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["categoryFilterIds"]] <- `category_filter_ids`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["audienceIdsToAdd"]] <- `audience_ids_to_add`

      query_params[["audienceIdsToRemove"]] <- `audience_ids_to_remove`

      query_params[["includeAllAppUsersAsMembers"]] <- `include_all_app_users_as_members`

      query_params[["includeAudiencesAsMembers"]] <- `include_audiences_as_members`

      query_params[["audienceOperator"]] <- `audience_operator`

      query_params[["linkedObjectType"]] <- `linked_object_type`

      query_params[["linkedObjectId"]] <- `linked_object_id`

      query_params[["indexNow"]] <- `index_now`

      local_var_url_path <- "/album/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "AlbumResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
