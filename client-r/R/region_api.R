#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Region operations
#' @description RegionApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateRegion  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The id of the account sending the request
#' var_region_class <- "region_class_example" # character | RegionClass of this region
#' var_short_name <- "short_name_example" # character | Short name of the region. This is optimized for search
#' var_full_name <- "full_name_example" # character | Full name of the region (Optional)
#' var_parent_ids <- "parent_ids_example" # character | Comma separated region ids that are parents of this region (Optional)
#' var_children_ids <- "children_ids_example" # character | Comma separated region ids that are children of this region (Optional)
#' var_postal_code_ids <- "postal_code_ids_example" # character | Comma separated postal code ids the region will include (Optional)
#' var_locations <- "locations_example" # character | Sets of name,lat,long used to create new postal codes assigned to the region (Optional)
#' var_retailer_location_id <- 56 # integer | the id of the retailer location that the region is being created for (Optional)
#' var_visibility <- "visibility_example" # character | The Visibility of the region (Optional)
#' var_category_ids <- "category_ids_example" # character | the categories that the region is assigned to (Optional)
#' var_filter_ids <- "filter_ids_example" # character | the filters that the region is assigned to (Optional)
#' var_start <- 56 # integer |  (Optional)
#' var_end <- 56 # integer |  (Optional)
#' var_polygon <- "polygon_example" # character | the polygon generated for the region (Optional)
#' var_meta_data <- "meta_data_example" # character | the meta data associated with the region (Optional)
#' var_latitude <- 3.4 # numeric | the latitude of the region (Optional)
#' var_longitude <- 3.4 # numeric | the longitude of the region (Optional)
#' var_version_code <- 56 # integer | the version code (Optional)
#' var_root <- "root_example" # character | If this is a root region or not. If true means this region has no parent regions (Optional)
#' var_active <- "active_example" # character | Active or inactive status of the region (Optional)
#'
#' #Create Region
#' api_instance <- RegionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateRegion(var_account_id, var_region_class, var_short_name, full_name = var_full_name, parent_ids = var_parent_ids, children_ids = var_children_ids, postal_code_ids = var_postal_code_ids, locations = var_locations, retailer_location_id = var_retailer_location_id, visibility = var_visibility, category_ids = var_category_ids, filter_ids = var_filter_ids, start = var_start, end = var_end, polygon = var_polygon, meta_data = var_meta_data, latitude = var_latitude, longitude = var_longitude, version_code = var_version_code, root = var_root, active = var_activedata_file = "result.txt")
#' result <- api_instance$CreateRegion(var_account_id, var_region_class, var_short_name, full_name = var_full_name, parent_ids = var_parent_ids, children_ids = var_children_ids, postal_code_ids = var_postal_code_ids, locations = var_locations, retailer_location_id = var_retailer_location_id, visibility = var_visibility, category_ids = var_category_ids, filter_ids = var_filter_ids, start = var_start, end = var_end, polygon = var_polygon, meta_data = var_meta_data, latitude = var_latitude, longitude = var_longitude, version_code = var_version_code, root = var_root, active = var_active)
#' dput(result)
#'
#'
#' ####################  DeleteRegion  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the id of the account logged in
#' var_region_id <- 56 # integer | the id of the region
#'
#' #Delete Region
#' api_instance <- RegionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteRegion(var_account_id, var_region_iddata_file = "result.txt")
#' result <- api_instance$DeleteRegion(var_account_id, var_region_id)
#' dput(result)
#'
#'
#' ####################  GetRegion  ####################
#'
#' library(openapi)
#' var_region_id <- 56 # integer | the id of the region to get
#' var_account_id <- 56 # integer | the id of the logged in user (Optional)
#'
#' #Get Region
#' api_instance <- RegionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetRegion(var_region_id, account_id = var_account_iddata_file = "result.txt")
#' result <- api_instance$GetRegion(var_region_id, account_id = var_account_id)
#' dput(result)
#'
#'
#' ####################  SearchRegions  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the owner account id of the region to be created (Optional)
#' var_query <- "query_example" # character | This parameter is deprecated. deprecated - use \"keyword\" (Optional)
#' var_keyword <- "keyword_example" # character | the keyword to filter results on (Optional)
#' var_latitude <- 3.4 # numeric | the latitude of the user (Optional)
#' var_longitude <- 3.4 # numeric | the longitude of the user (Optional)
#' var_range <- 3.4 # numeric | the search radius (Optional)
#' var_region_class <- "region_class_example" # character |  (Optional)
#' var_visibility <- "visibility_example" # character |  (Optional)
#' var_search_mode <- "search_mode_example" # character | the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server (Optional)
#' var_sort_field <- "sort_field_example" # character | the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided. (Optional)
#' var_descending <- "descending_example" # character | determines if the results get ordered in descending order (Optional)
#' var_include_parent <- "include_parent_example" # character | include the parent region or not (Optional)
#' var_include_children <- "include_children_example" # character | include the chidren regions or not (Optional)
#' var_include_postal_codes <- "include_postal_codes_example" # character | include the postal codes associated with the region or not (Optional)
#' var_category_ids <- "category_ids_example" # character | search on the categories associated with the region (Optional)
#' var_filter_ids <- "filter_ids_example" # character | search on the filters associated with the region (Optional)
#' var_version_code <- 56 # integer | filter by a specific version code (Optional)
#' var_active_only <- "active_only_example" # character | filter to show only active results (Optional)
#' var_show_deleted <- "show_deleted_example" # character | If showDeleted is true and activeOnly is false, will return regions that have been deleted (Optional)
#' var_last_updated_since <- 56 # integer | only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\) (Optional)
#' var_start <- 56 # integer | the start index for pagination (Optional)
#' var_limit <- 56 # integer | the limit for pagination (Optional)
#'
#' #Search Regions
#' api_instance <- RegionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchRegions(account_id = var_account_id, query = var_query, keyword = var_keyword, latitude = var_latitude, longitude = var_longitude, range = var_range, region_class = var_region_class, visibility = var_visibility, search_mode = var_search_mode, sort_field = var_sort_field, descending = var_descending, include_parent = var_include_parent, include_children = var_include_children, include_postal_codes = var_include_postal_codes, category_ids = var_category_ids, filter_ids = var_filter_ids, version_code = var_version_code, active_only = var_active_only, show_deleted = var_show_deleted, last_updated_since = var_last_updated_since, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$SearchRegions(account_id = var_account_id, query = var_query, keyword = var_keyword, latitude = var_latitude, longitude = var_longitude, range = var_range, region_class = var_region_class, visibility = var_visibility, search_mode = var_search_mode, sort_field = var_sort_field, descending = var_descending, include_parent = var_include_parent, include_children = var_include_children, include_postal_codes = var_include_postal_codes, category_ids = var_category_ids, filter_ids = var_filter_ids, version_code = var_version_code, active_only = var_active_only, show_deleted = var_show_deleted, last_updated_since = var_last_updated_since, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  UpdateRegion  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The id of the account sending the request
#' var_region_id <- 56 # integer | The id of the region to be updated
#' var_region_class <- "region_class_example" # character | RegionClass of this region (Optional)
#' var_short_name <- "short_name_example" # character | Short name of the region. This is optimized for search (Optional)
#' var_full_name <- "full_name_example" # character | Full name of the region (Optional)
#' var_parent_ids <- "parent_ids_example" # character | Comma separated region ids that are parents of this region (Optional)
#' var_children_ids <- "children_ids_example" # character | Comma separated region ids that are children of this region (Optional)
#' var_postal_code_ids <- "postal_code_ids_example" # character | Comma separated postal code ids the region will include (Optional)
#' var_locations <- "locations_example" # character | Sets of name,lat,long used to create new postal codes assigned to the region (Optional)
#' var_retailer_location_id <- 56 # integer | the retailer location ID that the region is associated with (Optional)
#' var_visibility <- "visibility_example" # character | The Visibility of the region (Optional)
#' var_category_ids <- "category_ids_example" # character | the categories that the region is assigned to (Optional)
#' var_filter_ids <- "filter_ids_example" # character | the filters that the region is assigned to (Optional)
#' var_start <- 56 # integer |  (Optional)
#' var_end <- 56 # integer |  (Optional)
#' var_polygon <- "polygon_example" # character | the polygon of the region (Optional)
#' var_meta_data <- "meta_data_example" # character | the meta data of the region (Optional)
#' var_latitude <- 3.4 # numeric | the latitude of the region (Optional)
#' var_longitude <- 3.4 # numeric | the longitude of the region (Optional)
#' var_version_code <- 56 # integer | the version code (Optional)
#' var_root <- "root_example" # character | If this is a root region or not. If true means this region has no parent regions (Optional)
#' var_active <- "active_example" # character | Active or inactive status of the region (Optional)
#' var_clear_lists <- "clear_lists_example" # character | If true clear the children and postal code lists before add new ones, otherwise just append. (Optional)
#'
#' #Update Region
#' api_instance <- RegionApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateRegion(var_account_id, var_region_id, region_class = var_region_class, short_name = var_short_name, full_name = var_full_name, parent_ids = var_parent_ids, children_ids = var_children_ids, postal_code_ids = var_postal_code_ids, locations = var_locations, retailer_location_id = var_retailer_location_id, visibility = var_visibility, category_ids = var_category_ids, filter_ids = var_filter_ids, start = var_start, end = var_end, polygon = var_polygon, meta_data = var_meta_data, latitude = var_latitude, longitude = var_longitude, version_code = var_version_code, root = var_root, active = var_active, clear_lists = var_clear_listsdata_file = "result.txt")
#' result <- api_instance$UpdateRegion(var_account_id, var_region_id, region_class = var_region_class, short_name = var_short_name, full_name = var_full_name, parent_ids = var_parent_ids, children_ids = var_children_ids, postal_code_ids = var_postal_code_ids, locations = var_locations, retailer_location_id = var_retailer_location_id, visibility = var_visibility, category_ids = var_category_ids, filter_ids = var_filter_ids, start = var_start, end = var_end, polygon = var_polygon, meta_data = var_meta_data, latitude = var_latitude, longitude = var_longitude, version_code = var_version_code, root = var_root, active = var_active, clear_lists = var_clear_lists)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
RegionApi <- R6::R6Class(
  "RegionApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new RegionApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Region
    #'
    #' @param account_id The id of the account sending the request
    #' @param region_class RegionClass of this region
    #' @param short_name Short name of the region. This is optimized for search
    #' @param full_name (optional) Full name of the region
    #' @param parent_ids (optional) Comma separated region ids that are parents of this region
    #' @param children_ids (optional) Comma separated region ids that are children of this region
    #' @param postal_code_ids (optional) Comma separated postal code ids the region will include
    #' @param locations (optional) Sets of name,lat,long used to create new postal codes assigned to the region
    #' @param retailer_location_id (optional) the id of the retailer location that the region is being created for
    #' @param visibility (optional) The Visibility of the region
    #' @param category_ids (optional) the categories that the region is assigned to
    #' @param filter_ids (optional) the filters that the region is assigned to
    #' @param start (optional) 
    #' @param end (optional) 
    #' @param polygon (optional) the polygon generated for the region
    #' @param meta_data (optional) the meta data associated with the region
    #' @param latitude (optional) the latitude of the region
    #' @param longitude (optional) the longitude of the region
    #' @param version_code (optional) the version code
    #' @param root (optional) If this is a root region or not. If true means this region has no parent regions
    #' @param active (optional) Active or inactive status of the region
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return RegionResponse
    CreateRegion = function(account_id, region_class, short_name, full_name = NULL, parent_ids = NULL, children_ids = NULL, postal_code_ids = NULL, locations = NULL, retailer_location_id = NULL, visibility = NULL, category_ids = NULL, filter_ids = NULL, start = NULL, end = NULL, polygon = NULL, meta_data = NULL, latitude = NULL, longitude = NULL, version_code = NULL, root = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateRegionWithHttpInfo(account_id, region_class, short_name, full_name, parent_ids, children_ids, postal_code_ids, locations, retailer_location_id, visibility, category_ids, filter_ids, start, end, polygon, meta_data, latitude, longitude, version_code, root, active, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Region
    #'
    #' @param account_id The id of the account sending the request
    #' @param region_class RegionClass of this region
    #' @param short_name Short name of the region. This is optimized for search
    #' @param full_name (optional) Full name of the region
    #' @param parent_ids (optional) Comma separated region ids that are parents of this region
    #' @param children_ids (optional) Comma separated region ids that are children of this region
    #' @param postal_code_ids (optional) Comma separated postal code ids the region will include
    #' @param locations (optional) Sets of name,lat,long used to create new postal codes assigned to the region
    #' @param retailer_location_id (optional) the id of the retailer location that the region is being created for
    #' @param visibility (optional) The Visibility of the region
    #' @param category_ids (optional) the categories that the region is assigned to
    #' @param filter_ids (optional) the filters that the region is assigned to
    #' @param start (optional) 
    #' @param end (optional) 
    #' @param polygon (optional) the polygon generated for the region
    #' @param meta_data (optional) the meta data associated with the region
    #' @param latitude (optional) the latitude of the region
    #' @param longitude (optional) the longitude of the region
    #' @param version_code (optional) the version code
    #' @param root (optional) If this is a root region or not. If true means this region has no parent regions
    #' @param active (optional) Active or inactive status of the region
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (RegionResponse) with additional information such as HTTP status code, headers
    CreateRegionWithHttpInfo = function(account_id, region_class, short_name, full_name = NULL, parent_ids = NULL, children_ids = NULL, postal_code_ids = NULL, locations = NULL, retailer_location_id = NULL, visibility = NULL, category_ids = NULL, filter_ids = NULL, start = NULL, end = NULL, polygon = NULL, meta_data = NULL, latitude = NULL, longitude = NULL, version_code = NULL, root = NULL, active = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`region_class`)) {
        stop("Missing required parameter `region_class`.")
      }

      if (missing(`short_name`)) {
        stop("Missing required parameter `short_name`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RegionApi$CreateRegion, `account_id` is not nullable")
      }

      if (!missing(`region_class`) && is.null(`region_class`)) {
        stop("Invalid value for `region_class` when calling RegionApi$CreateRegion, `region_class` is not nullable")
      }

      if (!missing(`short_name`) && is.null(`short_name`)) {
        stop("Invalid value for `short_name` when calling RegionApi$CreateRegion, `short_name` is not nullable")
      }

      if (!missing(`full_name`) && is.null(`full_name`)) {
        stop("Invalid value for `full_name` when calling RegionApi$CreateRegion, `full_name` is not nullable")
      }

      if (!missing(`parent_ids`) && is.null(`parent_ids`)) {
        stop("Invalid value for `parent_ids` when calling RegionApi$CreateRegion, `parent_ids` is not nullable")
      }

      if (!missing(`children_ids`) && is.null(`children_ids`)) {
        stop("Invalid value for `children_ids` when calling RegionApi$CreateRegion, `children_ids` is not nullable")
      }

      if (!missing(`postal_code_ids`) && is.null(`postal_code_ids`)) {
        stop("Invalid value for `postal_code_ids` when calling RegionApi$CreateRegion, `postal_code_ids` is not nullable")
      }

      if (!missing(`locations`) && is.null(`locations`)) {
        stop("Invalid value for `locations` when calling RegionApi$CreateRegion, `locations` is not nullable")
      }

      if (!missing(`retailer_location_id`) && is.null(`retailer_location_id`)) {
        stop("Invalid value for `retailer_location_id` when calling RegionApi$CreateRegion, `retailer_location_id` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling RegionApi$CreateRegion, `visibility` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling RegionApi$CreateRegion, `category_ids` is not nullable")
      }

      if (!missing(`filter_ids`) && is.null(`filter_ids`)) {
        stop("Invalid value for `filter_ids` when calling RegionApi$CreateRegion, `filter_ids` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling RegionApi$CreateRegion, `start` is not nullable")
      }

      if (!missing(`end`) && is.null(`end`)) {
        stop("Invalid value for `end` when calling RegionApi$CreateRegion, `end` is not nullable")
      }

      if (!missing(`polygon`) && is.null(`polygon`)) {
        stop("Invalid value for `polygon` when calling RegionApi$CreateRegion, `polygon` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling RegionApi$CreateRegion, `meta_data` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling RegionApi$CreateRegion, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling RegionApi$CreateRegion, `longitude` is not nullable")
      }

      if (!missing(`version_code`) && is.null(`version_code`)) {
        stop("Invalid value for `version_code` when calling RegionApi$CreateRegion, `version_code` is not nullable")
      }

      if (!missing(`root`) && is.null(`root`)) {
        stop("Invalid value for `root` when calling RegionApi$CreateRegion, `root` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling RegionApi$CreateRegion, `active` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["regionClass"]] <- `region_class`

      query_params[["shortName"]] <- `short_name`

      query_params[["fullName"]] <- `full_name`

      query_params[["parentIds"]] <- `parent_ids`

      query_params[["childrenIds"]] <- `children_ids`

      query_params[["postalCodeIds"]] <- `postal_code_ids`

      query_params[["locations"]] <- `locations`

      query_params[["retailerLocationId"]] <- `retailer_location_id`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling RegionApi$CreateRegion. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["filterIds"]] <- `filter_ids`

      query_params[["start"]] <- `start`

      query_params[["end"]] <- `end`

      query_params[["polygon"]] <- `polygon`

      query_params[["metaData"]] <- `meta_data`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["versionCode"]] <- `version_code`

      query_params[["root"]] <- `root`

      query_params[["active"]] <- `active`

      local_var_url_path <- "/region/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "RegionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Region
    #'
    #' @param account_id the id of the account logged in
    #' @param region_id the id of the region
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return RegionResponse
    DeleteRegion = function(account_id, region_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteRegionWithHttpInfo(account_id, region_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Region
    #'
    #' @param account_id the id of the account logged in
    #' @param region_id the id of the region
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (RegionResponse) with additional information such as HTTP status code, headers
    DeleteRegionWithHttpInfo = function(account_id, region_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`region_id`)) {
        stop("Missing required parameter `region_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RegionApi$DeleteRegion, `account_id` is not nullable")
      }

      if (!missing(`region_id`) && is.null(`region_id`)) {
        stop("Invalid value for `region_id` when calling RegionApi$DeleteRegion, `region_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["regionId"]] <- `region_id`

      local_var_url_path <- "/region/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "RegionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Region
    #'
    #' @param region_id the id of the region to get
    #' @param account_id (optional) the id of the logged in user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return RegionResponse
    GetRegion = function(region_id, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetRegionWithHttpInfo(region_id, account_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Region
    #'
    #' @param region_id the id of the region to get
    #' @param account_id (optional) the id of the logged in user
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (RegionResponse) with additional information such as HTTP status code, headers
    GetRegionWithHttpInfo = function(region_id, account_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`region_id`)) {
        stop("Missing required parameter `region_id`.")
      }

      if (!missing(`region_id`) && is.null(`region_id`)) {
        stop("Invalid value for `region_id` when calling RegionApi$GetRegion, `region_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RegionApi$GetRegion, `account_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["regionId"]] <- `region_id`

      local_var_url_path <- "/region/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "RegionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Regions
    #'
    #' @param account_id (optional) the owner account id of the region to be created
    #' @param query (optional) This parameter is deprecated. deprecated - use \"keyword\"
    #' @param keyword (optional) the keyword to filter results on
    #' @param latitude (optional) the latitude of the user
    #' @param longitude (optional) the longitude of the user
    #' @param range (optional) the search radius
    #' @param region_class (optional) 
    #' @param visibility (optional) 
    #' @param search_mode (optional) the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
    #' @param sort_field (optional) the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
    #' @param descending (optional) determines if the results get ordered in descending order
    #' @param include_parent (optional) include the parent region or not
    #' @param include_children (optional) include the chidren regions or not
    #' @param include_postal_codes (optional) include the postal codes associated with the region or not
    #' @param category_ids (optional) search on the categories associated with the region
    #' @param filter_ids (optional) search on the filters associated with the region
    #' @param version_code (optional) filter by a specific version code
    #' @param active_only (optional) filter to show only active results
    #' @param show_deleted (optional) If showDeleted is true and activeOnly is false, will return regions that have been deleted
    #' @param last_updated_since (optional) only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
    #' @param start (optional) the start index for pagination
    #' @param limit (optional) the limit for pagination
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[RegionResponse]
    SearchRegions = function(account_id = NULL, query = NULL, keyword = NULL, latitude = NULL, longitude = NULL, range = NULL, region_class = NULL, visibility = NULL, search_mode = NULL, sort_field = NULL, descending = NULL, include_parent = NULL, include_children = NULL, include_postal_codes = NULL, category_ids = NULL, filter_ids = NULL, version_code = NULL, active_only = NULL, show_deleted = NULL, last_updated_since = NULL, start = NULL, limit = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchRegionsWithHttpInfo(account_id, query, keyword, latitude, longitude, range, region_class, visibility, search_mode, sort_field, descending, include_parent, include_children, include_postal_codes, category_ids, filter_ids, version_code, active_only, show_deleted, last_updated_since, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Regions
    #'
    #' @param account_id (optional) the owner account id of the region to be created
    #' @param query (optional) This parameter is deprecated. deprecated - use \"keyword\"
    #' @param keyword (optional) the keyword to filter results on
    #' @param latitude (optional) the latitude of the user
    #' @param longitude (optional) the longitude of the user
    #' @param range (optional) the search radius
    #' @param region_class (optional) 
    #' @param visibility (optional) 
    #' @param search_mode (optional) the SearchIndexMode: RDS, LUCENE, or CLOUDINDEX. If not provided, will use the default defined in the Sirqul server
    #' @param sort_field (optional) the field to order results by: ID, UPDATED, NAME, or DISTANCE. If not provided, will use the default which is by ID for text and DISTANCE when lat/long is provided.
    #' @param descending (optional) determines if the results get ordered in descending order
    #' @param include_parent (optional) include the parent region or not
    #' @param include_children (optional) include the chidren regions or not
    #' @param include_postal_codes (optional) include the postal codes associated with the region or not
    #' @param category_ids (optional) search on the categories associated with the region
    #' @param filter_ids (optional) search on the filters associated with the region
    #' @param version_code (optional) filter by a specific version code
    #' @param active_only (optional) filter to show only active results
    #' @param show_deleted (optional) If showDeleted is true and activeOnly is false, will return regions that have been deleted
    #' @param last_updated_since (optional) only returns records that have last updated since this date \\(UTC timestamp in milliseconds\\)
    #' @param start (optional) the start index for pagination
    #' @param limit (optional) the limit for pagination
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[RegionResponse]) with additional information such as HTTP status code, headers
    SearchRegionsWithHttpInfo = function(account_id = NULL, query = NULL, keyword = NULL, latitude = NULL, longitude = NULL, range = NULL, region_class = NULL, visibility = NULL, search_mode = NULL, sort_field = NULL, descending = NULL, include_parent = NULL, include_children = NULL, include_postal_codes = NULL, category_ids = NULL, filter_ids = NULL, version_code = NULL, active_only = NULL, show_deleted = NULL, last_updated_since = NULL, start = NULL, limit = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RegionApi$SearchRegions, `account_id` is not nullable")
      }

      if (!missing(`query`) && is.null(`query`)) {
        stop("Invalid value for `query` when calling RegionApi$SearchRegions, `query` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling RegionApi$SearchRegions, `keyword` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling RegionApi$SearchRegions, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling RegionApi$SearchRegions, `longitude` is not nullable")
      }

      if (!missing(`range`) && is.null(`range`)) {
        stop("Invalid value for `range` when calling RegionApi$SearchRegions, `range` is not nullable")
      }

      if (!missing(`region_class`) && is.null(`region_class`)) {
        stop("Invalid value for `region_class` when calling RegionApi$SearchRegions, `region_class` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling RegionApi$SearchRegions, `visibility` is not nullable")
      }

      if (!missing(`search_mode`) && is.null(`search_mode`)) {
        stop("Invalid value for `search_mode` when calling RegionApi$SearchRegions, `search_mode` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling RegionApi$SearchRegions, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling RegionApi$SearchRegions, `descending` is not nullable")
      }

      if (!missing(`include_parent`) && is.null(`include_parent`)) {
        stop("Invalid value for `include_parent` when calling RegionApi$SearchRegions, `include_parent` is not nullable")
      }

      if (!missing(`include_children`) && is.null(`include_children`)) {
        stop("Invalid value for `include_children` when calling RegionApi$SearchRegions, `include_children` is not nullable")
      }

      if (!missing(`include_postal_codes`) && is.null(`include_postal_codes`)) {
        stop("Invalid value for `include_postal_codes` when calling RegionApi$SearchRegions, `include_postal_codes` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling RegionApi$SearchRegions, `category_ids` is not nullable")
      }

      if (!missing(`filter_ids`) && is.null(`filter_ids`)) {
        stop("Invalid value for `filter_ids` when calling RegionApi$SearchRegions, `filter_ids` is not nullable")
      }

      if (!missing(`version_code`) && is.null(`version_code`)) {
        stop("Invalid value for `version_code` when calling RegionApi$SearchRegions, `version_code` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling RegionApi$SearchRegions, `active_only` is not nullable")
      }

      if (!missing(`show_deleted`) && is.null(`show_deleted`)) {
        stop("Invalid value for `show_deleted` when calling RegionApi$SearchRegions, `show_deleted` is not nullable")
      }

      if (!missing(`last_updated_since`) && is.null(`last_updated_since`)) {
        stop("Invalid value for `last_updated_since` when calling RegionApi$SearchRegions, `last_updated_since` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling RegionApi$SearchRegions, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling RegionApi$SearchRegions, `limit` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["query"]] <- `query`

      query_params[["keyword"]] <- `keyword`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["range"]] <- `range`

      if (!is.null(`region_class`) && !(`region_class` %in% c("NATIONAL", "STATE", "COUNTY", "METRO_AREA", "CITY", "NEIGHBORHOOD", "TERRITORY", "CUSTOM", "ZONE"))) {
        stop("Invalid value for region_class when calling RegionApi$SearchRegions. Must be [NATIONAL, STATE, COUNTY, METRO_AREA, CITY, NEIGHBORHOOD, TERRITORY, CUSTOM, ZONE].")
      }
      query_params[["regionClass"]] <- `region_class`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling RegionApi$SearchRegions. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      if (!is.null(`search_mode`) && !(`search_mode` %in% c("RDS", "LUCENE", "CLOUDINDEX"))) {
        stop("Invalid value for search_mode when calling RegionApi$SearchRegions. Must be [RDS, LUCENE, CLOUDINDEX].")
      }
      query_params[["searchMode"]] <- `search_mode`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "UPDATED", "NAME", "DISTANCE"))) {
        stop("Invalid value for sort_field when calling RegionApi$SearchRegions. Must be [ID, UPDATED, NAME, DISTANCE].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["includeParent"]] <- `include_parent`

      query_params[["includeChildren"]] <- `include_children`

      query_params[["includePostalCodes"]] <- `include_postal_codes`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["filterIds"]] <- `filter_ids`

      query_params[["versionCode"]] <- `version_code`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["showDeleted"]] <- `show_deleted`

      query_params[["lastUpdatedSince"]] <- `last_updated_since`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/region/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[RegionResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Region
    #'
    #' @param account_id The id of the account sending the request
    #' @param region_id The id of the region to be updated
    #' @param region_class (optional) RegionClass of this region
    #' @param short_name (optional) Short name of the region. This is optimized for search
    #' @param full_name (optional) Full name of the region
    #' @param parent_ids (optional) Comma separated region ids that are parents of this region
    #' @param children_ids (optional) Comma separated region ids that are children of this region
    #' @param postal_code_ids (optional) Comma separated postal code ids the region will include
    #' @param locations (optional) Sets of name,lat,long used to create new postal codes assigned to the region
    #' @param retailer_location_id (optional) the retailer location ID that the region is associated with
    #' @param visibility (optional) The Visibility of the region
    #' @param category_ids (optional) the categories that the region is assigned to
    #' @param filter_ids (optional) the filters that the region is assigned to
    #' @param start (optional) 
    #' @param end (optional) 
    #' @param polygon (optional) the polygon of the region
    #' @param meta_data (optional) the meta data of the region
    #' @param latitude (optional) the latitude of the region
    #' @param longitude (optional) the longitude of the region
    #' @param version_code (optional) the version code
    #' @param root (optional) If this is a root region or not. If true means this region has no parent regions
    #' @param active (optional) Active or inactive status of the region
    #' @param clear_lists (optional) If true clear the children and postal code lists before add new ones, otherwise just append.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return RegionResponse
    UpdateRegion = function(account_id, region_id, region_class = NULL, short_name = NULL, full_name = NULL, parent_ids = NULL, children_ids = NULL, postal_code_ids = NULL, locations = NULL, retailer_location_id = NULL, visibility = NULL, category_ids = NULL, filter_ids = NULL, start = NULL, end = NULL, polygon = NULL, meta_data = NULL, latitude = NULL, longitude = NULL, version_code = NULL, root = NULL, active = NULL, clear_lists = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateRegionWithHttpInfo(account_id, region_id, region_class, short_name, full_name, parent_ids, children_ids, postal_code_ids, locations, retailer_location_id, visibility, category_ids, filter_ids, start, end, polygon, meta_data, latitude, longitude, version_code, root, active, clear_lists, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Region
    #'
    #' @param account_id The id of the account sending the request
    #' @param region_id The id of the region to be updated
    #' @param region_class (optional) RegionClass of this region
    #' @param short_name (optional) Short name of the region. This is optimized for search
    #' @param full_name (optional) Full name of the region
    #' @param parent_ids (optional) Comma separated region ids that are parents of this region
    #' @param children_ids (optional) Comma separated region ids that are children of this region
    #' @param postal_code_ids (optional) Comma separated postal code ids the region will include
    #' @param locations (optional) Sets of name,lat,long used to create new postal codes assigned to the region
    #' @param retailer_location_id (optional) the retailer location ID that the region is associated with
    #' @param visibility (optional) The Visibility of the region
    #' @param category_ids (optional) the categories that the region is assigned to
    #' @param filter_ids (optional) the filters that the region is assigned to
    #' @param start (optional) 
    #' @param end (optional) 
    #' @param polygon (optional) the polygon of the region
    #' @param meta_data (optional) the meta data of the region
    #' @param latitude (optional) the latitude of the region
    #' @param longitude (optional) the longitude of the region
    #' @param version_code (optional) the version code
    #' @param root (optional) If this is a root region or not. If true means this region has no parent regions
    #' @param active (optional) Active or inactive status of the region
    #' @param clear_lists (optional) If true clear the children and postal code lists before add new ones, otherwise just append.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (RegionResponse) with additional information such as HTTP status code, headers
    UpdateRegionWithHttpInfo = function(account_id, region_id, region_class = NULL, short_name = NULL, full_name = NULL, parent_ids = NULL, children_ids = NULL, postal_code_ids = NULL, locations = NULL, retailer_location_id = NULL, visibility = NULL, category_ids = NULL, filter_ids = NULL, start = NULL, end = NULL, polygon = NULL, meta_data = NULL, latitude = NULL, longitude = NULL, version_code = NULL, root = NULL, active = NULL, clear_lists = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`region_id`)) {
        stop("Missing required parameter `region_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RegionApi$UpdateRegion, `account_id` is not nullable")
      }

      if (!missing(`region_id`) && is.null(`region_id`)) {
        stop("Invalid value for `region_id` when calling RegionApi$UpdateRegion, `region_id` is not nullable")
      }

      if (!missing(`region_class`) && is.null(`region_class`)) {
        stop("Invalid value for `region_class` when calling RegionApi$UpdateRegion, `region_class` is not nullable")
      }

      if (!missing(`short_name`) && is.null(`short_name`)) {
        stop("Invalid value for `short_name` when calling RegionApi$UpdateRegion, `short_name` is not nullable")
      }

      if (!missing(`full_name`) && is.null(`full_name`)) {
        stop("Invalid value for `full_name` when calling RegionApi$UpdateRegion, `full_name` is not nullable")
      }

      if (!missing(`parent_ids`) && is.null(`parent_ids`)) {
        stop("Invalid value for `parent_ids` when calling RegionApi$UpdateRegion, `parent_ids` is not nullable")
      }

      if (!missing(`children_ids`) && is.null(`children_ids`)) {
        stop("Invalid value for `children_ids` when calling RegionApi$UpdateRegion, `children_ids` is not nullable")
      }

      if (!missing(`postal_code_ids`) && is.null(`postal_code_ids`)) {
        stop("Invalid value for `postal_code_ids` when calling RegionApi$UpdateRegion, `postal_code_ids` is not nullable")
      }

      if (!missing(`locations`) && is.null(`locations`)) {
        stop("Invalid value for `locations` when calling RegionApi$UpdateRegion, `locations` is not nullable")
      }

      if (!missing(`retailer_location_id`) && is.null(`retailer_location_id`)) {
        stop("Invalid value for `retailer_location_id` when calling RegionApi$UpdateRegion, `retailer_location_id` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling RegionApi$UpdateRegion, `visibility` is not nullable")
      }

      if (!missing(`category_ids`) && is.null(`category_ids`)) {
        stop("Invalid value for `category_ids` when calling RegionApi$UpdateRegion, `category_ids` is not nullable")
      }

      if (!missing(`filter_ids`) && is.null(`filter_ids`)) {
        stop("Invalid value for `filter_ids` when calling RegionApi$UpdateRegion, `filter_ids` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling RegionApi$UpdateRegion, `start` is not nullable")
      }

      if (!missing(`end`) && is.null(`end`)) {
        stop("Invalid value for `end` when calling RegionApi$UpdateRegion, `end` is not nullable")
      }

      if (!missing(`polygon`) && is.null(`polygon`)) {
        stop("Invalid value for `polygon` when calling RegionApi$UpdateRegion, `polygon` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling RegionApi$UpdateRegion, `meta_data` is not nullable")
      }

      if (!missing(`latitude`) && is.null(`latitude`)) {
        stop("Invalid value for `latitude` when calling RegionApi$UpdateRegion, `latitude` is not nullable")
      }

      if (!missing(`longitude`) && is.null(`longitude`)) {
        stop("Invalid value for `longitude` when calling RegionApi$UpdateRegion, `longitude` is not nullable")
      }

      if (!missing(`version_code`) && is.null(`version_code`)) {
        stop("Invalid value for `version_code` when calling RegionApi$UpdateRegion, `version_code` is not nullable")
      }

      if (!missing(`root`) && is.null(`root`)) {
        stop("Invalid value for `root` when calling RegionApi$UpdateRegion, `root` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling RegionApi$UpdateRegion, `active` is not nullable")
      }

      if (!missing(`clear_lists`) && is.null(`clear_lists`)) {
        stop("Invalid value for `clear_lists` when calling RegionApi$UpdateRegion, `clear_lists` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["regionId"]] <- `region_id`

      query_params[["regionClass"]] <- `region_class`

      query_params[["shortName"]] <- `short_name`

      query_params[["fullName"]] <- `full_name`

      query_params[["parentIds"]] <- `parent_ids`

      query_params[["childrenIds"]] <- `children_ids`

      query_params[["postalCodeIds"]] <- `postal_code_ids`

      query_params[["locations"]] <- `locations`

      query_params[["retailerLocationId"]] <- `retailer_location_id`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling RegionApi$UpdateRegion. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["categoryIds"]] <- `category_ids`

      query_params[["filterIds"]] <- `filter_ids`

      query_params[["start"]] <- `start`

      query_params[["end"]] <- `end`

      query_params[["polygon"]] <- `polygon`

      query_params[["metaData"]] <- `meta_data`

      query_params[["latitude"]] <- `latitude`

      query_params[["longitude"]] <- `longitude`

      query_params[["versionCode"]] <- `version_code`

      query_params[["root"]] <- `root`

      query_params[["active"]] <- `active`

      query_params[["clearLists"]] <- `clear_lists`

      local_var_url_path <- "/region/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "RegionResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
