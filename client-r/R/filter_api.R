#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Filter operations
#' @description FilterApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateFilter  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user (must have permissions to the target application)
#' var_name <- "name_example" # character | The name of the filter
#' var_app_key <- "app_key_example" # character | The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions) (Optional)
#' var_parent_filter_id <- 56 # integer | The ID of the parent filter, if not provided then the parent filter will be null (Optional)
#' var_description <- "description_example" # character | The description of the filter (Optional)
#' var_external_id <- "external_id_example" # character | A string identifier used by client applications to store external information (Optional)
#' var_external_type <- "external_type_example" # character | A string type used by client applications to store external information (Optional)
#' var_active <- "active_example" # character | Sets whether the filter is active or inactive (hidden from consumers) (Optional)
#' var_meta_data <- "meta_data_example" # character | external custom client defined data (Optional)
#'
#' #Create Filter
#' api_instance <- FilterApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateFilter(var_account_id, var_name, app_key = var_app_key, parent_filter_id = var_parent_filter_id, description = var_description, external_id = var_external_id, external_type = var_external_type, active = var_active, meta_data = var_meta_datadata_file = "result.txt")
#' result <- api_instance$CreateFilter(var_account_id, var_name, app_key = var_app_key, parent_filter_id = var_parent_filter_id, description = var_description, external_id = var_external_id, external_type = var_external_type, active = var_active, meta_data = var_meta_data)
#' dput(result)
#'
#'
#' ####################  DeleteFilter  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user (must have permissions to the filter's assigned application)
#' var_filter_id <- 56 # integer | The ID of the filter to delete
#'
#' #Delete Filter
#' api_instance <- FilterApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteFilter(var_account_id, var_filter_iddata_file = "result.txt")
#' result <- api_instance$DeleteFilter(var_account_id, var_filter_id)
#' dput(result)
#'
#'
#' ####################  GetFilter  ####################
#'
#' library(openapi)
#' var_filter_id <- 56 # integer | the id of the filter to get
#'
#' #Get Filter
#' api_instance <- FilterApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetFilter(var_filter_iddata_file = "result.txt")
#' result <- api_instance$GetFilter(var_filter_id)
#' dput(result)
#'
#'
#' ####################  SearchFilters  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user (Optional)
#' var_keyword <- "keyword_example" # character | The string to search on (Optional)
#' var_app_key <- "app_key_example" # character | the appKey of the application to retrieve filters for (Optional)
#' var_response_group <- "response_group_example" # character | The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided. (Optional)
#' var_root_only <- "root_only_example" # character | Restrict the search to only those filters with no parent filter assigned. (Optional)
#' var_sort_field <- "DISPLAY" # character | The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (Optional)
#' var_descending <- FALSE # character | The order to return the search results (Optional)
#' var_start <- 0 # integer | The record to begin the return set on (Optional)
#' var_limit <- 20 # integer | The number of records to return (Optional)
#' var_active_only <- TRUE # character | Determines whether to return only active categories (Optional)
#'
#' #Search Filters
#' api_instance <- FilterApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchFilters(account_id = var_account_id, keyword = var_keyword, app_key = var_app_key, response_group = var_response_group, root_only = var_root_only, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_onlydata_file = "result.txt")
#' result <- api_instance$SearchFilters(account_id = var_account_id, keyword = var_keyword, app_key = var_app_key, response_group = var_response_group, root_only = var_root_only, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_only)
#' dput(result)
#'
#'
#' ####################  UpdateFilter  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The account id of the user
#' var_filter_id <- 56 # integer | The ID of the filter to edit
#' var_parent_filter_id <- 56 # integer | The ID of the parent filter, if not provided then the parent filter will be null (Optional)
#' var_name <- "name_example" # character | The name of the filter (Optional)
#' var_description <- "description_example" # character | The description of the filter (Optional)
#' var_external_id <- "external_id_example" # character | A string identifier used by client applications to store external information (Optional)
#' var_external_type <- "external_type_example" # character | A string type used by client applications to store external information (Optional)
#' var_active <- "active_example" # character | Sets whether the filter is active or inactive (hidden from consumers) (Optional)
#' var_meta_data <- "meta_data_example" # character | external custom client defined data (Optional)
#'
#' #Update Filter
#' api_instance <- FilterApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateFilter(var_account_id, var_filter_id, parent_filter_id = var_parent_filter_id, name = var_name, description = var_description, external_id = var_external_id, external_type = var_external_type, active = var_active, meta_data = var_meta_datadata_file = "result.txt")
#' result <- api_instance$UpdateFilter(var_account_id, var_filter_id, parent_filter_id = var_parent_filter_id, name = var_name, description = var_description, external_id = var_external_id, external_type = var_external_type, active = var_active, meta_data = var_meta_data)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
FilterApi <- R6::R6Class(
  "FilterApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new FilterApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Filter
    #'
    #' @param account_id The account id of the user (must have permissions to the target application)
    #' @param name The name of the filter
    #' @param app_key (optional) The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
    #' @param parent_filter_id (optional) The ID of the parent filter, if not provided then the parent filter will be null
    #' @param description (optional) The description of the filter
    #' @param external_id (optional) A string identifier used by client applications to store external information
    #' @param external_type (optional) A string type used by client applications to store external information
    #' @param active (optional) Sets whether the filter is active or inactive (hidden from consumers)
    #' @param meta_data (optional) external custom client defined data
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return FilterTreeResponse
    CreateFilter = function(account_id, name, app_key = NULL, parent_filter_id = NULL, description = NULL, external_id = NULL, external_type = NULL, active = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateFilterWithHttpInfo(account_id, name, app_key, parent_filter_id, description, external_id, external_type, active, meta_data, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Filter
    #'
    #' @param account_id The account id of the user (must have permissions to the target application)
    #' @param name The name of the filter
    #' @param app_key (optional) The appKey of the application to assign the filter to, if not provided then the filter will be applied to the global application (if the account has permissions)
    #' @param parent_filter_id (optional) The ID of the parent filter, if not provided then the parent filter will be null
    #' @param description (optional) The description of the filter
    #' @param external_id (optional) A string identifier used by client applications to store external information
    #' @param external_type (optional) A string type used by client applications to store external information
    #' @param active (optional) Sets whether the filter is active or inactive (hidden from consumers)
    #' @param meta_data (optional) external custom client defined data
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (FilterTreeResponse) with additional information such as HTTP status code, headers
    CreateFilterWithHttpInfo = function(account_id, name, app_key = NULL, parent_filter_id = NULL, description = NULL, external_id = NULL, external_type = NULL, active = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling FilterApi$CreateFilter, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling FilterApi$CreateFilter, `name` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling FilterApi$CreateFilter, `app_key` is not nullable")
      }

      if (!missing(`parent_filter_id`) && is.null(`parent_filter_id`)) {
        stop("Invalid value for `parent_filter_id` when calling FilterApi$CreateFilter, `parent_filter_id` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling FilterApi$CreateFilter, `description` is not nullable")
      }

      if (!missing(`external_id`) && is.null(`external_id`)) {
        stop("Invalid value for `external_id` when calling FilterApi$CreateFilter, `external_id` is not nullable")
      }

      if (!missing(`external_type`) && is.null(`external_type`)) {
        stop("Invalid value for `external_type` when calling FilterApi$CreateFilter, `external_type` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling FilterApi$CreateFilter, `active` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling FilterApi$CreateFilter, `meta_data` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["parentFilterId"]] <- `parent_filter_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["externalId"]] <- `external_id`

      query_params[["externalType"]] <- `external_type`

      query_params[["active"]] <- `active`

      query_params[["metaData"]] <- `meta_data`

      local_var_url_path <- "/filter/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "FilterTreeResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Filter
    #'
    #' @param account_id The account id of the user (must have permissions to the filter's assigned application)
    #' @param filter_id The ID of the filter to delete
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    DeleteFilter = function(account_id, filter_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteFilterWithHttpInfo(account_id, filter_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Filter
    #'
    #' @param account_id The account id of the user (must have permissions to the filter's assigned application)
    #' @param filter_id The ID of the filter to delete
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    DeleteFilterWithHttpInfo = function(account_id, filter_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`filter_id`)) {
        stop("Missing required parameter `filter_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling FilterApi$DeleteFilter, `account_id` is not nullable")
      }

      if (!missing(`filter_id`) && is.null(`filter_id`)) {
        stop("Invalid value for `filter_id` when calling FilterApi$DeleteFilter, `filter_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["filterId"]] <- `filter_id`

      local_var_url_path <- "/filter/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Filter
    #'
    #' @param filter_id the id of the filter to get
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return FilterTreeResponse
    GetFilter = function(filter_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetFilterWithHttpInfo(filter_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Filter
    #'
    #' @param filter_id the id of the filter to get
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (FilterTreeResponse) with additional information such as HTTP status code, headers
    GetFilterWithHttpInfo = function(filter_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`filter_id`)) {
        stop("Missing required parameter `filter_id`.")
      }

      if (!missing(`filter_id`) && is.null(`filter_id`)) {
        stop("Invalid value for `filter_id` when calling FilterApi$GetFilter, `filter_id` is not nullable")
      }

      query_params[["filterId"]] <- `filter_id`

      local_var_url_path <- "/filter/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "FilterTreeResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Filters
    #'
    #' @param account_id (optional) The account id of the user
    #' @param keyword (optional) The string to search on
    #' @param app_key (optional) the appKey of the application to retrieve filters for
    #' @param response_group (optional) The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
    #' @param root_only (optional) Restrict the search to only those filters with no parent filter assigned.
    #' @param sort_field (optional) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (default value: "DISPLAY")
    #' @param descending (optional) The order to return the search results (default value: FALSE)
    #' @param start (optional) The record to begin the return set on (default value: 0)
    #' @param limit (optional) The number of records to return (default value: 20)
    #' @param active_only (optional) Determines whether to return only active categories (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return array[FilterResponse]
    SearchFilters = function(account_id = NULL, keyword = NULL, app_key = NULL, response_group = NULL, root_only = NULL, sort_field = "DISPLAY", descending = FALSE, start = 0, limit = 20, active_only = TRUE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchFiltersWithHttpInfo(account_id, keyword, app_key, response_group, root_only, sort_field, descending, start, limit, active_only, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Filters
    #'
    #' @param account_id (optional) The account id of the user
    #' @param keyword (optional) The string to search on
    #' @param app_key (optional) the appKey of the application to retrieve filters for
    #' @param response_group (optional) The group of filters to return: ALL, GLOBAL or MINE. ALL returns both global and application specific matches, GLOBAL only returns global matches, and MINE only returns the application specific matches. If not provided search on the application provided.
    #' @param root_only (optional) Restrict the search to only those filters with no parent filter assigned.
    #' @param sort_field (optional) The column to sort the search on. Possible values include: ID, CREATED, UPDATED, ACTIVE, NAME, DISPLAY (default value: "DISPLAY")
    #' @param descending (optional) The order to return the search results (default value: FALSE)
    #' @param start (optional) The record to begin the return set on (default value: 0)
    #' @param limit (optional) The number of records to return (default value: 20)
    #' @param active_only (optional) Determines whether to return only active categories (default value: TRUE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (array[FilterResponse]) with additional information such as HTTP status code, headers
    SearchFiltersWithHttpInfo = function(account_id = NULL, keyword = NULL, app_key = NULL, response_group = NULL, root_only = NULL, sort_field = "DISPLAY", descending = FALSE, start = 0, limit = 20, active_only = TRUE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling FilterApi$SearchFilters, `account_id` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling FilterApi$SearchFilters, `keyword` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling FilterApi$SearchFilters, `app_key` is not nullable")
      }

      if (!missing(`response_group`) && is.null(`response_group`)) {
        stop("Invalid value for `response_group` when calling FilterApi$SearchFilters, `response_group` is not nullable")
      }

      if (!missing(`root_only`) && is.null(`root_only`)) {
        stop("Invalid value for `root_only` when calling FilterApi$SearchFilters, `root_only` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling FilterApi$SearchFilters, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling FilterApi$SearchFilters, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling FilterApi$SearchFilters, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling FilterApi$SearchFilters, `limit` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling FilterApi$SearchFilters, `active_only` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["keyword"]] <- `keyword`

      query_params[["appKey"]] <- `app_key`

      if (!is.null(`response_group`) && !(`response_group` %in% c("ALL", "GLOBAL", "MINE"))) {
        stop("Invalid value for response_group when calling FilterApi$SearchFilters. Must be [ALL, GLOBAL, MINE].")
      }
      query_params[["responseGroup"]] <- `response_group`

      query_params[["rootOnly"]] <- `root_only`

      if (!is.null(`sort_field`) && !(`sort_field` %in% c("ID", "CREATED", "UPDATED", "DELETED", "SEARCH_TAGS", "ACTIVE", "NAME", "DISPLAY"))) {
        stop("Invalid value for sort_field when calling FilterApi$SearchFilters. Must be [ID, CREATED, UPDATED, DELETED, SEARCH_TAGS, ACTIVE, NAME, DISPLAY].")
      }
      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["activeOnly"]] <- `active_only`

      local_var_url_path <- "/filter/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "array[FilterResponse]"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Filter
    #'
    #' @param account_id The account id of the user
    #' @param filter_id The ID of the filter to edit
    #' @param parent_filter_id (optional) The ID of the parent filter, if not provided then the parent filter will be null
    #' @param name (optional) The name of the filter
    #' @param description (optional) The description of the filter
    #' @param external_id (optional) A string identifier used by client applications to store external information
    #' @param external_type (optional) A string type used by client applications to store external information
    #' @param active (optional) Sets whether the filter is active or inactive (hidden from consumers)
    #' @param meta_data (optional) external custom client defined data
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return FilterTreeResponse
    UpdateFilter = function(account_id, filter_id, parent_filter_id = NULL, name = NULL, description = NULL, external_id = NULL, external_type = NULL, active = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateFilterWithHttpInfo(account_id, filter_id, parent_filter_id, name, description, external_id, external_type, active, meta_data, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Filter
    #'
    #' @param account_id The account id of the user
    #' @param filter_id The ID of the filter to edit
    #' @param parent_filter_id (optional) The ID of the parent filter, if not provided then the parent filter will be null
    #' @param name (optional) The name of the filter
    #' @param description (optional) The description of the filter
    #' @param external_id (optional) A string identifier used by client applications to store external information
    #' @param external_type (optional) A string type used by client applications to store external information
    #' @param active (optional) Sets whether the filter is active or inactive (hidden from consumers)
    #' @param meta_data (optional) external custom client defined data
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (FilterTreeResponse) with additional information such as HTTP status code, headers
    UpdateFilterWithHttpInfo = function(account_id, filter_id, parent_filter_id = NULL, name = NULL, description = NULL, external_id = NULL, external_type = NULL, active = NULL, meta_data = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`filter_id`)) {
        stop("Missing required parameter `filter_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling FilterApi$UpdateFilter, `account_id` is not nullable")
      }

      if (!missing(`filter_id`) && is.null(`filter_id`)) {
        stop("Invalid value for `filter_id` when calling FilterApi$UpdateFilter, `filter_id` is not nullable")
      }

      if (!missing(`parent_filter_id`) && is.null(`parent_filter_id`)) {
        stop("Invalid value for `parent_filter_id` when calling FilterApi$UpdateFilter, `parent_filter_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling FilterApi$UpdateFilter, `name` is not nullable")
      }

      if (!missing(`description`) && is.null(`description`)) {
        stop("Invalid value for `description` when calling FilterApi$UpdateFilter, `description` is not nullable")
      }

      if (!missing(`external_id`) && is.null(`external_id`)) {
        stop("Invalid value for `external_id` when calling FilterApi$UpdateFilter, `external_id` is not nullable")
      }

      if (!missing(`external_type`) && is.null(`external_type`)) {
        stop("Invalid value for `external_type` when calling FilterApi$UpdateFilter, `external_type` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling FilterApi$UpdateFilter, `active` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling FilterApi$UpdateFilter, `meta_data` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["filterId"]] <- `filter_id`

      query_params[["parentFilterId"]] <- `parent_filter_id`

      query_params[["name"]] <- `name`

      query_params[["description"]] <- `description`

      query_params[["externalId"]] <- `external_id`

      query_params[["externalType"]] <- `external_type`

      query_params[["active"]] <- `active`

      query_params[["metaData"]] <- `meta_data`

      local_var_url_path <- "/filter/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "FilterTreeResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
