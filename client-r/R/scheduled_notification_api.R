#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title ScheduledNotification operations
#' @description ScheduledNotificationApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  CreateScheduledNotification  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_name <- "name_example" # character | The name of the scheduled notification
#' var_type <- "type_example" # character | The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
#' var_message <- "message_example" # character | The message to send
#' var_content_id <- 56 # integer | The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_content_name <- "content_name_example" # character | The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_content_type <- "content_type_example" # character | The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_parent_id <- 56 # integer | The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_parent_type <- "parent_type_example" # character | The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_app_key <- "app_key_example" # character | The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (Optional)
#' var_grouping_id <- "grouping_id_example" # character | Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (Optional)
#' var_connection_group_ids <- "connection_group_ids_example" # character | The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (Optional)
#' var_audience_id <- 56 # integer | This parameter is deprecated. The audience used to generate the list of recipients (Optional)
#' var_audience_ids <- "audience_ids_example" # character | The audiences used to generate the list of recipients (comma separated list of audience IDs) (Optional)
#' var_album_ids <- "album_ids_example" # character | The album ids to associate with the scheduled notification (comma separated list of album IDs) (Optional)
#' var_report_id <- 56 # integer | The report used to generate the the list of recipients (Optional)
#' var_report_params <- "report_params_example" # character | The parameters to supply to the report used to generate the the list of recipients (Optional)
#' var_endpoint_url <- "endpoint_url_example" # character | The URL for making an HTTP call (Optional)
#' var_payload <- "payload_example" # character | The parameters for making an HTTP call (Optional)
#' var_scheduled_date <- 56 # integer | The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (Optional)
#' var_start_date <- 56 # integer | The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (Optional)
#' var_end_date <- 56 # integer | The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (Optional)
#' var_cron_expression <- "cron_expression_example" # character | The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (Optional)
#' var_cron_type <- "cron_type_example" # character | The cron expression type: UNIX, CRON4J, QUARTZ (Optional)
#' var_meta_data <- "meta_data_example" # character | Additional metadata for the scheduled notification (Optional)
#' var_conditional_input <- "conditional_input_example" # character | Json input representing conditional logic that has to be met before running the scheduled notification (Optional)
#' var_template_type <- "template_type_example" # character | This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (Optional)
#' var_visibility <- "visibility_example" # character | Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (Optional)
#' var_active <- "active_example" # character | Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'. (Optional)
#' var_send_now <- "send_now_example" # character |  (Optional)
#' var_event_type <- "CUSTOM" # character | Sets the event type for the notification (Optional)
#' var_deep_link_uri <- "deep_link_uri_example" # character | The payload deep link URI that can be used by the client app to direct users to a screen in the app (Optional)
#' var_send_to_all <- "send_to_all_example" # character | Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (Optional)
#'
#' #Create Scheduled Notification
#' api_instance <- ScheduledNotificationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$CreateScheduledNotification(var_account_id, var_name, var_type, var_message, content_id = var_content_id, content_name = var_content_name, content_type = var_content_type, parent_id = var_parent_id, parent_type = var_parent_type, app_key = var_app_key, grouping_id = var_grouping_id, connection_group_ids = var_connection_group_ids, connection_account_ids = var_connection_account_ids, audience_id = var_audience_id, audience_ids = var_audience_ids, album_ids = var_album_ids, report_id = var_report_id, report_params = var_report_params, endpoint_url = var_endpoint_url, payload = var_payload, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, cron_type = var_cron_type, meta_data = var_meta_data, conditional_input = var_conditional_input, template_type = var_template_type, visibility = var_visibility, active = var_active, send_now = var_send_now, event_type = var_event_type, deep_link_uri = var_deep_link_uri, send_to_all = var_send_to_alldata_file = "result.txt")
#' result <- api_instance$CreateScheduledNotification(var_account_id, var_name, var_type, var_message, content_id = var_content_id, content_name = var_content_name, content_type = var_content_type, parent_id = var_parent_id, parent_type = var_parent_type, app_key = var_app_key, grouping_id = var_grouping_id, connection_group_ids = var_connection_group_ids, connection_account_ids = var_connection_account_ids, audience_id = var_audience_id, audience_ids = var_audience_ids, album_ids = var_album_ids, report_id = var_report_id, report_params = var_report_params, endpoint_url = var_endpoint_url, payload = var_payload, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, cron_type = var_cron_type, meta_data = var_meta_data, conditional_input = var_conditional_input, template_type = var_template_type, visibility = var_visibility, active = var_active, send_now = var_send_now, event_type = var_event_type, deep_link_uri = var_deep_link_uri, send_to_all = var_send_to_all)
#' dput(result)
#'
#'
#' ####################  DeleteScheduledNotification  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the id of the logged in user
#' var_scheduled_notification_id <- 56 # integer | the id of the scheduled notification to delete
#' var_delete_by_grouping_id <- "delete_by_grouping_id_example" # character | If set to true, also deletes Scheduled Notifications under the same account with the same groupingId. (Optional)
#'
#' #Delete Scheduled Notification
#' api_instance <- ScheduledNotificationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$DeleteScheduledNotification(var_account_id, var_scheduled_notification_id, delete_by_grouping_id = var_delete_by_grouping_iddata_file = "result.txt")
#' result <- api_instance$DeleteScheduledNotification(var_account_id, var_scheduled_notification_id, delete_by_grouping_id = var_delete_by_grouping_id)
#' dput(result)
#'
#'
#' ####################  GetScheduledNotification  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the id of the account logged in
#' var_scheduled_notification_id <- 56 # integer | the id of the scheduled notification to get
#'
#' #Get Scheduled Notification
#' api_instance <- ScheduledNotificationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetScheduledNotification(var_account_id, var_scheduled_notification_iddata_file = "result.txt")
#' result <- api_instance$GetScheduledNotification(var_account_id, var_scheduled_notification_id)
#' dput(result)
#'
#'
#' ####################  ScheduleNotificationListings  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_app_key <- "app_key_example" # character | The application to target
#' var_report_name <- "report_name_example" # character | The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
#' var_message <- "message_example" # character | The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
#' var_offset <- 56 # integer | Time in munites before the event starts to notify recipients
#' var_recipient_report_id <- 56 # integer | The report id used to generate the recipient list
#' var_report_params <- "report_params_example" # character | The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ```  (Optional)
#' var_type <- "type_example" # character | The type of scheduled notification; supported values are: MOBILE_NOTIFICATION (Optional)
#'
#' #Generate Schedule Notifications
#' api_instance <- ScheduledNotificationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$ScheduleNotificationListings(var_account_id, var_app_key, var_report_name, var_message, var_offset, var_recipient_report_id, report_params = var_report_params, type = var_typedata_file = "result.txt")
#' result <- api_instance$ScheduleNotificationListings(var_account_id, var_app_key, var_report_name, var_message, var_offset, var_recipient_report_id, report_params = var_report_params, type = var_type)
#' dput(result)
#'
#'
#' ####################  SearchScheduledNotifications  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | The logged in user.
#' var_grouping_id <- "grouping_id_example" # character | Filter results by a grouping identifier defined by the client (Optional)
#' var_audience_id <- 56 # integer | Filter results by audience (Optional)
#' var_filter <- "filter_example" # character | a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications. (Optional)
#' var_types <- "types_example" # character | Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION (Optional)
#' var_content_ids <- "content_ids_example" # character | search using content IDs (Optional)
#' var_content_types <- "content_types_example" # character | search using content types (Optional)
#' var_parent_ids <- "parent_ids_example" # character | search using parent IDs (Optional)
#' var_parent_types <- "parent_types_example" # character | search using parent types (Optional)
#' var_statuses <- "statuses_example" # character | Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending (Optional)
#' var_template_types <- "template_types_example" # character |  (Optional)
#' var_app_key <- "app_key_example" # character | Filter the list by a specific application (Optional)
#' var_keyword <- "keyword_example" # character | Keyword search on the scheduled notification names. (Optional)
#' var_sort_field <- "sort_field_example" # character | The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date (Optional)
#' var_descending <- "descending_example" # character | Determines whether the sorted list is in descending or ascending order (Optional)
#' var_start <- 56 # integer | Start the result set at some index. (Optional)
#' var_limit <- 56 # integer | Limit the result to some number. (Optional)
#' var_active_only <- "active_only_example" # character | Determines whether to return only active results (Optional)
#' var_group_by_grouping_id <- "group_by_grouping_id_example" # character | Determines whether to group results with the same groupingId together. (Optional)
#' var_return_audience_account_count <- "return_audience_account_count_example" # character | If true, include audience account counts in the response (Optional)
#'
#' #Search Scheduled Notifications
#' api_instance <- ScheduledNotificationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$SearchScheduledNotifications(var_account_id, grouping_id = var_grouping_id, audience_id = var_audience_id, filter = var_filter, types = var_types, content_ids = var_content_ids, content_types = var_content_types, parent_ids = var_parent_ids, parent_types = var_parent_types, statuses = var_statuses, template_types = var_template_types, app_key = var_app_key, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_only, group_by_grouping_id = var_group_by_grouping_id, return_audience_account_count = var_return_audience_account_countdata_file = "result.txt")
#' result <- api_instance$SearchScheduledNotifications(var_account_id, grouping_id = var_grouping_id, audience_id = var_audience_id, filter = var_filter, types = var_types, content_ids = var_content_ids, content_types = var_content_types, parent_ids = var_parent_ids, parent_types = var_parent_types, statuses = var_statuses, template_types = var_template_types, app_key = var_app_key, keyword = var_keyword, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit, active_only = var_active_only, group_by_grouping_id = var_group_by_grouping_id, return_audience_account_count = var_return_audience_account_count)
#' dput(result)
#'
#'
#' ####################  UpdateScheduledNotification  ####################
#'
#' library(openapi)
#' var_scheduled_notification_id <- 56 # integer | The id of scheduled notification to update
#' var_account_id <- 56 # integer | The logged in user.
#' var_name <- "name_example" # character | The name of the scheduled notification (Optional)
#' var_type <- "type_example" # character | The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages (Optional)
#' var_message <- "message_example" # character | The message to send (Optional)
#' var_payload <- "payload_example" # character | The parameters for making an HTTP call (Optional)
#' var_content_id <- 56 # integer | The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_content_name <- "content_name_example" # character | The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_content_type <- "content_type_example" # character | The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_parent_id <- 56 # integer | The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_parent_type <- "parent_type_example" # character | The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view. (Optional)
#' var_app_key <- "app_key_example" # character | The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type. (Optional)
#' var_grouping_id <- "grouping_id_example" # character | Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature. (Optional)
#' var_connection_group_ids <- "connection_group_ids_example" # character | The connection groups to use to generate the list of recipients (comma separated list of connection group IDs) (Optional)
#' var_connection_account_ids <- "connection_account_ids_example" # character | The connection accounts to use to generate the list of recipients (comma separated list of user account ids) (Optional)
#' var_audience_id <- 56 # integer | This parameter is deprecated. The audience used to generate the list of recipients (Optional)
#' var_audience_ids <- "audience_ids_example" # character | The audiences used to generate the list of recipients (comma separated list of audience IDs) (Optional)
#' var_album_ids <- "album_ids_example" # character | The album ids to associate with the scheduled notification (comma separated list of album IDs) (Optional)
#' var_report_id <- 56 # integer | The report used to generate the the list of recipients (Optional)
#' var_report_params <- "report_params_example" # character | The parameters to supply to the report used to generate the the list of recipients (Optional)
#' var_endpoint_url <- "endpoint_url_example" # character | The URL for making an HTTP call (Optional)
#' var_scheduled_date <- 56 # integer | The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used. (Optional)
#' var_start_date <- 56 # integer | The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now. (Optional)
#' var_end_date <- 56 # integer | The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date. (Optional)
#' var_cron_expression <- "cron_expression_example" # character | The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC. (Optional)
#' var_cron_type <- "cron_type_example" # character | The cron expression type: UNIX, CRON4J, QUARTZ (Optional)
#' var_meta_data <- "meta_data_example" # character | Additional metadata for the scheduled notification (Optional)
#' var_conditional_input <- "conditional_input_example" # character | Json input representing conditional logic that has to be met before running the scheduled notification (Optional)
#' var_template_type <- "template_type_example" # character | This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered (Optional)
#' var_visibility <- "visibility_example" # character | Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited) (Optional)
#' var_active <- "active_example" # character | Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. (Optional)
#' var_error_message <- "error_message_example" # character | the error message associated with the scheduled notification (Optional)
#' var_status <- "status_example" # character | the status of the scheduled notification (Optional)
#' var_update_by_grouping_id <- "update_by_grouping_id_example" # character | also updates ScheduledNotifications with the same groupingId and account (Optional)
#' var_send_now <- "send_now_example" # character | whether to send the scheduled notification now or not (Optional)
#' var_event_type <- "CUSTOM" # character | Sets the event type for the notification (Optional)
#' var_deep_link_uri <- "deep_link_uri_example" # character | The payload deep link URI that can be used by the client app to direct users to a screen in the app (Optional)
#' var_send_to_all <- "send_to_all_example" # character | Determines whether to send to all users of the app if set to true for push notifications (appKey is required) (Optional)
#'
#' #Update Scheduled Notification
#' api_instance <- ScheduledNotificationApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateScheduledNotification(var_scheduled_notification_id, var_account_id, name = var_name, type = var_type, message = var_message, payload = var_payload, content_id = var_content_id, content_name = var_content_name, content_type = var_content_type, parent_id = var_parent_id, parent_type = var_parent_type, app_key = var_app_key, grouping_id = var_grouping_id, connection_group_ids = var_connection_group_ids, connection_account_ids = var_connection_account_ids, audience_id = var_audience_id, audience_ids = var_audience_ids, album_ids = var_album_ids, report_id = var_report_id, report_params = var_report_params, endpoint_url = var_endpoint_url, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, cron_type = var_cron_type, meta_data = var_meta_data, conditional_input = var_conditional_input, template_type = var_template_type, visibility = var_visibility, active = var_active, error_message = var_error_message, status = var_status, update_by_grouping_id = var_update_by_grouping_id, send_now = var_send_now, event_type = var_event_type, deep_link_uri = var_deep_link_uri, send_to_all = var_send_to_alldata_file = "result.txt")
#' result <- api_instance$UpdateScheduledNotification(var_scheduled_notification_id, var_account_id, name = var_name, type = var_type, message = var_message, payload = var_payload, content_id = var_content_id, content_name = var_content_name, content_type = var_content_type, parent_id = var_parent_id, parent_type = var_parent_type, app_key = var_app_key, grouping_id = var_grouping_id, connection_group_ids = var_connection_group_ids, connection_account_ids = var_connection_account_ids, audience_id = var_audience_id, audience_ids = var_audience_ids, album_ids = var_album_ids, report_id = var_report_id, report_params = var_report_params, endpoint_url = var_endpoint_url, scheduled_date = var_scheduled_date, start_date = var_start_date, end_date = var_end_date, cron_expression = var_cron_expression, cron_type = var_cron_type, meta_data = var_meta_data, conditional_input = var_conditional_input, template_type = var_template_type, visibility = var_visibility, active = var_active, error_message = var_error_message, status = var_status, update_by_grouping_id = var_update_by_grouping_id, send_now = var_send_now, event_type = var_event_type, deep_link_uri = var_deep_link_uri, send_to_all = var_send_to_all)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
ScheduledNotificationApi <- R6::R6Class(
  "ScheduledNotificationApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new ScheduledNotificationApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Create Scheduled Notification
    #'
    #' @param account_id The logged in user.
    #' @param name The name of the scheduled notification
    #' @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    #' @param message The message to send
    #' @param content_id (optional) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_name (optional) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_type (optional) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_id (optional) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_type (optional) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param app_key (optional) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    #' @param grouping_id (optional) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    #' @param connection_group_ids (optional) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    #' @param connection_account_ids (optional) The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    #' @param audience_id (optional) This parameter is deprecated. The audience used to generate the list of recipients
    #' @param audience_ids (optional) The audiences used to generate the list of recipients (comma separated list of audience IDs)
    #' @param album_ids (optional) The album ids to associate with the scheduled notification (comma separated list of album IDs)
    #' @param report_id (optional) The report used to generate the the list of recipients
    #' @param report_params (optional) The parameters to supply to the report used to generate the the list of recipients
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param scheduled_date (optional) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    #' @param start_date (optional) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    #' @param end_date (optional) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    #' @param cron_expression (optional) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    #' @param cron_type (optional) The cron expression type: UNIX, CRON4J, QUARTZ
    #' @param meta_data (optional) Additional metadata for the scheduled notification
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the scheduled notification
    #' @param template_type (optional) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    #' @param visibility (optional) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
    #' @param send_now (optional) 
    #' @param event_type (optional) Sets the event type for the notification (default value: "CUSTOM")
    #' @param deep_link_uri (optional) The payload deep link URI that can be used by the client app to direct users to a screen in the app
    #' @param send_to_all (optional) Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ScheduledNotificationFullResponse
    CreateScheduledNotification = function(account_id, name, type, message, content_id = NULL, content_name = NULL, content_type = NULL, parent_id = NULL, parent_type = NULL, app_key = NULL, grouping_id = NULL, connection_group_ids = NULL, connection_account_ids = NULL, audience_id = NULL, audience_ids = NULL, album_ids = NULL, report_id = NULL, report_params = NULL, endpoint_url = NULL, payload = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, cron_type = NULL, meta_data = NULL, conditional_input = NULL, template_type = NULL, visibility = NULL, active = NULL, send_now = NULL, event_type = "CUSTOM", deep_link_uri = NULL, send_to_all = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$CreateScheduledNotificationWithHttpInfo(account_id, name, type, message, content_id, content_name, content_type, parent_id, parent_type, app_key, grouping_id, connection_group_ids, connection_account_ids, audience_id, audience_ids, album_ids, report_id, report_params, endpoint_url, payload, scheduled_date, start_date, end_date, cron_expression, cron_type, meta_data, conditional_input, template_type, visibility, active, send_now, event_type, deep_link_uri, send_to_all, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Create Scheduled Notification
    #'
    #' @param account_id The logged in user.
    #' @param name The name of the scheduled notification
    #' @param type The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    #' @param message The message to send
    #' @param content_id (optional) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_name (optional) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_type (optional) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_id (optional) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_type (optional) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param app_key (optional) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    #' @param grouping_id (optional) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    #' @param connection_group_ids (optional) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    #' @param connection_account_ids (optional) The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    #' @param audience_id (optional) This parameter is deprecated. The audience used to generate the list of recipients
    #' @param audience_ids (optional) The audiences used to generate the list of recipients (comma separated list of audience IDs)
    #' @param album_ids (optional) The album ids to associate with the scheduled notification (comma separated list of album IDs)
    #' @param report_id (optional) The report used to generate the the list of recipients
    #' @param report_params (optional) The parameters to supply to the report used to generate the the list of recipients
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param scheduled_date (optional) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    #' @param start_date (optional) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    #' @param end_date (optional) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    #' @param cron_expression (optional) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    #' @param cron_type (optional) The cron expression type: UNIX, CRON4J, QUARTZ
    #' @param meta_data (optional) Additional metadata for the scheduled notification
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the scheduled notification
    #' @param template_type (optional) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    #' @param visibility (optional) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule. The default value is 'true'.
    #' @param send_now (optional) 
    #' @param event_type (optional) Sets the event type for the notification (default value: "CUSTOM")
    #' @param deep_link_uri (optional) The payload deep link URI that can be used by the client app to direct users to a screen in the app
    #' @param send_to_all (optional) Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ScheduledNotificationFullResponse) with additional information such as HTTP status code, headers
    CreateScheduledNotificationWithHttpInfo = function(account_id, name, type, message, content_id = NULL, content_name = NULL, content_type = NULL, parent_id = NULL, parent_type = NULL, app_key = NULL, grouping_id = NULL, connection_group_ids = NULL, connection_account_ids = NULL, audience_id = NULL, audience_ids = NULL, album_ids = NULL, report_id = NULL, report_params = NULL, endpoint_url = NULL, payload = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, cron_type = NULL, meta_data = NULL, conditional_input = NULL, template_type = NULL, visibility = NULL, active = NULL, send_now = NULL, event_type = "CUSTOM", deep_link_uri = NULL, send_to_all = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`name`)) {
        stop("Missing required parameter `name`.")
      }

      if (missing(`type`)) {
        stop("Missing required parameter `type`.")
      }

      if (missing(`message`)) {
        stop("Missing required parameter `message`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ScheduledNotificationApi$CreateScheduledNotification, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling ScheduledNotificationApi$CreateScheduledNotification, `name` is not nullable")
      }

      if (!missing(`type`) && is.null(`type`)) {
        stop("Invalid value for `type` when calling ScheduledNotificationApi$CreateScheduledNotification, `type` is not nullable")
      }

      if (!missing(`message`) && is.null(`message`)) {
        stop("Invalid value for `message` when calling ScheduledNotificationApi$CreateScheduledNotification, `message` is not nullable")
      }

      if (!missing(`content_id`) && is.null(`content_id`)) {
        stop("Invalid value for `content_id` when calling ScheduledNotificationApi$CreateScheduledNotification, `content_id` is not nullable")
      }

      if (!missing(`content_name`) && is.null(`content_name`)) {
        stop("Invalid value for `content_name` when calling ScheduledNotificationApi$CreateScheduledNotification, `content_name` is not nullable")
      }

      if (!missing(`content_type`) && is.null(`content_type`)) {
        stop("Invalid value for `content_type` when calling ScheduledNotificationApi$CreateScheduledNotification, `content_type` is not nullable")
      }

      if (!missing(`parent_id`) && is.null(`parent_id`)) {
        stop("Invalid value for `parent_id` when calling ScheduledNotificationApi$CreateScheduledNotification, `parent_id` is not nullable")
      }

      if (!missing(`parent_type`) && is.null(`parent_type`)) {
        stop("Invalid value for `parent_type` when calling ScheduledNotificationApi$CreateScheduledNotification, `parent_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ScheduledNotificationApi$CreateScheduledNotification, `app_key` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling ScheduledNotificationApi$CreateScheduledNotification, `grouping_id` is not nullable")
      }

      if (!missing(`connection_group_ids`) && is.null(`connection_group_ids`)) {
        stop("Invalid value for `connection_group_ids` when calling ScheduledNotificationApi$CreateScheduledNotification, `connection_group_ids` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling ScheduledNotificationApi$CreateScheduledNotification, `connection_account_ids` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling ScheduledNotificationApi$CreateScheduledNotification, `audience_id` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling ScheduledNotificationApi$CreateScheduledNotification, `audience_ids` is not nullable")
      }

      if (!missing(`album_ids`) && is.null(`album_ids`)) {
        stop("Invalid value for `album_ids` when calling ScheduledNotificationApi$CreateScheduledNotification, `album_ids` is not nullable")
      }

      if (!missing(`report_id`) && is.null(`report_id`)) {
        stop("Invalid value for `report_id` when calling ScheduledNotificationApi$CreateScheduledNotification, `report_id` is not nullable")
      }

      if (!missing(`report_params`) && is.null(`report_params`)) {
        stop("Invalid value for `report_params` when calling ScheduledNotificationApi$CreateScheduledNotification, `report_params` is not nullable")
      }

      if (!missing(`endpoint_url`) && is.null(`endpoint_url`)) {
        stop("Invalid value for `endpoint_url` when calling ScheduledNotificationApi$CreateScheduledNotification, `endpoint_url` is not nullable")
      }

      if (!missing(`payload`) && is.null(`payload`)) {
        stop("Invalid value for `payload` when calling ScheduledNotificationApi$CreateScheduledNotification, `payload` is not nullable")
      }

      if (!missing(`scheduled_date`) && is.null(`scheduled_date`)) {
        stop("Invalid value for `scheduled_date` when calling ScheduledNotificationApi$CreateScheduledNotification, `scheduled_date` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling ScheduledNotificationApi$CreateScheduledNotification, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling ScheduledNotificationApi$CreateScheduledNotification, `end_date` is not nullable")
      }

      if (!missing(`cron_expression`) && is.null(`cron_expression`)) {
        stop("Invalid value for `cron_expression` when calling ScheduledNotificationApi$CreateScheduledNotification, `cron_expression` is not nullable")
      }

      if (!missing(`cron_type`) && is.null(`cron_type`)) {
        stop("Invalid value for `cron_type` when calling ScheduledNotificationApi$CreateScheduledNotification, `cron_type` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling ScheduledNotificationApi$CreateScheduledNotification, `meta_data` is not nullable")
      }

      if (!missing(`conditional_input`) && is.null(`conditional_input`)) {
        stop("Invalid value for `conditional_input` when calling ScheduledNotificationApi$CreateScheduledNotification, `conditional_input` is not nullable")
      }

      if (!missing(`template_type`) && is.null(`template_type`)) {
        stop("Invalid value for `template_type` when calling ScheduledNotificationApi$CreateScheduledNotification, `template_type` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling ScheduledNotificationApi$CreateScheduledNotification, `visibility` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling ScheduledNotificationApi$CreateScheduledNotification, `active` is not nullable")
      }

      if (!missing(`send_now`) && is.null(`send_now`)) {
        stop("Invalid value for `send_now` when calling ScheduledNotificationApi$CreateScheduledNotification, `send_now` is not nullable")
      }

      if (!missing(`event_type`) && is.null(`event_type`)) {
        stop("Invalid value for `event_type` when calling ScheduledNotificationApi$CreateScheduledNotification, `event_type` is not nullable")
      }

      if (!missing(`deep_link_uri`) && is.null(`deep_link_uri`)) {
        stop("Invalid value for `deep_link_uri` when calling ScheduledNotificationApi$CreateScheduledNotification, `deep_link_uri` is not nullable")
      }

      if (!missing(`send_to_all`) && is.null(`send_to_all`)) {
        stop("Invalid value for `send_to_all` when calling ScheduledNotificationApi$CreateScheduledNotification, `send_to_all` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["type"]] <- `type`

      query_params[["message"]] <- `message`

      query_params[["contentId"]] <- `content_id`

      query_params[["contentName"]] <- `content_name`

      query_params[["contentType"]] <- `content_type`

      query_params[["parentId"]] <- `parent_id`

      query_params[["parentType"]] <- `parent_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["connectionGroupIds"]] <- `connection_group_ids`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      query_params[["audienceId"]] <- `audience_id`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["albumIds"]] <- `album_ids`

      query_params[["reportId"]] <- `report_id`

      query_params[["reportParams"]] <- `report_params`

      query_params[["endpointURL"]] <- `endpoint_url`

      query_params[["payload"]] <- `payload`

      query_params[["scheduledDate"]] <- `scheduled_date`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["cronExpression"]] <- `cron_expression`

      query_params[["cronType"]] <- `cron_type`

      query_params[["metaData"]] <- `meta_data`

      query_params[["conditionalInput"]] <- `conditional_input`

      query_params[["templateType"]] <- `template_type`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling ScheduledNotificationApi$CreateScheduledNotification. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["active"]] <- `active`

      query_params[["sendNow"]] <- `send_now`

      query_params[["eventType"]] <- `event_type`

      query_params[["deepLinkURI"]] <- `deep_link_uri`

      query_params[["sendToAll"]] <- `send_to_all`

      local_var_url_path <- "/notification/schedule/create"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ScheduledNotificationFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Delete Scheduled Notification
    #'
    #' @param account_id the id of the logged in user
    #' @param scheduled_notification_id the id of the scheduled notification to delete
    #' @param delete_by_grouping_id (optional) If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ScheduledNotificationFullResponse
    DeleteScheduledNotification = function(account_id, scheduled_notification_id, delete_by_grouping_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$DeleteScheduledNotificationWithHttpInfo(account_id, scheduled_notification_id, delete_by_grouping_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Delete Scheduled Notification
    #'
    #' @param account_id the id of the logged in user
    #' @param scheduled_notification_id the id of the scheduled notification to delete
    #' @param delete_by_grouping_id (optional) If set to true, also deletes Scheduled Notifications under the same account with the same groupingId.
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ScheduledNotificationFullResponse) with additional information such as HTTP status code, headers
    DeleteScheduledNotificationWithHttpInfo = function(account_id, scheduled_notification_id, delete_by_grouping_id = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`scheduled_notification_id`)) {
        stop("Missing required parameter `scheduled_notification_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ScheduledNotificationApi$DeleteScheduledNotification, `account_id` is not nullable")
      }

      if (!missing(`scheduled_notification_id`) && is.null(`scheduled_notification_id`)) {
        stop("Invalid value for `scheduled_notification_id` when calling ScheduledNotificationApi$DeleteScheduledNotification, `scheduled_notification_id` is not nullable")
      }

      if (!missing(`delete_by_grouping_id`) && is.null(`delete_by_grouping_id`)) {
        stop("Invalid value for `delete_by_grouping_id` when calling ScheduledNotificationApi$DeleteScheduledNotification, `delete_by_grouping_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["scheduledNotificationId"]] <- `scheduled_notification_id`

      query_params[["deleteByGroupingId"]] <- `delete_by_grouping_id`

      local_var_url_path <- "/notification/schedule/delete"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ScheduledNotificationFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Scheduled Notification
    #'
    #' @param account_id the id of the account logged in
    #' @param scheduled_notification_id the id of the scheduled notification to get
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ScheduledNotificationFullResponse
    GetScheduledNotification = function(account_id, scheduled_notification_id, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetScheduledNotificationWithHttpInfo(account_id, scheduled_notification_id, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Scheduled Notification
    #'
    #' @param account_id the id of the account logged in
    #' @param scheduled_notification_id the id of the scheduled notification to get
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ScheduledNotificationFullResponse) with additional information such as HTTP status code, headers
    GetScheduledNotificationWithHttpInfo = function(account_id, scheduled_notification_id, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`scheduled_notification_id`)) {
        stop("Missing required parameter `scheduled_notification_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ScheduledNotificationApi$GetScheduledNotification, `account_id` is not nullable")
      }

      if (!missing(`scheduled_notification_id`) && is.null(`scheduled_notification_id`)) {
        stop("Invalid value for `scheduled_notification_id` when calling ScheduledNotificationApi$GetScheduledNotification, `scheduled_notification_id` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["scheduledNotificationId"]] <- `scheduled_notification_id`

      local_var_url_path <- "/notification/schedule/get"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ScheduledNotificationFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Generate Schedule Notifications
    #'
    #' @param account_id The logged in user.
    #' @param app_key The application to target
    #' @param report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
    #' @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
    #' @param offset Time in munites before the event starts to notify recipients
    #' @param recipient_report_id The report id used to generate the recipient list
    #' @param report_params (optional) The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
    #' @param type (optional) The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    ScheduleNotificationListings = function(account_id, app_key, report_name, message, offset, recipient_report_id, report_params = NULL, type = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$ScheduleNotificationListingsWithHttpInfo(account_id, app_key, report_name, message, offset, recipient_report_id, report_params, type, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Generate Schedule Notifications
    #'
    #' @param account_id The logged in user.
    #' @param app_key The application to target
    #' @param report_name The name of the report used to identify events. The report must return columns named: id, name, date, params, and type otherwise it will fail
    #' @param message The message to be sent to the recipients. If you set %name% the report row name value will be swapped in. If you set %time% or %date% the report row start date/time value will be swapped in
    #' @param offset Time in munites before the event starts to notify recipients
    #' @param recipient_report_id The report id used to generate the recipient list
    #' @param report_params (optional) The parameters of the report used to identify events in a json structure, example: ```json {   \"string\": \"value\",   \"number\": 3.345,   \"date\": \"2014-05-01 00:00:00\" } ``` 
    #' @param type (optional) The type of scheduled notification; supported values are: MOBILE_NOTIFICATION
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    ScheduleNotificationListingsWithHttpInfo = function(account_id, app_key, report_name, message, offset, recipient_report_id, report_params = NULL, type = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`report_name`)) {
        stop("Missing required parameter `report_name`.")
      }

      if (missing(`message`)) {
        stop("Missing required parameter `message`.")
      }

      if (missing(`offset`)) {
        stop("Missing required parameter `offset`.")
      }

      if (missing(`recipient_report_id`)) {
        stop("Missing required parameter `recipient_report_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ScheduledNotificationApi$ScheduleNotificationListings, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ScheduledNotificationApi$ScheduleNotificationListings, `app_key` is not nullable")
      }

      if (!missing(`report_name`) && is.null(`report_name`)) {
        stop("Invalid value for `report_name` when calling ScheduledNotificationApi$ScheduleNotificationListings, `report_name` is not nullable")
      }

      if (!missing(`message`) && is.null(`message`)) {
        stop("Invalid value for `message` when calling ScheduledNotificationApi$ScheduleNotificationListings, `message` is not nullable")
      }

      if (!missing(`offset`) && is.null(`offset`)) {
        stop("Invalid value for `offset` when calling ScheduledNotificationApi$ScheduleNotificationListings, `offset` is not nullable")
      }

      if (!missing(`recipient_report_id`) && is.null(`recipient_report_id`)) {
        stop("Invalid value for `recipient_report_id` when calling ScheduledNotificationApi$ScheduleNotificationListings, `recipient_report_id` is not nullable")
      }

      if (!missing(`report_params`) && is.null(`report_params`)) {
        stop("Invalid value for `report_params` when calling ScheduledNotificationApi$ScheduleNotificationListings, `report_params` is not nullable")
      }

      if (!missing(`type`) && is.null(`type`)) {
        stop("Invalid value for `type` when calling ScheduledNotificationApi$ScheduleNotificationListings, `type` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["reportName"]] <- `report_name`

      query_params[["reportParams"]] <- `report_params`

      query_params[["message"]] <- `message`

      query_params[["offset"]] <- `offset`

      query_params[["type"]] <- `type`

      query_params[["recipientReportId"]] <- `recipient_report_id`

      local_var_url_path <- "/notification/schedule/generate"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Scheduled Notifications
    #'
    #' @param account_id The logged in user.
    #' @param grouping_id (optional) Filter results by a grouping identifier defined by the client
    #' @param audience_id (optional) Filter results by audience
    #' @param filter (optional) a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
    #' @param types (optional) Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
    #' @param content_ids (optional) search using content IDs
    #' @param content_types (optional) search using content types
    #' @param parent_ids (optional) search using parent IDs
    #' @param parent_types (optional) search using parent types
    #' @param statuses (optional) Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
    #' @param template_types (optional) 
    #' @param app_key (optional) Filter the list by a specific application
    #' @param keyword (optional) Keyword search on the scheduled notification names.
    #' @param sort_field (optional) The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order
    #' @param start (optional) Start the result set at some index.
    #' @param limit (optional) Limit the result to some number.
    #' @param active_only (optional) Determines whether to return only active results
    #' @param group_by_grouping_id (optional) Determines whether to group results with the same groupingId together.
    #' @param return_audience_account_count (optional) If true, include audience account counts in the response
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ScheduledNotificationFullResponse
    SearchScheduledNotifications = function(account_id, grouping_id = NULL, audience_id = NULL, filter = NULL, types = NULL, content_ids = NULL, content_types = NULL, parent_ids = NULL, parent_types = NULL, statuses = NULL, template_types = NULL, app_key = NULL, keyword = NULL, sort_field = NULL, descending = NULL, start = NULL, limit = NULL, active_only = NULL, group_by_grouping_id = NULL, return_audience_account_count = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$SearchScheduledNotificationsWithHttpInfo(account_id, grouping_id, audience_id, filter, types, content_ids, content_types, parent_ids, parent_types, statuses, template_types, app_key, keyword, sort_field, descending, start, limit, active_only, group_by_grouping_id, return_audience_account_count, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Scheduled Notifications
    #'
    #' @param account_id The logged in user.
    #' @param grouping_id (optional) Filter results by a grouping identifier defined by the client
    #' @param audience_id (optional) Filter results by audience
    #' @param filter (optional) a comma separated list of filters: MINE - Return scheduled notifications that the user has created. SHARED - Return scheduled notifications that have been shared to the user via addUsersToPermissionable. FOLLOWER - Return scheduled notifications that have been created by the users followers (the content needs to have been APPROVED or FEATURED). FOLLOWING - Return scheduled notifications that have been created by people who the user is following (the content needs to have been APPROVED or FEATURED). PUBLIC - Return all PUBLIC scheduled notifications that have been APPROVED or FEATURED. ALL_PUBLIC - Return all PUBLIC scheduled notifications regardless of whether they are approved or not (ignores the approval status). LIKED - Return all scheduled notifications that the user has liked. FEATURED - Return all scheduled notifications that have been featured. PENDING - Return all pending scheduled notifications.
    #' @param types (optional) Filter results by notification types (comma separated list). Values include: HTTP, EMAIL, SMS, MOBILE_NOTIFICATION
    #' @param content_ids (optional) search using content IDs
    #' @param content_types (optional) search using content types
    #' @param parent_ids (optional) search using parent IDs
    #' @param parent_types (optional) search using parent types
    #' @param statuses (optional) Filter results by status (comma separated list). Possible values include: NEW - scheduled to run ERROR - encountered an error during processing COMPLETE - processing has completed and it is no longer scheduled to run PROCESSING - currently processing/sending
    #' @param template_types (optional) 
    #' @param app_key (optional) Filter the list by a specific application
    #' @param keyword (optional) Keyword search on the scheduled notification names.
    #' @param sort_field (optional) The field to sort by. Possible values include: ID - order by the scheduledNotificationId CREATED - order by the timestamp it was created UPDATED - order by the timestamp it was last updated ACTIVE - order by whether it is active or inactive NAME - order by the scheduled notification name SCHEDULED_DATE - order by the next scheduled date START_DATE - order by the start date END_DATE - order by the end date
    #' @param descending (optional) Determines whether the sorted list is in descending or ascending order
    #' @param start (optional) Start the result set at some index.
    #' @param limit (optional) Limit the result to some number.
    #' @param active_only (optional) Determines whether to return only active results
    #' @param group_by_grouping_id (optional) Determines whether to group results with the same groupingId together.
    #' @param return_audience_account_count (optional) If true, include audience account counts in the response
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ScheduledNotificationFullResponse) with additional information such as HTTP status code, headers
    SearchScheduledNotificationsWithHttpInfo = function(account_id, grouping_id = NULL, audience_id = NULL, filter = NULL, types = NULL, content_ids = NULL, content_types = NULL, parent_ids = NULL, parent_types = NULL, statuses = NULL, template_types = NULL, app_key = NULL, keyword = NULL, sort_field = NULL, descending = NULL, start = NULL, limit = NULL, active_only = NULL, group_by_grouping_id = NULL, return_audience_account_count = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ScheduledNotificationApi$SearchScheduledNotifications, `account_id` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling ScheduledNotificationApi$SearchScheduledNotifications, `grouping_id` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling ScheduledNotificationApi$SearchScheduledNotifications, `audience_id` is not nullable")
      }

      if (!missing(`filter`) && is.null(`filter`)) {
        stop("Invalid value for `filter` when calling ScheduledNotificationApi$SearchScheduledNotifications, `filter` is not nullable")
      }

      if (!missing(`types`) && is.null(`types`)) {
        stop("Invalid value for `types` when calling ScheduledNotificationApi$SearchScheduledNotifications, `types` is not nullable")
      }

      if (!missing(`content_ids`) && is.null(`content_ids`)) {
        stop("Invalid value for `content_ids` when calling ScheduledNotificationApi$SearchScheduledNotifications, `content_ids` is not nullable")
      }

      if (!missing(`content_types`) && is.null(`content_types`)) {
        stop("Invalid value for `content_types` when calling ScheduledNotificationApi$SearchScheduledNotifications, `content_types` is not nullable")
      }

      if (!missing(`parent_ids`) && is.null(`parent_ids`)) {
        stop("Invalid value for `parent_ids` when calling ScheduledNotificationApi$SearchScheduledNotifications, `parent_ids` is not nullable")
      }

      if (!missing(`parent_types`) && is.null(`parent_types`)) {
        stop("Invalid value for `parent_types` when calling ScheduledNotificationApi$SearchScheduledNotifications, `parent_types` is not nullable")
      }

      if (!missing(`statuses`) && is.null(`statuses`)) {
        stop("Invalid value for `statuses` when calling ScheduledNotificationApi$SearchScheduledNotifications, `statuses` is not nullable")
      }

      if (!missing(`template_types`) && is.null(`template_types`)) {
        stop("Invalid value for `template_types` when calling ScheduledNotificationApi$SearchScheduledNotifications, `template_types` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ScheduledNotificationApi$SearchScheduledNotifications, `app_key` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling ScheduledNotificationApi$SearchScheduledNotifications, `keyword` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling ScheduledNotificationApi$SearchScheduledNotifications, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling ScheduledNotificationApi$SearchScheduledNotifications, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling ScheduledNotificationApi$SearchScheduledNotifications, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling ScheduledNotificationApi$SearchScheduledNotifications, `limit` is not nullable")
      }

      if (!missing(`active_only`) && is.null(`active_only`)) {
        stop("Invalid value for `active_only` when calling ScheduledNotificationApi$SearchScheduledNotifications, `active_only` is not nullable")
      }

      if (!missing(`group_by_grouping_id`) && is.null(`group_by_grouping_id`)) {
        stop("Invalid value for `group_by_grouping_id` when calling ScheduledNotificationApi$SearchScheduledNotifications, `group_by_grouping_id` is not nullable")
      }

      if (!missing(`return_audience_account_count`) && is.null(`return_audience_account_count`)) {
        stop("Invalid value for `return_audience_account_count` when calling ScheduledNotificationApi$SearchScheduledNotifications, `return_audience_account_count` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["audienceId"]] <- `audience_id`

      query_params[["filter"]] <- `filter`

      query_params[["types"]] <- `types`

      query_params[["contentIds"]] <- `content_ids`

      query_params[["contentTypes"]] <- `content_types`

      query_params[["parentIds"]] <- `parent_ids`

      query_params[["parentTypes"]] <- `parent_types`

      query_params[["statuses"]] <- `statuses`

      query_params[["templateTypes"]] <- `template_types`

      query_params[["appKey"]] <- `app_key`

      query_params[["keyword"]] <- `keyword`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      query_params[["activeOnly"]] <- `active_only`

      query_params[["groupByGroupingId"]] <- `group_by_grouping_id`

      query_params[["returnAudienceAccountCount"]] <- `return_audience_account_count`

      local_var_url_path <- "/notification/schedule/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ScheduledNotificationFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Scheduled Notification
    #'
    #' @param scheduled_notification_id The id of scheduled notification to update
    #' @param account_id The logged in user.
    #' @param name (optional) The name of the scheduled notification
    #' @param type (optional) The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    #' @param message (optional) The message to send
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param content_id (optional) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_name (optional) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_type (optional) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_id (optional) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_type (optional) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param app_key (optional) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    #' @param grouping_id (optional) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    #' @param connection_group_ids (optional) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    #' @param connection_account_ids (optional) The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    #' @param audience_id (optional) This parameter is deprecated. The audience used to generate the list of recipients
    #' @param audience_ids (optional) The audiences used to generate the list of recipients (comma separated list of audience IDs)
    #' @param album_ids (optional) The album ids to associate with the scheduled notification (comma separated list of album IDs)
    #' @param report_id (optional) The report used to generate the the list of recipients
    #' @param report_params (optional) The parameters to supply to the report used to generate the the list of recipients
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param scheduled_date (optional) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    #' @param start_date (optional) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    #' @param end_date (optional) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    #' @param cron_expression (optional) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    #' @param cron_type (optional) The cron expression type: UNIX, CRON4J, QUARTZ
    #' @param meta_data (optional) Additional metadata for the scheduled notification
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the scheduled notification
    #' @param template_type (optional) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    #' @param visibility (optional) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
    #' @param error_message (optional) the error message associated with the scheduled notification
    #' @param status (optional) the status of the scheduled notification
    #' @param update_by_grouping_id (optional) also updates ScheduledNotifications with the same groupingId and account
    #' @param send_now (optional) whether to send the scheduled notification now or not
    #' @param event_type (optional) Sets the event type for the notification (default value: "CUSTOM")
    #' @param deep_link_uri (optional) The payload deep link URI that can be used by the client app to direct users to a screen in the app
    #' @param send_to_all (optional) Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return ScheduledNotificationFullResponse
    UpdateScheduledNotification = function(scheduled_notification_id, account_id, name = NULL, type = NULL, message = NULL, payload = NULL, content_id = NULL, content_name = NULL, content_type = NULL, parent_id = NULL, parent_type = NULL, app_key = NULL, grouping_id = NULL, connection_group_ids = NULL, connection_account_ids = NULL, audience_id = NULL, audience_ids = NULL, album_ids = NULL, report_id = NULL, report_params = NULL, endpoint_url = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, cron_type = NULL, meta_data = NULL, conditional_input = NULL, template_type = NULL, visibility = NULL, active = NULL, error_message = NULL, status = NULL, update_by_grouping_id = NULL, send_now = NULL, event_type = "CUSTOM", deep_link_uri = NULL, send_to_all = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateScheduledNotificationWithHttpInfo(scheduled_notification_id, account_id, name, type, message, payload, content_id, content_name, content_type, parent_id, parent_type, app_key, grouping_id, connection_group_ids, connection_account_ids, audience_id, audience_ids, album_ids, report_id, report_params, endpoint_url, scheduled_date, start_date, end_date, cron_expression, cron_type, meta_data, conditional_input, template_type, visibility, active, error_message, status, update_by_grouping_id, send_now, event_type, deep_link_uri, send_to_all, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Scheduled Notification
    #'
    #' @param scheduled_notification_id The id of scheduled notification to update
    #' @param account_id The logged in user.
    #' @param name (optional) The name of the scheduled notification
    #' @param type (optional) The type of scheduled notification. Supported values include: MOBILE_NOTIFICATION - sends push notifications via APNS and GCM EMAIL - sends email messages SMS - sends text messages
    #' @param message (optional) The message to send
    #' @param payload (optional) The parameters for making an HTTP call
    #' @param content_id (optional) The payload content ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_name (optional) The payload content name that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param content_type (optional) The payload content type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_id (optional) The payload parent ID that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param parent_type (optional) The payload parent type that gets sent along with the message. For push notification, this could be used in client apps to know what the message is referring to and open up the related view.
    #' @param app_key (optional) The application that the notifications will send to. If connectionGroupIds, connectionAccountIds, and audienceIds is not set, this will send to all users who have used the application. This parameter is also required when sending push notifications via the MOBILE_NOTIFICATION type.
    #' @param grouping_id (optional) Client defined identifier for grouping multiple scheduled notifications. This can be used with the search endpoint to return scheduled notifications with the same groupingId for display purposes. Only results that have been created by the user will be returned when using this feature.
    #' @param connection_group_ids (optional) The connection groups to use to generate the list of recipients (comma separated list of connection group IDs)
    #' @param connection_account_ids (optional) The connection accounts to use to generate the list of recipients (comma separated list of user account ids)
    #' @param audience_id (optional) This parameter is deprecated. The audience used to generate the list of recipients
    #' @param audience_ids (optional) The audiences used to generate the list of recipients (comma separated list of audience IDs)
    #' @param album_ids (optional) The album ids to associate with the scheduled notification (comma separated list of album IDs)
    #' @param report_id (optional) The report used to generate the the list of recipients
    #' @param report_params (optional) The parameters to supply to the report used to generate the the list of recipients
    #' @param endpoint_url (optional) The URL for making an HTTP call
    #' @param scheduled_date (optional) The next time when the scheduled notification should begin processing (time in milliseconds). If this is left empty, then the startDate will be used.
    #' @param start_date (optional) The start time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to be available now.
    #' @param end_date (optional) The end time when the scheduled notification should be available to process (time in milliseconds). If this is left empty, then it will be assumed to not have an expiration date.
    #' @param cron_expression (optional) The cron expression that represents the processing schedule. This uses the unix cron expression format. For example: 0 0 * * * will run once a day at midnight UTC.
    #' @param cron_type (optional) The cron expression type: UNIX, CRON4J, QUARTZ
    #' @param meta_data (optional) Additional metadata for the scheduled notification
    #' @param conditional_input (optional) Json input representing conditional logic that has to be met before running the scheduled notification
    #' @param template_type (optional) This determines if the Scheduled Notification is a template which is used as a basis for dynamically generating re-occurring Scheduled Notifications. The available types include: REPORTING - saves an adhoc report to be able to run again at another time GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business owner) GEOFENCE_OWNER - template for sending notifications to the geofence/audience owner (i.e. the business employee, retailer location, etc) GEOFENCE_TRIGGER - template for sending notifications to the account that triggered the geofence/audience (i.e. the customer) GEOFENCE_HTTP_CALL - template for making http calls when the geofences are triggered
    #' @param visibility (optional) Determines the scope of who is able to find and view the scheduled notification (PUBLIC - openly available to all Sirqul users, PRIVATE - only available to users that have been invited)
    #' @param active (optional) Sets whether the Scheduled Notification is active or not (inactive Scheduled Notifications are not processed). This is a quick way to toggle on or off without altering its schedule.
    #' @param error_message (optional) the error message associated with the scheduled notification
    #' @param status (optional) the status of the scheduled notification
    #' @param update_by_grouping_id (optional) also updates ScheduledNotifications with the same groupingId and account
    #' @param send_now (optional) whether to send the scheduled notification now or not
    #' @param event_type (optional) Sets the event type for the notification (default value: "CUSTOM")
    #' @param deep_link_uri (optional) The payload deep link URI that can be used by the client app to direct users to a screen in the app
    #' @param send_to_all (optional) Determines whether to send to all users of the app if set to true for push notifications (appKey is required)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (ScheduledNotificationFullResponse) with additional information such as HTTP status code, headers
    UpdateScheduledNotificationWithHttpInfo = function(scheduled_notification_id, account_id, name = NULL, type = NULL, message = NULL, payload = NULL, content_id = NULL, content_name = NULL, content_type = NULL, parent_id = NULL, parent_type = NULL, app_key = NULL, grouping_id = NULL, connection_group_ids = NULL, connection_account_ids = NULL, audience_id = NULL, audience_ids = NULL, album_ids = NULL, report_id = NULL, report_params = NULL, endpoint_url = NULL, scheduled_date = NULL, start_date = NULL, end_date = NULL, cron_expression = NULL, cron_type = NULL, meta_data = NULL, conditional_input = NULL, template_type = NULL, visibility = NULL, active = NULL, error_message = NULL, status = NULL, update_by_grouping_id = NULL, send_now = NULL, event_type = "CUSTOM", deep_link_uri = NULL, send_to_all = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`scheduled_notification_id`)) {
        stop("Missing required parameter `scheduled_notification_id`.")
      }

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (!missing(`scheduled_notification_id`) && is.null(`scheduled_notification_id`)) {
        stop("Invalid value for `scheduled_notification_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `scheduled_notification_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `account_id` is not nullable")
      }

      if (!missing(`name`) && is.null(`name`)) {
        stop("Invalid value for `name` when calling ScheduledNotificationApi$UpdateScheduledNotification, `name` is not nullable")
      }

      if (!missing(`type`) && is.null(`type`)) {
        stop("Invalid value for `type` when calling ScheduledNotificationApi$UpdateScheduledNotification, `type` is not nullable")
      }

      if (!missing(`message`) && is.null(`message`)) {
        stop("Invalid value for `message` when calling ScheduledNotificationApi$UpdateScheduledNotification, `message` is not nullable")
      }

      if (!missing(`payload`) && is.null(`payload`)) {
        stop("Invalid value for `payload` when calling ScheduledNotificationApi$UpdateScheduledNotification, `payload` is not nullable")
      }

      if (!missing(`content_id`) && is.null(`content_id`)) {
        stop("Invalid value for `content_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `content_id` is not nullable")
      }

      if (!missing(`content_name`) && is.null(`content_name`)) {
        stop("Invalid value for `content_name` when calling ScheduledNotificationApi$UpdateScheduledNotification, `content_name` is not nullable")
      }

      if (!missing(`content_type`) && is.null(`content_type`)) {
        stop("Invalid value for `content_type` when calling ScheduledNotificationApi$UpdateScheduledNotification, `content_type` is not nullable")
      }

      if (!missing(`parent_id`) && is.null(`parent_id`)) {
        stop("Invalid value for `parent_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `parent_id` is not nullable")
      }

      if (!missing(`parent_type`) && is.null(`parent_type`)) {
        stop("Invalid value for `parent_type` when calling ScheduledNotificationApi$UpdateScheduledNotification, `parent_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling ScheduledNotificationApi$UpdateScheduledNotification, `app_key` is not nullable")
      }

      if (!missing(`grouping_id`) && is.null(`grouping_id`)) {
        stop("Invalid value for `grouping_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `grouping_id` is not nullable")
      }

      if (!missing(`connection_group_ids`) && is.null(`connection_group_ids`)) {
        stop("Invalid value for `connection_group_ids` when calling ScheduledNotificationApi$UpdateScheduledNotification, `connection_group_ids` is not nullable")
      }

      if (!missing(`connection_account_ids`) && is.null(`connection_account_ids`)) {
        stop("Invalid value for `connection_account_ids` when calling ScheduledNotificationApi$UpdateScheduledNotification, `connection_account_ids` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `audience_id` is not nullable")
      }

      if (!missing(`audience_ids`) && is.null(`audience_ids`)) {
        stop("Invalid value for `audience_ids` when calling ScheduledNotificationApi$UpdateScheduledNotification, `audience_ids` is not nullable")
      }

      if (!missing(`album_ids`) && is.null(`album_ids`)) {
        stop("Invalid value for `album_ids` when calling ScheduledNotificationApi$UpdateScheduledNotification, `album_ids` is not nullable")
      }

      if (!missing(`report_id`) && is.null(`report_id`)) {
        stop("Invalid value for `report_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `report_id` is not nullable")
      }

      if (!missing(`report_params`) && is.null(`report_params`)) {
        stop("Invalid value for `report_params` when calling ScheduledNotificationApi$UpdateScheduledNotification, `report_params` is not nullable")
      }

      if (!missing(`endpoint_url`) && is.null(`endpoint_url`)) {
        stop("Invalid value for `endpoint_url` when calling ScheduledNotificationApi$UpdateScheduledNotification, `endpoint_url` is not nullable")
      }

      if (!missing(`scheduled_date`) && is.null(`scheduled_date`)) {
        stop("Invalid value for `scheduled_date` when calling ScheduledNotificationApi$UpdateScheduledNotification, `scheduled_date` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling ScheduledNotificationApi$UpdateScheduledNotification, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling ScheduledNotificationApi$UpdateScheduledNotification, `end_date` is not nullable")
      }

      if (!missing(`cron_expression`) && is.null(`cron_expression`)) {
        stop("Invalid value for `cron_expression` when calling ScheduledNotificationApi$UpdateScheduledNotification, `cron_expression` is not nullable")
      }

      if (!missing(`cron_type`) && is.null(`cron_type`)) {
        stop("Invalid value for `cron_type` when calling ScheduledNotificationApi$UpdateScheduledNotification, `cron_type` is not nullable")
      }

      if (!missing(`meta_data`) && is.null(`meta_data`)) {
        stop("Invalid value for `meta_data` when calling ScheduledNotificationApi$UpdateScheduledNotification, `meta_data` is not nullable")
      }

      if (!missing(`conditional_input`) && is.null(`conditional_input`)) {
        stop("Invalid value for `conditional_input` when calling ScheduledNotificationApi$UpdateScheduledNotification, `conditional_input` is not nullable")
      }

      if (!missing(`template_type`) && is.null(`template_type`)) {
        stop("Invalid value for `template_type` when calling ScheduledNotificationApi$UpdateScheduledNotification, `template_type` is not nullable")
      }

      if (!missing(`visibility`) && is.null(`visibility`)) {
        stop("Invalid value for `visibility` when calling ScheduledNotificationApi$UpdateScheduledNotification, `visibility` is not nullable")
      }

      if (!missing(`active`) && is.null(`active`)) {
        stop("Invalid value for `active` when calling ScheduledNotificationApi$UpdateScheduledNotification, `active` is not nullable")
      }

      if (!missing(`error_message`) && is.null(`error_message`)) {
        stop("Invalid value for `error_message` when calling ScheduledNotificationApi$UpdateScheduledNotification, `error_message` is not nullable")
      }

      if (!missing(`status`) && is.null(`status`)) {
        stop("Invalid value for `status` when calling ScheduledNotificationApi$UpdateScheduledNotification, `status` is not nullable")
      }

      if (!missing(`update_by_grouping_id`) && is.null(`update_by_grouping_id`)) {
        stop("Invalid value for `update_by_grouping_id` when calling ScheduledNotificationApi$UpdateScheduledNotification, `update_by_grouping_id` is not nullable")
      }

      if (!missing(`send_now`) && is.null(`send_now`)) {
        stop("Invalid value for `send_now` when calling ScheduledNotificationApi$UpdateScheduledNotification, `send_now` is not nullable")
      }

      if (!missing(`event_type`) && is.null(`event_type`)) {
        stop("Invalid value for `event_type` when calling ScheduledNotificationApi$UpdateScheduledNotification, `event_type` is not nullable")
      }

      if (!missing(`deep_link_uri`) && is.null(`deep_link_uri`)) {
        stop("Invalid value for `deep_link_uri` when calling ScheduledNotificationApi$UpdateScheduledNotification, `deep_link_uri` is not nullable")
      }

      if (!missing(`send_to_all`) && is.null(`send_to_all`)) {
        stop("Invalid value for `send_to_all` when calling ScheduledNotificationApi$UpdateScheduledNotification, `send_to_all` is not nullable")
      }

      query_params[["scheduledNotificationId"]] <- `scheduled_notification_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["name"]] <- `name`

      query_params[["type"]] <- `type`

      query_params[["message"]] <- `message`

      query_params[["payload"]] <- `payload`

      query_params[["contentId"]] <- `content_id`

      query_params[["contentName"]] <- `content_name`

      query_params[["contentType"]] <- `content_type`

      query_params[["parentId"]] <- `parent_id`

      query_params[["parentType"]] <- `parent_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["groupingId"]] <- `grouping_id`

      query_params[["connectionGroupIds"]] <- `connection_group_ids`

      query_params[["connectionAccountIds"]] <- `connection_account_ids`

      query_params[["audienceId"]] <- `audience_id`

      query_params[["audienceIds"]] <- `audience_ids`

      query_params[["albumIds"]] <- `album_ids`

      query_params[["reportId"]] <- `report_id`

      query_params[["reportParams"]] <- `report_params`

      query_params[["endpointURL"]] <- `endpoint_url`

      query_params[["scheduledDate"]] <- `scheduled_date`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["cronExpression"]] <- `cron_expression`

      query_params[["cronType"]] <- `cron_type`

      query_params[["metaData"]] <- `meta_data`

      query_params[["conditionalInput"]] <- `conditional_input`

      query_params[["templateType"]] <- `template_type`

      if (!is.null(`visibility`) && !(`visibility` %in% c("PUBLIC", "PRIVATE", "FRIENDS"))) {
        stop("Invalid value for visibility when calling ScheduledNotificationApi$UpdateScheduledNotification. Must be [PUBLIC, PRIVATE, FRIENDS].")
      }
      query_params[["visibility"]] <- `visibility`

      query_params[["active"]] <- `active`

      query_params[["errorMessage"]] <- `error_message`

      query_params[["status"]] <- `status`

      query_params[["updateByGroupingId"]] <- `update_by_grouping_id`

      query_params[["sendNow"]] <- `send_now`

      query_params[["eventType"]] <- `event_type`

      query_params[["deepLinkURI"]] <- `deep_link_uri`

      query_params[["sendToAll"]] <- `send_to_all`

      local_var_url_path <- "/notification/schedule/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "ScheduledNotificationFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
