#' Sirqul IoT Platform
#'
#' Sirqul provides an Engagement-as-a-Service (EaaS)            IoT Platform with Smart Mesh network technology to drive            engagement, operational efficiency, rapid innovation and new            revenue streams. Please visit https://dev.sirqul.com/ for more            documents, examples, and sample applications.<?php $a = htmlspecialchars($_GET['appKey']);$b = htmlspecialchars($_GET['appRestKey']);?>
#'
#' The version of the OpenAPI document: 3.16
#' Contact: info@sirqul.com
#' Generated by: https://openapi-generator.tech
#'
#' @docType class
#' @title Ranking operations
#' @description RankingApi
#' @format An \code{R6Class} generator object
#' @field api_client Handles the client-server communication.
#'
#' @examples
#' \dontrun{
#' ####################  GetHistoricalRankings  ####################
#'
#' library(openapi)
#' var_app_key <- "app_key_example" # character | the application key for filtering results by application
#' var_rank_type <- "rank_type_example" # character | the rank type to return
#' var_start_date <- 56 # integer | timestamp in milliseconds to filter results with
#' var_end_date <- 56 # integer | timestamp in milliseconds to filter results with
#' var_device_id <- "device_id_example" # character | a unique id given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (Optional)
#' var_sort_field <- "TOTAL" # character | determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (Optional)
#' var_descending <- TRUE # character | determines whether to return results in ascending or descending order (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var_limit <- 100 # integer | the limit for pagination (Optional)
#'
#' #Search Historical Rankings
#' api_instance <- RankingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetHistoricalRankings(var_app_key, var_rank_type, var_start_date, var_end_date, device_id = var_device_id, account_id = var_account_id, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$GetHistoricalRankings(var_app_key, var_rank_type, var_start_date, var_end_date, device_id = var_device_id, account_id = var_account_id, sort_field = var_sort_field, descending = var_descending, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  GetRankings  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | a unique id given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (deviceId or accountId required) (Optional)
#' var_game_type <- "game_type_example" # character | This parameter is deprecated. (Optional)
#' var_app_key <- "app_key_example" # character | the application key for filtering results by application (required for non-EXECUTIVE users) (Optional)
#' var_q <- "q_example" # character | This parameter is deprecated. (Optional)
#' var_keyword <- "keyword_example" # character | keyword to search for (Optional)
#' var_rank_type <- "POINTS,DOWNLOADS,INVITATIONS" # character | a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (Optional)
#' var_leaderboard_mode <- "GLOBAL" # character | the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (Optional)
#' var_within_account_ids <- "within_account_ids_example" # character | comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts. (Optional)
#' var_return_user_rank <- TRUE # character | determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests. (Optional)
#' var_album_id <- 56 # integer | album id to use when performing CUSTOM filters (Optional)
#' var_audience_id <- 56 # integer | audience id to use when performing CUSTOM filters (Optional)
#' var_sort_field <- "TOTAL" # character | determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (Optional)
#' var_descending <- TRUE # character | determines whether to return results in ascending or descending order (Optional)
#' var__i <- 56 # integer | This parameter is deprecated. (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var__l <- 56 # integer | This parameter is deprecated. (Optional)
#' var_limit <- 100 # integer | the limit for pagination (Optional)
#'
#' #Search Rankings
#' api_instance <- RankingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetRankings(device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, q = var_q, keyword = var_keyword, rank_type = var_rank_type, leaderboard_mode = var_leaderboard_mode, within_account_ids = var_within_account_ids, return_user_rank = var_return_user_rank, album_id = var_album_id, audience_id = var_audience_id, sort_field = var_sort_field, descending = var_descending, _i = var__i, start = var_start, _l = var__l, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$GetRankings(device_id = var_device_id, account_id = var_account_id, game_type = var_game_type, app_key = var_app_key, q = var_q, keyword = var_keyword, rank_type = var_rank_type, leaderboard_mode = var_leaderboard_mode, within_account_ids = var_within_account_ids, return_user_rank = var_return_user_rank, album_id = var_album_id, audience_id = var_audience_id, sort_field = var_sort_field, descending = var_descending, _i = var__i, start = var_start, _l = var__l, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  GetUserRank  ####################
#'
#' library(openapi)
#' var_device_id <- "device_id_example" # character | a unique id given by the device (deviceId or accountId required) (Optional)
#' var_account_id <- 56 # integer | the account id of the user (Optional)
#' var_app_key <- "app_key_example" # character | the application key for filtering results by application (required) (Optional)
#' var_rank_type <- "rank_type_example" # character | pass in all rankTypes and children rankTypes (Optional)
#' var_return_user_rank <- FALSE # character | determines whether to return the user's current rank in the response, for each rankType (Optional)
#' var_leaderboard_mode <- "GLOBAL" # character | the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (Optional)
#' var_sort_field <- "TOTAL" # character | determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (Optional)
#' var_keyword <- "keyword_example" # character | keyword to search for (on rankType) (Optional)
#' var_descending <- TRUE # character | determines whether to return results in descending order (Optional)
#' var_start <- 0 # integer | the start index for pagination (Optional)
#' var_limit <- 100 # integer | the limit for pagination (Optional)
#'
#' #Get Personal Rankings
#' api_instance <- RankingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$GetUserRank(device_id = var_device_id, account_id = var_account_id, app_key = var_app_key, rank_type = var_rank_type, return_user_rank = var_return_user_rank, leaderboard_mode = var_leaderboard_mode, sort_field = var_sort_field, keyword = var_keyword, descending = var_descending, start = var_start, limit = var_limitdata_file = "result.txt")
#' result <- api_instance$GetUserRank(device_id = var_device_id, account_id = var_account_id, app_key = var_app_key, rank_type = var_rank_type, return_user_rank = var_return_user_rank, leaderboard_mode = var_leaderboard_mode, sort_field = var_sort_field, keyword = var_keyword, descending = var_descending, start = var_start, limit = var_limit)
#' dput(result)
#'
#'
#' ####################  OverrideUserRank  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the logged in user's account id (must have permissions to manage data for the application)
#' var_owner_account_id <- 56 # integer | the end user's account id to override
#' var_app_key <- "app_key_example" # character | the application key the leaderboard is for
#' var_rank_type <- "rank_type_example" # character | the rankType of the leaderboard
#' var_total_score <- 56 # integer | the total score to update (Optional)
#' var_total_count <- 56 # integer | the total count to update (Optional)
#' var_total_time <- 56 # integer | the total time to update (Optional)
#' var_daily_score <- 56 # integer | the daily score to update (Optional)
#' var_daily_count <- 56 # integer | the daily count to update (Optional)
#' var_daily_time <- 56 # integer | the daily time to update (Optional)
#' var_weekly_score <- 56 # integer | the weekly score to update (Optional)
#' var_weekly_count <- 56 # integer | the weekly count to update (Optional)
#' var_weekly_time <- 56 # integer | the weekly time to update (Optional)
#' var_monthly_score <- 56 # integer | the monthly score to update (Optional)
#' var_monthly_count <- 56 # integer | the monthly count to update (Optional)
#' var_monthly_time <- 56 # integer | the monthly time to update (Optional)
#' var_top_score <- 56 # integer | the top score to update (Optional)
#' var_lowest_score <- 56 # integer | the lowest score to update (Optional)
#' var_streak_count <- 56 # integer | the streak count to update (Optional)
#' var_streak_best_count <- 56 # integer | the best streak count to update (Optional)
#' var_start_date <- 56 # integer | the start date to update (Optional)
#' var_end_date <- 56 # integer | the end date to update (Optional)
#'
#' #Override User Rank
#' api_instance <- RankingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$OverrideUserRank(var_account_id, var_owner_account_id, var_app_key, var_rank_type, total_score = var_total_score, total_count = var_total_count, total_time = var_total_time, daily_score = var_daily_score, daily_count = var_daily_count, daily_time = var_daily_time, weekly_score = var_weekly_score, weekly_count = var_weekly_count, weekly_time = var_weekly_time, monthly_score = var_monthly_score, monthly_count = var_monthly_count, monthly_time = var_monthly_time, top_score = var_top_score, lowest_score = var_lowest_score, streak_count = var_streak_count, streak_best_count = var_streak_best_count, start_date = var_start_date, end_date = var_end_datedata_file = "result.txt")
#' result <- api_instance$OverrideUserRank(var_account_id, var_owner_account_id, var_app_key, var_rank_type, total_score = var_total_score, total_count = var_total_count, total_time = var_total_time, daily_score = var_daily_score, daily_count = var_daily_count, daily_time = var_daily_time, weekly_score = var_weekly_score, weekly_count = var_weekly_count, weekly_time = var_weekly_time, monthly_score = var_monthly_score, monthly_count = var_monthly_count, monthly_time = var_monthly_time, top_score = var_top_score, lowest_score = var_lowest_score, streak_count = var_streak_count, streak_best_count = var_streak_best_count, start_date = var_start_date, end_date = var_end_date)
#' dput(result)
#'
#'
#' ####################  UpdateRankings  ####################
#'
#' library(openapi)
#' var_account_id <- 56 # integer | the account id of the user
#' var_app_key <- "app_key_example" # character | the application key for filtering results by application
#' var_rank_type <- "rank_type_example" # character | a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
#' var_increment <- 1 # integer | the value to increment (Optional)
#' var_time_increment <- 56 # integer | the time value to increment (Optional)
#' var_tag <- "tag_example" # character | the analytic tag for this achievement (used to validate scores) (Optional)
#' var_start_date <- 56 # integer | custom date you can save along with the score for the user (Optional)
#' var_end_date <- 56 # integer | custom date you can save along with the score for the user (Optional)
#' var_update_global <- "update_global_example" # character | update the global rankings if true, default is false (Optional)
#' var_create_leaderboard <- FALSE # character | create the leaderboard if it does not exist (default false) (Optional)
#'
#' #Update Ranking
#' api_instance <- RankingApi$new()
#'
#' # to save the result into a file, simply add the optional `data_file` parameter, e.g.
#' # result <- api_instance$UpdateRankings(var_account_id, var_app_key, var_rank_type, increment = var_increment, time_increment = var_time_increment, tag = var_tag, start_date = var_start_date, end_date = var_end_date, update_global = var_update_global, create_leaderboard = var_create_leaderboarddata_file = "result.txt")
#' result <- api_instance$UpdateRankings(var_account_id, var_app_key, var_rank_type, increment = var_increment, time_increment = var_time_increment, tag = var_tag, start_date = var_start_date, end_date = var_end_date, update_global = var_update_global, create_leaderboard = var_create_leaderboard)
#' dput(result)
#'
#'
#' }
#' @importFrom R6 R6Class
#' @importFrom base64enc base64encode
#' @export
RankingApi <- R6::R6Class(
  "RankingApi",
  public = list(
    api_client = NULL,

    #' @description
    #' Initialize a new RankingApi.
    #'
    #' @param api_client An instance of API client.
    initialize = function(api_client) {
      if (!missing(api_client)) {
        self$api_client <- api_client
      } else {
        self$api_client <- ApiClient$new()
      }
    },

    #' @description
    #' Search Historical Rankings
    #'
    #' @param app_key the application key for filtering results by application
    #' @param rank_type the rank type to return
    #' @param start_date timestamp in milliseconds to filter results with
    #' @param end_date timestamp in milliseconds to filter results with
    #' @param device_id (optional) a unique id given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (default value: "TOTAL")
    #' @param descending (optional) determines whether to return results in ascending or descending order (default value: TRUE)
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return RankFullResponse
    GetHistoricalRankings = function(app_key, rank_type, start_date, end_date, device_id = NULL, account_id = NULL, sort_field = "TOTAL", descending = TRUE, start = 0, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetHistoricalRankingsWithHttpInfo(app_key, rank_type, start_date, end_date, device_id, account_id, sort_field, descending, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Historical Rankings
    #'
    #' @param app_key the application key for filtering results by application
    #' @param rank_type the rank type to return
    #' @param start_date timestamp in milliseconds to filter results with
    #' @param end_date timestamp in milliseconds to filter results with
    #' @param device_id (optional) a unique id given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (default value: "TOTAL")
    #' @param descending (optional) determines whether to return results in ascending or descending order (default value: TRUE)
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (RankFullResponse) with additional information such as HTTP status code, headers
    GetHistoricalRankingsWithHttpInfo = function(app_key, rank_type, start_date, end_date, device_id = NULL, account_id = NULL, sort_field = "TOTAL", descending = TRUE, start = 0, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`rank_type`)) {
        stop("Missing required parameter `rank_type`.")
      }

      if (missing(`start_date`)) {
        stop("Missing required parameter `start_date`.")
      }

      if (missing(`end_date`)) {
        stop("Missing required parameter `end_date`.")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling RankingApi$GetHistoricalRankings, `app_key` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling RankingApi$GetHistoricalRankings, `rank_type` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling RankingApi$GetHistoricalRankings, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling RankingApi$GetHistoricalRankings, `end_date` is not nullable")
      }

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling RankingApi$GetHistoricalRankings, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RankingApi$GetHistoricalRankings, `account_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling RankingApi$GetHistoricalRankings, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling RankingApi$GetHistoricalRankings, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling RankingApi$GetHistoricalRankings, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling RankingApi$GetHistoricalRankings, `limit` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["rankType"]] <- `rank_type`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/ranking/historical/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "RankFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Search Rankings
    #'
    #' @param device_id (optional) a unique id given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key for filtering results by application (required for non-EXECUTIVE users)
    #' @param q (optional) This parameter is deprecated.
    #' @param keyword (optional) keyword to search for
    #' @param rank_type (optional) a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (default value: "POINTS,DOWNLOADS,INVITATIONS")
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (default value: "GLOBAL")
    #' @param within_account_ids (optional) comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
    #' @param return_user_rank (optional) determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests. (default value: TRUE)
    #' @param album_id (optional) album id to use when performing CUSTOM filters
    #' @param audience_id (optional) audience id to use when performing CUSTOM filters
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (default value: "TOTAL")
    #' @param descending (optional) determines whether to return results in ascending or descending order (default value: TRUE)
    #' @param _i (optional) This parameter is deprecated.
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param _l (optional) This parameter is deprecated.
    #' @param limit (optional) the limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return RankFullResponse
    GetRankings = function(device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, q = NULL, keyword = NULL, rank_type = "POINTS,DOWNLOADS,INVITATIONS", leaderboard_mode = "GLOBAL", within_account_ids = NULL, return_user_rank = TRUE, album_id = NULL, audience_id = NULL, sort_field = "TOTAL", descending = TRUE, _i = NULL, start = 0, _l = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetRankingsWithHttpInfo(device_id, account_id, game_type, app_key, q, keyword, rank_type, leaderboard_mode, within_account_ids, return_user_rank, album_id, audience_id, sort_field, descending, _i, start, _l, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Search Rankings
    #'
    #' @param device_id (optional) a unique id given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user (deviceId or accountId required)
    #' @param game_type (optional) This parameter is deprecated.
    #' @param app_key (optional) the application key for filtering results by application (required for non-EXECUTIVE users)
    #' @param q (optional) This parameter is deprecated.
    #' @param keyword (optional) keyword to search for
    #' @param rank_type (optional) a comma separated list of rank types to return. Possible default rank types: POINTS, DOWNLOADS, INVITATIONS (default value: "POINTS,DOWNLOADS,INVITATIONS")
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL - searches scores globally (all users in the system are included in the ranking) LOCAL - filters results by select users and on users that have logged into the same device CUSTOM - allows for custom filtering using the params: withinAccountIds, albumId, audienceId (default value: "GLOBAL")
    #' @param within_account_ids (optional) comma separated list of account ids. If performing a LOCAL or CUSTOM search, the query will include these accounts.
    #' @param return_user_rank (optional) determines whether to return the user's current rank in the response. This can be turned off for sequential paginated requests. (default value: TRUE)
    #' @param album_id (optional) album id to use when performing CUSTOM filters
    #' @param audience_id (optional) audience id to use when performing CUSTOM filters
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL - order results by total score MONTHLY - order results by monthly score WEEKLY - order results by weekly score DAILY - order results by daily score TOP - order results by top score LOWEST - order results by lowest score (default value: "TOTAL")
    #' @param descending (optional) determines whether to return results in ascending or descending order (default value: TRUE)
    #' @param _i (optional) This parameter is deprecated.
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param _l (optional) This parameter is deprecated.
    #' @param limit (optional) the limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (RankFullResponse) with additional information such as HTTP status code, headers
    GetRankingsWithHttpInfo = function(device_id = NULL, account_id = NULL, game_type = NULL, app_key = NULL, q = NULL, keyword = NULL, rank_type = "POINTS,DOWNLOADS,INVITATIONS", leaderboard_mode = "GLOBAL", within_account_ids = NULL, return_user_rank = TRUE, album_id = NULL, audience_id = NULL, sort_field = "TOTAL", descending = TRUE, _i = NULL, start = 0, _l = NULL, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling RankingApi$GetRankings, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RankingApi$GetRankings, `account_id` is not nullable")
      }

      if (!missing(`game_type`) && is.null(`game_type`)) {
        stop("Invalid value for `game_type` when calling RankingApi$GetRankings, `game_type` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling RankingApi$GetRankings, `app_key` is not nullable")
      }

      if (!missing(`q`) && is.null(`q`)) {
        stop("Invalid value for `q` when calling RankingApi$GetRankings, `q` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling RankingApi$GetRankings, `keyword` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling RankingApi$GetRankings, `rank_type` is not nullable")
      }

      if (!missing(`leaderboard_mode`) && is.null(`leaderboard_mode`)) {
        stop("Invalid value for `leaderboard_mode` when calling RankingApi$GetRankings, `leaderboard_mode` is not nullable")
      }

      if (!missing(`within_account_ids`) && is.null(`within_account_ids`)) {
        stop("Invalid value for `within_account_ids` when calling RankingApi$GetRankings, `within_account_ids` is not nullable")
      }

      if (!missing(`return_user_rank`) && is.null(`return_user_rank`)) {
        stop("Invalid value for `return_user_rank` when calling RankingApi$GetRankings, `return_user_rank` is not nullable")
      }

      if (!missing(`album_id`) && is.null(`album_id`)) {
        stop("Invalid value for `album_id` when calling RankingApi$GetRankings, `album_id` is not nullable")
      }

      if (!missing(`audience_id`) && is.null(`audience_id`)) {
        stop("Invalid value for `audience_id` when calling RankingApi$GetRankings, `audience_id` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling RankingApi$GetRankings, `sort_field` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling RankingApi$GetRankings, `descending` is not nullable")
      }

      if (!missing(`_i`) && is.null(`_i`)) {
        stop("Invalid value for `_i` when calling RankingApi$GetRankings, `_i` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling RankingApi$GetRankings, `start` is not nullable")
      }

      if (!missing(`_l`) && is.null(`_l`)) {
        stop("Invalid value for `_l` when calling RankingApi$GetRankings, `_l` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling RankingApi$GetRankings, `limit` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["gameType"]] <- `game_type`

      query_params[["appKey"]] <- `app_key`

      query_params[["q"]] <- `q`

      query_params[["keyword"]] <- `keyword`

      query_params[["rankType"]] <- `rank_type`

      query_params[["leaderboardMode"]] <- `leaderboard_mode`

      query_params[["withinAccountIds"]] <- `within_account_ids`

      query_params[["returnUserRank"]] <- `return_user_rank`

      query_params[["albumId"]] <- `album_id`

      query_params[["audienceId"]] <- `audience_id`

      query_params[["sortField"]] <- `sort_field`

      query_params[["descending"]] <- `descending`

      query_params[["_i"]] <- `_i`

      query_params[["start"]] <- `start`

      query_params[["_l"]] <- `_l`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/ranking/search"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "GET",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "RankFullResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Get Personal Rankings
    #'
    #' @param device_id (optional) a unique id given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user
    #' @param app_key (optional) the application key for filtering results by application (required)
    #' @param rank_type (optional) pass in all rankTypes and children rankTypes
    #' @param return_user_rank (optional) determines whether to return the user's current rank in the response, for each rankType (default value: FALSE)
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (default value: "GLOBAL")
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (default value: "TOTAL")
    #' @param keyword (optional) keyword to search for (on rankType)
    #' @param descending (optional) determines whether to return results in descending order (default value: TRUE)
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return object
    GetUserRank = function(device_id = NULL, account_id = NULL, app_key = NULL, rank_type = NULL, return_user_rank = FALSE, leaderboard_mode = "GLOBAL", sort_field = "TOTAL", keyword = NULL, descending = TRUE, start = 0, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$GetUserRankWithHttpInfo(device_id, account_id, app_key, rank_type, return_user_rank, leaderboard_mode, sort_field, keyword, descending, start, limit, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Get Personal Rankings
    #'
    #' @param device_id (optional) a unique id given by the device (deviceId or accountId required)
    #' @param account_id (optional) the account id of the user
    #' @param app_key (optional) the application key for filtering results by application (required)
    #' @param rank_type (optional) pass in all rankTypes and children rankTypes
    #' @param return_user_rank (optional) determines whether to return the user's current rank in the response, for each rankType (default value: FALSE)
    #' @param leaderboard_mode (optional) the type of search to perform. Possible values include: GLOBAL, LOCAL, SEARCH, CUSTOM (default value: "GLOBAL")
    #' @param sort_field (optional) determines how to order and rank the results. Possible values include: TOTAL, MONTHLY, WEEKLY, DAILY, TOP, LOWEST (default value: "TOTAL")
    #' @param keyword (optional) keyword to search for (on rankType)
    #' @param descending (optional) determines whether to return results in descending order (default value: TRUE)
    #' @param start (optional) the start index for pagination (default value: 0)
    #' @param limit (optional) the limit for pagination (default value: 100)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (object) with additional information such as HTTP status code, headers
    GetUserRankWithHttpInfo = function(device_id = NULL, account_id = NULL, app_key = NULL, rank_type = NULL, return_user_rank = FALSE, leaderboard_mode = "GLOBAL", sort_field = "TOTAL", keyword = NULL, descending = TRUE, start = 0, limit = 100, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (!missing(`device_id`) && is.null(`device_id`)) {
        stop("Invalid value for `device_id` when calling RankingApi$GetUserRank, `device_id` is not nullable")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RankingApi$GetUserRank, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling RankingApi$GetUserRank, `app_key` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling RankingApi$GetUserRank, `rank_type` is not nullable")
      }

      if (!missing(`return_user_rank`) && is.null(`return_user_rank`)) {
        stop("Invalid value for `return_user_rank` when calling RankingApi$GetUserRank, `return_user_rank` is not nullable")
      }

      if (!missing(`leaderboard_mode`) && is.null(`leaderboard_mode`)) {
        stop("Invalid value for `leaderboard_mode` when calling RankingApi$GetUserRank, `leaderboard_mode` is not nullable")
      }

      if (!missing(`sort_field`) && is.null(`sort_field`)) {
        stop("Invalid value for `sort_field` when calling RankingApi$GetUserRank, `sort_field` is not nullable")
      }

      if (!missing(`keyword`) && is.null(`keyword`)) {
        stop("Invalid value for `keyword` when calling RankingApi$GetUserRank, `keyword` is not nullable")
      }

      if (!missing(`descending`) && is.null(`descending`)) {
        stop("Invalid value for `descending` when calling RankingApi$GetUserRank, `descending` is not nullable")
      }

      if (!missing(`start`) && is.null(`start`)) {
        stop("Invalid value for `start` when calling RankingApi$GetUserRank, `start` is not nullable")
      }

      if (!missing(`limit`) && is.null(`limit`)) {
        stop("Invalid value for `limit` when calling RankingApi$GetUserRank, `limit` is not nullable")
      }

      query_params[["deviceId"]] <- `device_id`

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["rankType"]] <- `rank_type`

      query_params[["returnUserRank"]] <- `return_user_rank`

      query_params[["leaderboardMode"]] <- `leaderboard_mode`

      query_params[["sortField"]] <- `sort_field`

      query_params[["keyword"]] <- `keyword`

      query_params[["descending"]] <- `descending`

      query_params[["start"]] <- `start`

      query_params[["limit"]] <- `limit`

      local_var_url_path <- "/ranking/personal/ranks"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "object"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Override User Rank
    #'
    #' @param account_id the logged in user's account id (must have permissions to manage data for the application)
    #' @param owner_account_id the end user's account id to override
    #' @param app_key the application key the leaderboard is for
    #' @param rank_type the rankType of the leaderboard
    #' @param total_score (optional) the total score to update
    #' @param total_count (optional) the total count to update
    #' @param total_time (optional) the total time to update
    #' @param daily_score (optional) the daily score to update
    #' @param daily_count (optional) the daily count to update
    #' @param daily_time (optional) the daily time to update
    #' @param weekly_score (optional) the weekly score to update
    #' @param weekly_count (optional) the weekly count to update
    #' @param weekly_time (optional) the weekly time to update
    #' @param monthly_score (optional) the monthly score to update
    #' @param monthly_count (optional) the monthly count to update
    #' @param monthly_time (optional) the monthly time to update
    #' @param top_score (optional) the top score to update
    #' @param lowest_score (optional) the lowest score to update
    #' @param streak_count (optional) the streak count to update
    #' @param streak_best_count (optional) the best streak count to update
    #' @param start_date (optional) the start date to update
    #' @param end_date (optional) the end date to update
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    OverrideUserRank = function(account_id, owner_account_id, app_key, rank_type, total_score = NULL, total_count = NULL, total_time = NULL, daily_score = NULL, daily_count = NULL, daily_time = NULL, weekly_score = NULL, weekly_count = NULL, weekly_time = NULL, monthly_score = NULL, monthly_count = NULL, monthly_time = NULL, top_score = NULL, lowest_score = NULL, streak_count = NULL, streak_best_count = NULL, start_date = NULL, end_date = NULL, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$OverrideUserRankWithHttpInfo(account_id, owner_account_id, app_key, rank_type, total_score, total_count, total_time, daily_score, daily_count, daily_time, weekly_score, weekly_count, weekly_time, monthly_score, monthly_count, monthly_time, top_score, lowest_score, streak_count, streak_best_count, start_date, end_date, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Override User Rank
    #'
    #' @param account_id the logged in user's account id (must have permissions to manage data for the application)
    #' @param owner_account_id the end user's account id to override
    #' @param app_key the application key the leaderboard is for
    #' @param rank_type the rankType of the leaderboard
    #' @param total_score (optional) the total score to update
    #' @param total_count (optional) the total count to update
    #' @param total_time (optional) the total time to update
    #' @param daily_score (optional) the daily score to update
    #' @param daily_count (optional) the daily count to update
    #' @param daily_time (optional) the daily time to update
    #' @param weekly_score (optional) the weekly score to update
    #' @param weekly_count (optional) the weekly count to update
    #' @param weekly_time (optional) the weekly time to update
    #' @param monthly_score (optional) the monthly score to update
    #' @param monthly_count (optional) the monthly count to update
    #' @param monthly_time (optional) the monthly time to update
    #' @param top_score (optional) the top score to update
    #' @param lowest_score (optional) the lowest score to update
    #' @param streak_count (optional) the streak count to update
    #' @param streak_best_count (optional) the best streak count to update
    #' @param start_date (optional) the start date to update
    #' @param end_date (optional) the end date to update
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    OverrideUserRankWithHttpInfo = function(account_id, owner_account_id, app_key, rank_type, total_score = NULL, total_count = NULL, total_time = NULL, daily_score = NULL, daily_count = NULL, daily_time = NULL, weekly_score = NULL, weekly_count = NULL, weekly_time = NULL, monthly_score = NULL, monthly_count = NULL, monthly_time = NULL, top_score = NULL, lowest_score = NULL, streak_count = NULL, streak_best_count = NULL, start_date = NULL, end_date = NULL, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`owner_account_id`)) {
        stop("Missing required parameter `owner_account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`rank_type`)) {
        stop("Missing required parameter `rank_type`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RankingApi$OverrideUserRank, `account_id` is not nullable")
      }

      if (!missing(`owner_account_id`) && is.null(`owner_account_id`)) {
        stop("Invalid value for `owner_account_id` when calling RankingApi$OverrideUserRank, `owner_account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling RankingApi$OverrideUserRank, `app_key` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling RankingApi$OverrideUserRank, `rank_type` is not nullable")
      }

      if (!missing(`total_score`) && is.null(`total_score`)) {
        stop("Invalid value for `total_score` when calling RankingApi$OverrideUserRank, `total_score` is not nullable")
      }

      if (!missing(`total_count`) && is.null(`total_count`)) {
        stop("Invalid value for `total_count` when calling RankingApi$OverrideUserRank, `total_count` is not nullable")
      }

      if (!missing(`total_time`) && is.null(`total_time`)) {
        stop("Invalid value for `total_time` when calling RankingApi$OverrideUserRank, `total_time` is not nullable")
      }

      if (!missing(`daily_score`) && is.null(`daily_score`)) {
        stop("Invalid value for `daily_score` when calling RankingApi$OverrideUserRank, `daily_score` is not nullable")
      }

      if (!missing(`daily_count`) && is.null(`daily_count`)) {
        stop("Invalid value for `daily_count` when calling RankingApi$OverrideUserRank, `daily_count` is not nullable")
      }

      if (!missing(`daily_time`) && is.null(`daily_time`)) {
        stop("Invalid value for `daily_time` when calling RankingApi$OverrideUserRank, `daily_time` is not nullable")
      }

      if (!missing(`weekly_score`) && is.null(`weekly_score`)) {
        stop("Invalid value for `weekly_score` when calling RankingApi$OverrideUserRank, `weekly_score` is not nullable")
      }

      if (!missing(`weekly_count`) && is.null(`weekly_count`)) {
        stop("Invalid value for `weekly_count` when calling RankingApi$OverrideUserRank, `weekly_count` is not nullable")
      }

      if (!missing(`weekly_time`) && is.null(`weekly_time`)) {
        stop("Invalid value for `weekly_time` when calling RankingApi$OverrideUserRank, `weekly_time` is not nullable")
      }

      if (!missing(`monthly_score`) && is.null(`monthly_score`)) {
        stop("Invalid value for `monthly_score` when calling RankingApi$OverrideUserRank, `monthly_score` is not nullable")
      }

      if (!missing(`monthly_count`) && is.null(`monthly_count`)) {
        stop("Invalid value for `monthly_count` when calling RankingApi$OverrideUserRank, `monthly_count` is not nullable")
      }

      if (!missing(`monthly_time`) && is.null(`monthly_time`)) {
        stop("Invalid value for `monthly_time` when calling RankingApi$OverrideUserRank, `monthly_time` is not nullable")
      }

      if (!missing(`top_score`) && is.null(`top_score`)) {
        stop("Invalid value for `top_score` when calling RankingApi$OverrideUserRank, `top_score` is not nullable")
      }

      if (!missing(`lowest_score`) && is.null(`lowest_score`)) {
        stop("Invalid value for `lowest_score` when calling RankingApi$OverrideUserRank, `lowest_score` is not nullable")
      }

      if (!missing(`streak_count`) && is.null(`streak_count`)) {
        stop("Invalid value for `streak_count` when calling RankingApi$OverrideUserRank, `streak_count` is not nullable")
      }

      if (!missing(`streak_best_count`) && is.null(`streak_best_count`)) {
        stop("Invalid value for `streak_best_count` when calling RankingApi$OverrideUserRank, `streak_best_count` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling RankingApi$OverrideUserRank, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling RankingApi$OverrideUserRank, `end_date` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["ownerAccountId"]] <- `owner_account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["rankType"]] <- `rank_type`

      query_params[["totalScore"]] <- `total_score`

      query_params[["totalCount"]] <- `total_count`

      query_params[["totalTime"]] <- `total_time`

      query_params[["dailyScore"]] <- `daily_score`

      query_params[["dailyCount"]] <- `daily_count`

      query_params[["dailyTime"]] <- `daily_time`

      query_params[["weeklyScore"]] <- `weekly_score`

      query_params[["weeklyCount"]] <- `weekly_count`

      query_params[["weeklyTime"]] <- `weekly_time`

      query_params[["monthlyScore"]] <- `monthly_score`

      query_params[["monthlyCount"]] <- `monthly_count`

      query_params[["monthlyTime"]] <- `monthly_time`

      query_params[["topScore"]] <- `top_score`

      query_params[["lowestScore"]] <- `lowest_score`

      query_params[["streakCount"]] <- `streak_count`

      query_params[["streakBestCount"]] <- `streak_best_count`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      local_var_url_path <- "/ranking/override"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    },

    #' @description
    #' Update Ranking
    #'
    #' @param account_id the account id of the user
    #' @param app_key the application key for filtering results by application
    #' @param rank_type a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
    #' @param increment (optional) the value to increment (default value: 1)
    #' @param time_increment (optional) the time value to increment
    #' @param tag (optional) the analytic tag for this achievement (used to validate scores)
    #' @param start_date (optional) custom date you can save along with the score for the user
    #' @param end_date (optional) custom date you can save along with the score for the user
    #' @param update_global (optional) update the global rankings if true, default is false
    #' @param create_leaderboard (optional) create the leaderboard if it does not exist (default false) (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return SirqulResponse
    UpdateRankings = function(account_id, app_key, rank_type, increment = 1, time_increment = NULL, tag = NULL, start_date = NULL, end_date = NULL, update_global = NULL, create_leaderboard = FALSE, data_file = NULL, ..., .parse = TRUE) {
      local_var_response <- self$UpdateRankingsWithHttpInfo(account_id, app_key, rank_type, increment, time_increment, tag, start_date, end_date, update_global, create_leaderboard, data_file = data_file, ..., .parse = .parse)
      if (local_var_response$status_code >= 200 && local_var_response$status_code <= 299) {
        return(local_var_response$content)
      } else if (local_var_response$status_code >= 300 && local_var_response$status_code <= 399) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 400 && local_var_response$status_code <= 499) {
        return(local_var_response)
      } else if (local_var_response$status_code >= 500 && local_var_response$status_code <= 599) {
        return(local_var_response)
      }
    },

    #' @description
    #' Update Ranking
    #'
    #' @param account_id the account id of the user
    #' @param app_key the application key for filtering results by application
    #' @param rank_type a unique label for identifying the ranking. This can be any alphanumeric string (no spaces or special characters) with a maximum length of 64 characters. There are also default rank types to use which include: POINTS, DOWNLOADS, INVITATIONS, CREATIONS, VOTES, REDEEMED, ACTIONS
    #' @param increment (optional) the value to increment (default value: 1)
    #' @param time_increment (optional) the time value to increment
    #' @param tag (optional) the analytic tag for this achievement (used to validate scores)
    #' @param start_date (optional) custom date you can save along with the score for the user
    #' @param end_date (optional) custom date you can save along with the score for the user
    #' @param update_global (optional) update the global rankings if true, default is false
    #' @param create_leaderboard (optional) create the leaderboard if it does not exist (default false) (default value: FALSE)
    #' @param data_file (optional) name of the data file to save the result
    #' @param ... Other optional arguments
    #' @param .parse Logical. If \code{TRUE} then the response will be parsed to a generated type. If \code{FALSE} the response will be returned as unparsed text.
    #'
    #' @return API response (SirqulResponse) with additional information such as HTTP status code, headers
    UpdateRankingsWithHttpInfo = function(account_id, app_key, rank_type, increment = 1, time_increment = NULL, tag = NULL, start_date = NULL, end_date = NULL, update_global = NULL, create_leaderboard = FALSE, data_file = NULL, ..., .parse = TRUE) {
      args <- list(...)
      query_params <- list()
      header_params <- c()
      form_params <- list()
      file_params <- list()
      local_var_body <- NULL
      oauth_scopes <- NULL
      is_oauth <- FALSE

      if (missing(`account_id`)) {
        stop("Missing required parameter `account_id`.")
      }

      if (missing(`app_key`)) {
        stop("Missing required parameter `app_key`.")
      }

      if (missing(`rank_type`)) {
        stop("Missing required parameter `rank_type`.")
      }

      if (!missing(`account_id`) && is.null(`account_id`)) {
        stop("Invalid value for `account_id` when calling RankingApi$UpdateRankings, `account_id` is not nullable")
      }

      if (!missing(`app_key`) && is.null(`app_key`)) {
        stop("Invalid value for `app_key` when calling RankingApi$UpdateRankings, `app_key` is not nullable")
      }

      if (!missing(`rank_type`) && is.null(`rank_type`)) {
        stop("Invalid value for `rank_type` when calling RankingApi$UpdateRankings, `rank_type` is not nullable")
      }

      if (!missing(`increment`) && is.null(`increment`)) {
        stop("Invalid value for `increment` when calling RankingApi$UpdateRankings, `increment` is not nullable")
      }

      if (!missing(`time_increment`) && is.null(`time_increment`)) {
        stop("Invalid value for `time_increment` when calling RankingApi$UpdateRankings, `time_increment` is not nullable")
      }

      if (!missing(`tag`) && is.null(`tag`)) {
        stop("Invalid value for `tag` when calling RankingApi$UpdateRankings, `tag` is not nullable")
      }

      if (!missing(`start_date`) && is.null(`start_date`)) {
        stop("Invalid value for `start_date` when calling RankingApi$UpdateRankings, `start_date` is not nullable")
      }

      if (!missing(`end_date`) && is.null(`end_date`)) {
        stop("Invalid value for `end_date` when calling RankingApi$UpdateRankings, `end_date` is not nullable")
      }

      if (!missing(`update_global`) && is.null(`update_global`)) {
        stop("Invalid value for `update_global` when calling RankingApi$UpdateRankings, `update_global` is not nullable")
      }

      if (!missing(`create_leaderboard`) && is.null(`create_leaderboard`)) {
        stop("Invalid value for `create_leaderboard` when calling RankingApi$UpdateRankings, `create_leaderboard` is not nullable")
      }

      query_params[["accountId"]] <- `account_id`

      query_params[["appKey"]] <- `app_key`

      query_params[["rankType"]] <- `rank_type`

      query_params[["increment"]] <- `increment`

      query_params[["timeIncrement"]] <- `time_increment`

      query_params[["tag"]] <- `tag`

      query_params[["startDate"]] <- `start_date`

      query_params[["endDate"]] <- `end_date`

      query_params[["updateGlobal"]] <- `update_global`

      query_params[["createLeaderboard"]] <- `create_leaderboard`

      local_var_url_path <- "/ranking/update"

      # The Accept request HTTP header
      local_var_accepts <- list("*/*")

      # The Content-Type representation header
      local_var_content_types <- list()

      local_var_resp <- self$api_client$CallApi(url = paste0(self$api_client$base_path, local_var_url_path),
                                 method = "POST",
                                 query_params = query_params,
                                 header_params = header_params,
                                 form_params = form_params,
                                 file_params = file_params,
                                 accepts = local_var_accepts,
                                 content_types = local_var_content_types,
                                 body = local_var_body,
                                 is_oauth = is_oauth,
                                 oauth_scopes = oauth_scopes,
                                 ...)

      if (local_var_resp$status_code >= 200 && local_var_resp$status_code <= 299) {
        # save response in a file
        if (!is.null(data_file)) {
          self$api_client$WriteFile(local_var_resp, data_file)
        }
        if (!.parse) {
          local_var_resp$content <- local_var_resp$response_as_text()
          return(local_var_resp)
        }

        deserialized_resp_obj <- tryCatch(
          self$api_client$DeserializeResponse(local_var_resp, "SirqulResponse"),
          error = function(e) {
            stop("Failed to deserialize response")
          }
        )
        local_var_resp$content <- deserialized_resp_obj
        return(local_var_resp)
      } 
      
      local_var_error_msg <- local_var_resp$response_as_text()      
      if (local_var_resp$status_code >= 300 && local_var_resp$status_code <= 399) {
        ApiResponse$new(content = paste("Server returned ", local_var_resp$status_code, " response status code."),
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 400 && local_var_resp$status_code <= 499) {
        ApiResponse$new(content = "API client error",
                        response = local_var_resp,
                        status_code = local_var_resp$status_code)
      } else if (local_var_resp$status_code >= 500 && local_var_resp$status_code <= 599) {
        if (is.null(local_var_resp$response) || all(local_var_resp$response == "")) {
          local_var_resp$response <- "API server error"
        }
        return(local_var_resp)
      }
    }
  )
)
